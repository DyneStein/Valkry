[
    {
        "id": "m201",
        "title": "Unique Binary Search Trees",
        "description": "Given an integer n, return the number of structurally unique BST's (binary search trees) which has exactly n nodes of unique values from 1 to n. This is the nth Catalan number.",
        "difficulty": "MEDIUM",
        "category": "DP",
        "starterCode": "#include <iostream>\nusing namespace std;\nint numTrees(int n) { return 0; }\nint main() { cout << numTrees(3); return 0; }",
        "expectedOutput": "5",
        "solution": "#include <iostream>\nusing namespace std;\nint numTrees(int n) {\n    int dp[n + 1] = {};\n    dp[0] = dp[1] = 1;\n    for(int nodes = 2; nodes <= n; nodes++) {\n        for(int root = 1; root <= nodes; root++) {\n            int leftNodes = root - 1;\n            int rightNodes = nodes - root;\n            dp[nodes] += dp[leftNodes] * dp[rightNodes];\n        }\n    }\n    return dp[n];\n}\nint main() { cout << numTrees(3); return 0; }",
        "explanation": {
            "approach": "Use dynamic programming. For n nodes, try each value as root.",
            "steps": [
                "dp[i] = number of unique BSTs with i nodes",
                "Base case: dp[0] = dp[1] = 1"
            ],
            "complexity": "Time: O(n²), Space: O(n)"
        },
        "testCases": [
            {
                "input": "n=3",
                "expectedOutput": "5",
                "explanation": "5 unique BSTs with 3 nodes"
            },
            {
                "input": "n=1",
                "expectedOutput": "1",
                "explanation": "Only one tree with 1 node"
            },
            {
                "input": "n=4",
                "expectedOutput": "14",
                "explanation": "14 unique BSTs with 4 nodes"
            },
            {
                "input": "n=5",
                "expectedOutput": "42",
                "explanation": "5th Catalan number"
            }
        ]
    },
    {
        "id": "m202",
        "title": "Ugly Number II",
        "description": "An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5. Given integer n, return the nth ugly number.",
        "difficulty": "MEDIUM",
        "category": "DP",
        "starterCode": "#include <iostream>\nusing namespace std;\nint nthUglyNumber(int n) { return 0; }\nint main() { cout << nthUglyNumber(10); return 0; }",
        "expectedOutput": "12",
        "solution": "#include <iostream>\nusing namespace std;\nint nthUglyNumber(int n) {\n    int ugly[n];\n    ugly[0] = 1;\n    int i2 = 0, i3 = 0, i5 = 0;\n    for(int i = 1; i < n; i++) {\n        int next2 = ugly[i2] * 2;\n        int next3 = ugly[i3] * 3;\n        int next5 = ugly[i5] * 5;\n        ugly[i] = min(next2, min(next3, next5));\n        if(ugly[i] == next2) i2++;\n        if(ugly[i] == next3) i3++;\n        if(ugly[i] == next5) i5++;\n    }\n    return ugly[n - 1];\n}\nint main() { cout << nthUglyNumber(10); return 0; }",
        "explanation": {
            "approach": "Use three pointers, one for each prime factor (2, 3, 5).",
            "steps": [
                "Start with ugly[0] = 1",
                "Take minimum of next candidates"
            ],
            "complexity": "Time: O(n), Space: O(n)"
        },
        "testCases": [
            {
                "input": "n=10",
                "expectedOutput": "12",
                "explanation": "10th ugly: 1,2,3,4,5,6,8,9,10,12"
            },
            {
                "input": "n=1",
                "expectedOutput": "1",
                "explanation": "First ugly number is 1"
            },
            {
                "input": "n=7",
                "expectedOutput": "8",
                "explanation": "7th ugly number"
            },
            {
                "input": "n=15",
                "expectedOutput": "24",
                "explanation": "15th ugly number"
            }
        ]
    },
    {
        "id": "m203",
        "title": "Count Numbers with Unique Digits",
        "description": "Given an integer n, count all numbers with unique digits in the range [0, 10^n).",
        "difficulty": "MEDIUM",
        "category": "DP",
        "starterCode": "#include <iostream>\nusing namespace std;\nint countNumbersWithUniqueDigits(int n) { return 0; }\nint main() { cout << countNumbersWithUniqueDigits(2); return 0; }",
        "expectedOutput": "91",
        "solution": "#include <iostream>\nusing namespace std;\nint countNumbersWithUniqueDigits(int n) {\n    if(n == 0) return 1;\n    int result = 10;\n    int uniqueDigits = 9;\n    int availableDigits = 9;\n    for(int i = 2; i <= n && availableDigits > 0; i++) {\n        uniqueDigits *= availableDigits;\n        result += uniqueDigits;\n        availableDigits--;\n    }\n    return result;\n}\nint main() { cout << countNumbersWithUniqueDigits(2); return 0; }",
        "explanation": {
            "approach": "Combinatorics approach. First digit has 9 choices, each subsequent has one fewer.",
            "steps": [
                "For n=1: 10 numbers",
                "For 2-digit: 9*9 new numbers"
            ],
            "complexity": "Time: O(n), Space: O(1)"
        },
        "testCases": [
            {
                "input": "n=2",
                "expectedOutput": "91",
                "explanation": "91 numbers with unique digits 0-99"
            },
            {
                "input": "n=0",
                "expectedOutput": "1",
                "explanation": "Only 0"
            },
            {
                "input": "n=1",
                "expectedOutput": "10",
                "explanation": "0-9 all unique"
            },
            {
                "input": "n=3",
                "expectedOutput": "739",
                "explanation": "Count for 0-999"
            }
        ]
    },
    {
        "id": "m204",
        "title": "Frequency of Most Frequent Element",
        "description": "Given an array of integers and a number k, you can increment any element at most k times total. Return the maximum possible frequency of any element.",
        "difficulty": "MEDIUM",
        "category": "Sliding Window",
        "starterCode": "#include <iostream>\nusing namespace std;\nint maxFrequency(int nums[], int n, int k) { return 0; }\nint main() { int nu[] = {1, 2, 4}; cout << maxFrequency(nu, 3, 5); return 0; }",
        "expectedOutput": "3",
        "solution": "#include <iostream>\nusing namespace std;\nint maxFrequency(int nums[], int n, int k) {\n    for(int i = 0; i < n - 1; i++) for(int j = 0; j < n - i - 1; j++) if(nums[j] > nums[j + 1]) { int temp = nums[j]; nums[j] = nums[j + 1]; nums[j + 1] = temp; }\n    long long sum = 0;\n    int left = 0, maxFreq = 1;\n    for(int right = 0; right < n; right++) {\n        sum += nums[right];\n        while((long long)nums[right] * (right - left + 1) - sum > k) { sum -= nums[left]; left++; }\n        maxFreq = max(maxFreq, right - left + 1);\n    }\n    return maxFreq;\n}\nint main() { int nu[] = {1, 2, 4}; cout << maxFrequency(nu, 3, 5); return 0; }",
        "explanation": {
            "approach": "Sort then sliding window. Cost = max × windowSize - sum.",
            "steps": [
                "Sort array",
                "Slide window, track cost"
            ],
            "complexity": "Time: O(n log n), Space: O(1)"
        },
        "testCases": [
            {
                "input": "nums=[1,2,4], k=5",
                "expectedOutput": "3",
                "explanation": "Increment 1,2 to 4 (cost=5)"
            },
            {
                "input": "nums=[1,4,8,13], k=5",
                "expectedOutput": "2",
                "explanation": "Best: make 4,8 both 8"
            },
            {
                "input": "nums=[3,9,6], k=2",
                "expectedOutput": "1",
                "explanation": "Can't make any same"
            },
            {
                "input": "nums=[1,1,1], k=0",
                "expectedOutput": "3",
                "explanation": "Already all same"
            }
        ]
    },
    {
        "id": "m205",
        "title": "Maximum Erasure Value",
        "description": "Given an array of positive integers, find the maximum sum of a subarray where all elements are unique.",
        "difficulty": "MEDIUM",
        "category": "Sliding Window",
        "starterCode": "#include <iostream>\nusing namespace std;\nint maximumUniqueSubarray(int nums[], int n) { return 0; }\nint main() { int nu[] = {4, 2, 4, 5, 6}; cout << maximumUniqueSubarray(nu, 5); return 0; }",
        "expectedOutput": "17",
        "solution": "#include <iostream>\nusing namespace std;\nint maximumUniqueSubarray(int nums[], int n) {\n    bool seen[10001] = {};\n    int left = 0, sum = 0, maxSum = 0;\n    for(int right = 0; right < n; right++) {\n        while(seen[nums[right]]) { seen[nums[left]] = false; sum -= nums[left]; left++; }\n        seen[nums[right]] = true;\n        sum += nums[right];\n        maxSum = max(maxSum, sum);\n    }\n    return maxSum;\n}\nint main() { int nu[] = {4, 2, 4, 5, 6}; cout << maximumUniqueSubarray(nu, 5); return 0; }",
        "explanation": {
            "approach": "Sliding window with set for uniqueness.",
            "steps": [
                "Remove left until no duplicates",
                "Add right to window"
            ],
            "complexity": "Time: O(n), Space: O(n)"
        },
        "testCases": [
            {
                "input": "nums=[4,2,4,5,6]",
                "expectedOutput": "17",
                "explanation": "Subarray [2,4,5,6] = 17"
            },
            {
                "input": "nums=[5,2,1,2,5,2,1,2,5]",
                "expectedOutput": "8",
                "explanation": "Max unique sum is 8"
            },
            {
                "input": "nums=[1,2,3,4,5]",
                "expectedOutput": "15",
                "explanation": "All unique, sum all"
            },
            {
                "input": "nums=[1]",
                "expectedOutput": "1",
                "explanation": "Single element"
            }
        ]
    },
    {
        "id": "m206",
        "title": "Container With Most Water",
        "description": "Given n vertical lines, find two that form a container with the most water.",
        "difficulty": "MEDIUM",
        "category": "Two Pointers",
        "starterCode": "#include <iostream>\nusing namespace std;\nint maxArea(int height[], int n) { return 0; }\nint main() { int h[] = {1, 8, 6, 2, 5, 4, 8, 3, 7}; cout << maxArea(h, 9); return 0; }",
        "expectedOutput": "49",
        "solution": "#include <iostream>\nusing namespace std;\nint maxArea(int height[], int n) {\n    int left = 0, right = n - 1;\n    int maxWater = 0;\n    while(left < right) {\n        int h = min(height[left], height[right]);\n        int width = right - left;\n        maxWater = max(maxWater, h * width);\n        if(height[left] < height[right]) left++;\n        else right--;\n    }\n    return maxWater;\n}\nint main() { int h[] = {1, 8, 6, 2, 5, 4, 8, 3, 7}; cout << maxArea(h, 9); return 0; }",
        "explanation": {
            "approach": "Two pointers from ends. Move shorter line inward.",
            "steps": [
                "Calculate water at each step",
                "Move shorter pointer"
            ],
            "complexity": "Time: O(n), Space: O(1)"
        },
        "testCases": [
            {
                "input": "height=[1,8,6,2,5,4,8,3,7]",
                "expectedOutput": "49",
                "explanation": "Lines at 1 and 8 (height 7,8)"
            },
            {
                "input": "height=[1,1]",
                "expectedOutput": "1",
                "explanation": "Min container"
            },
            {
                "input": "height=[4,3,2,1,4]",
                "expectedOutput": "16",
                "explanation": "4*4 between ends"
            },
            {
                "input": "height=[1,2,1]",
                "expectedOutput": "2",
                "explanation": "Best is 1*2"
            }
        ]
    },
    {
        "id": "m207",
        "title": "3Sum",
        "description": "Given an array, find all unique triplets that sum to zero.",
        "difficulty": "MEDIUM",
        "category": "Two Pointers",
        "starterCode": "#include <iostream>\nusing namespace std;\nint threeSum(int nums[], int n) { return 0; }\nint main() { int nu[] = {-1, 0, 1, 2, -1, -4}; cout << threeSum(nu, 6); return 0; }",
        "expectedOutput": "2",
        "solution": "#include <iostream>\nusing namespace std;\nint threeSum(int nums[], int n) {\n    for(int i = 0; i < n - 1; i++) for(int j = 0; j < n - i - 1; j++) if(nums[j] > nums[j + 1]) { int temp = nums[j]; nums[j] = nums[j + 1]; nums[j + 1] = temp; }\n    int count = 0;\n    for(int i = 0; i < n - 2; i++) {\n        if(i > 0 && nums[i] == nums[i - 1]) continue;\n        int left = i + 1, right = n - 1;\n        while(left < right) {\n            int sum = nums[i] + nums[left] + nums[right];\n            if(sum == 0) { count++; while(left < right && nums[left] == nums[left + 1]) left++; while(left < right && nums[right] == nums[right - 1]) right--; left++; right--; }\n            else if(sum < 0) left++;\n            else right--;\n        }\n    }\n    return count;\n}\nint main() { int nu[] = {-1, 0, 1, 2, -1, -4}; cout << threeSum(nu, 6); return 0; }",
        "explanation": {
            "approach": "Sort, fix one element, two pointers for rest.",
            "steps": [
                "Sort array",
                "Skip duplicates",
                "Two pointer search"
            ],
            "complexity": "Time: O(n²), Space: O(1)"
        },
        "testCases": [
            {
                "input": "nums=[-1,0,1,2,-1,-4]",
                "expectedOutput": "2",
                "explanation": "[-1,-1,2] and [-1,0,1]"
            },
            {
                "input": "nums=[0,0,0]",
                "expectedOutput": "1",
                "explanation": "Only [0,0,0]"
            },
            {
                "input": "nums=[0,1,1]",
                "expectedOutput": "0",
                "explanation": "No triplet sums to 0"
            },
            {
                "input": "nums=[-2,0,1,1,2]",
                "expectedOutput": "2",
                "explanation": "Two triplets"
            }
        ]
    },
    {
        "id": "m208",
        "title": "3Sum Closest",
        "description": "Given an array and target, find the sum of three integers closest to target.",
        "difficulty": "MEDIUM",
        "category": "Two Pointers",
        "starterCode": "#include <iostream>\nusing namespace std;\nint threeSumClosest(int nums[], int n, int target) { return 0; }\nint main() { int nu[] = {-1, 2, 1, -4}; cout << threeSumClosest(nu, 4, 1); return 0; }",
        "expectedOutput": "2",
        "solution": "#include <iostream>\nusing namespace std;\nint threeSumClosest(int nums[], int n, int target) {\n    for(int i = 0; i < n - 1; i++) for(int j = 0; j < n - i - 1; j++) if(nums[j] > nums[j + 1]) { int temp = nums[j]; nums[j] = nums[j + 1]; nums[j + 1] = temp; }\n    int closest = nums[0] + nums[1] + nums[2];\n    for(int i = 0; i < n - 2; i++) {\n        int left = i + 1, right = n - 1;\n        while(left < right) {\n            int sum = nums[i] + nums[left] + nums[right];\n            if(abs(sum - target) < abs(closest - target)) closest = sum;\n            if(sum < target) left++;\n            else right--;\n        }\n    }\n    return closest;\n}\nint main() { int nu[] = {-1, 2, 1, -4}; cout << threeSumClosest(nu, 4, 1); return 0; }",
        "explanation": {
            "approach": "Similar to 3Sum, track closest sum.",
            "steps": [
                "Sort",
                "Track closest",
                "Two pointer adjust"
            ],
            "complexity": "Time: O(n²), Space: O(1)"
        },
        "testCases": [
            {
                "input": "nums=[-1,2,1,-4], target=1",
                "expectedOutput": "2",
                "explanation": "-1+2+1=2, closest to 1"
            },
            {
                "input": "nums=[0,0,0], target=1",
                "expectedOutput": "0",
                "explanation": "Only option is 0"
            },
            {
                "input": "nums=[1,1,1,1], target=0",
                "expectedOutput": "3",
                "explanation": "Closest is 1+1+1=3"
            },
            {
                "input": "nums=[-1,0,1,2], target=3",
                "expectedOutput": "3",
                "explanation": "0+1+2=3 exact"
            }
        ]
    },
    {
        "id": "m209",
        "title": "Sort Colors",
        "description": "Given an array of 0s, 1s, and 2s, sort them in-place (Dutch National Flag).",
        "difficulty": "MEDIUM",
        "category": "Two Pointers",
        "starterCode": "#include <iostream>\nusing namespace std;\nvoid sortColors(int nums[], int n) {}\nint main() { int nu[] = {2, 0, 2, 1, 1, 0}; sortColors(nu, 6); for(int i = 0; i < 6; i++) cout << nu[i] << \" \"; return 0; }",
        "expectedOutput": "0 0 1 1 2 2",
        "solution": "#include <iostream>\nusing namespace std;\nvoid sortColors(int nums[], int n) {\n    int low = 0, mid = 0, high = n - 1;\n    while(mid <= high) {\n        if(nums[mid] == 0) { int temp = nums[low]; nums[low] = nums[mid]; nums[mid] = temp; low++; mid++; }\n        else if(nums[mid] == 1) mid++;\n        else { int temp = nums[mid]; nums[mid] = nums[high]; nums[high] = temp; high--; }\n    }\n}\nint main() { int nu[] = {2, 0, 2, 1, 1, 0}; sortColors(nu, 6); for(int i = 0; i < 6; i++) cout << nu[i] << \" \"; return 0; }",
        "explanation": {
            "approach": "Three pointers: low (0s), mid (current), high (2s).",
            "steps": [
                "0→swap with low",
                "1→move mid",
                "2→swap with high"
            ],
            "complexity": "Time: O(n), Space: O(1)"
        },
        "testCases": [
            {
                "input": "nums=[2,0,2,1,1,0]",
                "expectedOutput": "0 0 1 1 2 2",
                "explanation": "Sorted into 3 groups"
            },
            {
                "input": "nums=[2,0,1]",
                "expectedOutput": "0 1 2",
                "explanation": "Each color once"
            },
            {
                "input": "nums=[0]",
                "expectedOutput": "0",
                "explanation": "Single element"
            },
            {
                "input": "nums=[1,1,1]",
                "expectedOutput": "1 1 1",
                "explanation": "All same"
            }
        ]
    },
    {
        "id": "m210",
        "title": "Minimum Size Subarray Sum",
        "description": "Find the minimal length of a contiguous subarray with sum >= target.",
        "difficulty": "MEDIUM",
        "category": "Sliding Window",
        "starterCode": "#include <iostream>\nusing namespace std;\nint minSubArrayLen(int target, int nums[], int n) { return 0; }\nint main() { int nu[] = {2, 3, 1, 2, 4, 3}; cout << minSubArrayLen(7, nu, 6); return 0; }",
        "expectedOutput": "2",
        "solution": "#include <iostream>\nusing namespace std;\nint minSubArrayLen(int target, int nums[], int n) {\n    int left = 0, sum = 0;\n    int minLen = n + 1;\n    for(int right = 0; right < n; right++) {\n        sum += nums[right];\n        while(sum >= target) {\n            minLen = min(minLen, right - left + 1);\n            sum -= nums[left];\n            left++;\n        }\n    }\n    return minLen > n ? 0 : minLen;\n}\nint main() { int nu[] = {2, 3, 1, 2, 4, 3}; cout << minSubArrayLen(7, nu, 6); return 0; }",
        "explanation": {
            "approach": "Sliding window, shrink while sum >= target.",
            "steps": [
                "Expand right",
                "Shrink left while valid"
            ],
            "complexity": "Time: O(n), Space: O(1)"
        },
        "testCases": [
            {
                "input": "target=7, nums=[2,3,1,2,4,3]",
                "expectedOutput": "2",
                "explanation": "[4,3] sums to 7"
            },
            {
                "input": "target=4, nums=[1,4,4]",
                "expectedOutput": "1",
                "explanation": "Single 4 >= 4"
            },
            {
                "input": "target=11, nums=[1,1,1,1,1,1]",
                "expectedOutput": "0",
                "explanation": "Can't reach 11"
            },
            {
                "input": "target=15, nums=[1,2,3,4,5]",
                "expectedOutput": "5",
                "explanation": "Need all elements"
            }
        ]
    }
]