[
    {
        "id": "core31",
        "title": "Climbing Stairs",
        "description": "You are climbing a staircase with n steps. Each time you can climb 1 or 2 steps. How many distinct ways can you climb to the top?",
        "difficulty": "EASY",
        "category": "Dynamic Programming",
        "starterCode": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint climbStairs(int n) {\n    return 0;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    cout << climbStairs(n);\n    return 0;\n}\n",
        "expectedOutput": "5",
        "solution": "#include <iostream>\nusing namespace std;\nint climbStairs(int n) {\n    if(n <= 2) return n;\n    int prev2 = 1, prev1 = 2;\n    for(int i = 3; i <= n; i++) {\n        int curr = prev1 + prev2;\n        prev2 = prev1;\n        prev1 = curr;\n    }\n    return prev1;\n}\nint main() { cout << climbStairs(4); return 0; }",
        "explanation": {
            "approach": "Fibonacci-like DP. ways(n) = ways(n-1) + ways(n-2).",
            "steps": [
                "Base: 1 way for step 1, 2 ways for step 2",
                "Each step = sum of prev two"
            ],
            "complexity": "Time: O(n), Space: O(1)"
        },
        "testCases": [
            {
                "input": "n=4",
                "expectedOutput": "5",
                "explanation": "1+1+1+1, 1+1+2, 1+2+1, 2+1+1, 2+2"
            },
            {
                "input": "n=2",
                "expectedOutput": "2",
                "explanation": "1+1 or 2"
            },
            {
                "input": "n=1",
                "expectedOutput": "1",
                "explanation": "Only 1 step"
            },
            {
                "input": "n=5",
                "expectedOutput": "8",
                "explanation": "Fibonacci pattern"
            }
        ]
    },
    {
        "id": "core32",
        "title": "Coin Change",
        "description": "Given coin denominations and target amount, find minimum coins needed. Return -1 if impossible.",
        "difficulty": "MEDIUM",
        "category": "Dynamic Programming",
        "starterCode": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint coinChange(vector<int>& coins, int n, int amount) {\n    return 0;\n}\n\nint main() {\n    int coins_size;\n    cin >> coins_size;\n    vector<int> coins(coins_size);\n    for (int i = 0; i < coins_size; i++) cin >> coins[i];\n    int n;\n    cin >> n;\n    int amount;\n    cin >> amount;\n    cout << coinChange(coins, n, amount);\n    return 0;\n}\n",
        "expectedOutput": "3",
        "solution": "#include <iostream>\nusing namespace std;\nint coinChange(int coins[], int n, int amount) {\n    int dp[amount + 1];\n    for(int i = 0; i <= amount; i++) dp[i] = amount + 1;\n    dp[0] = 0;\n    for(int a = 1; a <= amount; a++) {\n        for(int i = 0; i < n; i++) {\n            if(coins[i] <= a)\n                dp[a] = min(dp[a], dp[a - coins[i]] + 1);\n        }\n    }\n    return dp[amount] > amount ? -1 : dp[amount];\n}\nint main() { int c[] = {1, 2, 5}; cout << coinChange(c, 3, 11); return 0; }",
        "explanation": {
            "approach": "DP. dp[a] = min coins for amount a.",
            "steps": [
                "dp[0] = 0",
                "For each amount, try each coin"
            ],
            "complexity": "Time: O(amount × n), Space: O(amount)"
        },
        "testCases": [
            {
                "input": "coins=[1,2,5], amount=11",
                "expectedOutput": "3",
                "explanation": "5+5+1=11"
            },
            {
                "input": "coins=[2], amount=3",
                "expectedOutput": "-1",
                "explanation": "Impossible"
            },
            {
                "input": "coins=[1], amount=0",
                "expectedOutput": "0",
                "explanation": "No coins needed"
            },
            {
                "input": "coins=[1,5,10], amount=10",
                "expectedOutput": "1",
                "explanation": "Use one 10"
            }
        ]
    },
    {
        "id": "core33",
        "title": "Longest Common Subsequence",
        "description": "Find length of longest common subsequence of two strings.",
        "difficulty": "MEDIUM",
        "category": "Dynamic Programming",
        "starterCode": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint longestCommonSubsequence(string text1, string text2) {\n    return 0;\n}\n\nint main() {\n    string s1, s2;\n    cin >> s1 >> s2;\n    cout << longestCommonSubsequence(s1, s2);\n    return 0;\n}",
        "expectedOutput": "3",
        "solution": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint longestCommonSubsequence(string text1, string text2) {\n    int m = text1.length(), n = text2.length();\n    int dp[m + 1][n + 1];\n    \n    for(int i = 0; i <= m; i++) {\n        for(int j = 0; j <= n; j++) {\n            if (i == 0 || j == 0)\n                dp[i][j] = 0;\n            else if (text1[i - 1] == text2[j - 1])\n                dp[i][j] = dp[i - 1][j - 1] + 1;\n            else\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\n        }\n    }\n    return dp[m][n];\n}\n\nint main() {\n    string s1, s2;\n    if (cin >> s1 >> s2) {\n        cout << longestCommonSubsequence(s1, s2);\n    }\n    return 0;\n}",
        "explanation": {
            "approach": "2D DP. Match chars or take max of skipping either.",
            "steps": [
                "If chars match, extend",
                "Else max of skipping one"
            ],
            "complexity": "Time: O(m × n), Space: O(m × n)"
        },
        "testCases": [
            {
                "input": "abcde ace",
                "expectedOutput": "3",
                "explanation": "LCS is 'ace'"
            },
            {
                "input": "abc abc",
                "expectedOutput": "3",
                "explanation": "Identical strings"
            },
            {
                "input": "abc def",
                "expectedOutput": "0",
                "explanation": "No common chars"
            },
            {
                "input": "bl yby",
                "expectedOutput": "1",
                "explanation": "LCS is 'b'"
            }
        ]
    },
    {
        "id": "core34",
        "title": "Word Break",
        "description": "Can string be segmented into dictionary words?",
        "difficulty": "MEDIUM",
        "category": "Dynamic Programming",
        "starterCode": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nbool wordBreak(vector<int>& s, vector<string>& dict, int n) {\n    return false;\n}\n\nint main() {\n    int s_size;\n    cin >> s_size;\n    vector<int> s(s_size);\n    for (int i = 0; i < s_size; i++) cin >> s[i];\n    int dict_size;\n    cin >> dict_size;\n    vector<string> dict(dict_size);\n    for (int i = 0; i < dict_size; i++) cin >> dict[i];\n    int n;\n    cin >> n;\n    cout << wordBreak(s, dict, n);\n    return 0;\n}\n",
        "expectedOutput": "1",
        "solution": "#include <iostream>\nusing namespace std;\nbool match(char s[], int start, int end, char word[]) {\n    int i = 0;\n    for(int j = start; j < end; j++, i++)\n        if(word[i] == 0 || s[j] != word[i]) return false;\n    return word[i] == 0;\n}\nbool wordBreak(char s[], char* dict[], int n) {\n    int len = 0; while(s[len]) len++;\n    bool dp[len + 1];\n    for(int i = 0; i <= len; i++) dp[i] = false;\n    dp[0] = true;\n    for(int i = 1; i <= len; i++) {\n        for(int j = 0; j < i; j++) {\n            if(dp[j]) {\n                for(int w = 0; w < n; w++)\n                    if(match(s, j, i, dict[w])) dp[i] = true;\n            }\n        }\n    }\n    return dp[len];\n}\nint main() { char* d[] = {\"leet\", \"code\"}; cout << wordBreak(\"leetcode\", d, 2); return 0; }",
        "explanation": {
            "approach": "DP. dp[i] = can s[0..i-1] be segmented?",
            "steps": [
                "Check all positions",
                "Match dictionary words"
            ],
            "complexity": "Time: O(n² × m × L), Space: O(n)"
        },
        "testCases": [
            {
                "input": "s='leetcode', dict=['leet','code']",
                "expectedOutput": "1",
                "explanation": "leet+code"
            },
            {
                "input": "s='applepenapple', dict=['apple','pen']",
                "expectedOutput": "1",
                "explanation": "apple+pen+apple"
            },
            {
                "input": "s='catsandog', dict=['cats','dog','sand']",
                "expectedOutput": "0",
                "explanation": "Cannot segment"
            },
            {
                "input": "s='', dict=['a']",
                "expectedOutput": "1",
                "explanation": "Empty string valid"
            }
        ]
    },
    {
        "id": "core35",
        "title": "House Robber",
        "description": "Max money from houses, can't rob adjacent.",
        "difficulty": "MEDIUM",
        "category": "Dynamic Programming",
        "starterCode": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint rob(vector<int>& nums, int n) {\n    return 0;\n}\n\nint main() {\n    int nums_size;\n    cin >> nums_size;\n    vector<int> nums(nums_size);\n    for (int i = 0; i < nums_size; i++) cin >> nums[i];\n    int n;\n    cin >> n;\n    cout << rob(nums, n);\n    return 0;\n}\n",
        "expectedOutput": "12",
        "solution": "#include <iostream>\nusing namespace std;\nint rob(int nums[], int n) {\n    if(n == 0) return 0;\n    if(n == 1) return nums[0];\n    int prev2 = nums[0];\n    int prev1 = max(nums[0], nums[1]);\n    for(int i = 2; i < n; i++) {\n        int curr = max(prev1, prev2 + nums[i]);\n        prev2 = prev1;\n        prev1 = curr;\n    }\n    return prev1;\n}\nint main() { int h[] = {2, 7, 9, 3, 1}; cout << rob(h, 5); return 0; }",
        "explanation": {
            "approach": "DP. Skip or rob current house.",
            "steps": [
                "Either skip (prev1) or rob (prev2 + nums[i])"
            ],
            "complexity": "Time: O(n), Space: O(1)"
        },
        "testCases": [
            {
                "input": "[2,7,9,3,1]",
                "expectedOutput": "12",
                "explanation": "2+9+1=12"
            },
            {
                "input": "[1,2,3,1]",
                "expectedOutput": "4",
                "explanation": "1+3=4"
            },
            {
                "input": "[5]",
                "expectedOutput": "5",
                "explanation": "Single house"
            },
            {
                "input": "[2,1,1,2]",
                "expectedOutput": "4",
                "explanation": "2+2=4"
            }
        ]
    },
    {
        "id": "core36",
        "title": "Maximum Product Subarray",
        "description": "Find contiguous subarray with largest product.",
        "difficulty": "MEDIUM",
        "category": "Dynamic Programming",
        "starterCode": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxProduct(vector<int>& nums, int n) {\n    return 0;\n}\n\nint main() {\n    int nums_size;\n    cin >> nums_size;\n    vector<int> nums(nums_size);\n    for (int i = 0; i < nums_size; i++) cin >> nums[i];\n    int n;\n    cin >> n;\n    cout << maxProduct(nums, n);\n    return 0;\n}\n",
        "expectedOutput": "6",
        "solution": "#include <iostream>\nusing namespace std;\nint maxProduct(int nums[], int n) {\n    int maxProd = nums[0], currMax = nums[0], currMin = nums[0];\n    for(int i = 1; i < n; i++) {\n        if(nums[i] < 0) { int t = currMax; currMax = currMin; currMin = t; }\n        currMax = max(nums[i], currMax * nums[i]);\n        currMin = min(nums[i], currMin * nums[i]);\n        maxProd = max(maxProd, currMax);\n    }\n    return maxProd;\n}\nint main() { int a[] = {2, 3, -2, 4}; cout << maxProduct(a, 4); return 0; }",
        "explanation": {
            "approach": "Track both max and min (for negative × negative).",
            "steps": [
                "Swap max/min on negative",
                "Update both"
            ],
            "complexity": "Time: O(n), Space: O(1)"
        },
        "testCases": [
            {
                "input": "[2,3,-2,4]",
                "expectedOutput": "6",
                "explanation": "2×3=6"
            },
            {
                "input": "[-2,0,-1]",
                "expectedOutput": "0",
                "explanation": "0 breaks product"
            },
            {
                "input": "[-2,3,-4]",
                "expectedOutput": "24",
                "explanation": "-2×3×-4=24"
            },
            {
                "input": "[2]",
                "expectedOutput": "2",
                "explanation": "Single element"
            }
        ]
    },
    {
        "id": "core37",
        "title": "Longest Increasing Subsequence",
        "description": "Find length of LIS (not contiguous).",
        "difficulty": "MEDIUM",
        "category": "Dynamic Programming",
        "starterCode": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint lengthOfLIS(vector<int>& nums, int n) {\n    return 0;\n}\n\nint main() {\n    int nums_size;\n    cin >> nums_size;\n    vector<int> nums(nums_size);\n    for (int i = 0; i < nums_size; i++) cin >> nums[i];\n    int n;\n    cin >> n;\n    cout << lengthOfLIS(nums, n);\n    return 0;\n}\n",
        "expectedOutput": "4",
        "solution": "#include <iostream>\nusing namespace std;\nint lengthOfLIS(int nums[], int n) {\n    if(n == 0) return 0;\n    int dp[n];\n    for(int i = 0; i < n; i++) dp[i] = 1;\n    for(int i = 1; i < n; i++) {\n        for(int j = 0; j < i; j++) {\n            if(nums[j] < nums[i])\n                dp[i] = max(dp[i], dp[j] + 1);\n        }\n    }\n    int maxLen = 0;\n    for(int i = 0; i < n; i++) maxLen = max(maxLen, dp[i]);\n    return maxLen;\n}\nint main() { int a[] = {10, 9, 2, 5, 3, 7, 101, 18}; cout << lengthOfLIS(a, 8); return 0; }",
        "explanation": {
            "approach": "dp[i] = LIS ending at i.",
            "steps": [
                "Check all previous smaller elements"
            ],
            "complexity": "Time: O(n²), Space: O(n)"
        },
        "testCases": [
            {
                "input": "[10,9,2,5,3,7,101,18]",
                "expectedOutput": "4",
                "explanation": "2,3,7,101 or 2,5,7,101"
            },
            {
                "input": "[0,1,0,3,2,3]",
                "expectedOutput": "4",
                "explanation": "0,1,2,3"
            },
            {
                "input": "[7,7,7,7]",
                "expectedOutput": "1",
                "explanation": "All same"
            },
            {
                "input": "[1,2,3]",
                "expectedOutput": "3",
                "explanation": "Already sorted"
            }
        ]
    },
    {
        "id": "core38",
        "title": "0/1 Knapsack",
        "description": "Max value in knapsack with capacity W.",
        "difficulty": "MEDIUM",
        "category": "Dynamic Programming",
        "starterCode": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint knapsack(int W, vector<int>& wt, vector<int>& val, int n) {\n    return 0;\n}\n\nint main() {\n    int W;\n    cin >> W;\n    int wt_size;\n    cin >> wt_size;\n    vector<int> wt(wt_size);\n    for (int i = 0; i < wt_size; i++) cin >> wt[i];\n    int val_size;\n    cin >> val_size;\n    vector<int> val(val_size);\n    for (int i = 0; i < val_size; i++) cin >> val[i];\n    int n;\n    cin >> n;\n    cout << knapsack(W, wt, val, n);\n    return 0;\n}\n",
        "expectedOutput": "55",
        "solution": "#include <iostream>\nusing namespace std;\nint knapsack(int W, int wt[], int val[], int n) {\n    int dp[n + 1][W + 1];\n    for(int i = 0; i <= n; i++) {\n        for(int w = 0; w <= W; w++) {\n            if(i == 0 || w == 0) dp[i][w] = 0;\n            else if(wt[i-1] <= w)\n                dp[i][w] = max(val[i-1] + dp[i-1][w - wt[i-1]], dp[i-1][w]);\n            else dp[i][w] = dp[i-1][w];\n        }\n    }\n    return dp[n][W];\n}\nint main() { int w[] = {1, 2, 3}; int v[] = {10, 15, 40}; cout << knapsack(5, w, v, 3); return 0; }",
        "explanation": {
            "approach": "2D DP. Include or exclude each item.",
            "steps": [
                "For each item and capacity, take max of include/exclude"
            ],
            "complexity": "Time: O(n × W), Space: O(n × W)"
        },
        "testCases": [
            {
                "input": "W=5, w=[1,2,3], v=[10,15,40]",
                "expectedOutput": "55",
                "explanation": "Items 0,2 (10+40+15 capacity fit)"
            },
            {
                "input": "W=0, w=[1], v=[10]",
                "expectedOutput": "0",
                "explanation": "No capacity"
            },
            {
                "input": "W=10, w=[5,4,6], v=[10,40,30]",
                "expectedOutput": "50",
                "explanation": "Items 1,0"
            },
            {
                "input": "W=3, w=[4], v=[100]",
                "expectedOutput": "0",
                "explanation": "Item too heavy"
            }
        ]
    },
    {
        "id": "core39",
        "title": "Unique Paths",
        "description": "Count paths in m×n grid (only right/down).",
        "difficulty": "MEDIUM",
        "category": "Dynamic Programming",
        "starterCode": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint uniquePaths(int m, int n) {\n    return 0;\n}\n\nint main() {\n    int m;\n    cin >> m;\n    int n;\n    cin >> n;\n    cout << uniquePaths(m, n);\n    return 0;\n}\n",
        "expectedOutput": "28",
        "solution": "#include <iostream>\nusing namespace std;\nint uniquePaths(int m, int n) {\n    int dp[m][n];\n    for(int j = 0; j < n; j++) dp[0][j] = 1;\n    for(int i = 0; i < m; i++) dp[i][0] = 1;\n    for(int i = 1; i < m; i++)\n        for(int j = 1; j < n; j++)\n            dp[i][j] = dp[i-1][j] + dp[i][j-1];\n    return dp[m-1][n-1];\n}\nint main() { cout << uniquePaths(3, 7); return 0; }",
        "explanation": {
            "approach": "dp[i][j] = paths from top + paths from left.",
            "steps": [
                "First row/col = 1",
                "Each cell = sum of above and left"
            ],
            "complexity": "Time: O(m × n), Space: O(m × n)"
        },
        "testCases": [
            {
                "input": "m=3, n=7",
                "expectedOutput": "28",
                "explanation": "Combinatorial"
            },
            {
                "input": "m=3, n=2",
                "expectedOutput": "3",
                "explanation": "RRD, RDR, DRR"
            },
            {
                "input": "m=1, n=1",
                "expectedOutput": "1",
                "explanation": "Already at end"
            },
            {
                "input": "m=2, n=2",
                "expectedOutput": "2",
                "explanation": "RD or DR"
            }
        ]
    },
    {
        "id": "core40",
        "title": "Jump Game",
        "description": "Can you reach last index?",
        "difficulty": "MEDIUM",
        "category": "Dynamic Programming",
        "starterCode": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nbool canJump(vector<int>& nums, int n) {\n    return false;\n}\n\nint main() {\n    int nums_size;\n    cin >> nums_size;\n    vector<int> nums(nums_size);\n    for (int i = 0; i < nums_size; i++) cin >> nums[i];\n    int n;\n    cin >> n;\n    cout << canJump(nums, n);\n    return 0;\n}\n",
        "expectedOutput": "1",
        "solution": "#include <iostream>\nusing namespace std;\nbool canJump(int nums[], int n) {\n    int maxReach = 0;\n    for(int i = 0; i < n; i++) {\n        if(i > maxReach) return false;\n        maxReach = max(maxReach, i + nums[i]);\n        if(maxReach >= n - 1) return true;\n    }\n    return true;\n}\nint main() { int a[] = {2, 3, 1, 1, 4}; cout << canJump(a, 5); return 0; }",
        "explanation": {
            "approach": "Greedy. Track max reachable index.",
            "steps": [
                "Update max reach at each position"
            ],
            "complexity": "Time: O(n), Space: O(1)"
        },
        "testCases": [
            {
                "input": "[2,3,1,1,4]",
                "expectedOutput": "1",
                "explanation": "Jump 1→2→end"
            },
            {
                "input": "[3,2,1,0,4]",
                "expectedOutput": "0",
                "explanation": "Stuck at index 3"
            },
            {
                "input": "[0]",
                "expectedOutput": "1",
                "explanation": "Already at end"
            },
            {
                "input": "[2,0,0]",
                "expectedOutput": "1",
                "explanation": "Jump directly"
            }
        ]
    }
]