[
    {
        "id": "extra1",
        "title": "Binary Search Left Bound",
        "description": "First occurrence of target.",
        "difficulty": "MEDIUM",
        "category": "Binary Search",
        "starterCode": "#include <iostream>\nusing namespace std;\nint leftBound(int a[], int n, int t) { return -1; }\nint main() { int a[]={1,2,2,2,3}; cout<<leftBound(a,5,2); return 0; }",
        "expectedOutput": "1",
        "solution": "#include <iostream>\nusing namespace std;\nint leftBound(int a[], int n, int t) { int l=0, r=n; while(l<r) { int m=(l+r)/2; if(a[m]<t) l=m+1; else r=m; } return l<n && a[l]==t ? l : -1; }\nint main() { int a[]={1,2,2,2,3}; cout<<leftBound(a,5,2); return 0; }",
        "explanation": {
            "approach": "Binary search, keep going left when found.",
            "analogy": "Find leftmost boundary.",
            "steps": [
                "If a[m] < t, search right",
                "Else search left (including m)"
            ],
            "complexity": "Time: O(log n), Space: O(1)"
        }
    },
    {
        "id": "extra2",
        "title": "Binary Search Right Bound",
        "description": "Last occurrence of target.",
        "difficulty": "MEDIUM",
        "category": "Binary Search",
        "starterCode": "#include <iostream>\nusing namespace std;\nint rightBound(int a[], int n, int t) { return -1; }\nint main() { int a[]={1,2,2,2,3}; cout<<rightBound(a,5,2); return 0; }",
        "expectedOutput": "3",
        "solution": "#include <iostream>\nusing namespace std;\nint rightBound(int a[], int n, int t) { int l=0, r=n; while(l<r) { int m=(l+r)/2; if(a[m]<=t) l=m+1; else r=m; } return l-1>=0 && a[l-1]==t ? l-1 : -1; }\nint main() { int a[]={1,2,2,2,3}; cout<<rightBound(a,5,2); return 0; }",
        "explanation": {
            "approach": "Binary search, keep going right when found.",
            "analogy": "Find rightmost boundary.",
            "steps": [
                "If a[m] <= t, search right",
                "Else search left"
            ],
            "complexity": "Time: O(log n), Space: O(1)"
        }
    },
    {
        "id": "extra3",
        "title": "Peak Element",
        "description": "Find local maximum.",
        "difficulty": "MEDIUM",
        "category": "Binary Search",
        "starterCode": "#include <iostream>\nusing namespace std;\nint findPeak(int a[], int n) { return -1; }\nint main() { int a[]={1,2,3,1}; cout<<findPeak(a,4); return 0; }",
        "expectedOutput": "2",
        "solution": "#include <iostream>\nusing namespace std;\nint findPeak(int a[], int n) { int l=0, r=n-1; while(l<r) { int m=(l+r)/2; if(a[m]>a[m+1]) r=m; else l=m+1; } return l; }\nint main() { int a[]={1,2,3,1}; cout<<findPeak(a,4); return 0; }",
        "explanation": {
            "approach": "Go towards larger neighbor.",
            "analogy": "Climb the hill, peak is where you stop.",
            "steps": [
                "If a[m] > a[m+1], go left",
                "Else go right"
            ],
            "complexity": "Time: O(log n), Space: O(1)"
        }
    },
    {
        "id": "extra4",
        "title": "Search in Rotated Array",
        "description": "Search sorted rotated array.",
        "difficulty": "MEDIUM",
        "category": "Binary Search",
        "starterCode": "#include <iostream>\nusing namespace std;\nint search(int a[], int n, int t) { return -1; }\nint main() { int a[]={4,5,6,7,0,1,2}; cout<<search(a,7,0); return 0; }",
        "expectedOutput": "4",
        "solution": "#include <iostream>\nusing namespace std;\nint search(int a[], int n, int t) { int l=0, r=n-1; while(l<=r) { int m=(l+r)/2; if(a[m]==t) return m; if(a[l]<=a[m]) { if(a[l]<=t && t<a[m]) r=m-1; else l=m+1; } else { if(a[m]<t && t<=a[r]) l=m+1; else r=m-1; } } return -1; }\nint main() { int a[]={4,5,6,7,0,1,2}; cout<<search(a,7,0); return 0; }",
        "explanation": {
            "approach": "Determine which half is sorted, search there.",
            "analogy": "One half is always sorted.",
            "steps": [
                "Check which half is sorted",
                "If target in sorted half, search there",
                "Else search other half"
            ],
            "complexity": "Time: O(log n), Space: O(1)"
        }
    },
    {
        "id": "extra5",
        "title": "Find Minimum in Rotated",
        "description": "Min in rotated sorted array.",
        "difficulty": "MEDIUM",
        "category": "Binary Search",
        "starterCode": "#include <iostream>\nusing namespace std;\nint findMin(int a[], int n) { return 0; }\nint main() { int a[]={3,4,5,1,2}; cout<<findMin(a,5); return 0; }",
        "expectedOutput": "1",
        "solution": "#include <iostream>\nusing namespace std;\nint findMin(int a[], int n) { int l=0, r=n-1; while(l<r) { int m=(l+r)/2; if(a[m]>a[r]) l=m+1; else r=m; } return a[l]; }\nint main() { int a[]={3,4,5,1,2}; cout<<findMin(a,5); return 0; }",
        "explanation": {
            "approach": "Binary search for rotation point.",
            "analogy": "Find where the break is.",
            "steps": [
                "If a[m] > a[r], min is right",
                "Else min is left or at m"
            ],
            "complexity": "Time: O(log n), Space: O(1)"
        }
    },
    {
        "id": "extra6",
        "title": "Square Root Binary Search",
        "description": "Integer square root.",
        "difficulty": "EASY",
        "category": "Binary Search",
        "starterCode": "#include <iostream>\nusing namespace std;\nint mySqrt(int n) { return 0; }\nint main() { cout<<mySqrt(8); return 0; }",
        "expectedOutput": "2",
        "solution": "#include <iostream>\nusing namespace std;\nint mySqrt(int n) { if(n==0) return 0; int l=1, r=n, ans=0; while(l<=r) { int m=l+(r-l)/2; if(m<=n/m) { ans=m; l=m+1; } else r=m-1; } return ans; }\nint main() { cout<<mySqrt(8); return 0; }",
        "explanation": {
            "approach": "Binary search for largest x where x*x <= n.",
            "analogy": "Find the floor of square root.",
            "steps": [
                "Check if m*m <= n",
                "If yes, try larger",
                "If no, try smaller"
            ],
            "complexity": "Time: O(log n), Space: O(1)"
        }
    },
    {
        "id": "extra7",
        "title": "Search 2D Matrix",
        "description": "Search in sorted matrix.",
        "difficulty": "MEDIUM",
        "category": "Binary Search",
        "starterCode": "#include <iostream>\nusing namespace std;\nbool searchMatrix(int m[][4], int r, int c, int t) { return false; }\nint main() { int m[3][4]={{1,3,5,7},{10,11,16,20},{23,30,34,60}}; cout<<searchMatrix(m,3,4,3); return 0; }",
        "expectedOutput": "1",
        "solution": "#include <iostream>\nusing namespace std;\nbool searchMatrix(int m[][4], int r, int c, int t) { int lo=0, hi=r*c-1; while(lo<=hi) { int mid=(lo+hi)/2; int val=m[mid/c][mid%c]; if(val==t) return true; if(val<t) lo=mid+1; else hi=mid-1; } return false; }\nint main() { int m[3][4]={{1,3,5,7},{10,11,16,20},{23,30,34,60}}; cout<<searchMatrix(m,3,4,3); return 0; }",
        "explanation": {
            "approach": "Treat matrix as 1D array.",
            "analogy": "Row and column from single index.",
            "steps": [
                "Binary search on virtual 1D",
                "Index: row = mid/c, col = mid%c"
            ],
            "complexity": "Time: O(log(rÃ—c)), Space: O(1)"
        }
    },
    {
        "id": "extra8",
        "title": "Kth Smallest in Matrix",
        "description": "Find kth smallest element.",
        "difficulty": "MEDIUM",
        "category": "Binary Search",
        "starterCode": "#include <iostream>\nusing namespace std;\nint kthSmallest(int m[][3], int n, int k) { return 0; }\nint main() { int m[3][3]={{1,5,9},{10,11,13},{12,13,15}}; cout<<kthSmallest(m,3,5); return 0; }",
        "expectedOutput": "11",
        "solution": "#include <iostream>\nusing namespace std;\nint countLE(int m[][3], int n, int mid) { int c=0, col=n-1; for(int row=0;row<n;row++) { while(col>=0 && m[row][col]>mid) col--; c+=col+1; } return c; }\nint kthSmallest(int m[][3], int n, int k) { int lo=m[0][0], hi=m[n-1][n-1]; while(lo<hi) { int mid=lo+(hi-lo)/2; if(countLE(m,n,mid)>=k) hi=mid; else lo=mid+1; } return lo; }\nint main() { int m[3][3]={{1,5,9},{10,11,13},{12,13,15}}; cout<<kthSmallest(m,3,5); return 0; }",
        "explanation": {
            "approach": "Binary search on value, count elements <= mid.",
            "analogy": "Find value where exactly k elements are smaller.",
            "steps": [
                "Binary search on value range",
                "Count elements <= mid",
                "Adjust search based on count"
            ],
            "complexity": "Time: O(n log(max-min)), Space: O(1)"
        }
    },
    {
        "id": "extra9",
        "title": "Allocate Minimum Pages",
        "description": "Min max pages per student.",
        "difficulty": "HARD",
        "category": "Binary Search",
        "starterCode": "#include <iostream>\nusing namespace std;\nint allocateBooks(int a[], int n, int k) { return 0; }\nint main() { int a[]={12,34,67,90}; cout<<allocateBooks(a,4,2); return 0; }",
        "expectedOutput": "113",
        "solution": "#include <iostream>\nusing namespace std;\nbool canAllocate(int a[], int n, int k, int mid) { int s=1, pages=0; for(int i=0;i<n;i++) { if(a[i]>mid) return false; if(pages+a[i]>mid) { s++; pages=a[i]; } else pages+=a[i]; } return s<=k; }\nint allocateBooks(int a[], int n, int k) { int lo=0, hi=0; for(int i=0;i<n;i++) { lo=max(lo,a[i]); hi+=a[i]; } while(lo<hi) { int mid=(lo+hi)/2; if(canAllocate(a,n,k,mid)) hi=mid; else lo=mid+1; } return lo; }\nint main() { int a[]={12,34,67,90}; cout<<allocateBooks(a,4,2); return 0; }",
        "explanation": {
            "approach": "Binary search on answer (max pages).",
            "analogy": "Find minimum possible maximum pages.",
            "steps": [
                "Binary search on max pages",
                "Check if allocation possible",
                "Minimize the maximum"
            ],
            "complexity": "Time: O(n log sum), Space: O(1)"
        }
    },
    {
        "id": "extra10",
        "title": "Aggressive Cows",
        "description": "Max minimum distance.",
        "difficulty": "HARD",
        "category": "Binary Search",
        "starterCode": "#include <iostream>\nusing namespace std;\nint aggressiveCows(int pos[], int n, int c) { return 0; }\nint main() { int pos[]={1,2,4,8,9}; cout<<aggressiveCows(pos,5,3); return 0; }",
        "expectedOutput": "3",
        "solution": "#include <iostream>\nusing namespace std;\nbool canPlace(int pos[], int n, int c, int d) { int cows=1, last=pos[0]; for(int i=1;i<n;i++) if(pos[i]-last>=d) { cows++; last=pos[i]; } return cows>=c; }\nint aggressiveCows(int pos[], int n, int c) { for(int i=0;i<n-1;i++) for(int j=0;j<n-i-1;j++) if(pos[j]>pos[j+1]) swap(pos[j],pos[j+1]); int lo=1, hi=pos[n-1]-pos[0], ans=0; while(lo<=hi) { int mid=(lo+hi)/2; if(canPlace(pos,n,c,mid)) { ans=mid; lo=mid+1; } else hi=mid-1; } return ans; }\nint main() { int pos[]={1,2,4,8,9}; cout<<aggressiveCows(pos,5,3); return 0; }",
        "explanation": {
            "approach": "Binary search on answer (min distance).",
            "analogy": "Maximize the minimum gap between cows.",
            "steps": [
                "Sort positions",
                "Binary search on minimum distance",
                "Check if placement possible"
            ],
            "complexity": "Time: O(n log(max-min)), Space: O(1)"
        }
    }
]