[
    {
        "id": "e501",
        "title": "Number of Steps to Zero",
        "description": "Given a non-negative integer num, return the number of steps to reduce it to zero. If the current number is even, divide it by 2. If odd, subtract 1 from it.",
        "difficulty": "EASY",
        "category": "Math",
        "starterCode": "#include <iostream>\nusing namespace std;\nint numberOfSteps(int num) { return 0; }\nint main() { cout << numberOfSteps(14); return 0; }",
        "expectedOutput": "6",
        "solution": "#include <iostream>\nusing namespace std;\nint numberOfSteps(int num) {\n    int count = 0;\n    while(num > 0) {\n        if(num % 2 == 0) {\n            num /= 2;  // If even, divide by 2\n        } else {\n            num--;     // If odd, subtract 1\n        }\n        count++;\n    }\n    return count;\n}\nint main() { cout << numberOfSteps(14); return 0; }",
        "explanation": {
            "approach": "Follow the rules: if number is even, halve it; if odd, subtract one. Count each operation.",
            "analogy": "Like counting steps to climb down a ladder - each rung is either a big step (divide) or small step (subtract).",
            "steps": [
                "Start with the given number",
                "If even: divide by 2 (big step down)",
                "If odd: subtract 1 (small step down)",
                "Count each step",
                "Stop when you reach 0"
            ],
            "complexity": "Time: O(log n), Space: O(1)"
        }
    },
    {
        "id": "e502",
        "title": "Subtract Product and Sum",
        "description": "Given an integer n, return the difference between the product of its digits and the sum of its digits. For example, n=234: product=2×3×4=24, sum=2+3+4=9, answer=24-9=15.",
        "difficulty": "EASY",
        "category": "Math",
        "starterCode": "#include <iostream>\nusing namespace std;\nint subtractProductAndSum(int n) { return 0; }\nint main() { cout << subtractProductAndSum(234); return 0; }",
        "expectedOutput": "15",
        "solution": "#include <iostream>\nusing namespace std;\nint subtractProductAndSum(int n) {\n    int product = 1, sum = 0;\n    while(n > 0) {\n        int digit = n % 10;  // Get last digit\n        product *= digit;    // Multiply to product\n        sum += digit;        // Add to sum\n        n /= 10;            // Remove last digit\n    }\n    return product - sum;\n}\nint main() { cout << subtractProductAndSum(234); return 0; }",
        "explanation": {
            "approach": "Extract each digit one by one. Keep a running product (multiply all digits) and sum (add all digits). Return their difference.",
            "analogy": "Like taking apart a number into its pieces - multiply them together for product, add them for sum, then subtract.",
            "steps": [
                "Initialize product=1 (neutral for multiplication) and sum=0",
                "Get last digit using n % 10",
                "Multiply it into product, add to sum",
                "Remove last digit using n / 10",
                "Repeat until n becomes 0",
                "Return product - sum"
            ],
            "complexity": "Time: O(log n), Space: O(1)"
        }
    },
    {
        "id": "e503",
        "title": "Integer to Roman",
        "description": "Convert an integer to a Roman numeral. Roman numerals use: I=1, V=5, X=10, L=50, C=100, D=500, M=1000. For subtraction: IV=4, IX=9, XL=40, XC=90, CD=400, CM=900.",
        "difficulty": "EASY",
        "category": "Math",
        "starterCode": "#include <iostream>\nusing namespace std;\nvoid intToRoman(int num) {}\nint main() { intToRoman(3); return 0; }",
        "expectedOutput": "III",
        "solution": "#include <iostream>\nusing namespace std;\nvoid intToRoman(int num) {\n    int values[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    char* symbols[] = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\n    for(int i = 0; i < 13; i++) {\n        while(num >= values[i]) {\n            cout << symbols[i];\n            num -= values[i];\n        }\n    }\n}\nint main() { intToRoman(3); return 0; }",
        "explanation": {
            "approach": "Greedy approach - always use the largest Roman numeral that fits. Keep subtracting and outputting symbols.",
            "analogy": "Like making change with coins - use the biggest coin possible, then move to smaller ones.",
            "steps": [
                "Create mapping of values to Roman symbols (including subtraction cases like CM, XC)",
                "Start with largest value (1000=M)",
                "While number >= current value, output symbol and subtract value",
                "Move to next smaller value",
                "Repeat until number becomes 0"
            ],
            "complexity": "Time: O(1), Space: O(1)"
        }
    },
    {
        "id": "e504",
        "title": "Roman to Integer",
        "description": "Convert a Roman numeral string to an integer. When a smaller value appears before a larger value, it's subtraction (IV=4). Otherwise, add values together.",
        "difficulty": "EASY",
        "category": "Math",
        "starterCode": "#include <iostream>\nusing namespace std;\nint romanToInt(char s[]) { return 0; }\nint main() { cout << romanToInt(\"III\"); return 0; }",
        "expectedOutput": "3",
        "solution": "#include <iostream>\nusing namespace std;\nint getValue(char c) {\n    if(c == 'M') return 1000;\n    if(c == 'D') return 500;\n    if(c == 'C') return 100;\n    if(c == 'L') return 50;\n    if(c == 'X') return 10;\n    if(c == 'V') return 5;\n    if(c == 'I') return 1;\n    return 0;\n}\nint romanToInt(char s[]) {\n    int result = 0;\n    for(int i = 0; s[i]; i++) {\n        int curr = getValue(s[i]);\n        int next = getValue(s[i+1]);\n        if(curr < next) {\n            result -= curr;  // Subtraction case (IV, IX, etc.)\n        } else {\n            result += curr;  // Normal addition\n        }\n    }\n    return result;\n}\nint main() { cout << romanToInt(\"III\"); return 0; }",
        "explanation": {
            "approach": "Scan left to right. If current value is less than next, subtract it (like IV=5-1=4). Otherwise add it.",
            "analogy": "Reading backwards logic - if a small letter comes before a big one, it means 'minus'.",
            "steps": [
                "Create a function to convert each Roman letter to its value",
                "Loop through the string",
                "Compare current value with next value",
                "If current < next, subtract current from result",
                "Otherwise, add current to result"
            ],
            "complexity": "Time: O(n), Space: O(1)"
        }
    },
    {
        "id": "e505",
        "title": "Day of Year",
        "description": "Given a date string in format YYYY-MM-DD, return which day of the year it is (1 to 365/366). For example, 2019-01-09 is the 9th day.",
        "difficulty": "EASY",
        "category": "Math",
        "starterCode": "#include <iostream>\nusing namespace std;\nint dayOfYear(char date[]) { return 0; }\nint main() { cout << dayOfYear(\"2019-01-09\"); return 0; }",
        "expectedOutput": "9",
        "solution": "#include <iostream>\nusing namespace std;\nint dayOfYear(char date[]) {\n    int year = (date[0]-'0')*1000 + (date[1]-'0')*100 + (date[2]-'0')*10 + (date[3]-'0');\n    int month = (date[5]-'0')*10 + (date[6]-'0');\n    int day = (date[8]-'0')*10 + (date[9]-'0');\n    \n    int daysInMonth[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n    \n    // Check leap year\n    if((year % 4 == 0 && year % 100 != 0) || year % 400 == 0) {\n        daysInMonth[2] = 29;\n    }\n    \n    int result = day;\n    for(int i = 1; i < month; i++) {\n        result += daysInMonth[i];\n    }\n    return result;\n}\nint main() { cout << dayOfYear(\"2019-01-09\"); return 0; }",
        "explanation": {
            "approach": "Parse the date, sum up all days from previous months, add current day. Handle leap years for February.",
            "analogy": "Like counting pages in a book - add all pages of previous chapters plus your current page number.",
            "steps": [
                "Parse year, month, and day from string",
                "Check if it's a leap year (Feb has 29 days)",
                "Sum days of all months before current month",
                "Add the current day number",
                "Return total"
            ],
            "complexity": "Time: O(1), Space: O(1)"
        }
    },
    {
        "id": "e506",
        "title": "Day of the Week",
        "description": "Given a date (day, month, year), return the name of the day (Sunday, Monday, etc.) using Zeller's congruence or similar algorithm.",
        "difficulty": "EASY",
        "category": "Math",
        "starterCode": "#include <iostream>\nusing namespace std;\nvoid dayOfTheWeek(int day, int month, int year) {}\nint main() { dayOfTheWeek(31, 8, 2019); return 0; }",
        "expectedOutput": "Saturday",
        "solution": "#include <iostream>\nusing namespace std;\nvoid dayOfTheWeek(int d, int m, int y) {\n    char* days[] = {\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"};\n    // Zeller's congruence\n    if(m < 3) {\n        m += 12;\n        y--;\n    }\n    int k = y % 100;  // Year of century\n    int j = y / 100;  // Century\n    int h = (d + 13*(m+1)/5 + k + k/4 + j/4 - 2*j) % 7;\n    h = (h + 6) % 7;  // Adjust to Sunday = 0\n    cout << days[h];\n}\nint main() { dayOfTheWeek(31, 8, 2019); return 0; }",
        "explanation": {
            "approach": "Use Zeller's congruence - a mathematical formula that calculates the day of the week from any date.",
            "analogy": "Like a magic formula that, given any calendar date, tells you what day of the week it was/will be.",
            "steps": [
                "Adjust month and year (Jan/Feb treated as months 13/14 of previous year)",
                "Apply Zeller's formula with day, month, year components",
                "The result h gives the day (0=Saturday in original formula)",
                "Adjust to make Sunday=0",
                "Output the corresponding day name"
            ],
            "complexity": "Time: O(1), Space: O(1)"
        }
    },
    {
        "id": "e507",
        "title": "Cells with Odd Values",
        "description": "Given an m×n matrix initialized to zeros, and an array of increment operations (row, col), increment all cells in the specified row and column. Return count of cells with odd values.",
        "difficulty": "EASY",
        "category": "Matrix",
        "starterCode": "#include <iostream>\nusing namespace std;\nint oddCells(int m, int n, int indices[][2], int k) { return 0; }\nint main() { int ind[][2] = {{0,1}, {1,1}}; cout << oddCells(2, 3, ind, 2); return 0; }",
        "expectedOutput": "6",
        "solution": "#include <iostream>\nusing namespace std;\nint oddCells(int m, int n, int indices[][2], int k) {\n    int rowCount[50] = {}, colCount[50] = {};\n    \n    // Count increments per row and column\n    for(int i = 0; i < k; i++) {\n        rowCount[indices[i][0]]++;\n        colCount[indices[i][1]]++;\n    }\n    \n    // Count cells with odd total increments\n    int count = 0;\n    for(int i = 0; i < m; i++) {\n        for(int j = 0; j < n; j++) {\n            if((rowCount[i] + colCount[j]) % 2 == 1) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\nint main() { int ind[][2] = {{0,1}, {1,1}}; cout << oddCells(2, 3, ind, 2); return 0; }",
        "explanation": {
            "approach": "Instead of simulating the entire matrix, track how many times each row and column is incremented. A cell's value = row_count + col_count.",
            "analogy": "Like counting traffic at intersections - a car passes through cell (i,j) for every row-i increment and column-j increment.",
            "steps": [
                "Count increments for each row in rowCount[]",
                "Count increments for each column in colCount[]",
                "For each cell (i,j), its value = rowCount[i] + colCount[j]",
                "If this sum is odd, increment our answer",
                "Return total count of odd cells"
            ],
            "complexity": "Time: O(m×n + k), Space: O(m + n)"
        }
    },
    {
        "id": "e508",
        "title": "Shift 2D Grid",
        "description": "Given a 2D grid of integers and a number k, shift all elements k times. Each shift moves the last element to become the first (circular shift).",
        "difficulty": "EASY",
        "category": "Matrix",
        "starterCode": "#include <iostream>\nusing namespace std;\nvoid shiftGrid(int grid[][3], int m, int n, int k) {}\nint main() { int g[][3] = {{1,2,3}, {4,5,6}, {7,8,9}}; shiftGrid(g, 3, 3, 1); return 0; }",
        "expectedOutput": "9 1 2 3 4 5 6 7 8",
        "solution": "#include <iostream>\nusing namespace std;\nvoid shiftGrid(int grid[][3], int m, int n, int k) {\n    int size = m * n;\n    k %= size;  // Handle k > size\n    \n    // Flatten grid to 1D\n    int temp[size];\n    for(int i = 0; i < m; i++) {\n        for(int j = 0; j < n; j++) {\n            temp[i * n + j] = grid[i][j];\n        }\n    }\n    \n    // Shift and put back\n    for(int i = 0; i < m; i++) {\n        for(int j = 0; j < n; j++) {\n            int oldIndex = (i * n + j - k + size) % size;\n            grid[i][j] = temp[oldIndex];\n        }\n    }\n    \n    // Print result\n    for(int i = 0; i < m; i++) {\n        for(int j = 0; j < n; j++) {\n            cout << grid[i][j] << \" \";\n        }\n    }\n}\nint main() { int g[][3] = {{1,2,3}, {4,5,6}, {7,8,9}}; shiftGrid(g, 3, 3, 1); return 0; }",
        "explanation": {
            "approach": "Treat the 2D grid as a 1D array by flattening it. Perform circular shift on 1D array, then reshape back to 2D.",
            "analogy": "Like a conveyor belt - imagine all items in a single line. Shifting moves everything forward with the last item wrapping to the front.",
            "steps": [
                "Flatten the 2D grid into a 1D array",
                "Calculate new position for each element after k shifts",
                "New position = (old position + k) % total_size",
                "Reshape back to 2D grid",
                "Print the result"
            ],
            "complexity": "Time: O(m × n), Space: O(m × n)"
        }
    },
    {
        "id": "e509",
        "title": "Replace Elements with Greatest",
        "description": "Given an array, replace each element with the greatest element to its right. The last element becomes -1 since there's nothing to its right.",
        "difficulty": "EASY",
        "category": "Arrays",
        "starterCode": "#include <iostream>\nusing namespace std;\nvoid replaceElements(int arr[], int n) {}\nint main() { int a[] = {17, 18, 5, 4, 6, 1}; replaceElements(a, 6); for(int i = 0; i < 6; i++) cout << a[i] << \" \"; return 0; }",
        "expectedOutput": "18 6 6 6 1 -1",
        "solution": "#include <iostream>\nusing namespace std;\nvoid replaceElements(int arr[], int n) {\n    int maxRight = -1;  // Start with -1 for last element\n    \n    // Traverse from right to left\n    for(int i = n - 1; i >= 0; i--) {\n        int current = arr[i];  // Save current value\n        arr[i] = maxRight;     // Replace with max on right\n        if(current > maxRight) {\n            maxRight = current;  // Update max\n        }\n    }\n}\nint main() { int a[] = {17, 18, 5, 4, 6, 1}; replaceElements(a, 6); for(int i = 0; i < 6; i++) cout << a[i] << \" \"; return 0; }",
        "explanation": {
            "approach": "Scan from right to left, keeping track of the maximum seen so far. Each element gets replaced by this running maximum.",
            "analogy": "Like looking over your shoulder - each person reports the tallest person they can see behind them.",
            "steps": [
                "Start from the rightmost element",
                "Keep track of maximum value seen so far (starts as -1)",
                "Save current element, replace it with current max",
                "Update max if current was larger",
                "Move left and repeat"
            ],
            "complexity": "Time: O(n), Space: O(1)"
        }
    },
    {
        "id": "e510",
        "title": "Sort by Number of 1 Bits",
        "description": "Sort array by the number of 1s in their binary representation. If two numbers have the same number of 1 bits, sort them by their value.",
        "difficulty": "EASY",
        "category": "Sorting",
        "starterCode": "#include <iostream>\nusing namespace std;\nvoid sortByBits(int arr[], int n) {}\nint main() { int a[] = {0, 1, 2, 3, 4, 5, 6, 7, 8}; sortByBits(a, 9); for(int i = 0; i < 9; i++) cout << a[i] << \" \"; return 0; }",
        "expectedOutput": "0 1 2 4 8 3 5 6 7",
        "solution": "#include <iostream>\nusing namespace std;\nint countBits(int n) {\n    int count = 0;\n    while(n) {\n        count += n & 1;  // Add last bit\n        n >>= 1;        // Shift right\n    }\n    return count;\n}\nvoid sortByBits(int arr[], int n) {\n    // Bubble sort with custom comparison\n    for(int i = 0; i < n - 1; i++) {\n        for(int j = 0; j < n - i - 1; j++) {\n            int bits1 = countBits(arr[j]);\n            int bits2 = countBits(arr[j + 1]);\n            // Swap if more bits, or same bits but larger value\n            if(bits1 > bits2 || (bits1 == bits2 && arr[j] > arr[j + 1])) {\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n}\nint main() { int a[] = {0, 1, 2, 3, 4, 5, 6, 7, 8}; sortByBits(a, 9); for(int i = 0; i < 9; i++) cout << a[i] << \" \"; return 0; }",
        "explanation": {
            "approach": "Count the 1 bits in each number's binary form. Sort primarily by bit count, secondarily by value.",
            "analogy": "Like sorting students by test score, and if scores are tied, sort by name. Here 'score' is number of 1 bits.",
            "steps": [
                "Create a function to count 1 bits (using AND with 1, then shift right)",
                "Use sorting algorithm (bubble sort shown here)",
                "Compare by bit count first",
                "If bit counts are equal, compare by value",
                "Sort in ascending order"
            ],
            "complexity": "Time: O(n² × log(max)), Space: O(1)"
        }
    }
]