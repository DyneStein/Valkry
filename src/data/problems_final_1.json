[
    {
        "id": "final1",
        "title": "Rotate Matrix 90",
        "description": "Rotate matrix clockwise.",
        "difficulty": "MEDIUM",
        "category": "Matrix",
        "starterCode": "#include <iostream>\nusing namespace std;\nvoid rotate(int m[][3], int n) {}\nint main() { int m[3][3]={{1,2,3},{4,5,6},{7,8,9}}; rotate(m,3); for(int i=0;i<3;i++) { for(int j=0;j<3;j++) cout<<m[i][j]<<\" \"; } return 0; }",
        "expectedOutput": "7 4 1 8 5 2 9 6 3",
        "solution": "#include <iostream>\nusing namespace std;\nvoid rotate(int m[][3], int n) { for(int i=0;i<n;i++) for(int j=i;j<n;j++) swap(m[i][j],m[j][i]); for(int i=0;i<n;i++) for(int j=0;j<n/2;j++) swap(m[i][j],m[i][n-1-j]); }\nint main() { int m[3][3]={{1,2,3},{4,5,6},{7,8,9}}; rotate(m,3); for(int i=0;i<3;i++) { for(int j=0;j<3;j++) cout<<m[i][j]<<\" \"; } return 0; }",
        "explanation": {
            "approach": "Transpose then reverse each row.",
            "analogy": "Flip diagonally, then mirror horizontally.",
            "steps": [
                "Transpose matrix",
                "Reverse each row"
            ],
            "complexity": "Time: O(n²), Space: O(1)"
        }
    },
    {
        "id": "final2",
        "title": "Spiral Matrix",
        "description": "Print matrix in spiral.",
        "difficulty": "MEDIUM",
        "category": "Matrix",
        "starterCode": "#include <iostream>\nusing namespace std;\nvoid spiral(int m[][4], int r, int c) {}\nint main() { int m[3][4]={{1,2,3,4},{5,6,7,8},{9,10,11,12}}; spiral(m,3,4); return 0; }",
        "expectedOutput": "1 2 3 4 8 12 11 10 9 5 6 7",
        "solution": "#include <iostream>\nusing namespace std;\nvoid spiral(int m[][4], int r, int c) { int t=0,b=r-1,l=0,ri=c-1; while(t<=b && l<=ri) { for(int i=l;i<=ri;i++) cout<<m[t][i]<<\" \"; t++; for(int i=t;i<=b;i++) cout<<m[i][ri]<<\" \"; ri--; if(t<=b) { for(int i=ri;i>=l;i--) cout<<m[b][i]<<\" \"; b--; } if(l<=ri) { for(int i=b;i>=t;i--) cout<<m[i][l]<<\" \"; l++; } } }\nint main() { int m[3][4]={{1,2,3,4},{5,6,7,8},{9,10,11,12}}; spiral(m,3,4); return 0; }",
        "explanation": {
            "approach": "Track boundaries, shrink after each layer.",
            "analogy": "Peel the onion layer by layer.",
            "steps": [
                "Go right, down, left, up",
                "Shrink boundaries",
                "Repeat"
            ],
            "complexity": "Time: O(r×c), Space: O(1)"
        }
    },
    {
        "id": "final3",
        "title": "Set Matrix Zeros",
        "description": "Set row and col to 0.",
        "difficulty": "MEDIUM",
        "category": "Matrix",
        "starterCode": "#include <iostream>\nusing namespace std;\nvoid setZeroes(int m[][3], int r, int c) {}\nint main() { int m[3][3]={{1,1,1},{1,0,1},{1,1,1}}; setZeroes(m,3,3); for(int i=0;i<3;i++) for(int j=0;j<3;j++) cout<<m[i][j]<<\" \"; return 0; }",
        "expectedOutput": "1 0 1 0 0 0 1 0 1",
        "solution": "#include <iostream>\nusing namespace std;\nvoid setZeroes(int m[][3], int r, int c) { bool r0=false, c0=false; for(int i=0;i<r;i++) if(m[i][0]==0) c0=true; for(int j=0;j<c;j++) if(m[0][j]==0) r0=true; for(int i=1;i<r;i++) for(int j=1;j<c;j++) if(m[i][j]==0) { m[i][0]=0; m[0][j]=0; } for(int i=1;i<r;i++) for(int j=1;j<c;j++) if(m[i][0]==0||m[0][j]==0) m[i][j]=0; if(c0) for(int i=0;i<r;i++) m[i][0]=0; if(r0) for(int j=0;j<c;j++) m[0][j]=0; }\nint main() { int m[3][3]={{1,1,1},{1,0,1},{1,1,1}}; setZeroes(m,3,3); for(int i=0;i<3;i++) for(int j=0;j<3;j++) cout<<m[i][j]<<\" \"; return 0; }",
        "explanation": {
            "approach": "Use first row/col as markers.",
            "analogy": "Mark rows and cols to zero later.",
            "steps": [
                "Mark first row/col",
                "Use them as flags",
                "Set zeros based on flags"
            ],
            "complexity": "Time: O(r×c), Space: O(1)"
        }
    },
    {
        "id": "final4",
        "title": "Sudoku Validator",
        "description": "Check valid sudoku.",
        "difficulty": "MEDIUM",
        "category": "Matrix",
        "starterCode": "#include <iostream>\nusing namespace std;\nbool isValidSudoku(int b[][9]) { return false; }\nint main() { int b[9][9]={{5,3,0,0,7,0,0,0,0},{6,0,0,1,9,5,0,0,0},{0,9,8,0,0,0,0,6,0},{8,0,0,0,6,0,0,0,3},{4,0,0,8,0,3,0,0,1},{7,0,0,0,2,0,0,0,6},{0,6,0,0,0,0,2,8,0},{0,0,0,4,1,9,0,0,5},{0,0,0,0,8,0,0,7,9}}; cout<<isValidSudoku(b); return 0; }",
        "expectedOutput": "1",
        "solution": "#include <iostream>\nusing namespace std;\nbool isValidSudoku(int b[][9]) { for(int i=0;i<9;i++) { int r[10]={}, c[10]={}; for(int j=0;j<9;j++) { if(b[i][j] && r[b[i][j]]++) return false; if(b[j][i] && c[b[j][i]]++) return false; } } for(int bi=0;bi<3;bi++) for(int bj=0;bj<3;bj++) { int s[10]={}; for(int i=0;i<3;i++) for(int j=0;j<3;j++) if(b[bi*3+i][bj*3+j] && s[b[bi*3+i][bj*3+j]]++) return false; } return true; }\nint main() { int b[9][9]={{5,3,0,0,7,0,0,0,0},{6,0,0,1,9,5,0,0,0},{0,9,8,0,0,0,0,6,0},{8,0,0,0,6,0,0,0,3},{4,0,0,8,0,3,0,0,1},{7,0,0,0,2,0,0,0,6},{0,6,0,0,0,0,2,8,0},{0,0,0,4,1,9,0,0,5},{0,0,0,0,8,0,0,7,9}}; cout<<isValidSudoku(b); return 0; }",
        "explanation": {
            "approach": "Check rows, cols, and 3×3 boxes.",
            "analogy": "No repeats in any row, col, or box.",
            "steps": [
                "Check each row",
                "Check each column",
                "Check each 3×3 box"
            ],
            "complexity": "Time: O(1), Space: O(1)"
        }
    },
    {
        "id": "final5",
        "title": "Word Break",
        "description": "Can string be segmented.",
        "difficulty": "MEDIUM",
        "category": "DP",
        "starterCode": "#include <iostream>\nusing namespace std;\nbool wordBreak(char s[], char dict[][10], int n) { return false; }\nint main() { char dict[][10]={\"leet\",\"code\"}; cout<<wordBreak(\"leetcode\",dict,2); return 0; }",
        "expectedOutput": "1",
        "solution": "#include <iostream>\nusing namespace std;\nbool wordBreak(char s[], char dict[][10], int n) { int len=0; while(s[len]) len++; bool dp[len+1]={}; dp[0]=true; for(int i=1;i<=len;i++) for(int j=0;j<i;j++) if(dp[j]) { bool match=false; for(int k=0;k<n;k++) { int wl=0; while(dict[k][wl]) wl++; if(wl==i-j) { bool ok=true; for(int m=0;m<wl;m++) if(s[j+m]!=dict[k][m]) ok=false; if(ok) match=true; } } if(match) dp[i]=true; } return dp[len]; }\nint main() { char dict[][10]={\"leet\",\"code\"}; cout<<wordBreak(\"leetcode\",dict,2); return 0; }",
        "explanation": {
            "approach": "dp[i] = can we form s[0..i-1] from dictionary.",
            "analogy": "Build string word by word.",
            "steps": [
                "dp[0] = true (empty string)",
                "For each position, check all words"
            ],
            "complexity": "Time: O(n² × m), Space: O(n)"
        }
    },
    {
        "id": "final6",
        "title": "House Robber",
        "description": "Max money without adjacent.",
        "difficulty": "MEDIUM",
        "category": "DP",
        "starterCode": "#include <iostream>\nusing namespace std;\nint rob(int a[], int n) { return 0; }\nint main() { int a[]={2,7,9,3,1}; cout<<rob(a,5); return 0; }",
        "expectedOutput": "12",
        "solution": "#include <iostream>\nusing namespace std;\nint rob(int a[], int n) { if(n==0) return 0; if(n==1) return a[0]; int prev2=a[0], prev1=max(a[0],a[1]); for(int i=2;i<n;i++) { int cur=max(prev1, prev2+a[i]); prev2=prev1; prev1=cur; } return prev1; }\nint main() { int a[]={2,7,9,3,1}; cout<<rob(a,5); return 0; }",
        "explanation": {
            "approach": "Rob current + prev2 OR skip current.",
            "analogy": "Can't rob neighbors.",
            "steps": [
                "Either rob house i + profit from i-2",
                "Or skip house i, keep profit from i-1"
            ],
            "complexity": "Time: O(n), Space: O(1)"
        }
    },
    {
        "id": "final7",
        "title": "Unique Paths",
        "description": "Paths in grid.",
        "difficulty": "MEDIUM",
        "category": "DP",
        "starterCode": "#include <iostream>\nusing namespace std;\nint uniquePaths(int m, int n) { return 0; }\nint main() { cout<<uniquePaths(3,7); return 0; }",
        "expectedOutput": "28",
        "solution": "#include <iostream>\nusing namespace std;\nint uniquePaths(int m, int n) { int dp[m][n]; for(int i=0;i<m;i++) for(int j=0;j<n;j++) dp[i][j]=(i==0||j==0)?1:dp[i-1][j]+dp[i][j-1]; return dp[m-1][n-1]; }\nint main() { cout<<uniquePaths(3,7); return 0; }",
        "explanation": {
            "approach": "dp[i][j] = paths from top or left.",
            "analogy": "Can only come from above or left.",
            "steps": [
                "First row and col have 1 path each",
                "Others = sum of top + left"
            ],
            "complexity": "Time: O(m×n), Space: O(m×n)"
        }
    },
    {
        "id": "final8",
        "title": "Decode Ways",
        "description": "Ways to decode number string.",
        "difficulty": "MEDIUM",
        "category": "DP",
        "starterCode": "#include <iostream>\nusing namespace std;\nint numDecodings(char s[]) { return 0; }\nint main() { cout<<numDecodings(\"226\"); return 0; }",
        "expectedOutput": "3",
        "solution": "#include <iostream>\nusing namespace std;\nint numDecodings(char s[]) { int n=0; while(s[n]) n++; if(n==0||s[0]=='0') return 0; int dp[n+1]={}; dp[0]=1; dp[1]=1; for(int i=2;i<=n;i++) { if(s[i-1]!='0') dp[i]=dp[i-1]; int two=(s[i-2]-'0')*10+(s[i-1]-'0'); if(two>=10&&two<=26) dp[i]+=dp[i-2]; } return dp[n]; }\nint main() { cout<<numDecodings(\"226\"); return 0; }",
        "explanation": {
            "approach": "1 digit or 2 digit decode.",
            "analogy": "Like Fibonacci with constraints.",
            "steps": [
                "Single digit: 1-9 valid",
                "Two digits: 10-26 valid"
            ],
            "complexity": "Time: O(n), Space: O(n)"
        }
    },
    {
        "id": "final9",
        "title": "Jump Game",
        "description": "Can reach last index.",
        "difficulty": "MEDIUM",
        "category": "Greedy",
        "starterCode": "#include <iostream>\nusing namespace std;\nbool canJump(int a[], int n) { return false; }\nint main() { int a[]={2,3,1,1,4}; cout<<canJump(a,5); return 0; }",
        "expectedOutput": "1",
        "solution": "#include <iostream>\nusing namespace std;\nbool canJump(int a[], int n) { int reach=0; for(int i=0;i<n;i++) { if(i>reach) return false; reach=max(reach, i+a[i]); } return true; }\nint main() { int a[]={2,3,1,1,4}; cout<<canJump(a,5); return 0; }",
        "explanation": {
            "approach": "Track farthest reachable position.",
            "analogy": "Greedy - always update max reach.",
            "steps": [
                "Update max reachable",
                "If current > max reach, impossible"
            ],
            "complexity": "Time: O(n), Space: O(1)"
        }
    },
    {
        "id": "final10",
        "title": "Product Except Self",
        "description": "Product of all except current.",
        "difficulty": "MEDIUM",
        "category": "Arrays",
        "starterCode": "#include <iostream>\nusing namespace std;\nvoid productExceptSelf(int a[], int n) {}\nint main() { int a[]={1,2,3,4}; productExceptSelf(a,4); return 0; }",
        "expectedOutput": "24 12 8 6",
        "solution": "#include <iostream>\nusing namespace std;\nvoid productExceptSelf(int a[], int n) { int res[n]; res[0]=1; for(int i=1;i<n;i++) res[i]=res[i-1]*a[i-1]; int right=1; for(int i=n-1;i>=0;i--) { res[i]*=right; right*=a[i]; } for(int i=0;i<n;i++) cout<<res[i]<<\" \"; }\nint main() { int a[]={1,2,3,4}; productExceptSelf(a,4); return 0; }",
        "explanation": {
            "approach": "Left products × right products.",
            "analogy": "Prefix and suffix products.",
            "steps": [
                "Calculate prefix products",
                "Multiply by suffix products"
            ],
            "complexity": "Time: O(n), Space: O(n)"
        }
    }
]