[
    {
        "id": "final1",
        "title": "Rotate Matrix 90",
        "description": "Rotate matrix clockwise.",
        "difficulty": "MEDIUM",
        "category": "Matrix",
        "starterCode": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nvoid rotate(vector<vector<int>>& m, int n) {\n    // TODO\n}\n\nint main() {\n    int m_rows, m_cols;\n    cin >> m_rows >> m_cols;\n    vector<vector<int>> m(m_rows, vector<int>(m_cols));\n    for (int i = 0; i < m_rows; i++)\n        for (int j = 0; j < m_cols; j++)\n            cin >> m[i][j];\n    int n;\n    cin >> n;\n    rotate(m, n);\n    return 0;\n}\n",
        "expectedOutput": "7 4 1 8 5 2 9 6 3",
        "solution": "#include <iostream>\nusing namespace std;\nvoid rotate(int m[][3], int n) { for(int i=0;i<n;i++) for(int j=i;j<n;j++) swap(m[i][j],m[j][i]); for(int i=0;i<n;i++) for(int j=0;j<n/2;j++) swap(m[i][j],m[i][n-1-j]); }\nint main() { int m[3][3]={{1,2,3},{4,5,6},{7,8,9}}; rotate(m,3); for(int i=0;i<3;i++) { for(int j=0;j<3;j++) cout<<m[i][j]<<\" \"; } return 0; }",
        "explanation": {
            "approach": "Transpose then reverse each row.",
            "analogy": "Flip diagonally, then mirror horizontally.",
            "steps": [
                "Transpose matrix",
                "Reverse each row"
            ],
            "complexity": "Time: O(n²), Space: O(1)"
        },
        "testCases": [
            {
                "input": "{{1,2,3},{4,5,6},{7,8,9}}",
                "expectedOutput": "7 4 1 8 5 2 9 6 3",
                "explanation": "3x3 matrix rotated 90 degrees clockwise"
            },
            {
                "input": "{{1}}",
                "expectedOutput": "1",
                "explanation": "Single element matrix remains unchanged"
            },
            {
                "input": "{{1,2},{3,4}}",
                "expectedOutput": "3 1 4 2",
                "explanation": "2x2 matrix rotation"
            },
            {
                "input": "{{1,2,3,4},{5,6,7,8},{9,10,11,12},{13,14,15,16}}",
                "expectedOutput": "13 9 5 1 14 10 6 2 15 11 7 3 16 12 8 4",
                "explanation": "4x4 matrix rotation"
            }
        ]
    },
    {
        "id": "final2",
        "title": "Spiral Matrix",
        "description": "Print matrix in spiral.",
        "difficulty": "MEDIUM",
        "category": "Matrix",
        "starterCode": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nvoid spiral(vector<vector<int>>& m, int r, int c) {\n    // TODO\n}\n\nint main() {\n    int m_rows, m_cols;\n    cin >> m_rows >> m_cols;\n    vector<vector<int>> m(m_rows, vector<int>(m_cols));\n    for (int i = 0; i < m_rows; i++)\n        for (int j = 0; j < m_cols; j++)\n            cin >> m[i][j];\n    int r;\n    cin >> r;\n    int c;\n    cin >> c;\n    spiral(m, r, c);\n    return 0;\n}\n",
        "expectedOutput": "1 2 3 4 8 12 11 10 9 5 6 7",
        "solution": "#include <iostream>\nusing namespace std;\nvoid spiral(int m[][4], int r, int c) { int t=0,b=r-1,l=0,ri=c-1; while(t<=b && l<=ri) { for(int i=l;i<=ri;i++) cout<<m[t][i]<<\" \"; t++; for(int i=t;i<=b;i++) cout<<m[i][ri]<<\" \"; ri--; if(t<=b) { for(int i=ri;i>=l;i--) cout<<m[b][i]<<\" \"; b--; } if(l<=ri) { for(int i=b;i>=t;i--) cout<<m[i][l]<<\" \"; l++; } } }\nint main() { int m[3][4]={{1,2,3,4},{5,6,7,8},{9,10,11,12}}; spiral(m,3,4); return 0; }",
        "explanation": {
            "approach": "Track boundaries, shrink after each layer.",
            "analogy": "Peel the onion layer by layer.",
            "steps": [
                "Go right, down, left, up",
                "Shrink boundaries",
                "Repeat"
            ],
            "complexity": "Time: O(r×c), Space: O(1)"
        },
        "testCases": [
            {
                "input": "{{1,2,3,4},{5,6,7,8},{9,10,11,12}}",
                "expectedOutput": "1 2 3 4 8 12 11 10 9 5 6 7",
                "explanation": "3x4 matrix spiral traversal"
            },
            {
                "input": "{{1,2,3},{4,5,6},{7,8,9}}",
                "expectedOutput": "1 2 3 6 9 8 7 4 5",
                "explanation": "3x3 matrix spiral traversal"
            },
            {
                "input": "{{1}}",
                "expectedOutput": "1",
                "explanation": "Single element matrix"
            },
            {
                "input": "{{1,2,3,4}}",
                "expectedOutput": "1 2 3 4",
                "explanation": "Single row matrix"
            }
        ]
    },
    {
        "id": "final3",
        "title": "Set Matrix Zeros",
        "description": "Set row and col to 0.",
        "difficulty": "MEDIUM",
        "category": "Matrix",
        "starterCode": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nvoid setZeroes(vector<vector<int>>& m, int r, int c) {\n    // TODO\n}\n\nint main() {\n    int m_rows, m_cols;\n    cin >> m_rows >> m_cols;\n    vector<vector<int>> m(m_rows, vector<int>(m_cols));\n    for (int i = 0; i < m_rows; i++)\n        for (int j = 0; j < m_cols; j++)\n            cin >> m[i][j];\n    int r;\n    cin >> r;\n    int c;\n    cin >> c;\n    setZeroes(m, r, c);\n    return 0;\n}\n",
        "expectedOutput": "1 0 1 0 0 0 1 0 1",
        "solution": "#include <iostream>\nusing namespace std;\nvoid setZeroes(int m[][3], int r, int c) { bool r0=false, c0=false; for(int i=0;i<r;i++) if(m[i][0]==0) c0=true; for(int j=0;j<c;j++) if(m[0][j]==0) r0=true; for(int i=1;i<r;i++) for(int j=1;j<c;j++) if(m[i][j]==0) { m[i][0]=0; m[0][j]=0; } for(int i=1;i<r;i++) for(int j=1;j<c;j++) if(m[i][0]==0||m[0][j]==0) m[i][j]=0; if(c0) for(int i=0;i<r;i++) m[i][0]=0; if(r0) for(int j=0;j<c;j++) m[0][j]=0; }\nint main() { int m[3][3]={{1,1,1},{1,0,1},{1,1,1}}; setZeroes(m,3,3); for(int i=0;i<3;i++) for(int j=0;j<3;j++) cout<<m[i][j]<<\" \"; return 0; }",
        "explanation": {
            "approach": "Use first row/col as markers.",
            "analogy": "Mark rows and cols to zero later.",
            "steps": [
                "Mark first row/col",
                "Use them as flags",
                "Set zeros based on flags"
            ],
            "complexity": "Time: O(r×c), Space: O(1)"
        },
        "testCases": [
            {
                "input": "{{1,1,1},{1,0,1},{1,1,1}}",
                "expectedOutput": "1 0 1 0 0 0 1 0 1",
                "explanation": "Zero at center sets entire row and column to zero"
            },
            {
                "input": "{{0,1,1},{1,1,1},{1,1,1}}",
                "expectedOutput": "0 0 0 0 1 1 0 1 1",
                "explanation": "Zero at corner sets first row and column to zero"
            },
            {
                "input": "{{1,1,1},{1,1,1},{1,1,1}}",
                "expectedOutput": "1 1 1 1 1 1 1 1 1",
                "explanation": "No zeros in matrix - no change"
            },
            {
                "input": "{{0,0,0},{0,0,0},{0,0,0}}",
                "expectedOutput": "0 0 0 0 0 0 0 0 0",
                "explanation": "All zeros remain zeros"
            }
        ]
    },
    {
        "id": "final4",
        "title": "Sudoku Validator",
        "description": "Check valid sudoku.",
        "difficulty": "MEDIUM",
        "category": "Matrix",
        "starterCode": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nbool isValidSudoku(vector<vector<int>>& b) {\n    return false;\n}\n\nint main() {\n    int b_rows, b_cols;\n    cin >> b_rows >> b_cols;\n    vector<vector<int>> b(b_rows, vector<int>(b_cols));\n    for (int i = 0; i < b_rows; i++)\n        for (int j = 0; j < b_cols; j++)\n            cin >> b[i][j];\n    cout << isValidSudoku(b);\n    return 0;\n}\n",
        "expectedOutput": "1",
        "solution": "#include <iostream>\nusing namespace std;\nbool isValidSudoku(int b[][9]) { for(int i=0;i<9;i++) { int r[10]={}, c[10]={}; for(int j=0;j<9;j++) { if(b[i][j] && r[b[i][j]]++) return false; if(b[j][i] && c[b[j][i]]++) return false; } } for(int bi=0;bi<3;bi++) for(int bj=0;bj<3;bj++) { int s[10]={}; for(int i=0;i<3;i++) for(int j=0;j<3;j++) if(b[bi*3+i][bj*3+j] && s[b[bi*3+i][bj*3+j]]++) return false; } return true; }\nint main() { int b[9][9]={{5,3,0,0,7,0,0,0,0},{6,0,0,1,9,5,0,0,0},{0,9,8,0,0,0,0,6,0},{8,0,0,0,6,0,0,0,3},{4,0,0,8,0,3,0,0,1},{7,0,0,0,2,0,0,0,6},{0,6,0,0,0,0,2,8,0},{0,0,0,4,1,9,0,0,5},{0,0,0,0,8,0,0,7,9}}; cout<<isValidSudoku(b); return 0; }",
        "explanation": {
            "approach": "Check rows, cols, and 3×3 boxes.",
            "analogy": "No repeats in any row, col, or box.",
            "steps": [
                "Check each row",
                "Check each column",
                "Check each 3×3 box"
            ],
            "complexity": "Time: O(1), Space: O(1)"
        },
        "testCases": [
            {
                "input": "Valid partial sudoku",
                "expectedOutput": "1",
                "explanation": "No duplicate digits in any row, column, or 3x3 box"
            },
            {
                "input": "Duplicate in row",
                "expectedOutput": "0",
                "explanation": "Same digit appears twice in one row"
            },
            {
                "input": "Duplicate in 3x3 box",
                "expectedOutput": "0",
                "explanation": "Same digit appears twice in one 3x3 sub-box"
            },
            {
                "input": "Empty sudoku",
                "expectedOutput": "1",
                "explanation": "All zeros is technically valid"
            }
        ]
    },
    {
        "id": "final5",
        "title": "Word Break",
        "description": "Can string be segmented.",
        "difficulty": "MEDIUM",
        "category": "DP",
        "starterCode": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nbool wordBreak(vector<int>& s, vector<vector<int>>& dict, int n) {\n    return false;\n}\n\nint main() {\n    int s_size;\n    cin >> s_size;\n    vector<int> s(s_size);\n    for (int i = 0; i < s_size; i++) cin >> s[i];\n    int dict_rows, dict_cols;\n    cin >> dict_rows >> dict_cols;\n    vector<vector<int>> dict(dict_rows, vector<int>(dict_cols));\n    for (int i = 0; i < dict_rows; i++)\n        for (int j = 0; j < dict_cols; j++)\n            cin >> dict[i][j];\n    int n;\n    cin >> n;\n    cout << wordBreak(s, dict, n);\n    return 0;\n}\n",
        "expectedOutput": "1",
        "solution": "#include <iostream>\nusing namespace std;\nbool wordBreak(char s[], char dict[][10], int n) { int len=0; while(s[len]) len++; bool dp[len+1]={}; dp[0]=true; for(int i=1;i<=len;i++) for(int j=0;j<i;j++) if(dp[j]) { bool match=false; for(int k=0;k<n;k++) { int wl=0; while(dict[k][wl]) wl++; if(wl==i-j) { bool ok=true; for(int m=0;m<wl;m++) if(s[j+m]!=dict[k][m]) ok=false; if(ok) match=true; } } if(match) dp[i]=true; } return dp[len]; }\nint main() { char dict[][10]={\"leet\",\"code\"}; cout<<wordBreak(\"leetcode\",dict,2); return 0; }",
        "explanation": {
            "approach": "dp[i] = can we form s[0..i-1] from dictionary.",
            "analogy": "Build string word by word.",
            "steps": [
                "dp[0] = true (empty string)",
                "For each position, check all words"
            ],
            "complexity": "Time: O(n² × m), Space: O(n)"
        },
        "testCases": [
            {
                "input": "s=\"leetcode\", dict=[\"leet\",\"code\"]",
                "expectedOutput": "1",
                "explanation": "leetcode can be split into leet + code"
            },
            {
                "input": "s=\"applepenapple\", dict=[\"apple\",\"pen\"]",
                "expectedOutput": "1",
                "explanation": "applepenapple = apple + pen + apple"
            },
            {
                "input": "s=\"catsandog\", dict=[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]",
                "expectedOutput": "0",
                "explanation": "Cannot be segmented into dictionary words"
            },
            {
                "input": "s=\"a\", dict=[\"a\"]",
                "expectedOutput": "1",
                "explanation": "Single character match"
            }
        ]
    },
    {
        "id": "final6",
        "title": "House Robber",
        "description": "Max money without adjacent.",
        "difficulty": "MEDIUM",
        "category": "DP",
        "starterCode": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint rob(vector<int>& a, int n) {\n    return 0;\n}\n\nint main() {\n    int a_size;\n    cin >> a_size;\n    vector<int> a(a_size);\n    for (int i = 0; i < a_size; i++) cin >> a[i];\n    int n;\n    cin >> n;\n    cout << rob(a, n);\n    return 0;\n}\n",
        "expectedOutput": "12",
        "solution": "#include <iostream>\nusing namespace std;\nint rob(int a[], int n) { if(n==0) return 0; if(n==1) return a[0]; int prev2=a[0], prev1=max(a[0],a[1]); for(int i=2;i<n;i++) { int cur=max(prev1, prev2+a[i]); prev2=prev1; prev1=cur; } return prev1; }\nint main() { int a[]={2,7,9,3,1}; cout<<rob(a,5); return 0; }",
        "explanation": {
            "approach": "Rob current + prev2 OR skip current.",
            "analogy": "Can't rob neighbors.",
            "steps": [
                "Either rob house i + profit from i-2",
                "Or skip house i, keep profit from i-1"
            ],
            "complexity": "Time: O(n), Space: O(1)"
        },
        "testCases": [
            {
                "input": "{2,7,9,3,1}",
                "expectedOutput": "12",
                "explanation": "Rob houses 0,2,4 for 2+9+1=12"
            },
            {
                "input": "{1,2,3,1}",
                "expectedOutput": "4",
                "explanation": "Rob houses 0 and 2 for 1+3=4"
            },
            {
                "input": "{2,1,1,2}",
                "expectedOutput": "4",
                "explanation": "Rob houses 0 and 3 for 2+2=4"
            },
            {
                "input": "{100}",
                "expectedOutput": "100",
                "explanation": "Single house - rob it"
            }
        ]
    },
    {
        "id": "final7",
        "title": "Unique Paths",
        "description": "Paths in grid.",
        "difficulty": "MEDIUM",
        "category": "DP",
        "starterCode": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint uniquePaths(int m, int n) {\n    return 0;\n}\n\nint main() {\n    int m;\n    cin >> m;\n    int n;\n    cin >> n;\n    cout << uniquePaths(m, n);\n    return 0;\n}\n",
        "expectedOutput": "28",
        "solution": "#include <iostream>\nusing namespace std;\nint uniquePaths(int m, int n) { int dp[m][n]; for(int i=0;i<m;i++) for(int j=0;j<n;j++) dp[i][j]=(i==0||j==0)?1:dp[i-1][j]+dp[i][j-1]; return dp[m-1][n-1]; }\nint main() { cout<<uniquePaths(3,7); return 0; }",
        "explanation": {
            "approach": "dp[i][j] = paths from top or left.",
            "analogy": "Can only come from above or left.",
            "steps": [
                "First row and col have 1 path each",
                "Others = sum of top + left"
            ],
            "complexity": "Time: O(m×n), Space: O(m×n)"
        },
        "testCases": [
            {
                "input": "m=3, n=7",
                "expectedOutput": "28",
                "explanation": "3x7 grid has 28 unique paths to bottom-right"
            },
            {
                "input": "m=3, n=2",
                "expectedOutput": "3",
                "explanation": "3x2 grid has 3 unique paths"
            },
            {
                "input": "m=1, n=1",
                "expectedOutput": "1",
                "explanation": "1x1 grid has only 1 path (already there)"
            },
            {
                "input": "m=5, n=5",
                "expectedOutput": "70",
                "explanation": "5x5 grid has C(8,4) = 70 paths"
            }
        ]
    },
    {
        "id": "final8",
        "title": "Decode Ways",
        "description": "Ways to decode number string.",
        "difficulty": "MEDIUM",
        "category": "DP",
        "starterCode": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint numDecodings(vector<int>& s) {\n    return 0;\n}\n\nint main() {\n    int s_size;\n    cin >> s_size;\n    vector<int> s(s_size);\n    for (int i = 0; i < s_size; i++) cin >> s[i];\n    cout << numDecodings(s);\n    return 0;\n}\n",
        "expectedOutput": "3",
        "solution": "#include <iostream>\nusing namespace std;\nint numDecodings(char s[]) { int n=0; while(s[n]) n++; if(n==0||s[0]=='0') return 0; int dp[n+1]={}; dp[0]=1; dp[1]=1; for(int i=2;i<=n;i++) { if(s[i-1]!='0') dp[i]=dp[i-1]; int two=(s[i-2]-'0')*10+(s[i-1]-'0'); if(two>=10&&two<=26) dp[i]+=dp[i-2]; } return dp[n]; }\nint main() { cout<<numDecodings(\"226\"); return 0; }",
        "explanation": {
            "approach": "1 digit or 2 digit decode.",
            "analogy": "Like Fibonacci with constraints.",
            "steps": [
                "Single digit: 1-9 valid",
                "Two digits: 10-26 valid"
            ],
            "complexity": "Time: O(n), Space: O(n)"
        },
        "testCases": [
            {
                "input": "226",
                "expectedOutput": "3",
                "explanation": "Can decode as 2,2,6 or 22,6 or 2,26"
            },
            {
                "input": "12",
                "expectedOutput": "2",
                "explanation": "Can decode as 1,2 or 12"
            },
            {
                "input": "06",
                "expectedOutput": "0",
                "explanation": "Leading zero makes it invalid"
            },
            {
                "input": "11106",
                "expectedOutput": "2",
                "explanation": "1,1,10,6 or 11,10,6"
            }
        ]
    },
    {
        "id": "final9",
        "title": "Jump Game",
        "description": "Can reach last index.",
        "difficulty": "MEDIUM",
        "category": "Greedy",
        "starterCode": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nbool canJump(vector<int>& a, int n) {\n    return false;\n}\n\nint main() {\n    int a_size;\n    cin >> a_size;\n    vector<int> a(a_size);\n    for (int i = 0; i < a_size; i++) cin >> a[i];\n    int n;\n    cin >> n;\n    cout << canJump(a, n);\n    return 0;\n}\n",
        "expectedOutput": "1",
        "solution": "#include <iostream>\nusing namespace std;\nbool canJump(int a[], int n) { int reach=0; for(int i=0;i<n;i++) { if(i>reach) return false; reach=max(reach, i+a[i]); } return true; }\nint main() { int a[]={2,3,1,1,4}; cout<<canJump(a,5); return 0; }",
        "explanation": {
            "approach": "Track farthest reachable position.",
            "analogy": "Greedy - always update max reach.",
            "steps": [
                "Update max reachable",
                "If current > max reach, impossible"
            ],
            "complexity": "Time: O(n), Space: O(1)"
        },
        "testCases": [
            {
                "input": "{2,3,1,1,4}",
                "expectedOutput": "1",
                "explanation": "Can jump 1->2->last or 1->3->last"
            },
            {
                "input": "{3,2,1,0,4}",
                "expectedOutput": "0",
                "explanation": "Stuck at index 3 with jump length 0"
            },
            {
                "input": "{0}",
                "expectedOutput": "1",
                "explanation": "Already at last index"
            },
            {
                "input": "{1,1,1,1,1}",
                "expectedOutput": "1",
                "explanation": "Can reach end step by step"
            }
        ]
    },
    {
        "id": "final10",
        "title": "Product Except Self",
        "description": "Product of all except current.",
        "difficulty": "MEDIUM",
        "category": "Arrays",
        "starterCode": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nvoid productExceptSelf(vector<int>& a, int n) {\n    // TODO\n}\n\nint main() {\n    int a_size;\n    cin >> a_size;\n    vector<int> a(a_size);\n    for (int i = 0; i < a_size; i++) cin >> a[i];\n    int n;\n    cin >> n;\n    productExceptSelf(a, n);\n    return 0;\n}\n",
        "expectedOutput": "24 12 8 6",
        "solution": "#include <iostream>\nusing namespace std;\nvoid productExceptSelf(int a[], int n) { int res[n]; res[0]=1; for(int i=1;i<n;i++) res[i]=res[i-1]*a[i-1]; int right=1; for(int i=n-1;i>=0;i--) { res[i]*=right; right*=a[i]; } for(int i=0;i<n;i++) cout<<res[i]<<\" \"; }\nint main() { int a[]={1,2,3,4}; productExceptSelf(a,4); return 0; }",
        "explanation": {
            "approach": "Left products × right products.",
            "analogy": "Prefix and suffix products.",
            "steps": [
                "Calculate prefix products",
                "Multiply by suffix products"
            ],
            "complexity": "Time: O(n), Space: O(n)"
        },
        "testCases": [
            {
                "input": "{1,2,3,4}",
                "expectedOutput": "24 12 8 6",
                "explanation": "Each position has product of all other elements"
            },
            {
                "input": "{-1,1,0,-3,3}",
                "expectedOutput": "0 0 9 0 0",
                "explanation": "Zero makes all products 0 except at index 2"
            },
            {
                "input": "{2,3}",
                "expectedOutput": "3 2",
                "explanation": "Simple swap of products"
            },
            {
                "input": "{1,1,1,1}",
                "expectedOutput": "1 1 1 1",
                "explanation": "All ones produce all ones"
            }
        ]
    }
]