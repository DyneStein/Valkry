[
    {
        "id": "arr11",
        "title": "Kadane's Algorithm",
        "description": "Max subarray sum.",
        "difficulty": "MEDIUM",
        "category": "Arrays",
        "starterCode": "#include <iostream>\nusing namespace std;\nint maxSubArray(int a[], int n) { return 0; }\nint main() { int a[]={-2,1,-3,4,-1,2,1,-5,4}; cout<<maxSubArray(a,9); return 0; }",
        "expectedOutput": "6",
        "solution": "#include <iostream>\nusing namespace std;\nint maxSubArray(int a[], int n) { int mx=a[0],cur=a[0]; for(int i=1;i<n;i++) { cur=max(a[i],cur+a[i]); mx=max(mx,cur); } return mx; }\nint main() { int a[]={-2,1,-3,4,-1,2,1,-5,4}; cout<<maxSubArray(a,9); return 0; }",
        "explanation": {
            "approach": "Track current and max sum.",
            "analogy": "Extend or restart at each position.",
            "steps": [
                "cur = max(a[i], cur + a[i])",
                "mx = max(mx, cur)"
            ],
            "complexity": "Time: O(n), Space: O(1)"
        }
    },
    {
        "id": "arr12",
        "title": "Merge Sorted Arrays",
        "description": "Merge two sorted into one.",
        "difficulty": "EASY",
        "category": "Arrays",
        "starterCode": "#include <iostream>\nusing namespace std;\nvoid merge(int a[], int m, int b[], int n, int c[]) {}\nint main() { int a[]={1,3,5}, b[]={2,4,6}, c[6]; merge(a,3,b,3,c); for(int i=0;i<6;i++) cout<<c[i]<<\" \"; return 0; }",
        "expectedOutput": "1 2 3 4 5 6",
        "solution": "#include <iostream>\nusing namespace std;\nvoid merge(int a[], int m, int b[], int n, int c[]) { int i=0,j=0,k=0; while(i<m && j<n) c[k++]=a[i]<b[j]?a[i++]:b[j++]; while(i<m) c[k++]=a[i++]; while(j<n) c[k++]=b[j++]; }\nint main() { int a[]={1,3,5}, b[]={2,4,6}, c[6]; merge(a,3,b,3,c); for(int i=0;i<6;i++) cout<<c[i]<<\" \"; return 0; }",
        "explanation": {
            "approach": "Two pointer merge.",
            "analogy": "Pick smaller from each array.",
            "steps": [
                "Compare elements from both arrays",
                "Pick smaller, advance that pointer"
            ],
            "complexity": "Time: O(m+n), Space: O(m+n)"
        }
    },
    {
        "id": "arr13",
        "title": "Intersection of Two Arrays",
        "description": "Common elements.",
        "difficulty": "EASY",
        "category": "Arrays",
        "starterCode": "#include <iostream>\nusing namespace std;\nvoid intersection(int a[], int m, int b[], int n) {}\nint main() { int a[]={1,2,2,1}, b[]={2,2}; intersection(a,4,b,2); return 0; }",
        "expectedOutput": "2",
        "solution": "#include <iostream>\nusing namespace std;\nvoid intersection(int a[], int m, int b[], int n) { bool seen[1001]={}; for(int i=0;i<m;i++) seen[a[i]]=true; bool printed[1001]={}; for(int i=0;i<n;i++) if(seen[b[i]] && !printed[b[i]]) { cout<<b[i]<<\" \"; printed[b[i]]=true; } }\nint main() { int a[]={1,2,2,1}, b[]={2,2}; intersection(a,4,b,2); return 0; }",
        "explanation": {
            "approach": "Hash set for first array.",
            "analogy": "Mark present in first, find in second.",
            "steps": [
                "Mark all elements of a",
                "Print elements of b that exist in a"
            ],
            "complexity": "Time: O(m+n), Space: O(m)"
        }
    },
    {
        "id": "arr14",
        "title": "Union of Two Arrays",
        "description": "All unique elements.",
        "difficulty": "EASY",
        "category": "Arrays",
        "starterCode": "#include <iostream>\nusing namespace std;\nvoid unionArr(int a[], int m, int b[], int n) {}\nint main() { int a[]={1,2,3}, b[]={2,3,4,5}; unionArr(a,3,b,4); return 0; }",
        "expectedOutput": "1 2 3 4 5",
        "solution": "#include <iostream>\nusing namespace std;\nvoid unionArr(int a[], int m, int b[], int n) { bool seen[1001]={}; for(int i=0;i<m;i++) if(!seen[a[i]]) { cout<<a[i]<<\" \"; seen[a[i]]=true; } for(int i=0;i<n;i++) if(!seen[b[i]]) { cout<<b[i]<<\" \"; seen[b[i]]=true; } }\nint main() { int a[]={1,2,3}, b[]={2,3,4,5}; unionArr(a,3,b,4); return 0; }",
        "explanation": {
            "approach": "Track all seen elements.",
            "analogy": "Combine and deduplicate.",
            "steps": [
                "Print unseen from a",
                "Print unseen from b"
            ],
            "complexity": "Time: O(m+n), Space: O(m+n)"
        }
    },
    {
        "id": "arr15",
        "title": "Leaders in Array",
        "description": "Elements greater than all to right.",
        "difficulty": "EASY",
        "category": "Arrays",
        "starterCode": "#include <iostream>\nusing namespace std;\nvoid leaders(int a[], int n) {}\nint main() { int a[]={16,17,4,3,5,2}; leaders(a,6); return 0; }",
        "expectedOutput": "17 5 2",
        "solution": "#include <iostream>\nusing namespace std;\nvoid leaders(int a[], int n) { int mx=a[n-1]; int res[n], k=0; res[k++]=mx; for(int i=n-2;i>=0;i--) if(a[i]>mx) { mx=a[i]; res[k++]=mx; } for(int i=k-1;i>=0;i--) cout<<res[i]<<\" \"; }\nint main() { int a[]={16,17,4,3,5,2}; leaders(a,6); return 0; }",
        "explanation": {
            "approach": "Scan from right tracking max.",
            "analogy": "Leader = greater than all to right.",
            "steps": [
                "Track max from right",
                "If current > max, it's a leader"
            ],
            "complexity": "Time: O(n), Space: O(n)"
        }
    },
    {
        "id": "arr16",
        "title": "Next Greater Element",
        "description": "Next larger for each element.",
        "difficulty": "MEDIUM",
        "category": "Arrays",
        "starterCode": "#include <iostream>\nusing namespace std;\nvoid nextGreater(int a[], int n) {}\nint main() { int a[]={4,5,2,25}; nextGreater(a,4); return 0; }",
        "expectedOutput": "5 25 25 -1",
        "solution": "#include <iostream>\nusing namespace std;\nvoid nextGreater(int a[], int n) { int stk[n],top=-1,res[n]; for(int i=n-1;i>=0;i--) { while(top>=0 && stk[top]<=a[i]) top--; res[i]=top<0?-1:stk[top]; stk[++top]=a[i]; } for(int i=0;i<n;i++) cout<<res[i]<<\" \"; }\nint main() { int a[]={4,5,2,25}; nextGreater(a,4); return 0; }",
        "explanation": {
            "approach": "Monotonic stack.",
            "analogy": "Stack keeps larger elements.",
            "steps": [
                "Pop while stack top <= current",
                "Top is next greater"
            ],
            "complexity": "Time: O(n), Space: O(n)"
        }
    },
    {
        "id": "arr17",
        "title": "Rotate Array by K",
        "description": "Rotate array k positions.",
        "difficulty": "MEDIUM",
        "category": "Arrays",
        "starterCode": "#include <iostream>\nusing namespace std;\nvoid rotate(int a[], int n, int k) {}\nint main() { int a[]={1,2,3,4,5,6,7}; rotate(a,7,3); for(int i=0;i<7;i++) cout<<a[i]<<\" \"; return 0; }",
        "expectedOutput": "5 6 7 1 2 3 4",
        "solution": "#include <iostream>\nusing namespace std;\nvoid rev(int a[], int l, int r) { while(l<r) swap(a[l++],a[r--]); }\nvoid rotate(int a[], int n, int k) { k%=n; rev(a,0,n-1); rev(a,0,k-1); rev(a,k,n-1); }\nint main() { int a[]={1,2,3,4,5,6,7}; rotate(a,7,3); for(int i=0;i<7;i++) cout<<a[i]<<\" \"; return 0; }",
        "explanation": {
            "approach": "Three reversals.",
            "analogy": "Reverse all, then parts.",
            "steps": [
                "Reverse entire array",
                "Reverse first k",
                "Reverse rest"
            ],
            "complexity": "Time: O(n), Space: O(1)"
        }
    },
    {
        "id": "arr18",
        "title": "Move Zeros to End",
        "description": "Move zeros to end, maintain order.",
        "difficulty": "EASY",
        "category": "Arrays",
        "starterCode": "#include <iostream>\nusing namespace std;\nvoid moveZeros(int a[], int n) {}\nint main() { int a[]={0,1,0,3,12}; moveZeros(a,5); for(int i=0;i<5;i++) cout<<a[i]<<\" \"; return 0; }",
        "expectedOutput": "1 3 12 0 0",
        "solution": "#include <iostream>\nusing namespace std;\nvoid moveZeros(int a[], int n) { int j=0; for(int i=0;i<n;i++) if(a[i]!=0) swap(a[i],a[j++]); }\nint main() { int a[]={0,1,0,3,12}; moveZeros(a,5); for(int i=0;i<5;i++) cout<<a[i]<<\" \"; return 0; }",
        "explanation": {
            "approach": "Swap non-zeros to front.",
            "analogy": "Partition with zero as pivot.",
            "steps": [
                "Move non-zeros to front",
                "Zeros naturally end up at end"
            ],
            "complexity": "Time: O(n), Space: O(1)"
        }
    },
    {
        "id": "arr19",
        "title": "Subarray with Given Sum",
        "description": "Find subarray summing to target.",
        "difficulty": "MEDIUM",
        "category": "Arrays",
        "starterCode": "#include <iostream>\nusing namespace std;\nvoid subarraySum(int a[], int n, int target) {}\nint main() { int a[]={1,4,20,3,10,5}; subarraySum(a,6,33); return 0; }",
        "expectedOutput": "2 4",
        "solution": "#include <iostream>\nusing namespace std;\nvoid subarraySum(int a[], int n, int target) { int s=0,start=0; for(int i=0;i<n;i++) { s+=a[i]; while(s>target && start<i) s-=a[start++]; if(s==target) { cout<<start<<\" \"<<i; return; } } }\nint main() { int a[]={1,4,20,3,10,5}; subarraySum(a,6,33); return 0; }",
        "explanation": {
            "approach": "Sliding window.",
            "analogy": "Expand right, shrink left.",
            "steps": [
                "Add right element",
                "Shrink left while too big"
            ],
            "complexity": "Time: O(n), Space: O(1)"
        }
    },
    {
        "id": "arr20",
        "title": "Trapping Rain Water",
        "description": "Water trapped between bars.",
        "difficulty": "HARD",
        "category": "Arrays",
        "starterCode": "#include <iostream>\nusing namespace std;\nint trap(int h[], int n) { return 0; }\nint main() { int h[]={0,1,0,2,1,0,1,3,2,1,2,1}; cout<<trap(h,12); return 0; }",
        "expectedOutput": "6",
        "solution": "#include <iostream>\nusing namespace std;\nint trap(int h[], int n) { int l=0,r=n-1,lm=0,rm=0,w=0; while(l<r) { if(h[l]<h[r]) { if(h[l]>=lm) lm=h[l]; else w+=lm-h[l]; l++; } else { if(h[r]>=rm) rm=h[r]; else w+=rm-h[r]; r--; } } return w; }\nint main() { int h[]={0,1,0,2,1,0,1,3,2,1,2,1}; cout<<trap(h,12); return 0; }",
        "explanation": {
            "approach": "Two pointers with max tracking.",
            "analogy": "Water = min(leftMax, rightMax) - height.",
            "steps": [
                "Track left and right max",
                "Move smaller side"
            ],
            "complexity": "Time: O(n), Space: O(1)"
        }
    }
]