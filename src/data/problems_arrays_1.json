[
    {
        "id": "arr11",
        "title": "Kadane's Algorithm",
        "description": "Find maximum sum contiguous subarray.",
        "difficulty": "MEDIUM",
        "category": "Arrays",
        "starterCode": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxSubArray(vector<int>& a, int n) {\n    return 0;\n}\n\nint main() {\n    int a_size;\n    cin >> a_size;\n    vector<int> a(a_size);\n    for (int i = 0; i < a_size; i++) cin >> a[i];\n    int n;\n    cin >> n;\n    cout << maxSubArray(a, n);\n    return 0;\n}\n",
        "expectedOutput": "6",
        "solution": "#include <iostream>\nusing namespace std;\nint maxSubArray(int a[], int n) { int mx=a[0],cur=a[0]; for(int i=1;i<n;i++) { cur=max(a[i],cur+a[i]); mx=max(mx,cur); } return mx; }\nint main() { int a[]={-2,1,-3,4,-1,2,1,-5,4}; cout<<maxSubArray(a,9); return 0; }",
        "explanation": {
            "approach": "Track current and max sum, extend or restart at each position.",
            "steps": [
                "cur = max(a[i], cur + a[i])",
                "mx = max(mx, cur)"
            ],
            "complexity": "Time: O(n), Space: O(1)"
        },
        "testCases": [
            {
                "input": "[-2,1,-3,4,-1,2,1,-5,4]",
                "expectedOutput": "6",
                "explanation": "Subarray [4,-1,2,1] = 6"
            },
            {
                "input": "[1]",
                "expectedOutput": "1",
                "explanation": "Single element"
            },
            {
                "input": "[-1,-2,-3]",
                "expectedOutput": "-1",
                "explanation": "All negative, pick least"
            },
            {
                "input": "[5,4,-1,7,8]",
                "expectedOutput": "23",
                "explanation": "Entire array"
            }
        ]
    },
    {
        "id": "arr12",
        "title": "Merge Sorted Arrays",
        "description": "Merge two sorted arrays into one sorted array.",
        "difficulty": "EASY",
        "category": "Arrays",
        "starterCode": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nvoid merge(vector<int>& a, int m, vector<int>& b, int n, vector<int>& c) {\n    // TODO\n}\n\nint main() {\n    int a_size;\n    cin >> a_size;\n    vector<int> a(a_size);\n    for (int i = 0; i < a_size; i++) cin >> a[i];\n    int m;\n    cin >> m;\n    int b_size;\n    cin >> b_size;\n    vector<int> b(b_size);\n    for (int i = 0; i < b_size; i++) cin >> b[i];\n    int n;\n    cin >> n;\n    int c_size;\n    cin >> c_size;\n    vector<int> c(c_size);\n    for (int i = 0; i < c_size; i++) cin >> c[i];\n    merge(a, m, b, n, c);\n    return 0;\n}\n",
        "expectedOutput": "1 2 3 4 5 6",
        "solution": "#include <iostream>\nusing namespace std;\nvoid merge(int a[], int m, int b[], int n, int c[]) { int i=0,j=0,k=0; while(i<m && j<n) c[k++]=a[i]<b[j]?a[i++]:b[j++]; while(i<m) c[k++]=a[i++]; while(j<n) c[k++]=b[j++]; }\nint main() { int a[]={1,3,5}, b[]={2,4,6}, c[6]; merge(a,3,b,3,c); for(int i=0;i<6;i++) cout<<c[i]<<\" \"; return 0; }",
        "explanation": {
            "approach": "Two pointer merge: compare and pick smaller.",
            "steps": [
                "Compare elements",
                "Pick smaller, advance that pointer",
                "Copy remaining"
            ],
            "complexity": "Time: O(m+n), Space: O(m+n)"
        },
        "testCases": [
            {
                "input": "[1,3,5] + [2,4,6]",
                "expectedOutput": "1 2 3 4 5 6",
                "explanation": "Interleaved merge"
            },
            {
                "input": "[1,2,3] + []",
                "expectedOutput": "1 2 3",
                "explanation": "One empty"
            },
            {
                "input": "[1] + [2]",
                "expectedOutput": "1 2",
                "explanation": "Single elements"
            },
            {
                "input": "[1,2] + [3,4]",
                "expectedOutput": "1 2 3 4",
                "explanation": "No interleaving"
            }
        ]
    },
    {
        "id": "arr13",
        "title": "Intersection of Two Arrays",
        "description": "Find common unique elements between two arrays.",
        "difficulty": "EASY",
        "category": "Arrays",
        "starterCode": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nvoid intersection(vector<int>& a, int m, vector<int>& b, int n) {\n    // TODO\n}\n\nint main() {\n    int a_size;\n    cin >> a_size;\n    vector<int> a(a_size);\n    for (int i = 0; i < a_size; i++) cin >> a[i];\n    int m;\n    cin >> m;\n    int b_size;\n    cin >> b_size;\n    vector<int> b(b_size);\n    for (int i = 0; i < b_size; i++) cin >> b[i];\n    int n;\n    cin >> n;\n    intersection(a, m, b, n);\n    return 0;\n}\n",
        "expectedOutput": "2",
        "solution": "#include <iostream>\nusing namespace std;\nvoid intersection(int a[], int m, int b[], int n) { bool seen[1001]={}; for(int i=0;i<m;i++) seen[a[i]]=true; bool printed[1001]={}; for(int i=0;i<n;i++) if(seen[b[i]] && !printed[b[i]]) { cout<<b[i]<<\" \"; printed[b[i]]=true; } }\nint main() { int a[]={1,2,2,1}, b[]={2,2}; intersection(a,4,b,2); return 0; }",
        "explanation": {
            "approach": "Hash set: mark first array, find in second.",
            "steps": [
                "Mark all elements of a",
                "Print elements of b that exist in a"
            ],
            "complexity": "Time: O(m+n), Space: O(m)"
        },
        "testCases": [
            {
                "input": "[1,2,2,1] ∩ [2,2]",
                "expectedOutput": "2",
                "explanation": "Common element is 2"
            },
            {
                "input": "[4,9,5] ∩ [9,4,9,8,4]",
                "expectedOutput": "9 4",
                "explanation": "Two common elements"
            },
            {
                "input": "[1,2,3] ∩ [4,5,6]",
                "expectedOutput": "",
                "explanation": "No common"
            },
            {
                "input": "[1,1,1] ∩ [1]",
                "expectedOutput": "1",
                "explanation": "Deduplicated"
            }
        ]
    },
    {
        "id": "arr14",
        "title": "Union of Two Arrays",
        "description": "Find all unique elements from both arrays.",
        "difficulty": "EASY",
        "category": "Arrays",
        "starterCode": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nvoid unionArr(vector<int>& a, int m, vector<int>& b, int n) {\n    // TODO\n}\n\nint main() {\n    int a_size;\n    cin >> a_size;\n    vector<int> a(a_size);\n    for (int i = 0; i < a_size; i++) cin >> a[i];\n    int m;\n    cin >> m;\n    int b_size;\n    cin >> b_size;\n    vector<int> b(b_size);\n    for (int i = 0; i < b_size; i++) cin >> b[i];\n    int n;\n    cin >> n;\n    unionArr(a, m, b, n);\n    return 0;\n}\n",
        "expectedOutput": "1 2 3 4 5",
        "solution": "#include <iostream>\nusing namespace std;\nvoid unionArr(int a[], int m, int b[], int n) { bool seen[1001]={}; for(int i=0;i<m;i++) if(!seen[a[i]]) { cout<<a[i]<<\" \"; seen[a[i]]=true; } for(int i=0;i<n;i++) if(!seen[b[i]]) { cout<<b[i]<<\" \"; seen[b[i]]=true; } }\nint main() { int a[]={1,2,3}, b[]={2,3,4,5}; unionArr(a,3,b,4); return 0; }",
        "explanation": {
            "approach": "Track all seen, print unseen from both.",
            "steps": [
                "Print unseen from a",
                "Print unseen from b"
            ],
            "complexity": "Time: O(m+n), Space: O(m+n)"
        },
        "testCases": [
            {
                "input": "[1,2,3] ∪ [2,3,4,5]",
                "expectedOutput": "1 2 3 4 5",
                "explanation": "Combined unique"
            },
            {
                "input": "[1,1,1] ∪ [2,2,2]",
                "expectedOutput": "1 2",
                "explanation": "Deduplicated"
            },
            {
                "input": "[] ∪ [1,2,3]",
                "expectedOutput": "1 2 3",
                "explanation": "One empty"
            },
            {
                "input": "[5,6] ∪ [1,2]",
                "expectedOutput": "5 6 1 2",
                "explanation": "No overlap"
            }
        ]
    },
    {
        "id": "arr15",
        "title": "Leaders in Array",
        "description": "Find elements greater than all to their right.",
        "difficulty": "EASY",
        "category": "Arrays",
        "starterCode": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nvoid leaders(vector<int>& a, int n) {\n    // TODO\n}\n\nint main() {\n    int a_size;\n    cin >> a_size;\n    vector<int> a(a_size);\n    for (int i = 0; i < a_size; i++) cin >> a[i];\n    int n;\n    cin >> n;\n    leaders(a, n);\n    return 0;\n}\n",
        "expectedOutput": "17 5 2",
        "solution": "#include <iostream>\nusing namespace std;\nvoid leaders(int a[], int n) { int mx=a[n-1]; int res[n], k=0; res[k++]=mx; for(int i=n-2;i>=0;i--) if(a[i]>mx) { mx=a[i]; res[k++]=mx; } for(int i=k-1;i>=0;i--) cout<<res[i]<<\" \"; }\nint main() { int a[]={16,17,4,3,5,2}; leaders(a,6); return 0; }",
        "explanation": {
            "approach": "Scan from right tracking max.",
            "steps": [
                "Track max from right",
                "If current > max, it's a leader"
            ],
            "complexity": "Time: O(n), Space: O(n)"
        },
        "testCases": [
            {
                "input": "[16,17,4,3,5,2]",
                "expectedOutput": "17 5 2",
                "explanation": "17>all right, 5>2, 2 is last"
            },
            {
                "input": "[1,2,3,4,5]",
                "expectedOutput": "5",
                "explanation": "Only last is leader"
            },
            {
                "input": "[5,4,3,2,1]",
                "expectedOutput": "5 4 3 2 1",
                "explanation": "All are leaders"
            },
            {
                "input": "[7]",
                "expectedOutput": "7",
                "explanation": "Single element is leader"
            }
        ]
    },
    {
        "id": "arr16",
        "title": "Next Greater Element",
        "description": "Find next larger element for each position.",
        "difficulty": "MEDIUM",
        "category": "Arrays",
        "starterCode": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nvoid nextGreater(vector<int>& a, int n) {\n    // TODO\n}\n\nint main() {\n    int a_size;\n    cin >> a_size;\n    vector<int> a(a_size);\n    for (int i = 0; i < a_size; i++) cin >> a[i];\n    int n;\n    cin >> n;\n    nextGreater(a, n);\n    return 0;\n}\n",
        "expectedOutput": "5 25 25 -1",
        "solution": "#include <iostream>\nusing namespace std;\nvoid nextGreater(int a[], int n) { int stk[n],top=-1,res[n]; for(int i=n-1;i>=0;i--) { while(top>=0 && stk[top]<=a[i]) top--; res[i]=top<0?-1:stk[top]; stk[++top]=a[i]; } for(int i=0;i<n;i++) cout<<res[i]<<\" \"; }\nint main() { int a[]={4,5,2,25}; nextGreater(a,4); return 0; }",
        "explanation": {
            "approach": "Monotonic stack keeps larger elements.",
            "steps": [
                "Pop while stack top <= current",
                "Top is next greater"
            ],
            "complexity": "Time: O(n), Space: O(n)"
        },
        "testCases": [
            {
                "input": "[4,5,2,25]",
                "expectedOutput": "5 25 25 -1",
                "explanation": "4->5, 5->25, 2->25, 25->none"
            },
            {
                "input": "[13,7,6,12]",
                "expectedOutput": "-1 12 12 -1",
                "explanation": "For 7 and 6, next greater is 12"
            },
            {
                "input": "[1,2,3,4]",
                "expectedOutput": "2 3 4 -1",
                "explanation": "Each has next as greater"
            },
            {
                "input": "[4,3,2,1]",
                "expectedOutput": "-1 -1 -1 -1",
                "explanation": "Decreasing, no greater"
            }
        ]
    },
    {
        "id": "arr17",
        "title": "Rotate Array by K",
        "description": "Rotate array k positions to the right.",
        "difficulty": "MEDIUM",
        "category": "Arrays",
        "starterCode": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nvoid rotate(vector<int>& a, int n, int k) {\n    // TODO\n}\n\nint main() {\n    int a_size;\n    cin >> a_size;\n    vector<int> a(a_size);\n    for (int i = 0; i < a_size; i++) cin >> a[i];\n    int n;\n    cin >> n;\n    int k;\n    cin >> k;\n    rotate(a, n, k);\n    return 0;\n}\n",
        "expectedOutput": "5 6 7 1 2 3 4",
        "solution": "#include <iostream>\nusing namespace std;\nvoid rev(int a[], int l, int r) { while(l<r) swap(a[l++],a[r--]); }\nvoid rotate(int a[], int n, int k) { k%=n; rev(a,0,n-1); rev(a,0,k-1); rev(a,k,n-1); }\nint main() { int a[]={1,2,3,4,5,6,7}; rotate(a,7,3); for(int i=0;i<7;i++) cout<<a[i]<<\" \"; return 0; }",
        "explanation": {
            "approach": "Three reversals: all, first k, last n-k.",
            "steps": [
                "Reverse entire array",
                "Reverse first k",
                "Reverse rest"
            ],
            "complexity": "Time: O(n), Space: O(1)"
        },
        "testCases": [
            {
                "input": "[1,2,3,4,5,6,7], k=3",
                "expectedOutput": "5 6 7 1 2 3 4",
                "explanation": "Last 3 move to front"
            },
            {
                "input": "[1,2,3], k=1",
                "expectedOutput": "3 1 2",
                "explanation": "Last moves to front"
            },
            {
                "input": "[1,2,3], k=3",
                "expectedOutput": "1 2 3",
                "explanation": "Full rotation = no change"
            },
            {
                "input": "[-1,-100,3,99], k=2",
                "expectedOutput": "3 99 -1 -100",
                "explanation": "With negatives"
            }
        ]
    },
    {
        "id": "arr18",
        "title": "Move Zeros to End",
        "description": "Move all zeros to end while maintaining order of non-zeros.",
        "difficulty": "EASY",
        "category": "Arrays",
        "starterCode": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nvoid moveZeros(vector<int>& a, int n) {\n    // TODO\n}\n\nint main() {\n    int a_size;\n    cin >> a_size;\n    vector<int> a(a_size);\n    for (int i = 0; i < a_size; i++) cin >> a[i];\n    int n;\n    cin >> n;\n    moveZeros(a, n);\n    return 0;\n}\n",
        "expectedOutput": "1 3 12 0 0",
        "solution": "#include <iostream>\nusing namespace std;\nvoid moveZeros(int a[], int n) { int j=0; for(int i=0;i<n;i++) if(a[i]!=0) swap(a[i],a[j++]); }\nint main() { int a[]={0,1,0,3,12}; moveZeros(a,5); for(int i=0;i<5;i++) cout<<a[i]<<\" \"; return 0; }",
        "explanation": {
            "approach": "Swap non-zeros to front position.",
            "steps": [
                "Keep pointer for next non-zero position",
                "Swap when non-zero found"
            ],
            "complexity": "Time: O(n), Space: O(1)"
        },
        "testCases": [
            {
                "input": "[0,1,0,3,12]",
                "expectedOutput": "1 3 12 0 0",
                "explanation": "Non-zeros first"
            },
            {
                "input": "[0]",
                "expectedOutput": "0",
                "explanation": "Single zero"
            },
            {
                "input": "[1,2,3]",
                "expectedOutput": "1 2 3",
                "explanation": "No zeros"
            },
            {
                "input": "[0,0,0,1]",
                "expectedOutput": "1 0 0 0",
                "explanation": "Many zeros"
            }
        ]
    },
    {
        "id": "arr19",
        "title": "Subarray with Given Sum",
        "description": "Find contiguous subarray summing to target.",
        "difficulty": "MEDIUM",
        "category": "Arrays",
        "starterCode": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nvoid subarraySum(vector<int>& a, int n, int target) {\n    // TODO\n}\n\nint main() {\n    int a_size;\n    cin >> a_size;\n    vector<int> a(a_size);\n    for (int i = 0; i < a_size; i++) cin >> a[i];\n    int n;\n    cin >> n;\n    int target;\n    cin >> target;\n    subarraySum(a, n, target);\n    return 0;\n}\n",
        "expectedOutput": "2 4",
        "solution": "#include <iostream>\nusing namespace std;\nvoid subarraySum(int a[], int n, int target) { int s=0,start=0; for(int i=0;i<n;i++) { s+=a[i]; while(s>target && start<i) s-=a[start++]; if(s==target) { cout<<start<<\" \"<<i; return; } } }\nint main() { int a[]={1,4,20,3,10,5}; subarraySum(a,6,33); return 0; }",
        "explanation": {
            "approach": "Sliding window: expand right, shrink left.",
            "steps": [
                "Add right element",
                "Shrink left while sum too big"
            ],
            "complexity": "Time: O(n), Space: O(1)"
        },
        "testCases": [
            {
                "input": "[1,4,20,3,10,5], sum=33",
                "expectedOutput": "2 4",
                "explanation": "20+3+10=33"
            },
            {
                "input": "[1,4], sum=0",
                "expectedOutput": "-1",
                "explanation": "No subarray"
            },
            {
                "input": "[1,4,0,0,3,10,5], sum=7",
                "expectedOutput": "3 5",
                "explanation": "0+0+3+10... wait"
            },
            {
                "input": "[15], sum=15",
                "expectedOutput": "0 0",
                "explanation": "Single element"
            }
        ]
    },
    {
        "id": "arr20",
        "title": "Trapping Rain Water",
        "description": "Calculate water trapped between bars after rain.",
        "difficulty": "HARD",
        "category": "Arrays",
        "starterCode": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint trap(vector<int>& h, int n) {\n    return 0;\n}\n\nint main() {\n    int h_size;\n    cin >> h_size;\n    vector<int> h(h_size);\n    for (int i = 0; i < h_size; i++) cin >> h[i];\n    int n;\n    cin >> n;\n    cout << trap(h, n);\n    return 0;\n}\n",
        "expectedOutput": "6",
        "solution": "#include <iostream>\nusing namespace std;\nint trap(int h[], int n) { int l=0,r=n-1,lm=0,rm=0,w=0; while(l<r) { if(h[l]<h[r]) { if(h[l]>=lm) lm=h[l]; else w+=lm-h[l]; l++; } else { if(h[r]>=rm) rm=h[r]; else w+=rm-h[r]; r--; } } return w; }\nint main() { int h[]={0,1,0,2,1,0,1,3,2,1,2,1}; cout<<trap(h,12); return 0; }",
        "explanation": {
            "approach": "Two pointers with left/right max tracking.",
            "steps": [
                "Water at position = min(leftMax,rightMax) - height",
                "Move smaller side"
            ],
            "complexity": "Time: O(n), Space: O(1)"
        },
        "testCases": [
            {
                "input": "[0,1,0,2,1,0,1,3,2,1,2,1]",
                "expectedOutput": "6",
                "explanation": "Classic example"
            },
            {
                "input": "[4,2,0,3,2,5]",
                "expectedOutput": "9",
                "explanation": "Wider basin"
            },
            {
                "input": "[1,2,3,4,5]",
                "expectedOutput": "0",
                "explanation": "Ascending, no trap"
            },
            {
                "input": "[5,4,3,2,1]",
                "expectedOutput": "0",
                "explanation": "Descending, no trap"
            }
        ]
    }
]