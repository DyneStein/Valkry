[
    {
        "id": "dp11",
        "title": "Rod Cutting",
        "description": "Max profit from rod pieces.",
        "difficulty": "MEDIUM",
        "category": "DP",
        "starterCode": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint cutRod(vector<int>& prices, int n) {\n    return 0;\n}\n\nint main() {\n    int prices_size;\n    cin >> prices_size;\n    vector<int> prices(prices_size);\n    for (int i = 0; i < prices_size; i++) cin >> prices[i];\n    int n;\n    cin >> n;\n    cout << cutRod(prices, n);\n    return 0;\n}\n",
        "expectedOutput": "22",
        "solution": "#include <iostream>\nusing namespace std;\nint cutRod(int prices[], int n) { int dp[n+1]={}; for(int i=1;i<=n;i++) for(int j=1;j<=i;j++) dp[i]=max(dp[i],prices[j-1]+dp[i-j]); return dp[n]; }\nint main() { int prices[]={1,5,8,9,10,17,17,20}; cout<<cutRod(prices,8); return 0; }",
        "explanation": {
            "approach": "DP - max value for each length.",
            "analogy": "Try all first cut positions.",
            "steps": [
                "dp[i] = max profit for length i",
                "Try cutting at each position"
            ],
            "complexity": "Time: O(n²), Space: O(n)"
        },
        "testCases": [
            {
                "input": "prices={1,5,8,9,10,17,17,20}, n=8",
                "expectedOutput": "22",
                "explanation": "Cut into 2+6 for max profit"
            },
            {
                "input": "prices={3,5,8,9,10,17,17,20}, n=4",
                "expectedOutput": "12",
                "explanation": "Four pieces of length 1"
            },
            {
                "input": "prices={1,5}, n=2",
                "expectedOutput": "5",
                "explanation": "Keep whole rod"
            },
            {
                "input": "prices={1,5,8}, n=3",
                "expectedOutput": "8",
                "explanation": "Keep rod of length 3"
            }
        ]
    },
    {
        "id": "dp12",
        "title": "Matrix Chain Multiplication",
        "description": "Min operations to multiply matrices.",
        "difficulty": "HARD",
        "category": "DP",
        "starterCode": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint matrixChain(vector<int>& dims, int n) {\n    return 0;\n}\n\nint main() {\n    int dims_size;\n    cin >> dims_size;\n    vector<int> dims(dims_size);\n    for (int i = 0; i < dims_size; i++) cin >> dims[i];\n    int n;\n    cin >> n;\n    cout << matrixChain(dims, n);\n    return 0;\n}\n",
        "expectedOutput": "4500",
        "solution": "#include <iostream>\nusing namespace std;\nint matrixChain(int dims[], int n) { int m=n-1; int dp[m][m]; for(int i=0;i<m;i++) dp[i][i]=0; for(int len=2;len<=m;len++) for(int i=0;i<=m-len;i++) { int j=i+len-1; dp[i][j]=1e9; for(int k=i;k<j;k++) dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+1][j]+dims[i]*dims[k+1]*dims[j+1]); } return dp[0][m-1]; }\nint main() { int dims[]={10,30,5,60}; cout<<matrixChain(dims,4); return 0; }",
        "explanation": {
            "approach": "DP on ranges.",
            "analogy": "Find optimal split point.",
            "steps": [
                "dp[i][j] = min ops for i to j",
                "Try all split points k"
            ],
            "complexity": "Time: O(n³), Space: O(n²)"
        },
        "testCases": [
            {
                "input": "dims={10,30,5,60}",
                "expectedOutput": "4500",
                "explanation": "Optimal parenthesization"
            },
            {
                "input": "dims={40,20,30,10,30}",
                "expectedOutput": "26000",
                "explanation": "5 matrices"
            },
            {
                "input": "dims={1,2,3}",
                "expectedOutput": "6",
                "explanation": "Two 1xN matrices"
            },
            {
                "input": "dims={10,20,30}",
                "expectedOutput": "6000",
                "explanation": "Two matrices: 10x20 * 20x30"
            }
        ]
    },
    {
        "id": "dp13",
        "title": "Egg Drop",
        "description": "Min trials for k eggs, n floors.",
        "difficulty": "HARD",
        "category": "DP",
        "starterCode": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint eggDrop(int k, int n) {\n    return 0;\n}\n\nint main() {\n    int k;\n    cin >> k;\n    int n;\n    cin >> n;\n    cout << eggDrop(k, n);\n    return 0;\n}\n",
        "expectedOutput": "4",
        "solution": "#include <iostream>\nusing namespace std;\nint eggDrop(int k, int n) { int dp[k+1][n+1]; for(int i=0;i<=k;i++) { dp[i][0]=0; dp[i][1]=1; } for(int j=0;j<=n;j++) dp[1][j]=j; for(int i=2;i<=k;i++) for(int j=2;j<=n;j++) { dp[i][j]=j; for(int x=1;x<=j;x++) dp[i][j]=min(dp[i][j],1+max(dp[i-1][x-1],dp[i][j-x])); } return dp[k][n]; }\nint main() { cout<<eggDrop(2,10); return 0; }",
        "explanation": {
            "approach": "DP - min trials for eggs and floors.",
            "analogy": "Try dropping from each floor.",
            "steps": [
                "dp[k][n] = min trials for k eggs, n floors",
                "Try dropping from each floor x"
            ],
            "complexity": "Time: O(k × n²), Space: O(kn)"
        },
        "testCases": [
            {
                "input": "k=2, n=10",
                "expectedOutput": "4",
                "explanation": "4 trials needed with 2 eggs"
            },
            {
                "input": "k=1, n=5",
                "expectedOutput": "5",
                "explanation": "Linear search with 1 egg"
            },
            {
                "input": "k=2, n=6",
                "expectedOutput": "3",
                "explanation": "3 trials for 6 floors"
            },
            {
                "input": "k=3, n=14",
                "expectedOutput": "4",
                "explanation": "More eggs allow fewer trials"
            }
        ]
    },
    {
        "id": "dp14",
        "title": "Longest Bitonic Subseq",
        "description": "Longest increasing then decreasing.",
        "difficulty": "MEDIUM",
        "category": "DP",
        "starterCode": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint longestBitonic(vector<int>& a, int n) {\n    return 0;\n}\n\nint main() {\n    int a_size;\n    cin >> a_size;\n    vector<int> a(a_size);\n    for (int i = 0; i < a_size; i++) cin >> a[i];\n    int n;\n    cin >> n;\n    cout << longestBitonic(a, n);\n    return 0;\n}\n",
        "expectedOutput": "6",
        "solution": "#include <iostream>\nusing namespace std;\nint longestBitonic(int a[], int n) { int lis[n],lds[n]; for(int i=0;i<n;i++) { lis[i]=1; for(int j=0;j<i;j++) if(a[j]<a[i]) lis[i]=max(lis[i],lis[j]+1); } for(int i=n-1;i>=0;i--) { lds[i]=1; for(int j=n-1;j>i;j--) if(a[j]<a[i]) lds[i]=max(lds[i],lds[j]+1); } int mx=0; for(int i=0;i<n;i++) mx=max(mx,lis[i]+lds[i]-1); return mx; }\nint main() { int a[]={1,11,2,10,4,5,2,1}; cout<<longestBitonic(a,8); return 0; }",
        "explanation": {
            "approach": "LIS from left + LDS from right.",
            "analogy": "Peak at each position.",
            "steps": [
                "Compute LIS ending at each i",
                "Compute LDS starting at each i",
                "Max of lis[i] + lds[i] - 1"
            ],
            "complexity": "Time: O(n²), Space: O(n)"
        },
        "testCases": [
            {
                "input": "{1,11,2,10,4,5,2,1}",
                "expectedOutput": "6",
                "explanation": "1,2,10,4,2,1 or similar"
            },
            {
                "input": "{1,2,3,4,5}",
                "expectedOutput": "5",
                "explanation": "Increasing only is valid"
            },
            {
                "input": "{5,4,3,2,1}",
                "expectedOutput": "5",
                "explanation": "Decreasing only is valid"
            },
            {
                "input": "{1,3,5,3,1}",
                "expectedOutput": "5",
                "explanation": "Perfect bitonic with peak at 5"
            }
        ]
    },
    {
        "id": "dp15",
        "title": "Palindrome Partitioning",
        "description": "Min cuts for palindrome partition.",
        "difficulty": "HARD",
        "category": "DP",
        "starterCode": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint minCut(vector<int>& s) {\n    return 0;\n}\n\nint main() {\n    int s_size;\n    cin >> s_size;\n    vector<int> s(s_size);\n    for (int i = 0; i < s_size; i++) cin >> s[i];\n    cout << minCut(s);\n    return 0;\n}\n",
        "expectedOutput": "1",
        "solution": "#include <iostream>\nusing namespace std;\nint minCut(char s[]) { int n=0; while(s[n]) n++; bool isPalin[n][n]={}; for(int i=0;i<n;i++) isPalin[i][i]=true; for(int len=2;len<=n;len++) for(int i=0;i<=n-len;i++) { int j=i+len-1; if(s[i]==s[j]) isPalin[i][j]=(len==2)|isPalin[i+1][j-1]; } int dp[n]; for(int i=0;i<n;i++) { if(isPalin[0][i]) dp[i]=0; else { dp[i]=i; for(int j=1;j<=i;j++) if(isPalin[j][i]) dp[i]=min(dp[i],dp[j-1]+1); } } return dp[n-1]; }\nint main() { cout<<minCut(\"aab\"); return 0; }",
        "explanation": {
            "approach": "DP with palindrome precomputation.",
            "analogy": "Min cuts to make all parts palindromes.",
            "steps": [
                "Precompute all palindrome substrings",
                "dp[i] = min cuts for s[0..i]"
            ],
            "complexity": "Time: O(n²), Space: O(n²)"
        },
        "testCases": [
            {
                "input": "\"aab\"",
                "expectedOutput": "1",
                "explanation": "Cut: aa|b"
            },
            {
                "input": "\"a\"",
                "expectedOutput": "0",
                "explanation": "Already palindrome"
            },
            {
                "input": "\"ab\"",
                "expectedOutput": "1",
                "explanation": "Cut: a|b"
            },
            {
                "input": "\"aba\"",
                "expectedOutput": "0",
                "explanation": "Already a palindrome, no cuts needed"
            }
        ]
    },
    {
        "id": "dp16",
        "title": "Longest Zigzag",
        "description": "Longest alternating subsequence.",
        "difficulty": "MEDIUM",
        "category": "DP",
        "starterCode": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint longestZigzag(vector<int>& a, int n) {\n    return 0;\n}\n\nint main() {\n    int a_size;\n    cin >> a_size;\n    vector<int> a(a_size);\n    for (int i = 0; i < a_size; i++) cin >> a[i];\n    int n;\n    cin >> n;\n    cout << longestZigzag(a, n);\n    return 0;\n}\n",
        "expectedOutput": "6",
        "solution": "#include <iostream>\nusing namespace std;\nint longestZigzag(int a[], int n) { int up[n],down[n]; up[0]=down[0]=1; for(int i=1;i<n;i++) { up[i]=down[i]=1; for(int j=0;j<i;j++) { if(a[i]>a[j]) up[i]=max(up[i],down[j]+1); if(a[i]<a[j]) down[i]=max(down[i],up[j]+1); } } int mx=1; for(int i=0;i<n;i++) mx=max(mx,max(up[i],down[i])); return mx; }\nint main() { int a[]={1,7,4,9,2,5}; cout<<longestZigzag(a,6); return 0; }",
        "explanation": {
            "approach": "Track up and down endings.",
            "analogy": "Alternate up then down.",
            "steps": [
                "up[i] = zigzag ending up at i",
                "down[i] = zigzag ending down at i"
            ],
            "complexity": "Time: O(n²), Space: O(n)"
        },
        "testCases": [
            {
                "input": "{1,7,4,9,2,5}",
                "expectedOutput": "6",
                "explanation": "Entire array is zigzag"
            },
            {
                "input": "{1,2,3,4,5}",
                "expectedOutput": "2",
                "explanation": "Only pairs zigzag"
            },
            {
                "input": "{10,22,9,33,49,50,31,60}",
                "expectedOutput": "6",
                "explanation": "Valid zigzag sequence"
            },
            {
                "input": "{1,5,1,5,1}",
                "expectedOutput": "5",
                "explanation": "Perfect zigzag pattern"
            }
        ]
    },
    {
        "id": "dp17",
        "title": "Count Palindromic Substrings",
        "description": "Count all palindromic substrings.",
        "difficulty": "MEDIUM",
        "category": "DP",
        "starterCode": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint countSubstrings(vector<int>& s) {\n    return 0;\n}\n\nint main() {\n    int s_size;\n    cin >> s_size;\n    vector<int> s(s_size);\n    for (int i = 0; i < s_size; i++) cin >> s[i];\n    cout << countSubstrings(s);\n    return 0;\n}\n",
        "expectedOutput": "6",
        "solution": "#include <iostream>\nusing namespace std;\nint countSubstrings(char s[]) { int n=0; while(s[n]) n++; int cnt=0; for(int i=0;i<n;i++) { int l=i,r=i; while(l>=0 && r<n && s[l]==s[r]) { cnt++; l--; r++; } l=i; r=i+1; while(l>=0 && r<n && s[l]==s[r]) { cnt++; l--; r++; } } return cnt; }\nint main() { cout<<countSubstrings(\"aaa\"); return 0; }",
        "explanation": {
            "approach": "Expand around each center.",
            "analogy": "Try odd and even length palindromes.",
            "steps": [
                "For each center, expand",
                "Count all palindromes found"
            ],
            "complexity": "Time: O(n²), Space: O(1)"
        },
        "testCases": [
            {
                "input": "\"aaa\"",
                "expectedOutput": "6",
                "explanation": "a,a,a,aa,aa,aaa"
            },
            {
                "input": "\"abc\"",
                "expectedOutput": "3",
                "explanation": "Only single chars"
            },
            {
                "input": "\"aba\"",
                "expectedOutput": "4",
                "explanation": "a,b,a,aba"
            },
            {
                "input": "\"abba\"",
                "expectedOutput": "6",
                "explanation": "a,b,b,a,bb,abba"
            }
        ]
    },
    {
        "id": "dp18",
        "title": "Optimal BST",
        "description": "Min search cost BST.",
        "difficulty": "HARD",
        "category": "DP",
        "starterCode": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint optimalBST(vector<int>& keys, vector<int>& freq, int n) {\n    return 0;\n}\n\nint main() {\n    int keys_size;\n    cin >> keys_size;\n    vector<int> keys(keys_size);\n    for (int i = 0; i < keys_size; i++) cin >> keys[i];\n    int freq_size;\n    cin >> freq_size;\n    vector<int> freq(freq_size);\n    for (int i = 0; i < freq_size; i++) cin >> freq[i];\n    int n;\n    cin >> n;\n    cout << optimalBST(keys, freq, n);\n    return 0;\n}\n",
        "expectedOutput": "142",
        "solution": "#include <iostream>\nusing namespace std;\nint optimalBST(int keys[], int freq[], int n) { int dp[n][n], sum[n][n]; for(int i=0;i<n;i++) { dp[i][i]=freq[i]; sum[i][i]=freq[i]; } for(int len=2;len<=n;len++) for(int i=0;i<=n-len;i++) { int j=i+len-1; dp[i][j]=1e9; sum[i][j]=sum[i][j-1]+freq[j]; for(int r=i;r<=j;r++) { int c=sum[i][j]+(r>i?dp[i][r-1]:0)+(r<j?dp[r+1][j]:0); dp[i][j]=min(dp[i][j],c); } } return dp[0][n-1]; }\nint main() { int keys[]={10,12,20}; int freq[]={34,8,50}; cout<<optimalBST(keys,freq,3); return 0; }",
        "explanation": {
            "approach": "DP on ranges, try each as root.",
            "analogy": "Min expected search cost.",
            "steps": [
                "dp[i][j] = min cost for keys i to j",
                "Try each key as root"
            ],
            "complexity": "Time: O(n³), Space: O(n²)"
        },
        "testCases": [
            {
                "input": "keys={10,12,20}, freq={34,8,50}",
                "expectedOutput": "142",
                "explanation": "Optimal BST structure"
            },
            {
                "input": "keys={10,12}, freq={50,25}",
                "expectedOutput": "100",
                "explanation": "Two keys"
            },
            {
                "input": "keys={1}, freq={10}",
                "expectedOutput": "10",
                "explanation": "Single key"
            },
            {
                "input": "keys={1,2,3}, freq={10,10,10}",
                "expectedOutput": "50",
                "explanation": "Equal frequencies"
            }
        ]
    },
    {
        "id": "dp19",
        "title": "Maximum Product Subarray",
        "description": "Max product contiguous.",
        "difficulty": "MEDIUM",
        "category": "DP",
        "starterCode": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxProduct(vector<int>& a, int n) {\n    return 0;\n}\n\nint main() {\n    int a_size;\n    cin >> a_size;\n    vector<int> a(a_size);\n    for (int i = 0; i < a_size; i++) cin >> a[i];\n    int n;\n    cin >> n;\n    cout << maxProduct(a, n);\n    return 0;\n}\n",
        "expectedOutput": "6",
        "solution": "#include <iostream>\nusing namespace std;\nint maxProduct(int a[], int n) { int mx=a[0],mn=a[0],res=a[0]; for(int i=1;i<n;i++) { if(a[i]<0) swap(mx,mn); mx=max(a[i],mx*a[i]); mn=min(a[i],mn*a[i]); res=max(res,mx); } return res; }\nint main() { int a[]={2,3,-2,4}; cout<<maxProduct(a,4); return 0; }",
        "explanation": {
            "approach": "Track max and min products.",
            "analogy": "Negative × negative = positive.",
            "steps": [
                "Track both max and min at each position",
                "Swap on negative"
            ],
            "complexity": "Time: O(n), Space: O(1)"
        },
        "testCases": [
            {
                "input": "{2,3,-2,4}",
                "expectedOutput": "6",
                "explanation": "2*3=6"
            },
            {
                "input": "{-2,0,-1}",
                "expectedOutput": "0",
                "explanation": "Zero is maximum"
            },
            {
                "input": "{-2,3,-4}",
                "expectedOutput": "24",
                "explanation": "-2*3*-4=24"
            },
            {
                "input": "{-1,-2,-3}",
                "expectedOutput": "6",
                "explanation": "-2*-3=6"
            }
        ]
    },
    {
        "id": "dp20",
        "title": "Coin Change Count",
        "description": "Number of ways to make amount.",
        "difficulty": "MEDIUM",
        "category": "DP",
        "starterCode": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint coinChangeWays(vector<int>& coins, int n, int amt) {\n    return 0;\n}\n\nint main() {\n    int coins_size;\n    cin >> coins_size;\n    vector<int> coins(coins_size);\n    for (int i = 0; i < coins_size; i++) cin >> coins[i];\n    int n;\n    cin >> n;\n    int amt;\n    cin >> amt;\n    cout << coinChangeWays(coins, n, amt);\n    return 0;\n}\n",
        "expectedOutput": "4",
        "solution": "#include <iostream>\nusing namespace std;\nint coinChangeWays(int coins[], int n, int amt) { int dp[amt+1]={}; dp[0]=1; for(int i=0;i<n;i++) for(int j=coins[i];j<=amt;j++) dp[j]+=dp[j-coins[i]]; return dp[amt]; }\nint main() { int coins[]={1,2,5}; cout<<coinChangeWays(coins,3,5); return 0; }",
        "explanation": {
            "approach": "DP - count ways for each amount.",
            "analogy": "Unbounded knapsack variation.",
            "steps": [
                "Process each coin",
                "Add ways using that coin"
            ],
            "complexity": "Time: O(n × amt), Space: O(amt)"
        },
        "testCases": [
            {
                "input": "coins={1,2,5}, amt=5",
                "expectedOutput": "4",
                "explanation": "5=5,2+2+1,2+1+1+1,1+1+1+1+1"
            },
            {
                "input": "coins={2}, amt=3",
                "expectedOutput": "0",
                "explanation": "Cannot make 3 with only 2"
            },
            {
                "input": "coins={1}, amt=5",
                "expectedOutput": "1",
                "explanation": "Only one way with 1s"
            },
            {
                "input": "coins={1,2}, amt=4",
                "expectedOutput": "3",
                "explanation": "4=2+2,2+1+1,1+1+1+1"
            }
        ]
    }
]