[
    {
        "id": "med31",
        "title": "Swap Nodes in Pairs",
        "description": "Swap adjacent nodes.",
        "difficulty": "MEDIUM",
        "category": "Linked List",
        "starterCode": "#include <iostream>\nusing namespace std;\nstruct Node { int v; Node* n; Node(int x):v(x),n(0){} };\nNode* swapPairs(Node* h) { return nullptr; }\nint main() { Node* h=new Node(1); h->n=new Node(2); h->n->n=new Node(3); h->n->n->n=new Node(4); h=swapPairs(h); while(h) { cout<<h->v<<\" \"; h=h->n; } return 0; }",
        "expectedOutput": "2 1 4 3",
        "solution": "#include <iostream>\nusing namespace std;\nstruct Node { int v; Node* n; Node(int x):v(x),n(0){} };\nNode* swapPairs(Node* h) { Node d(0); d.n=h; Node* p=&d; while(p->n && p->n->n) { Node* a=p->n, *b=p->n->n; a->n=b->n; b->n=a; p->n=b; p=a; } return d.n; }\nint main() { Node* h=new Node(1); h->n=new Node(2); h->n->n=new Node(3); h->n->n->n=new Node(4); h=swapPairs(h); while(h) { cout<<h->v<<\" \"; h=h->n; } return 0; }",
        "explanation": {
            "approach": "Swap pairs iteratively.",
            "analogy": "Swap two at a time.",
            "steps": [
                "Get pair (a,b)",
                "Reconnect: prev→b→a→next",
                "Move p to a"
            ],
            "complexity": "Time: O(n), Space: O(1)"
        }
    },
    {
        "id": "med32",
        "title": "Sort List",
        "description": "Sort linked list.",
        "difficulty": "MEDIUM",
        "category": "Linked List",
        "starterCode": "#include <iostream>\nusing namespace std;\nstruct Node { int v; Node* n; Node(int x):v(x),n(0){} };\nNode* sortList(Node* h) { return nullptr; }\nint main() { Node* h=new Node(4); h->n=new Node(2); h->n->n=new Node(1); h->n->n->n=new Node(3); h=sortList(h); while(h) { cout<<h->v<<\" \"; h=h->n; } return 0; }",
        "expectedOutput": "1 2 3 4",
        "solution": "#include <iostream>\nusing namespace std;\nstruct Node { int v; Node* n; Node(int x):v(x),n(0){} };\nNode* merge(Node* a, Node* b) { Node d(0),*t=&d; while(a&&b) { if(a->v<b->v) { t->n=a; a=a->n; } else { t->n=b; b=b->n; } t=t->n; } t->n=a?a:b; return d.n; }\nNode* sortList(Node* h) { if(!h||!h->n) return h; Node* s=h,*f=h,*p=0; while(f&&f->n) { p=s; s=s->n; f=f->n->n; } p->n=0; return merge(sortList(h),sortList(s)); }\nint main() { Node* h=new Node(4); h->n=new Node(2); h->n->n=new Node(1); h->n->n->n=new Node(3); h=sortList(h); while(h) { cout<<h->v<<\" \"; h=h->n; } return 0; }",
        "explanation": {
            "approach": "Merge sort for linked list.",
            "analogy": "Divide at middle, merge sorted halves.",
            "steps": [
                "Find middle",
                "Split list",
                "Recursively sort",
                "Merge"
            ],
            "complexity": "Time: O(n log n), Space: O(log n)"
        }
    },
    {
        "id": "med33",
        "title": "Reorder List",
        "description": "Reorder L0→Ln→L1→Ln-1...",
        "difficulty": "MEDIUM",
        "category": "Linked List",
        "starterCode": "#include <iostream>\nusing namespace std;\nstruct Node { int v; Node* n; Node(int x):v(x),n(0){} };\nvoid reorderList(Node* h) {}\nint main() { Node* h=new Node(1); h->n=new Node(2); h->n->n=new Node(3); h->n->n->n=new Node(4); reorderList(h); while(h) { cout<<h->v<<\" \"; h=h->n; } return 0; }",
        "expectedOutput": "1 4 2 3",
        "solution": "#include <iostream>\nusing namespace std;\nstruct Node { int v; Node* n; Node(int x):v(x),n(0){} };\nvoid reorderList(Node* h) { if(!h||!h->n) return; Node* s=h,*f=h; while(f->n&&f->n->n) { s=s->n; f=f->n->n; } Node* sec=s->n; s->n=0; Node* p=0; while(sec) { Node* t=sec->n; sec->n=p; p=sec; sec=t; } Node* f1=h,*f2=p; while(f2) { Node* t1=f1->n,*t2=f2->n; f1->n=f2; f2->n=t1; f1=t1; f2=t2; } }\nint main() { Node* h=new Node(1); h->n=new Node(2); h->n->n=new Node(3); h->n->n->n=new Node(4); reorderList(h); while(h) { cout<<h->v<<\" \"; h=h->n; } return 0; }",
        "explanation": {
            "approach": "Split, reverse second half, merge alternately.",
            "analogy": "Interleave first half with reversed second.",
            "steps": [
                "Find middle",
                "Reverse second half",
                "Merge alternately"
            ],
            "complexity": "Time: O(n), Space: O(1)"
        }
    },
    {
        "id": "med34",
        "title": "Validate BST",
        "description": "Check if valid BST.",
        "difficulty": "MEDIUM",
        "category": "Trees",
        "starterCode": "#include <iostream>\nusing namespace std;\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\nbool isValidBST(Node* r) { return false; }\nint main() { Node* r=new Node(2); r->l=new Node(1); r->r=new Node(3); cout<<isValidBST(r); return 0; }",
        "expectedOutput": "1",
        "solution": "#include <iostream>\nusing namespace std;\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\nbool valid(Node* r, long mn, long mx) { if(!r) return true; if(r->v<=mn||r->v>=mx) return false; return valid(r->l,mn,r->v)&&valid(r->r,r->v,mx); }\nbool isValidBST(Node* r) { return valid(r,LONG_MIN,LONG_MAX); }\nint main() { Node* r=new Node(2); r->l=new Node(1); r->r=new Node(3); cout<<isValidBST(r); return 0; }",
        "explanation": {
            "approach": "Track valid range at each node.",
            "analogy": "Each node has min/max constraints.",
            "steps": [
                "Pass min/max bounds",
                "Left updates max, right updates min"
            ],
            "complexity": "Time: O(n), Space: O(h)"
        }
    },
    {
        "id": "med35",
        "title": "Flatten Binary Tree",
        "description": "Flatten to linked list.",
        "difficulty": "MEDIUM",
        "category": "Trees",
        "starterCode": "#include <iostream>\nusing namespace std;\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\nvoid flatten(Node* r) {}\nint main() { Node* r=new Node(1); r->l=new Node(2); r->r=new Node(5); r->l->l=new Node(3); r->l->r=new Node(4); r->r->r=new Node(6); flatten(r); while(r) { cout<<r->v<<\" \"; r=r->r; } return 0; }",
        "expectedOutput": "1 2 3 4 5 6",
        "solution": "#include <iostream>\nusing namespace std;\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\nvoid flatten(Node* r) { while(r) { if(r->l) { Node* p=r->l; while(p->r) p=p->r; p->r=r->r; r->r=r->l; r->l=0; } r=r->r; } }\nint main() { Node* r=new Node(1); r->l=new Node(2); r->r=new Node(5); r->l->l=new Node(3); r->l->r=new Node(4); r->r->r=new Node(6); flatten(r); while(r) { cout<<r->v<<\" \"; r=r->r; } return 0; }",
        "explanation": {
            "approach": "Move left subtree to right, attach old right to end.",
            "analogy": "Flatten preorder to right pointers.",
            "steps": [
                "Find rightmost of left subtree",
                "Attach right subtree there",
                "Move left to right"
            ],
            "complexity": "Time: O(n), Space: O(1)"
        }
    },
    {
        "id": "med36",
        "title": "Binary Tree Right View",
        "description": "Nodes visible from right.",
        "difficulty": "MEDIUM",
        "category": "Trees",
        "starterCode": "#include <iostream>\nusing namespace std;\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\nvoid rightView(Node* r) {}\nint main() { Node* r=new Node(1); r->l=new Node(2); r->r=new Node(3); r->l->r=new Node(5); r->r->r=new Node(4); rightView(r); return 0; }",
        "expectedOutput": "1 3 4",
        "solution": "#include <iostream>\nusing namespace std;\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\nint maxLevel=-1;\nvoid solve(Node* r, int lv) { if(!r) return; if(lv>maxLevel) { cout<<r->v<<\" \"; maxLevel=lv; } solve(r->r,lv+1); solve(r->l,lv+1); }\nvoid rightView(Node* r) { maxLevel=-1; solve(r,0); }\nint main() { Node* r=new Node(1); r->l=new Node(2); r->r=new Node(3); r->l->r=new Node(5); r->r->r=new Node(4); rightView(r); return 0; }",
        "explanation": {
            "approach": "First node at each level from right.",
            "analogy": "Visit right before left.",
            "steps": [
                "Track max level seen",
                "Print if new level",
                "Go right first"
            ],
            "complexity": "Time: O(n), Space: O(h)"
        }
    },
    {
        "id": "med37",
        "title": "Kth Smallest in BST",
        "description": "Find kth smallest element.",
        "difficulty": "MEDIUM",
        "category": "Trees",
        "starterCode": "#include <iostream>\nusing namespace std;\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\nint kthSmallest(Node* r, int k) { return 0; }\nint main() { Node* r=new Node(3); r->l=new Node(1); r->r=new Node(4); r->l->r=new Node(2); cout<<kthSmallest(r,1); return 0; }",
        "expectedOutput": "1",
        "solution": "#include <iostream>\nusing namespace std;\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\nint cnt,result;\nvoid inorder(Node* r, int k) { if(!r) return; inorder(r->l,k); if(++cnt==k) { result=r->v; return; } inorder(r->r,k); }\nint kthSmallest(Node* r, int k) { cnt=0; result=0; inorder(r,k); return result; }\nint main() { Node* r=new Node(3); r->l=new Node(1); r->r=new Node(4); r->l->r=new Node(2); cout<<kthSmallest(r,1); return 0; }",
        "explanation": {
            "approach": "Inorder gives sorted order.",
            "analogy": "Count nodes in inorder.",
            "steps": [
                "Inorder traversal",
                "Count until k"
            ],
            "complexity": "Time: O(h+k), Space: O(h)"
        }
    },
    {
        "id": "med38",
        "title": "Construct BST from Preorder",
        "description": "Build BST from preorder.",
        "difficulty": "MEDIUM",
        "category": "Trees",
        "starterCode": "#include <iostream>\nusing namespace std;\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\nNode* buildBST(int pre[], int n) { return nullptr; }\nvoid inorder(Node* r) { if(!r) return; inorder(r->l); cout<<r->v<<\" \"; inorder(r->r); }\nint main() { int pre[]={8,5,1,7,10,12}; Node* r=buildBST(pre,6); inorder(r); return 0; }",
        "expectedOutput": "1 5 7 8 10 12",
        "solution": "#include <iostream>\nusing namespace std;\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\nint idx=0;\nNode* build(int pre[], int n, int mn, int mx) { if(idx>=n||pre[idx]<mn||pre[idx]>mx) return 0; Node* r=new Node(pre[idx++]); r->l=build(pre,n,mn,r->v); r->r=build(pre,n,r->v,mx); return r; }\nNode* buildBST(int pre[], int n) { idx=0; return build(pre,n,INT_MIN,INT_MAX); }\nvoid inorder(Node* r) { if(!r) return; inorder(r->l); cout<<r->v<<\" \"; inorder(r->r); }\nint main() { int pre[]={8,5,1,7,10,12}; Node* r=buildBST(pre,6); inorder(r); return 0; }",
        "explanation": {
            "approach": "Use bounds to determine subtree.",
            "analogy": "Each node has valid range.",
            "steps": [
                "If value in range, create node",
                "Recurse with updated bounds"
            ],
            "complexity": "Time: O(n), Space: O(h)"
        }
    },
    {
        "id": "med39",
        "title": "Course Schedule",
        "description": "Can finish all courses.",
        "difficulty": "MEDIUM",
        "category": "Graph",
        "starterCode": "#include <iostream>\nusing namespace std;\nbool canFinish(int n, int pre[][2], int m) { return false; }\nint main() { int pre[][2]={{1,0},{0,1}}; cout<<canFinish(2,pre,2); return 0; }",
        "expectedOutput": "0",
        "solution": "#include <iostream>\nusing namespace std;\nint adj[100][100],deg[100],sz[100];\nbool canFinish(int n, int pre[][2], int m) { for(int i=0;i<n;i++) { sz[i]=0; deg[i]=0; } for(int i=0;i<m;i++) { adj[pre[i][1]][sz[pre[i][1]]++]=pre[i][0]; deg[pre[i][0]]++; } int q[100],f=0,r=0,cnt=0; for(int i=0;i<n;i++) if(deg[i]==0) q[r++]=i; while(f<r) { int u=q[f++]; cnt++; for(int i=0;i<sz[u];i++) if(--deg[adj[u][i]]==0) q[r++]=adj[u][i]; } return cnt==n; }\nint main() { int pre[][2]={{1,0},{0,1}}; cout<<canFinish(2,pre,2); return 0; }",
        "explanation": {
            "approach": "Topological sort - detect cycle.",
            "analogy": "No cycle means can finish all.",
            "steps": [
                "Build graph and in-degrees",
                "BFS from zero-degree nodes",
                "Check if all visited"
            ],
            "complexity": "Time: O(V+E), Space: O(V+E)"
        }
    },
    {
        "id": "med40",
        "title": "Number of Islands",
        "description": "Count connected 1s.",
        "difficulty": "MEDIUM",
        "category": "Graph",
        "starterCode": "#include <iostream>\nusing namespace std;\nint numIslands(int g[][5], int r, int c) { return 0; }\nint main() { int g[][5]={{1,1,0,0,0},{1,1,0,0,0},{0,0,1,0,0},{0,0,0,1,1}}; cout<<numIslands(g,4,5); return 0; }",
        "expectedOutput": "3",
        "solution": "#include <iostream>\nusing namespace std;\nvoid dfs(int g[][5], int r, int c, int i, int j) { if(i<0||i>=r||j<0||j>=c||g[i][j]!=1) return; g[i][j]=0; dfs(g,r,c,i+1,j); dfs(g,r,c,i-1,j); dfs(g,r,c,i,j+1); dfs(g,r,c,i,j-1); }\nint numIslands(int g[][5], int r, int c) { int cnt=0; for(int i=0;i<r;i++) for(int j=0;j<c;j++) if(g[i][j]==1) { cnt++; dfs(g,r,c,i,j); } return cnt; }\nint main() { int g[][5]={{1,1,0,0,0},{1,1,0,0,0},{0,0,1,0,0},{0,0,0,1,1}}; cout<<numIslands(g,4,5); return 0; }",
        "explanation": {
            "approach": "DFS to mark connected land.",
            "analogy": "Flood fill each island.",
            "steps": [
                "For each 1, increment count",
                "DFS to mark all connected as visited"
            ],
            "complexity": "Time: O(rc), Space: O(rc)"
        }
    }
]