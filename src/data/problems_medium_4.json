[
    {
        "id": "med31",
        "title": "Swap Nodes in Pairs",
        "description": "Swap adjacent nodes.",
        "difficulty": "MEDIUM",
        "category": "Linked List",
        "starterCode": "#include <iostream>\nusing namespace std;\nstruct Node { int v; Node* n; Node(int x):v(x),n(0){} };\nNode* swapPairs(Node* h) { return nullptr; }\nint main() { Node* h=new Node(1); h->n=new Node(2); h->n->n=new Node(3); h->n->n->n=new Node(4); h=swapPairs(h); while(h) { cout<<h->v<<\" \"; h=h->n; } return 0; }",
        "expectedOutput": "2 1 4 3",
        "solution": "#include <iostream>\nusing namespace std;\nstruct Node { int v; Node* n; Node(int x):v(x),n(0){} };\nNode* swapPairs(Node* h) { Node d(0); d.n=h; Node* p=&d; while(p->n && p->n->n) { Node* a=p->n, *b=p->n->n; a->n=b->n; b->n=a; p->n=b; p=a; } return d.n; }\nint main() { Node* h=new Node(1); h->n=new Node(2); h->n->n=new Node(3); h->n->n->n=new Node(4); h=swapPairs(h); while(h) { cout<<h->v<<\" \"; h=h->n; } return 0; }",
        "explanation": {
            "approach": "Swap pairs iteratively.",
            "steps": [
                "Get pair (a,b)",
                "Reconnect: prev→b→a→next",
                "Move p to a"
            ],
            "complexity": "Time: O(n), Space: O(1)"
        },
        "testCases": [
            {
                "input": "list=1,2,3,4",
                "expectedOutput": "2 1 4 3",
                "explanation": "Swap pairs: 1,2→2,1 and 3,4→4,3"
            },
            {
                "input": "list=1,2,3",
                "expectedOutput": "2 1 3",
                "explanation": "Odd length, last unpaired"
            },
            {
                "input": "list=1",
                "expectedOutput": "1",
                "explanation": "Single element unchanged"
            },
            {
                "input": "list=1,2",
                "expectedOutput": "2 1",
                "explanation": "One pair swapped"
            }
        ],
        "requiresManualInput": true,
        "inputCategory": "linkedList",
        "inputInstructions": "This problem uses a linked list. The input is given as an array [1,2,3,4,5]. Build your linked list from this array before processing."
    },
    {
        "id": "med32",
        "title": "Sort List",
        "description": "Sort linked list.",
        "difficulty": "MEDIUM",
        "category": "Linked List",
        "starterCode": "#include <iostream>\nusing namespace std;\nstruct Node { int v; Node* n; Node(int x):v(x),n(0){} };\nNode* sortList(Node* h) { return nullptr; }\nint main() { Node* h=new Node(4); h->n=new Node(2); h->n->n=new Node(1); h->n->n->n=new Node(3); h=sortList(h); while(h) { cout<<h->v<<\" \"; h=h->n; } return 0; }",
        "expectedOutput": "1 2 3 4",
        "solution": "#include <iostream>\nusing namespace std;\nstruct Node { int v; Node* n; Node(int x):v(x),n(0){} };\nNode* merge(Node* a, Node* b) { Node d(0),*t=&d; while(a&&b) { if(a->v<b->v) { t->n=a; a=a->n; } else { t->n=b; b=b->n; } t=t->n; } t->n=a?a:b; return d.n; }\nNode* sortList(Node* h) { if(!h||!h->n) return h; Node* s=h,*f=h,*p=0; while(f&&f->n) { p=s; s=s->n; f=f->n->n; } p->n=0; return merge(sortList(h),sortList(s)); }\nint main() { Node* h=new Node(4); h->n=new Node(2); h->n->n=new Node(1); h->n->n->n=new Node(3); h=sortList(h); while(h) { cout<<h->v<<\" \"; h=h->n; } return 0; }",
        "explanation": {
            "approach": "Merge sort for linked list.",
            "steps": [
                "Find middle",
                "Split list",
                "Recursively sort",
                "Merge"
            ],
            "complexity": "Time: O(n log n), Space: O(log n)"
        },
        "testCases": [
            {
                "input": "list=4,2,1,3",
                "expectedOutput": "1 2 3 4",
                "explanation": "Unsorted list becomes sorted"
            },
            {
                "input": "list=-1,5,3,4,0",
                "expectedOutput": "-1 0 3 4 5",
                "explanation": "Handles negative and mixed"
            },
            {
                "input": "list=1",
                "expectedOutput": "1",
                "explanation": "Single element already sorted"
            },
            {
                "input": "list=2,1",
                "expectedOutput": "1 2",
                "explanation": "Two elements swapped"
            }
        ],
        "requiresManualInput": true,
        "inputCategory": "linkedList",
        "inputInstructions": "This problem uses a linked list. The input is given as an array [1,2,3,4,5]. Build your linked list from this array before processing."
    },
    {
        "id": "med33",
        "title": "Reorder List",
        "description": "Reorder L0→Ln→L1→Ln-1...",
        "difficulty": "MEDIUM",
        "category": "Linked List",
        "starterCode": "#include <iostream>\nusing namespace std;\nstruct Node { int v; Node* n; Node(int x):v(x),n(0){} };\nvoid reorderList(Node* h) {}\nint main() { Node* h=new Node(1); h->n=new Node(2); h->n->n=new Node(3); h->n->n->n=new Node(4); reorderList(h); while(h) { cout<<h->v<<\" \"; h=h->n; } return 0; }",
        "expectedOutput": "1 4 2 3",
        "solution": "#include <iostream>\nusing namespace std;\nstruct Node { int v; Node* n; Node(int x):v(x),n(0){} };\nvoid reorderList(Node* h) { if(!h||!h->n) return; Node* s=h,*f=h; while(f->n&&f->n->n) { s=s->n; f=f->n->n; } Node* sec=s->n; s->n=0; Node* p=0; while(sec) { Node* t=sec->n; sec->n=p; p=sec; sec=t; } Node* f1=h,*f2=p; while(f2) { Node* t1=f1->n,*t2=f2->n; f1->n=f2; f2->n=t1; f1=t1; f2=t2; } }\nint main() { Node* h=new Node(1); h->n=new Node(2); h->n->n=new Node(3); h->n->n->n=new Node(4); reorderList(h); while(h) { cout<<h->v<<\" \"; h=h->n; } return 0; }",
        "explanation": {
            "approach": "Split, reverse second half, merge alternately.",
            "steps": [
                "Find middle",
                "Reverse second half",
                "Merge alternately"
            ],
            "complexity": "Time: O(n), Space: O(1)"
        },
        "testCases": [
            {
                "input": "list=1,2,3,4",
                "expectedOutput": "1 4 2 3",
                "explanation": "Interleave first and reversed second half"
            },
            {
                "input": "list=1,2,3,4,5",
                "expectedOutput": "1 5 2 4 3",
                "explanation": "Odd length interleaving"
            },
            {
                "input": "list=1",
                "expectedOutput": "1",
                "explanation": "Single element unchanged"
            },
            {
                "input": "list=1,2",
                "expectedOutput": "1 2",
                "explanation": "Two elements unchanged"
            }
        ],
        "requiresManualInput": true,
        "inputCategory": "linkedList",
        "inputInstructions": "This problem uses a linked list. The input is given as an array [1,2,3,4,5]. Build your linked list from this array before processing."
    },
    {
        "id": "med34",
        "title": "Validate BST",
        "description": "Check if valid BST.",
        "difficulty": "MEDIUM",
        "category": "Trees",
        "starterCode": "#include <iostream>\nusing namespace std;\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\nbool isValidBST(Node* r) { return false; }\nint main() { Node* r=new Node(2); r->l=new Node(1); r->r=new Node(3); cout<<isValidBST(r); return 0; }",
        "expectedOutput": "1",
        "solution": "#include <iostream>\nusing namespace std;\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\nbool valid(Node* r, long mn, long mx) { if(!r) return true; if(r->v<=mn||r->v>=mx) return false; return valid(r->l,mn,r->v)&&valid(r->r,r->v,mx); }\nbool isValidBST(Node* r) { return valid(r,LONG_MIN,LONG_MAX); }\nint main() { Node* r=new Node(2); r->l=new Node(1); r->r=new Node(3); cout<<isValidBST(r); return 0; }",
        "explanation": {
            "approach": "Track valid range at each node.",
            "steps": [
                "Pass min/max bounds",
                "Left updates max, right updates min"
            ],
            "complexity": "Time: O(n), Space: O(h)"
        },
        "testCases": [
            {
                "input": "tree=[2,1,3]",
                "expectedOutput": "1",
                "explanation": "Valid BST: 1<2<3"
            },
            {
                "input": "tree=[5,1,4,null,null,3,6]",
                "expectedOutput": "0",
                "explanation": "Invalid: 4 in right but <5"
            },
            {
                "input": "tree=[1]",
                "expectedOutput": "1",
                "explanation": "Single node is valid BST"
            },
            {
                "input": "tree=[5,4,6,null,null,3,7]",
                "expectedOutput": "0",
                "explanation": "3 in right subtree but <5"
            }
        ],
        "requiresManualInput": true,
        "inputCategory": "tree",
        "inputInstructions": "This problem uses a binary tree structure. The input format is a level-order array like [1,2,3,null,4]. Your solution should build the tree from this input."
    },
    {
        "id": "med35",
        "title": "Flatten Binary Tree",
        "description": "Flatten to linked list.",
        "difficulty": "MEDIUM",
        "category": "Trees",
        "starterCode": "#include <iostream>\nusing namespace std;\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\nvoid flatten(Node* r) {}\nint main() { Node* r=new Node(1); r->l=new Node(2); r->r=new Node(5); r->l->l=new Node(3); r->l->r=new Node(4); r->r->r=new Node(6); flatten(r); while(r) { cout<<r->v<<\" \"; r=r->r; } return 0; }",
        "expectedOutput": "1 2 3 4 5 6",
        "solution": "#include <iostream>\nusing namespace std;\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\nvoid flatten(Node* r) { while(r) { if(r->l) { Node* p=r->l; while(p->r) p=p->r; p->r=r->r; r->r=r->l; r->l=0; } r=r->r; } }\nint main() { Node* r=new Node(1); r->l=new Node(2); r->r=new Node(5); r->l->l=new Node(3); r->l->r=new Node(4); r->r->r=new Node(6); flatten(r); while(r) { cout<<r->v<<\" \"; r=r->r; } return 0; }",
        "explanation": {
            "approach": "Move left subtree to right, attach old right to end.",
            "steps": [
                "Find rightmost of left subtree",
                "Attach right subtree there",
                "Move left to right"
            ],
            "complexity": "Time: O(n), Space: O(1)"
        },
        "testCases": [
            {
                "input": "tree=[1,2,5,3,4,null,6]",
                "expectedOutput": "1 2 3 4 5 6",
                "explanation": "Preorder to right-only list"
            },
            {
                "input": "tree=[1]",
                "expectedOutput": "1",
                "explanation": "Single node unchanged"
            },
            {
                "input": "tree=[1,2]",
                "expectedOutput": "1 2",
                "explanation": "Left child becomes right"
            },
            {
                "input": "tree=[1,null,2]",
                "expectedOutput": "1 2",
                "explanation": "Right-only tree unchanged"
            }
        ],
        "requiresManualInput": true,
        "inputCategory": "tree",
        "inputInstructions": "This problem uses a binary tree structure. The input format is a level-order array like [1,2,3,null,4]. Your solution should build the tree from this input."
    },
    {
        "id": "med36",
        "title": "Binary Tree Right View",
        "description": "Nodes visible from right.",
        "difficulty": "MEDIUM",
        "category": "Trees",
        "starterCode": "#include <iostream>\nusing namespace std;\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\nvoid rightView(Node* r) {}\nint main() { Node* r=new Node(1); r->l=new Node(2); r->r=new Node(3); r->l->r=new Node(5); r->r->r=new Node(4); rightView(r); return 0; }",
        "expectedOutput": "1 3 4",
        "solution": "#include <iostream>\nusing namespace std;\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\nint maxLevel=-1;\nvoid solve(Node* r, int lv) { if(!r) return; if(lv>maxLevel) { cout<<r->v<<\" \"; maxLevel=lv; } solve(r->r,lv+1); solve(r->l,lv+1); }\nvoid rightView(Node* r) { maxLevel=-1; solve(r,0); }\nint main() { Node* r=new Node(1); r->l=new Node(2); r->r=new Node(3); r->l->r=new Node(5); r->r->r=new Node(4); rightView(r); return 0; }",
        "explanation": {
            "approach": "First node at each level from right.",
            "steps": [
                "Track max level seen",
                "Print if new level",
                "Go right first"
            ],
            "complexity": "Time: O(n), Space: O(h)"
        },
        "testCases": [
            {
                "input": "tree=[1,2,3,null,5,null,4]",
                "expectedOutput": "1 3 4",
                "explanation": "Rightmost at each level"
            },
            {
                "input": "tree=[1,2]",
                "expectedOutput": "1 2",
                "explanation": "Left visible when no right"
            },
            {
                "input": "tree=[1]",
                "expectedOutput": "1",
                "explanation": "Single node"
            },
            {
                "input": "tree=[1,2,3]",
                "expectedOutput": "1 3",
                "explanation": "Root and right child"
            }
        ],
        "requiresManualInput": true,
        "inputCategory": "tree",
        "inputInstructions": "This problem uses a binary tree structure. The input format is a level-order array like [1,2,3,null,4]. Your solution should build the tree from this input."
    },
    {
        "id": "med37",
        "title": "Kth Smallest in BST",
        "description": "Find kth smallest element.",
        "difficulty": "MEDIUM",
        "category": "Trees",
        "starterCode": "#include <iostream>\nusing namespace std;\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\nint kthSmallest(Node* r, int k) { return 0; }\nint main() { Node* r=new Node(3); r->l=new Node(1); r->r=new Node(4); r->l->r=new Node(2); cout<<kthSmallest(r,1); return 0; }",
        "expectedOutput": "1",
        "solution": "#include <iostream>\nusing namespace std;\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\nint cnt,result;\nvoid inorder(Node* r, int k) { if(!r) return; inorder(r->l,k); if(++cnt==k) { result=r->v; return; } inorder(r->r,k); }\nint kthSmallest(Node* r, int k) { cnt=0; result=0; inorder(r,k); return result; }\nint main() { Node* r=new Node(3); r->l=new Node(1); r->r=new Node(4); r->l->r=new Node(2); cout<<kthSmallest(r,1); return 0; }",
        "explanation": {
            "approach": "Inorder gives sorted order.",
            "steps": [
                "Inorder traversal",
                "Count until k"
            ],
            "complexity": "Time: O(h+k), Space: O(h)"
        },
        "testCases": [
            {
                "input": "tree=[3,1,4,null,2], k=1",
                "expectedOutput": "1",
                "explanation": "1st smallest is 1"
            },
            {
                "input": "tree=[5,3,6,2,4,null,null,1], k=3",
                "expectedOutput": "3",
                "explanation": "3rd smallest"
            },
            {
                "input": "tree=[1], k=1",
                "expectedOutput": "1",
                "explanation": "Only element"
            },
            {
                "input": "tree=[3,1,4,null,2], k=4",
                "expectedOutput": "4",
                "explanation": "4th smallest (largest)"
            }
        ],
        "requiresManualInput": true,
        "inputCategory": "tree",
        "inputInstructions": "This problem uses a binary tree structure. The input format is a level-order array like [1,2,3,null,4]. Your solution should build the tree from this input."
    },
    {
        "id": "med38",
        "title": "Construct BST from Preorder",
        "description": "Build BST from preorder.",
        "difficulty": "MEDIUM",
        "category": "Trees",
        "starterCode": "#include <iostream>\nusing namespace std;\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\nNode* buildBST(int pre[], int n) { return nullptr; }\nvoid inorder(Node* r) { if(!r) return; inorder(r->l); cout<<r->v<<\" \"; inorder(r->r); }\nint main() { int pre[]={8,5,1,7,10,12}; Node* r=buildBST(pre,6); inorder(r); return 0; }",
        "expectedOutput": "1 5 7 8 10 12",
        "solution": "#include <iostream>\nusing namespace std;\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\nint idx=0;\nNode* build(int pre[], int n, int mn, int mx) { if(idx>=n||pre[idx]<mn||pre[idx]>mx) return 0; Node* r=new Node(pre[idx++]); r->l=build(pre,n,mn,r->v); r->r=build(pre,n,r->v,mx); return r; }\nNode* buildBST(int pre[], int n) { idx=0; return build(pre,n,INT_MIN,INT_MAX); }\nvoid inorder(Node* r) { if(!r) return; inorder(r->l); cout<<r->v<<\" \"; inorder(r->r); }\nint main() { int pre[]={8,5,1,7,10,12}; Node* r=buildBST(pre,6); inorder(r); return 0; }",
        "explanation": {
            "approach": "Use bounds to determine subtree.",
            "steps": [
                "If value in range, create node",
                "Recurse with updated bounds"
            ],
            "complexity": "Time: O(n), Space: O(h)"
        },
        "testCases": [
            {
                "input": "preorder=[8,5,1,7,10,12]",
                "expectedOutput": "1 5 7 8 10 12",
                "explanation": "Build BST, inorder is sorted"
            },
            {
                "input": "preorder=[1,3]",
                "expectedOutput": "1 3",
                "explanation": "Root with right child"
            },
            {
                "input": "preorder=[2,1,3]",
                "expectedOutput": "1 2 3",
                "explanation": "Balanced tree"
            },
            {
                "input": "preorder=[5]",
                "expectedOutput": "5",
                "explanation": "Single node"
            }
        ],
        "requiresManualInput": true,
        "inputCategory": "tree",
        "inputInstructions": "This problem uses a binary tree structure. The input format is a level-order array like [1,2,3,null,4]. Your solution should build the tree from this input."
    },
    {
        "id": "med39",
        "title": "Course Schedule",
        "description": "Can finish all courses.",
        "difficulty": "MEDIUM",
        "category": "Graph",
        "starterCode": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nbool canFinish(int n, vector<vector<int>>& pre, int m) {\n    return false;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    int pre_rows, pre_cols;\n    cin >> pre_rows >> pre_cols;\n    vector<vector<int>> pre(pre_rows, vector<int>(pre_cols));\n    for (int i = 0; i < pre_rows; i++)\n        for (int j = 0; j < pre_cols; j++)\n            cin >> pre[i][j];\n    int m;\n    cin >> m;\n    cout << canFinish(n, pre, m);\n    return 0;\n}\n",
        "expectedOutput": "0",
        "solution": "#include <iostream>\nusing namespace std;\nint adj[100][100],deg[100],sz[100];\nbool canFinish(int n, int pre[][2], int m) { for(int i=0;i<n;i++) { sz[i]=0; deg[i]=0; } for(int i=0;i<m;i++) { adj[pre[i][1]][sz[pre[i][1]]++]=pre[i][0]; deg[pre[i][0]]++; } int q[100],f=0,r=0,cnt=0; for(int i=0;i<n;i++) if(deg[i]==0) q[r++]=i; while(f<r) { int u=q[f++]; cnt++; for(int i=0;i<sz[u];i++) if(--deg[adj[u][i]]==0) q[r++]=adj[u][i]; } return cnt==n; }\nint main() { int pre[][2]={{1,0},{0,1}}; cout<<canFinish(2,pre,2); return 0; }",
        "explanation": {
            "approach": "Topological sort - detect cycle.",
            "steps": [
                "Build graph and in-degrees",
                "BFS from zero-degree nodes",
                "Check if all visited"
            ],
            "complexity": "Time: O(V+E), Space: O(V+E)"
        },
        "testCases": [
            {
                "input": "n=2, prereqs=[[1,0],[0,1]]",
                "expectedOutput": "0",
                "explanation": "Cycle detected, cannot finish"
            },
            {
                "input": "n=2, prereqs=[[1,0]]",
                "expectedOutput": "1",
                "explanation": "Take 0 then 1, no cycle"
            },
            {
                "input": "n=1, prereqs=[]",
                "expectedOutput": "1",
                "explanation": "Single course, no prereqs"
            },
            {
                "input": "n=3, prereqs=[[1,0],[2,1]]",
                "expectedOutput": "1",
                "explanation": "Linear dependency, valid"
            }
        ]
    },
    {
        "id": "med40",
        "title": "Number of Islands",
        "description": "Count connected 1s.",
        "difficulty": "MEDIUM",
        "category": "Graph",
        "starterCode": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint numIslands(vector<vector<int>>& g, int r, int c) {\n    return 0;\n}\n\nint main() {\n    int g_rows, g_cols;\n    cin >> g_rows >> g_cols;\n    vector<vector<int>> g(g_rows, vector<int>(g_cols));\n    for (int i = 0; i < g_rows; i++)\n        for (int j = 0; j < g_cols; j++)\n            cin >> g[i][j];\n    int r;\n    cin >> r;\n    int c;\n    cin >> c;\n    cout << numIslands(g, r, c);\n    return 0;\n}\n",
        "expectedOutput": "3",
        "solution": "#include <iostream>\nusing namespace std;\nvoid dfs(int g[][5], int r, int c, int i, int j) { if(i<0||i>=r||j<0||j>=c||g[i][j]!=1) return; g[i][j]=0; dfs(g,r,c,i+1,j); dfs(g,r,c,i-1,j); dfs(g,r,c,i,j+1); dfs(g,r,c,i,j-1); }\nint numIslands(int g[][5], int r, int c) { int cnt=0; for(int i=0;i<r;i++) for(int j=0;j<c;j++) if(g[i][j]==1) { cnt++; dfs(g,r,c,i,j); } return cnt; }\nint main() { int g[][5]={{1,1,0,0,0},{1,1,0,0,0},{0,0,1,0,0},{0,0,0,1,1}}; cout<<numIslands(g,4,5); return 0; }",
        "explanation": {
            "approach": "DFS to mark connected land.",
            "steps": [
                "For each 1, increment count",
                "DFS to mark all connected as visited"
            ],
            "complexity": "Time: O(rc), Space: O(rc)"
        },
        "testCases": [
            {
                "input": "grid 4x5 with 3 islands",
                "expectedOutput": "3",
                "explanation": "Three separate island groups"
            },
            {
                "input": "grid all 0s",
                "expectedOutput": "0",
                "explanation": "No land, no islands"
            },
            {
                "input": "grid all 1s",
                "expectedOutput": "1",
                "explanation": "All connected, one island"
            },
            {
                "input": "grid [[1]]",
                "expectedOutput": "1",
                "explanation": "Single cell island"
            }
        ]
    }
]