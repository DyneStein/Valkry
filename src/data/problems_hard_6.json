[
    {
        "id": "h136",
        "title": "Island Perimeter",
        "description": "Calculate perimeter of island in grid where 1 is land and 0 is water.",
        "difficulty": "EASY",
        "category": "Matrix",
        "starterCode": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint islandPerimeter(vector<vector<int>>& grid, int r, int c) {\n    return 0;\n}\n\nint main() {\n    int grid_rows, grid_cols;\n    cin >> grid_rows >> grid_cols;\n    vector<vector<int>> grid(grid_rows, vector<int>(grid_cols));\n    for (int i = 0; i < grid_rows; i++)\n        for (int j = 0; j < grid_cols; j++)\n            cin >> grid[i][j];\n    int r;\n    cin >> r;\n    int c;\n    cin >> c;\n    cout << islandPerimeter(grid, r, c);\n    return 0;\n}\n",
        "expectedOutput": "16",
        "solution": "#include <iostream>\nusing namespace std;\nint islandPerimeter(int grid[][4], int r, int c) { int p=0; for(int i=0;i<r;i++) for(int j=0;j<c;j++) if(grid[i][j]) { p+=4; if(i>0&&grid[i-1][j]) p-=2; if(j>0&&grid[i][j-1]) p-=2; } return p; }\nint main() { int g[][4]={{0,1,0,0},{1,1,1,0},{0,1,0,0},{1,1,0,0}}; cout<<islandPerimeter(g,4,4); return 0; }",
        "explanation": {
            "approach": "Count 4 edges per land cell, subtract 2 for each adjacent land.",
            "steps": [
                "Each land cell contributes 4 edges",
                "Subtract 2 for each neighbor"
            ],
            "complexity": "Time: O(mn), Space: O(1)"
        },
        "testCases": [
            {
                "input": "4x4 grid with island",
                "expectedOutput": "16",
                "explanation": "Island perimeter is 16"
            },
            {
                "input": "Single cell [[1]]",
                "expectedOutput": "4",
                "explanation": "Square has 4 sides"
            },
            {
                "input": "[[1,1],[1,1]]",
                "expectedOutput": "8",
                "explanation": "2x2 square perimeter"
            },
            {
                "input": "Line [[1,1,1,1]]",
                "expectedOutput": "10",
                "explanation": "Horizontal line perimeter"
            }
        ]
    },
    {
        "id": "h137",
        "title": "Best Time to Buy and Sell Stock III",
        "description": "Maximum profit with at most 2 transactions.",
        "difficulty": "HARD",
        "category": "DP",
        "starterCode": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxProfit(vector<int>& prices, int n) {\n    return 0;\n}\n\nint main() {\n    int prices_size;\n    cin >> prices_size;\n    vector<int> prices(prices_size);\n    for (int i = 0; i < prices_size; i++) cin >> prices[i];\n    int n;\n    cin >> n;\n    cout << maxProfit(prices, n);\n    return 0;\n}\n",
        "expectedOutput": "6",
        "solution": "#include <iostream>\nusing namespace std;\nint maxProfit(int prices[], int n) { int b1=1e9,b2=1e9,p1=0,p2=0; for(int i=0;i<n;i++) { b1=min(b1,prices[i]); p1=max(p1,prices[i]-b1); b2=min(b2,prices[i]-p1); p2=max(p2,prices[i]-b2); } return p2; }\nint main() { int p[]={3,3,5,0,0,3,1,4}; cout<<maxProfit(p,8); return 0; }",
        "explanation": {
            "approach": "Track two transactions with running min buy and max profit.",
            "steps": [
                "b1, p1 for first transaction",
                "b2, p2 for second using p1 as 'discount'"
            ],
            "complexity": "Time: O(n), Space: O(1)"
        },
        "testCases": [
            {
                "input": "[3,3,5,0,0,3,1,4]",
                "expectedOutput": "6",
                "explanation": "Buy at 0, sell at 3, buy at 1, sell at 4"
            },
            {
                "input": "[1,2,3,4,5]",
                "expectedOutput": "4",
                "explanation": "Single transaction 1->5"
            },
            {
                "input": "[7,6,4,3,1]",
                "expectedOutput": "0",
                "explanation": "Prices only decrease"
            },
            {
                "input": "[1,2,4,2,5,7,2,4,9,0]",
                "expectedOutput": "13",
                "explanation": "Two optimal transactions"
            }
        ]
    },
    {
        "id": "h138",
        "title": "Best Time to Buy and Sell Stock IV",
        "description": "Maximum profit with at most k transactions.",
        "difficulty": "HARD",
        "category": "DP",
        "starterCode": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maxProfit(int k, vector<int>& prices, int n) {\n    return 0;\n}\n\nint main() {\n    int k;\n    cin >> k;\n    int prices_size;\n    cin >> prices_size;\n    vector<int> prices(prices_size);\n    for (int i = 0; i < prices_size; i++) cin >> prices[i];\n    int n;\n    cin >> n;\n    cout << maxProfit(k, prices, n);\n    return 0;\n}\n",
        "expectedOutput": "2",
        "solution": "#include <iostream>\nusing namespace std;\nint maxProfit(int k, int prices[], int n) { if(n==0||k==0) return 0; if(k>=n/2) { int p=0; for(int i=1;i<n;i++) if(prices[i]>prices[i-1]) p+=prices[i]-prices[i-1]; return p; } int dp[k+1][n]; for(int i=0;i<=k;i++) dp[i][0]=0; for(int j=0;j<n;j++) dp[0][j]=0; for(int i=1;i<=k;i++) { int mx=-prices[0]; for(int j=1;j<n;j++) { dp[i][j]=max(dp[i][j-1],prices[j]+mx); mx=max(mx,dp[i-1][j-1]-prices[j]); } } return dp[k][n-1]; }\nint main() { int p[]={2,4,1}; cout<<maxProfit(2,p,3); return 0; }",
        "explanation": {
            "approach": "DP with state for number of transactions used.",
            "steps": [
                "dp[i][j] = max profit with i transactions up to day j",
                "Optimize with running max difference"
            ],
            "complexity": "Time: O(kn), Space: O(kn)"
        },
        "testCases": [
            {
                "input": "k=2, [2,4,1]",
                "expectedOutput": "2",
                "explanation": "Buy at 2, sell at 4"
            },
            {
                "input": "k=2, [3,2,6,5,0,3]",
                "expectedOutput": "7",
                "explanation": "2->6 and 0->3"
            },
            {
                "input": "k=1, [1,2,3]",
                "expectedOutput": "2",
                "explanation": "Single transaction 1->3"
            },
            {
                "input": "k=0, [1,2,3]",
                "expectedOutput": "0",
                "explanation": "No transactions allowed"
            }
        ]
    },
    {
        "id": "h139",
        "title": "Distinct Subsequences",
        "description": "Count distinct subsequences of s that equal t.",
        "difficulty": "HARD",
        "category": "DP",
        "starterCode": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint numDistinct(vector<int>& s, vector<int>& t) {\n    return 0;\n}\n\nint main() {\n    int s_size;\n    cin >> s_size;\n    vector<int> s(s_size);\n    for (int i = 0; i < s_size; i++) cin >> s[i];\n    int t_size;\n    cin >> t_size;\n    vector<int> t(t_size);\n    for (int i = 0; i < t_size; i++) cin >> t[i];\n    cout << numDistinct(s, t);\n    return 0;\n}\n",
        "expectedOutput": "3",
        "solution": "#include <iostream>\nusing namespace std;\nint numDistinct(char s[], char t[]) { int m=0,n=0; while(s[m]) m++; while(t[n]) n++; int dp[m+1][n+1]; for(int i=0;i<=m;i++) dp[i][0]=1; for(int j=1;j<=n;j++) dp[0][j]=0; for(int i=1;i<=m;i++) for(int j=1;j<=n;j++) dp[i][j]=dp[i-1][j]+(s[i-1]==t[j-1]?dp[i-1][j-1]:0); return dp[m][n]; }\nint main() { cout<<numDistinct(\"rabbbit\",\"rabbit\"); return 0; }",
        "explanation": {
            "approach": "DP counting subsequences matching target.",
            "steps": [
                "dp[i][j] = ways to form t[0..j-1] from s[0..i-1]",
                "Add dp[i-1][j-1] if chars match"
            ],
            "complexity": "Time: O(mn), Space: O(mn)"
        },
        "testCases": [
            {
                "input": "rabbbit, rabbit",
                "expectedOutput": "3",
                "explanation": "3 ways to select 'rabbit'"
            },
            {
                "input": "babgbag, bag",
                "expectedOutput": "5",
                "explanation": "5 distinct subsequences"
            },
            {
                "input": "a, a",
                "expectedOutput": "1",
                "explanation": "Single match"
            },
            {
                "input": "ab, b",
                "expectedOutput": "1",
                "explanation": "One way"
            }
        ]
    },
    {
        "id": "h140",
        "title": "Interleaving String",
        "description": "Check if s3 is formed by interleaving s1 and s2.",
        "difficulty": "HARD",
        "category": "DP",
        "starterCode": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nbool isInterleave(vector<int>& s1, vector<int>& s2, vector<int>& s3) {\n    return false;\n}\n\nint main() {\n    int s1_size;\n    cin >> s1_size;\n    vector<int> s1(s1_size);\n    for (int i = 0; i < s1_size; i++) cin >> s1[i];\n    int s2_size;\n    cin >> s2_size;\n    vector<int> s2(s2_size);\n    for (int i = 0; i < s2_size; i++) cin >> s2[i];\n    int s3_size;\n    cin >> s3_size;\n    vector<int> s3(s3_size);\n    for (int i = 0; i < s3_size; i++) cin >> s3[i];\n    cout << isInterleave(s1, s2, s3);\n    return 0;\n}\n",
        "expectedOutput": "1",
        "solution": "#include <iostream>\nusing namespace std;\nbool isInterleave(char s1[], char s2[], char s3[]) { int m=0,n=0,l=0; while(s1[m]) m++; while(s2[n]) n++; while(s3[l]) l++; if(m+n!=l) return false; bool dp[m+1][n+1]; dp[0][0]=true; for(int i=1;i<=m;i++) dp[i][0]=dp[i-1][0]&&s1[i-1]==s3[i-1]; for(int j=1;j<=n;j++) dp[0][j]=dp[0][j-1]&&s2[j-1]==s3[j-1]; for(int i=1;i<=m;i++) for(int j=1;j<=n;j++) dp[i][j]=(dp[i-1][j]&&s1[i-1]==s3[i+j-1])||(dp[i][j-1]&&s2[j-1]==s3[i+j-1]); return dp[m][n]; }\nint main() { cout<<isInterleave(\"aabcc\",\"dbbca\",\"aadbbcbcac\"); return 0; }",
        "explanation": {
            "approach": "DP for interleaving validation.",
            "steps": [
                "dp[i][j] = can s1[0..i) + s2[0..j) interleave to s3[0..i+j)",
                "Check if next char from s1 or s2 matches"
            ],
            "complexity": "Time: O(mn), Space: O(mn)"
        },
        "testCases": [
            {
                "input": "aabcc, dbbca, aadbbcbcac",
                "expectedOutput": "1",
                "explanation": "Valid interleaving"
            },
            {
                "input": "aabcc, dbbca, aadbbbaccc",
                "expectedOutput": "0",
                "explanation": "Invalid interleaving"
            },
            {
                "input": "a, b, ab",
                "expectedOutput": "1",
                "explanation": "Simple interleave"
            },
            {
                "input": "\"\", \"\", \"\"",
                "expectedOutput": "1",
                "explanation": "Empty strings"
            }
        ]
    },
    {
        "id": "h141",
        "title": "Largest Rectangle in Histogram",
        "description": "Find largest rectangle that can be formed in histogram.",
        "difficulty": "HARD",
        "category": "Stack",
        "starterCode": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint largestRectangleArea(vector<int>& heights, int n) {\n    return 0;\n}\n\nint main() {\n    int heights_size;\n    cin >> heights_size;\n    vector<int> heights(heights_size);\n    for (int i = 0; i < heights_size; i++) cin >> heights[i];\n    int n;\n    cin >> n;\n    cout << largestRectangleArea(heights, n);\n    return 0;\n}\n",
        "expectedOutput": "10",
        "solution": "#include <iostream>\nusing namespace std;\nint largestRectangleArea(int h[], int n) { int stk[n+1],top=-1,mx=0; for(int i=0;i<=n;i++) { int cur=i==n?0:h[i]; while(top>=0&&cur<h[stk[top]]) { int ht=h[stk[top--]]; int w=top<0?i:i-stk[top]-1; mx=max(mx,ht*w); } stk[++top]=i; } return mx; }\nint main() { int h[]={2,1,5,6,2,3}; cout<<largestRectangleArea(h,6); return 0; }",
        "explanation": {
            "approach": "Stack to find nearest smaller on both sides.",
            "steps": [
                "Maintain increasing stack",
                "Pop when smaller found",
                "Calculate area with popped bar as height"
            ],
            "complexity": "Time: O(n), Space: O(n)"
        },
        "testCases": [
            {
                "input": "[2,1,5,6,2,3]",
                "expectedOutput": "10",
                "explanation": "5x2 rectangle"
            },
            {
                "input": "[2,4]",
                "expectedOutput": "4",
                "explanation": "Either 2x2 or 1x4"
            },
            {
                "input": "[1]",
                "expectedOutput": "1",
                "explanation": "Single bar"
            },
            {
                "input": "[3,3,3,3]",
                "expectedOutput": "12",
                "explanation": "3x4 rectangle"
            }
        ]
    },
    {
        "id": "h142",
        "title": "Maximal Rectangle",
        "description": "Find largest rectangle containing only 1s in binary matrix.",
        "difficulty": "HARD",
        "category": "Stack",
        "starterCode": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint maximalRectangle(vector<vector<int>>& m, int r, int c) {\n    return 0;\n}\n\nint main() {\n    int m_rows, m_cols;\n    cin >> m_rows >> m_cols;\n    vector<vector<int>> m(m_rows, vector<int>(m_cols));\n    for (int i = 0; i < m_rows; i++)\n        for (int j = 0; j < m_cols; j++)\n            cin >> m[i][j];\n    int r;\n    cin >> r;\n    int c;\n    cin >> c;\n    cout << maximalRectangle(m, r, c);\n    return 0;\n}\n",
        "expectedOutput": "6",
        "solution": "#include <iostream>\nusing namespace std;\nint largestRect(int h[], int n) { int stk[n+1],top=-1,mx=0; for(int i=0;i<=n;i++) { int cur=i==n?0:h[i]; while(top>=0&&cur<h[stk[top]]) { int ht=h[stk[top--]]; int w=top<0?i:i-stk[top]-1; mx=max(mx,ht*w); } stk[++top]=i; } return mx; }\nint maximalRectangle(char m[][5], int r, int c) { int h[c]={}; int mx=0; for(int i=0;i<r;i++) { for(int j=0;j<c;j++) h[j]=m[i][j]=='1'?h[j]+1:0; mx=max(mx,largestRect(h,c)); } return mx; }\nint main() { char m[][5]={{\"10100\"},{\"10111\"},{\"11111\"},{\"10010\"}}; cout<<maximalRectangle(m,4,5); return 0; }",
        "explanation": {
            "approach": "Convert each row to histogram, apply largest rectangle.",
            "steps": [
                "Build cumulative heights row by row",
                "Apply histogram algorithm per row"
            ],
            "complexity": "Time: O(mn), Space: O(n)"
        },
        "testCases": [
            {
                "input": "4x5 binary matrix",
                "expectedOutput": "6",
                "explanation": "3x2 rectangle of 1s"
            },
            {
                "input": "[[1]]",
                "expectedOutput": "1",
                "explanation": "Single cell"
            },
            {
                "input": "[[1,1],[1,1]]",
                "expectedOutput": "4",
                "explanation": "2x2 square"
            },
            {
                "input": "[[0,0],[0,0]]",
                "expectedOutput": "0",
                "explanation": "No 1s"
            }
        ]
    },
    {
        "id": "h143",
        "title": "Trapping Rain Water",
        "description": "Calculate water trapped between elevation bars.",
        "difficulty": "HARD",
        "category": "Stack",
        "starterCode": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint trap(vector<int>& h, int n) {\n    return 0;\n}\n\nint main() {\n    int h_size;\n    cin >> h_size;\n    vector<int> h(h_size);\n    for (int i = 0; i < h_size; i++) cin >> h[i];\n    int n;\n    cin >> n;\n    cout << trap(h, n);\n    return 0;\n}\n",
        "expectedOutput": "6",
        "solution": "#include <iostream>\nusing namespace std;\nint trap(int h[], int n) { int l=0,r=n-1,lm=0,rm=0,w=0; while(l<r) { if(h[l]<h[r]) { if(h[l]>=lm) lm=h[l]; else w+=lm-h[l]; l++; } else { if(h[r]>=rm) rm=h[r]; else w+=rm-h[r]; r--; } } return w; }\nint main() { int h[]={0,1,0,2,1,0,1,3,2,1,2,1}; cout<<trap(h,12); return 0; }",
        "explanation": {
            "approach": "Two pointers tracking max heights from each side.",
            "steps": [
                "Track leftMax and rightMax",
                "Process shorter side",
                "Add water = max - current height"
            ],
            "complexity": "Time: O(n), Space: O(1)"
        },
        "testCases": [
            {
                "input": "[0,1,0,2,1,0,1,3,2,1,2,1]",
                "expectedOutput": "6",
                "explanation": "Water in valleys"
            },
            {
                "input": "[4,2,0,3,2,5]",
                "expectedOutput": "9",
                "explanation": "Larger opening"
            },
            {
                "input": "[1,2,3,4,5]",
                "expectedOutput": "0",
                "explanation": "Ascending, no trap"
            },
            {
                "input": "[5,4,3,2,1]",
                "expectedOutput": "0",
                "explanation": "Descending, no trap"
            }
        ]
    }
]