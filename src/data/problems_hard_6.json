[
    {
        "id": "h136",
        "title": "Island Perimeter",
        "description": "Calculate island perimeter.",
        "difficulty": "EASY",
        "category": "Matrix",
        "starterCode": "#include <iostream>\nusing namespace std;\nint islandPerimeter(int grid[][4], int r, int c) { return 0; }\nint main() { int g[][4]={{0,1,0,0},{1,1,1,0},{0,1,0,0},{1,1,0,0}}; cout<<islandPerimeter(g,4,4); return 0; }",
        "expectedOutput": "16",
        "solution": "#include <iostream>\nusing namespace std;\nint islandPerimeter(int grid[][4], int r, int c) { int p=0; for(int i=0;i<r;i++) for(int j=0;j<c;j++) if(grid[i][j]) { p+=4; if(i>0&&grid[i-1][j]) p-=2; if(j>0&&grid[i][j-1]) p-=2; } return p; }\nint main() { int g[][4]={{0,1,0,0},{1,1,1,0},{0,1,0,0},{1,1,0,0}}; cout<<islandPerimeter(g,4,4); return 0; }",
        "explanation": {
            "approach": "Count edges minus shared.",
            "steps": [
                "Each land adds 4 edges",
                "Subtract 2 for each adjacent land"
            ],
            "complexity": "Time: O(mn), Space: O(1)"
        }
    },
    {
        "id": "h137",
        "title": "Best Time Buy Sell III",
        "description": "Max profit with 2 transactions.",
        "difficulty": "HARD",
        "category": "DP",
        "starterCode": "#include <iostream>\nusing namespace std;\nint maxProfit(int prices[], int n) { return 0; }\nint main() { int p[]={3,3,5,0,0,3,1,4}; cout<<maxProfit(p,8); return 0; }",
        "expectedOutput": "6",
        "solution": "#include <iostream>\nusing namespace std;\nint maxProfit(int prices[], int n) { int b1=1e9,b2=1e9,p1=0,p2=0; for(int i=0;i<n;i++) { b1=min(b1,prices[i]); p1=max(p1,prices[i]-b1); b2=min(b2,prices[i]-p1); p2=max(p2,prices[i]-b2); } return p2; }\nint main() { int p[]={3,3,5,0,0,3,1,4}; cout<<maxProfit(p,8); return 0; }",
        "explanation": {
            "approach": "Track two transactions.",
            "steps": [
                "b1, p1 for first transaction",
                "b2, p2 for second using p1"
            ],
            "complexity": "Time: O(n), Space: O(1)"
        }
    },
    {
        "id": "h138",
        "title": "Best Time Buy Sell IV",
        "description": "Max profit with k transactions.",
        "difficulty": "HARD",
        "category": "DP",
        "starterCode": "#include <iostream>\nusing namespace std;\nint maxProfit(int k, int prices[], int n) { return 0; }\nint main() { int p[]={2,4,1}; cout<<maxProfit(2,p,3); return 0; }",
        "expectedOutput": "2",
        "solution": "#include <iostream>\nusing namespace std;\nint maxProfit(int k, int prices[], int n) { if(n==0||k==0) return 0; if(k>=n/2) { int p=0; for(int i=1;i<n;i++) if(prices[i]>prices[i-1]) p+=prices[i]-prices[i-1]; return p; } int dp[k+1][n]; for(int i=0;i<=k;i++) dp[i][0]=0; for(int j=0;j<n;j++) dp[0][j]=0; for(int i=1;i<=k;i++) { int mx=-prices[0]; for(int j=1;j<n;j++) { dp[i][j]=max(dp[i][j-1],prices[j]+mx); mx=max(mx,dp[i-1][j-1]-prices[j]); } } return dp[k][n-1]; }\nint main() { int p[]={2,4,1}; cout<<maxProfit(2,p,3); return 0; }",
        "explanation": {
            "approach": "DP with k transactions.",
            "steps": [
                "dp[i][j] = max profit with i transactions up to day j",
                "Optimize with running max"
            ],
            "complexity": "Time: O(kn), Space: O(kn)"
        }
    },
    {
        "id": "h139",
        "title": "Distinct Subsequences",
        "description": "Count subsequences matching t.",
        "difficulty": "HARD",
        "category": "DP",
        "starterCode": "#include <iostream>\nusing namespace std;\nint numDistinct(char s[], char t[]) { return 0; }\nint main() { cout<<numDistinct(\"rabbbit\",\"rabbit\"); return 0; }",
        "expectedOutput": "3",
        "solution": "#include <iostream>\nusing namespace std;\nint numDistinct(char s[], char t[]) { int m=0,n=0; while(s[m]) m++; while(t[n]) n++; int dp[m+1][n+1]; for(int i=0;i<=m;i++) dp[i][0]=1; for(int j=1;j<=n;j++) dp[0][j]=0; for(int i=1;i<=m;i++) for(int j=1;j<=n;j++) dp[i][j]=dp[i-1][j]+(s[i-1]==t[j-1]?dp[i-1][j-1]:0); return dp[m][n]; }\nint main() { cout<<numDistinct(\"rabbbit\",\"rabbit\"); return 0; }",
        "explanation": {
            "approach": "DP counting subsequences.",
            "steps": [
                "dp[i][j] = ways to form t[0..j] from s[0..i]",
                "Add dp[i-1][j-1] if chars match"
            ],
            "complexity": "Time: O(mn), Space: O(mn)"
        }
    },
    {
        "id": "h140",
        "title": "Interleaving String",
        "description": "Can s3 be formed by interleaving s1 and s2.",
        "difficulty": "HARD",
        "category": "DP",
        "starterCode": "#include <iostream>\nusing namespace std;\nbool isInterleave(char s1[], char s2[], char s3[]) { return false; }\nint main() { cout<<isInterleave(\"aabcc\",\"dbbca\",\"aadbbcbcac\"); return 0; }",
        "expectedOutput": "1",
        "solution": "#include <iostream>\nusing namespace std;\nbool isInterleave(char s1[], char s2[], char s3[]) { int m=0,n=0,l=0; while(s1[m]) m++; while(s2[n]) n++; while(s3[l]) l++; if(m+n!=l) return false; bool dp[m+1][n+1]; dp[0][0]=true; for(int i=1;i<=m;i++) dp[i][0]=dp[i-1][0]&&s1[i-1]==s3[i-1]; for(int j=1;j<=n;j++) dp[0][j]=dp[0][j-1]&&s2[j-1]==s3[j-1]; for(int i=1;i<=m;i++) for(int j=1;j<=n;j++) dp[i][j]=(dp[i-1][j]&&s1[i-1]==s3[i+j-1])||(dp[i][j-1]&&s2[j-1]==s3[i+j-1]); return dp[m][n]; }\nint main() { cout<<isInterleave(\"aabcc\",\"dbbca\",\"aadbbcbcac\"); return 0; }",
        "explanation": {
            "approach": "DP for interleaving.",
            "steps": [
                "dp[i][j] = s1[0..i] and s2[0..j] can form s3[0..i+j]",
                "Check if next char matches s1 or s2"
            ],
            "complexity": "Time: O(mn), Space: O(mn)"
        }
    },
    {
        "id": "h141",
        "title": "Largest Rectangle Histogram",
        "description": "Max rectangle area.",
        "difficulty": "HARD",
        "category": "Stack",
        "starterCode": "#include <iostream>\nusing namespace std;\nint largestRectangleArea(int heights[], int n) { return 0; }\nint main() { int h[]={2,1,5,6,2,3}; cout<<largestRectangleArea(h,6); return 0; }",
        "expectedOutput": "10",
        "solution": "#include <iostream>\nusing namespace std;\nint largestRectangleArea(int h[], int n) { int stk[n+1],top=-1,mx=0; for(int i=0;i<=n;i++) { int cur=i==n?0:h[i]; while(top>=0&&cur<h[stk[top]]) { int ht=h[stk[top--]]; int w=top<0?i:i-stk[top]-1; mx=max(mx,ht*w); } stk[++top]=i; } return mx; }\nint main() { int h[]={2,1,5,6,2,3}; cout<<largestRectangleArea(h,6); return 0; }",
        "explanation": {
            "approach": "Stack for nearest smaller.",
            "steps": [
                "Stack stores increasing indices",
                "Pop when smaller found",
                "Calculate area with popped as height"
            ],
            "complexity": "Time: O(n), Space: O(n)"
        }
    },
    {
        "id": "h142",
        "title": "Maximal Rectangle",
        "description": "Max rectangle of 1s in matrix.",
        "difficulty": "HARD",
        "category": "Stack",
        "starterCode": "#include <iostream>\nusing namespace std;\nint maximalRectangle(char m[][5], int r, int c) { return 0; }\nint main() { char m[][5]={{\"10100\"},{\"10111\"},{\"11111\"},{\"10010\"}}; cout<<maximalRectangle(m,4,5); return 0; }",
        "expectedOutput": "6",
        "solution": "#include <iostream>\nusing namespace std;\nint largestRect(int h[], int n) { int stk[n+1],top=-1,mx=0; for(int i=0;i<=n;i++) { int cur=i==n?0:h[i]; while(top>=0&&cur<h[stk[top]]) { int ht=h[stk[top--]]; int w=top<0?i:i-stk[top]-1; mx=max(mx,ht*w); } stk[++top]=i; } return mx; }\nint maximalRectangle(char m[][5], int r, int c) { int h[c]={}; int mx=0; for(int i=0;i<r;i++) { for(int j=0;j<c;j++) h[j]=m[i][j]=='1'?h[j]+1:0; mx=max(mx,largestRect(h,c)); } return mx; }\nint main() { char m[][5]={{\"10100\"},{\"10111\"},{\"11111\"},{\"10010\"}}; cout<<maximalRectangle(m,4,5); return 0; }",
        "explanation": {
            "approach": "Reduce to histogram problem.",
            "steps": [
                "Build histogram heights row by row",
                "Apply largest rectangle in histogram"
            ],
            "complexity": "Time: O(mn), Space: O(n)"
        }
    },
    {
        "id": "h143",
        "title": "Trapping Rain Water",
        "description": "Water trapped between bars.",
        "difficulty": "HARD",
        "category": "Stack",
        "starterCode": "#include <iostream>\nusing namespace std;\nint trap(int h[], int n) { return 0; }\nint main() { int h[]={0,1,0,2,1,0,1,3,2,1,2,1}; cout<<trap(h,12); return 0; }",
        "expectedOutput": "6",
        "solution": "#include <iostream>\nusing namespace std;\nint trap(int h[], int n) { int l=0,r=n-1,lm=0,rm=0,w=0; while(l<r) { if(h[l]<h[r]) { if(h[l]>=lm) lm=h[l]; else w+=lm-h[l]; l++; } else { if(h[r]>=rm) rm=h[r]; else w+=rm-h[r]; r--; } } return w; }\nint main() { int h[]={0,1,0,2,1,0,1,3,2,1,2,1}; cout<<trap(h,12); return 0; }",
        "explanation": {
            "approach": "Two pointers with max tracking.",
            "steps": [
                "Track left and right max",
                "Move smaller side",
                "Add water = max - current"
            ],
            "complexity": "Time: O(n), Space: O(1)"
        }
    }
]