[
    {
        "id": "ds1",
        "title": "Stack using Array",
        "description": "Implement stack operations.",
        "difficulty": "EASY",
        "category": "Data Structures",
        "starterCode": "#include <iostream>\nusing namespace std;\nclass Stack { int a[100], t; public: Stack():t(-1){} void push(int x){} int pop(){return -1;} int top(){return -1;} bool empty(){return true;} };\nint main() { Stack s; s.push(1); s.push(2); cout<<s.top()<<\" \"; s.pop(); cout<<s.top(); return 0; }",
        "expectedOutput": "2 1",
        "solution": "#include <iostream>\nusing namespace std;\nclass Stack { int a[100], t; public: Stack():t(-1){} void push(int x){a[++t]=x;} int pop(){return a[t--];} int top(){return a[t];} bool empty(){return t==-1;} };\nint main() { Stack s; s.push(1); s.push(2); cout<<s.top()<<\" \"; s.pop(); cout<<s.top(); return 0; }",
        "explanation": {
            "approach": "Array with top pointer.",
            "analogy": "Stack of plates - add/remove from top.",
            "steps": [
                "push: increment top, store",
                "pop: return and decrement top"
            ],
            "complexity": "Time: O(1) all ops, Space: O(n)"
        }
    },
    {
        "id": "ds2",
        "title": "Queue using Array",
        "description": "Implement queue operations.",
        "difficulty": "EASY",
        "category": "Data Structures",
        "starterCode": "#include <iostream>\nusing namespace std;\nclass Queue { int a[100], f, r; public: Queue():f(0),r(-1){} void enqueue(int x){} int dequeue(){return -1;} int front(){return -1;} bool empty(){return true;} };\nint main() { Queue q; q.enqueue(1); q.enqueue(2); cout<<q.front()<<\" \"; q.dequeue(); cout<<q.front(); return 0; }",
        "expectedOutput": "1 2",
        "solution": "#include <iostream>\nusing namespace std;\nclass Queue { int a[100], f, r; public: Queue():f(0),r(-1){} void enqueue(int x){a[++r]=x;} int dequeue(){return a[f++];} int front(){return a[f];} bool empty(){return f>r;} };\nint main() { Queue q; q.enqueue(1); q.enqueue(2); cout<<q.front()<<\" \"; q.dequeue(); cout<<q.front(); return 0; }",
        "explanation": {
            "approach": "Array with front and rear pointers.",
            "analogy": "Line at a store - join at back, leave from front.",
            "steps": [
                "enqueue: add at rear",
                "dequeue: remove from front"
            ],
            "complexity": "Time: O(1) all ops, Space: O(n)"
        }
    },
    {
        "id": "ds3",
        "title": "Linked List Insert",
        "description": "Insert at end of list.",
        "difficulty": "EASY",
        "category": "Data Structures",
        "starterCode": "#include <iostream>\nusing namespace std;\nstruct Node { int val; Node* next; Node(int x):val(x),next(0){} };\nNode* insert(Node* head, int x) { return nullptr; }\nint main() { Node* h=nullptr; h=insert(h,1); h=insert(h,2); h=insert(h,3); Node* t=h; while(t) { cout<<t->val<<\" \"; t=t->next; } return 0; }",
        "expectedOutput": "1 2 3",
        "solution": "#include <iostream>\nusing namespace std;\nstruct Node { int val; Node* next; Node(int x):val(x),next(0){} };\nNode* insert(Node* head, int x) { Node* n=new Node(x); if(!head) return n; Node* t=head; while(t->next) t=t->next; t->next=n; return head; }\nint main() { Node* h=nullptr; h=insert(h,1); h=insert(h,2); h=insert(h,3); Node* t=h; while(t) { cout<<t->val<<\" \"; t=t->next; } return 0; }",
        "explanation": {
            "approach": "Traverse to end, link new node.",
            "analogy": "Add to end of chain.",
            "steps": [
                "Create new node",
                "Find last node",
                "Link new node"
            ],
            "complexity": "Time: O(n), Space: O(1)"
        }
    },
    {
        "id": "ds4",
        "title": "Linked List Delete",
        "description": "Delete node with value.",
        "difficulty": "EASY",
        "category": "Data Structures",
        "starterCode": "#include <iostream>\nusing namespace std;\nstruct Node { int val; Node* next; Node(int x):val(x),next(0){} };\nNode* deleteNode(Node* head, int x) { return nullptr; }\nint main() { Node* h=new Node(1); h->next=new Node(2); h->next->next=new Node(3); h=deleteNode(h,2); Node* t=h; while(t) { cout<<t->val<<\" \"; t=t->next; } return 0; }",
        "expectedOutput": "1 3",
        "solution": "#include <iostream>\nusing namespace std;\nstruct Node { int val; Node* next; Node(int x):val(x),next(0){} };\nNode* deleteNode(Node* head, int x) { if(!head) return nullptr; if(head->val==x) return head->next; Node* t=head; while(t->next && t->next->val!=x) t=t->next; if(t->next) t->next=t->next->next; return head; }\nint main() { Node* h=new Node(1); h->next=new Node(2); h->next->next=new Node(3); h=deleteNode(h,2); Node* t=h; while(t) { cout<<t->val<<\" \"; t=t->next; } return 0; }",
        "explanation": {
            "approach": "Find node before target, skip over.",
            "analogy": "Remove link from chain.",
            "steps": [
                "Find predecessor",
                "Skip target node"
            ],
            "complexity": "Time: O(n), Space: O(1)"
        }
    },
    {
        "id": "ds5",
        "title": "Reverse Linked List",
        "description": "Reverse list in-place.",
        "difficulty": "EASY",
        "category": "Data Structures",
        "starterCode": "#include <iostream>\nusing namespace std;\nstruct Node { int val; Node* next; Node(int x):val(x),next(0){} };\nNode* reverse(Node* head) { return nullptr; }\nint main() { Node* h=new Node(1); h->next=new Node(2); h->next->next=new Node(3); h=reverse(h); Node* t=h; while(t) { cout<<t->val<<\" \"; t=t->next; } return 0; }",
        "expectedOutput": "3 2 1",
        "solution": "#include <iostream>\nusing namespace std;\nstruct Node { int val; Node* next; Node(int x):val(x),next(0){} };\nNode* reverse(Node* head) { Node* prev=nullptr, *cur=head; while(cur) { Node* next=cur->next; cur->next=prev; prev=cur; cur=next; } return prev; }\nint main() { Node* h=new Node(1); h->next=new Node(2); h->next->next=new Node(3); h=reverse(h); Node* t=h; while(t) { cout<<t->val<<\" \"; t=t->next; } return 0; }",
        "explanation": {
            "approach": "Reverse pointers one by one.",
            "analogy": "Turn each arrow backwards.",
            "steps": [
                "Track previous",
                "Reverse current's next",
                "Move forward"
            ],
            "complexity": "Time: O(n), Space: O(1)"
        }
    },
    {
        "id": "ds6",
        "title": "Detect Cycle in List",
        "description": "Check for cycle.",
        "difficulty": "MEDIUM",
        "category": "Data Structures",
        "starterCode": "#include <iostream>\nusing namespace std;\nstruct Node { int val; Node* next; Node(int x):val(x),next(0){} };\nbool hasCycle(Node* head) { return false; }\nint main() { Node* h=new Node(1); h->next=new Node(2); h->next->next=new Node(3); h->next->next->next=h->next; cout<<hasCycle(h); return 0; }",
        "expectedOutput": "1",
        "solution": "#include <iostream>\nusing namespace std;\nstruct Node { int val; Node* next; Node(int x):val(x),next(0){} };\nbool hasCycle(Node* head) { Node* s=head, *f=head; while(f && f->next) { s=s->next; f=f->next->next; if(s==f) return true; } return false; }\nint main() { Node* h=new Node(1); h->next=new Node(2); h->next->next=new Node(3); h->next->next->next=h->next; cout<<hasCycle(h); return 0; }",
        "explanation": {
            "approach": "Floyd's cycle detection - slow and fast pointers.",
            "analogy": "If runners on track, they'll meet if there's a loop.",
            "steps": [
                "Slow moves 1 step",
                "Fast moves 2 steps",
                "If they meet, cycle exists"
            ],
            "complexity": "Time: O(n), Space: O(1)"
        }
    },
    {
        "id": "ds7",
        "title": "Valid Parentheses",
        "description": "Check balanced brackets.",
        "difficulty": "EASY",
        "category": "Data Structures",
        "starterCode": "#include <iostream>\nusing namespace std;\nbool isValid(char s[]) { return false; }\nint main() { cout<<isValid(\"([{}])\"); return 0; }",
        "expectedOutput": "1",
        "solution": "#include <iostream>\nusing namespace std;\nbool isValid(char s[]) { char stk[100]; int t=-1; for(int i=0;s[i];i++) { if(s[i]=='('||s[i]=='['||s[i]=='{') stk[++t]=s[i]; else { if(t<0) return false; if(s[i]==')' && stk[t]!='(') return false; if(s[i]==']' && stk[t]!='[') return false; if(s[i]=='}' && stk[t]!='{') return false; t--; } } return t==-1; }\nint main() { cout<<isValid(\"([{}])\"); return 0; }",
        "explanation": {
            "approach": "Stack to match brackets.",
            "analogy": "Each opener waits for its closer.",
            "steps": [
                "Push opening brackets",
                "Pop and match closing",
                "Stack should be empty at end"
            ],
            "complexity": "Time: O(n), Space: O(n)"
        }
    },
    {
        "id": "ds8",
        "title": "Min Stack",
        "description": "Stack with getMin in O(1).",
        "difficulty": "MEDIUM",
        "category": "Data Structures",
        "starterCode": "#include <iostream>\nusing namespace std;\nclass MinStack { public: void push(int x){} void pop(){} int top(){return 0;} int getMin(){return 0;} };\nint main() { MinStack s; s.push(5); s.push(2); s.push(3); cout<<s.getMin(); return 0; }",
        "expectedOutput": "2",
        "solution": "#include <iostream>\nusing namespace std;\nclass MinStack { int a[100], m[100], t; public: MinStack():t(-1){} void push(int x){a[++t]=x; m[t]=t==0?x:min(x,m[t-1]);} void pop(){t--;} int top(){return a[t];} int getMin(){return m[t];} };\nint main() { MinStack s; s.push(5); s.push(2); s.push(3); cout<<s.getMin(); return 0; }",
        "explanation": {
            "approach": "Auxiliary stack tracking min at each level.",
            "analogy": "Remember minimum as you build up.",
            "steps": [
                "Track min at each push",
                "Pop updates automatically"
            ],
            "complexity": "Time: O(1) all ops, Space: O(n)"
        }
    },
    {
        "id": "ds9",
        "title": "Implement Queue using Stacks",
        "description": "Queue with two stacks.",
        "difficulty": "MEDIUM",
        "category": "Data Structures",
        "starterCode": "#include <iostream>\nusing namespace std;\nclass MyQueue { int s1[100], s2[100], t1, t2; public: MyQueue():t1(-1),t2(-1){} void push(int x){} int pop(){return 0;} };\nint main() { MyQueue q; q.push(1); q.push(2); cout<<q.pop()<<\" \"<<q.pop(); return 0; }",
        "expectedOutput": "1 2",
        "solution": "#include <iostream>\nusing namespace std;\nclass MyQueue { int s1[100], s2[100], t1, t2; public: MyQueue():t1(-1),t2(-1){} void push(int x){s1[++t1]=x;} int pop(){ if(t2<0) while(t1>=0) s2[++t2]=s1[t1--]; return s2[t2--]; } };\nint main() { MyQueue q; q.push(1); q.push(2); cout<<q.pop()<<\" \"<<q.pop(); return 0; }",
        "explanation": {
            "approach": "Push to s1, pop from s2 (transfer when empty).",
            "analogy": "Two stacks simulate queue via reversal.",
            "steps": [
                "Push always to s1",
                "Pop from s2, refill from s1 if empty"
            ],
            "complexity": "Time: O(1) amortized, Space: O(n)"
        }
    },
    {
        "id": "ds10",
        "title": "Implement Stack using Queues",
        "description": "Stack with two queues.",
        "difficulty": "MEDIUM",
        "category": "Data Structures",
        "starterCode": "#include <iostream>\nusing namespace std;\n#include <queue>\nclass MyStack { queue<int> q; public: void push(int x){} int pop(){return 0;} };\nint main() { MyStack s; s.push(1); s.push(2); cout<<s.pop()<<\" \"<<s.pop(); return 0; }",
        "expectedOutput": "2 1",
        "solution": "#include <iostream>\nusing namespace std;\n#include <queue>\nclass MyStack { queue<int> q; public: void push(int x){ q.push(x); for(int i=0;i<q.size()-1;i++){q.push(q.front());q.pop();} } int pop(){ int t=q.front(); q.pop(); return t; } };\nint main() { MyStack s; s.push(1); s.push(2); cout<<s.pop()<<\" \"<<s.pop(); return 0; }",
        "explanation": {
            "approach": "After push, rotate to put new at front.",
            "analogy": "Reorganize queue so last is first.",
            "steps": [
                "Push to queue",
                "Rotate n-1 elements to back"
            ],
            "complexity": "Time: O(n) push, O(1) pop, Space: O(n)"
        }
    }
]