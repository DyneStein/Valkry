[
    {
        "id": "med1",
        "title": "Two Sum Sorted",
        "description": "Two pointers for sorted array.",
        "difficulty": "MEDIUM",
        "category": "Two Pointers",
        "starterCode": "#include <iostream>\nusing namespace std;\nvoid twoSum(int a[], int n, int t) {}\nint main() { int a[]={2,7,11,15}; twoSum(a,4,9); return 0; }",
        "expectedOutput": "0 1",
        "solution": "#include <iostream>\nusing namespace std;\nvoid twoSum(int a[], int n, int t) { int l=0, r=n-1; while(l<r) { int s=a[l]+a[r]; if(s==t) { cout<<l<<\" \"<<r; return; } if(s<t) l++; else r--; } }\nint main() { int a[]={2,7,11,15}; twoSum(a,4,9); return 0; }",
        "explanation": {
            "approach": "Two pointers from both ends, adjust based on sum.",
            "analogy": "Squeeze from both ends until you find the target.",
            "steps": [
                "If sum < target, move left pointer right",
                "If sum > target, move right pointer left"
            ],
            "complexity": "Time: O(n), Space: O(1)"
        }
    },
    {
        "id": "med2",
        "title": "Container With Most Water",
        "description": "Max area between lines.",
        "difficulty": "MEDIUM",
        "category": "Two Pointers",
        "starterCode": "#include <iostream>\nusing namespace std;\nint maxArea(int h[], int n) { return 0; }\nint main() { int h[]={1,8,6,2,5,4,8,3,7}; cout<<maxArea(h,9); return 0; }",
        "expectedOutput": "49",
        "solution": "#include <iostream>\nusing namespace std;\nint maxArea(int h[], int n) { int l=0, r=n-1, mx=0; while(l<r) { int area=(r-l)*min(h[l],h[r]); mx=max(mx,area); if(h[l]<h[r]) l++; else r--; } return mx; }\nint main() { int h[]={1,8,6,2,5,4,8,3,7}; cout<<maxArea(h,9); return 0; }",
        "explanation": {
            "approach": "Two pointers, move shorter line inward.",
            "analogy": "The shorter wall limits water height.",
            "steps": [
                "Calculate area",
                "Move the shorter side inward"
            ],
            "complexity": "Time: O(n), Space: O(1)"
        }
    },
    {
        "id": "med3",
        "title": "Three Sum",
        "description": "Find triplets summing to target.",
        "difficulty": "MEDIUM",
        "category": "Two Pointers",
        "starterCode": "#include <iostream>\nusing namespace std;\nvoid threeSum(int a[], int n, int t) {}\nint main() { int a[]={-1,0,1,2,-1,-4}; threeSum(a,6,0); return 0; }",
        "expectedOutput": "-1 -1 2 -1 0 1",
        "solution": "#include <iostream>\nusing namespace std;\nvoid threeSum(int a[], int n, int t) { for(int i=0;i<n-2;i++) for(int j=i+1;j<n-1;j++) for(int k=j+1;k<n;k++) if(a[i]+a[j]+a[k]==t) cout<<a[i]<<\" \"<<a[j]<<\" \"<<a[k]<<\" \"; }\nint main() { int a[]={-1,0,1,2,-1,-4}; threeSum(a,6,0); return 0; }",
        "explanation": {
            "approach": "Fix one element, use two sum on rest.",
            "analogy": "Pick one, find pair in rest.",
            "steps": [
                "For each element, find two sum in remaining"
            ],
            "complexity": "Time: O(n³) brute, O(n²) optimized, Space: O(1)"
        }
    },
    {
        "id": "med4",
        "title": "Merge Sorted Arrays",
        "description": "Merge two sorted arrays.",
        "difficulty": "MEDIUM",
        "category": "Arrays",
        "starterCode": "#include <iostream>\nusing namespace std;\nvoid merge(int a[], int m, int b[], int n, int c[]) {}\nint main() { int a[]={1,3,5}, b[]={2,4,6}, c[6]; merge(a,3,b,3,c); for(int i=0;i<6;i++) cout<<c[i]<<(i<5?\" \":\"\"); return 0; }",
        "expectedOutput": "1 2 3 4 5 6",
        "solution": "#include <iostream>\nusing namespace std;\nvoid merge(int a[], int m, int b[], int n, int c[]) { int i=0,j=0,k=0; while(i<m && j<n) c[k++]= a[i]<b[j] ? a[i++] : b[j++]; while(i<m) c[k++]=a[i++]; while(j<n) c[k++]=b[j++]; }\nint main() { int a[]={1,3,5}, b[]={2,4,6}, c[6]; merge(a,3,b,3,c); for(int i=0;i<6;i++) cout<<c[i]<<(i<5?\" \":\"\"); return 0; }",
        "explanation": {
            "approach": "Two pointers, pick smaller each time.",
            "analogy": "Merge two sorted decks of cards.",
            "steps": [
                "Compare front of both",
                "Take smaller",
                "Repeat"
            ],
            "complexity": "Time: O(m+n), Space: O(m+n)"
        }
    },
    {
        "id": "med5",
        "title": "Quick Sort",
        "description": "Divide and conquer sort.",
        "difficulty": "MEDIUM",
        "category": "Sorting",
        "starterCode": "#include <iostream>\nusing namespace std;\nvoid quickSort(int a[], int l, int r) {}\nint main() { int a[]={10,7,8,9,1,5}; quickSort(a,0,5); for(int i=0;i<6;i++) cout<<a[i]<<(i<5?\" \":\"\"); return 0; }",
        "expectedOutput": "1 5 7 8 9 10",
        "solution": "#include <iostream>\nusing namespace std;\nint partition(int a[], int l, int r) { int p=a[r], i=l-1; for(int j=l;j<r;j++) if(a[j]<p) { i++; swap(a[i],a[j]); } swap(a[i+1],a[r]); return i+1; }\nvoid quickSort(int a[], int l, int r) { if(l<r) { int p=partition(a,l,r); quickSort(a,l,p-1); quickSort(a,p+1,r); } }\nint main() { int a[]={10,7,8,9,1,5}; quickSort(a,0,5); for(int i=0;i<6;i++) cout<<a[i]<<(i<5?\" \":\"\"); return 0; }",
        "explanation": {
            "approach": "Pick pivot, partition, recurse on halves.",
            "analogy": "Put smaller on left, larger on right, repeat.",
            "steps": [
                "Choose pivot",
                "Partition around it",
                "Recurse"
            ],
            "complexity": "Time: O(n log n) avg, Space: O(log n)"
        }
    },
    {
        "id": "med6",
        "title": "Merge Sort",
        "description": "Divide merge sort.",
        "difficulty": "MEDIUM",
        "category": "Sorting",
        "starterCode": "#include <iostream>\nusing namespace std;\nvoid mergeSort(int a[], int l, int r) {}\nint main() { int a[]={12,11,13,5,6,7}; mergeSort(a,0,5); for(int i=0;i<6;i++) cout<<a[i]<<(i<5?\" \":\"\"); return 0; }",
        "expectedOutput": "5 6 7 11 12 13",
        "solution": "#include <iostream>\nusing namespace std;\nvoid merge(int a[], int l, int m, int r) { int n1=m-l+1, n2=r-m; int L[n1], R[n2]; for(int i=0;i<n1;i++) L[i]=a[l+i]; for(int i=0;i<n2;i++) R[i]=a[m+1+i]; int i=0,j=0,k=l; while(i<n1 && j<n2) a[k++]= L[i]<=R[j] ? L[i++] : R[j++]; while(i<n1) a[k++]=L[i++]; while(j<n2) a[k++]=R[j++]; }\nvoid mergeSort(int a[], int l, int r) { if(l<r) { int m=(l+r)/2; mergeSort(a,l,m); mergeSort(a,m+1,r); merge(a,l,m,r); } }\nint main() { int a[]={12,11,13,5,6,7}; mergeSort(a,0,5); for(int i=0;i<6;i++) cout<<a[i]<<(i<5?\" \":\"\"); return 0; }",
        "explanation": {
            "approach": "Split in half, sort each, merge.",
            "analogy": "Divide army, organize each half, combine.",
            "steps": [
                "Split in middle",
                "Recursively sort",
                "Merge sorted halves"
            ],
            "complexity": "Time: O(n log n), Space: O(n)"
        }
    },
    {
        "id": "med7",
        "title": "Kadane's Algorithm",
        "description": "Maximum subarray sum.",
        "difficulty": "MEDIUM",
        "category": "DP",
        "starterCode": "#include <iostream>\nusing namespace std;\nint maxSubArray(int a[], int n) { return 0; }\nint main() { int a[]={-2,1,-3,4,-1,2,1,-5,4}; cout<<maxSubArray(a,9); return 0; }",
        "expectedOutput": "6",
        "solution": "#include <iostream>\nusing namespace std;\nint maxSubArray(int a[], int n) { int mx=a[0], cur=a[0]; for(int i=1;i<n;i++) { cur=max(a[i], cur+a[i]); mx=max(mx, cur); } return mx; }\nint main() { int a[]={-2,1,-3,4,-1,2,1,-5,4}; cout<<maxSubArray(a,9); return 0; }",
        "explanation": {
            "approach": "Either start fresh or extend previous.",
            "analogy": "Best profit streak - reset if going negative.",
            "steps": [
                "cur = max(current element, extend previous)",
                "Track overall max"
            ],
            "complexity": "Time: O(n), Space: O(1)"
        }
    },
    {
        "id": "med8",
        "title": "Longest Increasing Subsequence",
        "description": "Length of LIS.",
        "difficulty": "MEDIUM",
        "category": "DP",
        "starterCode": "#include <iostream>\nusing namespace std;\nint lis(int a[], int n) { return 0; }\nint main() { int a[]={10,9,2,5,3,7,101,18}; cout<<lis(a,8); return 0; }",
        "expectedOutput": "4",
        "solution": "#include <iostream>\nusing namespace std;\nint lis(int a[], int n) { int dp[n]; for(int i=0;i<n;i++) dp[i]=1; for(int i=1;i<n;i++) for(int j=0;j<i;j++) if(a[j]<a[i]) dp[i]=max(dp[i], dp[j]+1); int mx=0; for(int i=0;i<n;i++) mx=max(mx,dp[i]); return mx; }\nint main() { int a[]={10,9,2,5,3,7,101,18}; cout<<lis(a,8); return 0; }",
        "explanation": {
            "approach": "dp[i] = longest ending at i.",
            "analogy": "Build sequence one element at a time.",
            "steps": [
                "For each element, check all before",
                "If smaller, extend that sequence"
            ],
            "complexity": "Time: O(n²), Space: O(n)"
        }
    },
    {
        "id": "med9",
        "title": "Coin Change",
        "description": "Minimum coins for amount.",
        "difficulty": "MEDIUM",
        "category": "DP",
        "starterCode": "#include <iostream>\nusing namespace std;\nint coinChange(int coins[], int n, int amount) { return -1; }\nint main() { int c[]={1,2,5}; cout<<coinChange(c,3,11); return 0; }",
        "expectedOutput": "3",
        "solution": "#include <iostream>\nusing namespace std;\nint coinChange(int coins[], int n, int amount) { int dp[amount+1]; for(int i=0;i<=amount;i++) dp[i]=amount+1; dp[0]=0; for(int i=1;i<=amount;i++) for(int j=0;j<n;j++) if(coins[j]<=i) dp[i]=min(dp[i], dp[i-coins[j]]+1); return dp[amount]>amount ? -1 : dp[amount]; }\nint main() { int c[]={1,2,5}; cout<<coinChange(c,3,11); return 0; }",
        "explanation": {
            "approach": "dp[i] = min coins for amount i.",
            "analogy": "Build up from $0, try each coin.",
            "steps": [
                "For each amount, try each coin",
                "Take minimum coins needed"
            ],
            "complexity": "Time: O(amount × coins), Space: O(amount)"
        }
    },
    {
        "id": "med10",
        "title": "Climbing Stairs",
        "description": "Ways to climb n stairs.",
        "difficulty": "MEDIUM",
        "category": "DP",
        "starterCode": "#include <iostream>\nusing namespace std;\nint climbStairs(int n) { return 0; }\nint main() { cout<<climbStairs(5); return 0; }",
        "expectedOutput": "8",
        "solution": "#include <iostream>\nusing namespace std;\nint climbStairs(int n) { if(n<=2) return n; int a=1, b=2; for(int i=3;i<=n;i++) { int c=a+b; a=b; b=c; } return b; }\nint main() { cout<<climbStairs(5); return 0; }",
        "explanation": {
            "approach": "Fibonacci pattern - ways(n) = ways(n-1) + ways(n-2).",
            "analogy": "From step n-1 take 1 step, or from n-2 take 2.",
            "steps": [
                "Base: 1 or 2 steps",
                "Each step = sum of previous two"
            ],
            "complexity": "Time: O(n), Space: O(1)"
        }
    }
]