[
    {
        "id": "core71",
        "title": "Level Order Traversal",
        "description": "BFS level-by-level traversal of binary tree.",
        "difficulty": "MEDIUM",
        "category": "Trees",
        "starterCode": "#include <iostream>\nusing namespace std;\nstruct TreeNode { int val; TreeNode *left, *right; TreeNode(int x): val(x), left(0), right(0) {} };\nvoid levelOrder(TreeNode* root) {}\nint main() { TreeNode* r = new TreeNode(3); r->left = new TreeNode(9); r->right = new TreeNode(20); levelOrder(r); return 0; }",
        "expectedOutput": "3 9 20",
        "solution": "#include <iostream>\nusing namespace std;\nstruct TreeNode { int val; TreeNode *left, *right; TreeNode(int x): val(x), left(0), right(0) {} };\nvoid levelOrder(TreeNode* root) {\n    if(!root) return;\n    TreeNode* queue[100];\n    int front = 0, back = 0;\n    queue[back++] = root;\n    while(front < back) {\n        TreeNode* node = queue[front++];\n        cout << node->val << \" \";\n        if(node->left) queue[back++] = node->left;\n        if(node->right) queue[back++] = node->right;\n    }\n}\nint main() { TreeNode* r = new TreeNode(3); r->left = new TreeNode(9); r->right = new TreeNode(20); levelOrder(r); return 0; }",
        "explanation": {
            "approach": "BFS using queue, process level by level.",
            "steps": [
                "Enqueue root",
                "Dequeue, print, enqueue children",
                "Repeat"
            ],
            "complexity": "Time: O(n), Space: O(n)"
        },
        "testCases": [
            {
                "input": "Tree: 3->9,20",
                "expectedOutput": "3 9 20",
                "explanation": "Level 0: 3, Level 1: 9,20"
            },
            {
                "input": "Single node",
                "expectedOutput": "1",
                "explanation": "Only root"
            },
            {
                "input": "Empty tree",
                "expectedOutput": "",
                "explanation": "Nothing to traverse"
            },
            {
                "input": "Full binary tree",
                "expectedOutput": "1 2 3 4 5 6 7",
                "explanation": "All levels"
            }
        ]
    },
    {
        "id": "core72",
        "title": "Validate Binary Search Tree",
        "description": "Check if tree is valid BST (left < root < right for all nodes).",
        "difficulty": "MEDIUM",
        "category": "Trees",
        "starterCode": "#include <iostream>\nusing namespace std;\nstruct TreeNode { int val; TreeNode *left, *right; TreeNode(int x): val(x), left(0), right(0) {} };\nbool isValidBST(TreeNode* root) { return false; }\nint main() { TreeNode* r = new TreeNode(2); r->left = new TreeNode(1); r->right = new TreeNode(3); cout << isValidBST(r); return 0; }",
        "expectedOutput": "1",
        "solution": "#include <iostream>\nusing namespace std;\nstruct TreeNode { int val; TreeNode *left, *right; TreeNode(int x): val(x), left(0), right(0) {} };\nbool validate(TreeNode* node, long minVal, long maxVal) {\n    if(!node) return true;\n    if(node->val <= minVal || node->val >= maxVal) return false;\n    return validate(node->left, minVal, node->val) &&\n           validate(node->right, node->val, maxVal);\n}\nbool isValidBST(TreeNode* root) {\n    return validate(root, LONG_MIN, LONG_MAX);\n}\nint main() { TreeNode* r = new TreeNode(2); r->left = new TreeNode(1); r->right = new TreeNode(3); cout << isValidBST(r); return 0; }",
        "explanation": {
            "approach": "Recursively validate with min/max bounds.",
            "steps": [
                "Node must be within (min, max)",
                "Update bounds when going left/right"
            ],
            "complexity": "Time: O(n), Space: O(h)"
        },
        "testCases": [
            {
                "input": "Valid BST: 2->1,3",
                "expectedOutput": "1",
                "explanation": "1<2<3, valid"
            },
            {
                "input": "Invalid: 5->1,4->3,6",
                "expectedOutput": "0",
                "explanation": "6>5 in left subtree"
            },
            {
                "input": "Single node",
                "expectedOutput": "1",
                "explanation": "Always valid"
            },
            {
                "input": "Equal values",
                "expectedOutput": "0",
                "explanation": "BST requires strict inequality"
            }
        ]
    },
    {
        "id": "core73",
        "title": "Construct Binary Tree from Preorder and Inorder",
        "description": "Build tree from preorder and inorder traversal arrays.",
        "difficulty": "MEDIUM",
        "category": "Trees",
        "starterCode": "#include <iostream>\nusing namespace std;\nstruct TreeNode { int val; TreeNode *left, *right; TreeNode(int x): val(x), left(0), right(0) {} };\nTreeNode* buildTree(int pre[], int in[], int n) { return nullptr; }\nint main() { int pre[] = {3, 9, 20}; int in[] = {9, 3, 20}; TreeNode* r = buildTree(pre, in, 3); cout << r->val; return 0; }",
        "expectedOutput": "3",
        "solution": "#include <iostream>\nusing namespace std;\nstruct TreeNode { int val; TreeNode *left, *right; TreeNode(int x): val(x), left(0), right(0) {} };\nint preIdx;\nTreeNode* build(int pre[], int in[], int inStart, int inEnd) {\n    if(inStart > inEnd) return nullptr;\n    int rootVal = pre[preIdx++];\n    TreeNode* root = new TreeNode(rootVal);\n    int inIdx = inStart;\n    for(int i = inStart; i <= inEnd; i++)\n        if(in[i] == rootVal) { inIdx = i; break; }\n    root->left = build(pre, in, inStart, inIdx - 1);\n    root->right = build(pre, in, inIdx + 1, inEnd);\n    return root;\n}\nTreeNode* buildTree(int pre[], int in[], int n) {\n    preIdx = 0;\n    return build(pre, in, 0, n - 1);\n}\nint main() { int pre[] = {3, 9, 20}; int in[] = {9, 3, 20}; TreeNode* r = buildTree(pre, in, 3); cout << r->val; return 0; }",
        "explanation": {
            "approach": "Preorder gives root, inorder splits left/right subtrees.",
            "steps": [
                "First preorder element is root",
                "Find in inorder to split",
                "Recurse"
            ],
            "complexity": "Time: O(n²), Space: O(n)"
        },
        "testCases": [
            {
                "input": "pre=[3,9,20], in=[9,3,20]",
                "expectedOutput": "3",
                "explanation": "Root is 3"
            },
            {
                "input": "Single element",
                "expectedOutput": "1",
                "explanation": "Only root"
            },
            {
                "input": "Left-skewed tree",
                "expectedOutput": "Root value",
                "explanation": "All nodes on left"
            },
            {
                "input": "Right-skewed tree",
                "expectedOutput": "Root value",
                "explanation": "All nodes on right"
            }
        ]
    },
    {
        "id": "core74",
        "title": "Kth Smallest in BST",
        "description": "Find kth smallest element in BST (1-indexed).",
        "difficulty": "MEDIUM",
        "category": "Trees",
        "starterCode": "#include <iostream>\nusing namespace std;\nstruct TreeNode { int val; TreeNode *left, *right; TreeNode(int x): val(x), left(0), right(0) {} };\nint kthSmallest(TreeNode* root, int k) { return 0; }\nint main() { TreeNode* r = new TreeNode(3); r->left = new TreeNode(1); r->right = new TreeNode(4); r->left->right = new TreeNode(2); cout << kthSmallest(r, 1); return 0; }",
        "expectedOutput": "1",
        "solution": "#include <iostream>\nusing namespace std;\nstruct TreeNode { int val; TreeNode *left, *right; TreeNode(int x): val(x), left(0), right(0) {} };\nint count, result;\nvoid inorder(TreeNode* node, int k) {\n    if(!node || count >= k) return;\n    inorder(node->left, k);\n    count++;\n    if(count == k) { result = node->val; return; }\n    inorder(node->right, k);\n}\nint kthSmallest(TreeNode* root, int k) {\n    count = 0; result = 0;\n    inorder(root, k);\n    return result;\n}\nint main() { TreeNode* r = new TreeNode(3); r->left = new TreeNode(1); r->right = new TreeNode(4); r->left->right = new TreeNode(2); cout << kthSmallest(r, 1); return 0; }",
        "explanation": {
            "approach": "Inorder traversal gives sorted order in BST.",
            "steps": [
                "Inorder visits nodes in ascending order",
                "Count until k"
            ],
            "complexity": "Time: O(h+k), Space: O(h)"
        },
        "testCases": [
            {
                "input": "BST, k=1",
                "expectedOutput": "1",
                "explanation": "Smallest element"
            },
            {
                "input": "BST, k=3",
                "expectedOutput": "3",
                "explanation": "Third smallest"
            },
            {
                "input": "Single node, k=1",
                "expectedOutput": "5",
                "explanation": "Only element"
            },
            {
                "input": "BST, k=n",
                "expectedOutput": "Largest",
                "explanation": "Last in inorder"
            }
        ]
    },
    {
        "id": "core75",
        "title": "Binary Tree Maximum Path Sum",
        "description": "Find maximum sum path in tree (can start/end anywhere).",
        "difficulty": "HARD",
        "category": "Trees",
        "starterCode": "#include <iostream>\nusing namespace std;\nstruct TreeNode { int val; TreeNode *left, *right; TreeNode(int x): val(x), left(0), right(0) {} };\nint maxPathSum(TreeNode* root) { return 0; }\nint main() { TreeNode* r = new TreeNode(-10); r->left = new TreeNode(9); r->right = new TreeNode(20); cout << maxPathSum(r); return 0; }",
        "expectedOutput": "29",
        "solution": "#include <iostream>\nusing namespace std;\nstruct TreeNode { int val; TreeNode *left, *right; TreeNode(int x): val(x), left(0), right(0) {} };\nint maxSum;\nint maxGain(TreeNode* node) {\n    if(!node) return 0;\n    int leftGain = max(0, maxGain(node->left));\n    int rightGain = max(0, maxGain(node->right));\n    int pathSum = node->val + leftGain + rightGain;\n    maxSum = max(maxSum, pathSum);\n    return node->val + max(leftGain, rightGain);\n}\nint maxPathSum(TreeNode* root) {\n    maxSum = -1000000000;\n    maxGain(root);\n    return maxSum;\n}\nint main() { TreeNode* r = new TreeNode(-10); r->left = new TreeNode(9); r->right = new TreeNode(20); cout << maxPathSum(r); return 0; }",
        "explanation": {
            "approach": "At each node, compute path through it, track global max.",
            "steps": [
                "Ignore negative paths (use 0)",
                "Update global max",
                "Return single-side gain to parent"
            ],
            "complexity": "Time: O(n), Space: O(h)"
        },
        "testCases": [
            {
                "input": "-10->9,20->15,7",
                "expectedOutput": "42",
                "explanation": "15+20+7"
            },
            {
                "input": "1->2,3",
                "expectedOutput": "6",
                "explanation": "2+1+3"
            },
            {
                "input": "Single node -3",
                "expectedOutput": "-3",
                "explanation": "Only path"
            },
            {
                "input": "All negative",
                "expectedOutput": "Least negative",
                "explanation": "Must include one node"
            }
        ]
    },
    {
        "id": "core76",
        "title": "Serialize and Deserialize Binary Tree",
        "description": "Convert tree to string and back.",
        "difficulty": "HARD",
        "category": "Trees",
        "starterCode": "#include <iostream>\nusing namespace std;\nstruct TreeNode { int val; TreeNode *left, *right; TreeNode(int x): val(x), left(0), right(0) {} };\nvoid serialize(TreeNode* root) {}\nint main() { TreeNode* r = new TreeNode(1); r->left = new TreeNode(2); r->right = new TreeNode(3); serialize(r); return 0; }",
        "expectedOutput": "1 2 # # 3 # #",
        "solution": "#include <iostream>\nusing namespace std;\nstruct TreeNode { int val; TreeNode *left, *right; TreeNode(int x): val(x), left(0), right(0) {} };\nvoid serialize(TreeNode* root) {\n    if(!root) { cout << \"# \"; return; }\n    cout << root->val << \" \";\n    serialize(root->left);\n    serialize(root->right);\n}\nint main() { TreeNode* r = new TreeNode(1); r->left = new TreeNode(2); r->right = new TreeNode(3); serialize(r); return 0; }",
        "explanation": {
            "approach": "Preorder with null markers.",
            "steps": [
                "Output value or # for null",
                "Preorder traversal"
            ],
            "complexity": "Time: O(n), Space: O(n)"
        },
        "testCases": [
            {
                "input": "Tree 1->2,3",
                "expectedOutput": "1 2 # # 3 # #",
                "explanation": "Preorder with nulls"
            },
            {
                "input": "Empty tree",
                "expectedOutput": "#",
                "explanation": "Just null marker"
            },
            {
                "input": "Single node",
                "expectedOutput": "1 # #",
                "explanation": "Root with null children"
            },
            {
                "input": "Left-only tree",
                "expectedOutput": "1 2 3 # # # #",
                "explanation": "Chain left"
            }
        ]
    },
    {
        "id": "core77",
        "title": "Word Ladder",
        "description": "Shortest transformation from beginWord to endWord, changing one letter at a time.",
        "difficulty": "HARD",
        "category": "BFS",
        "starterCode": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint ladderLength(vector<int>& beginWord, vector<int>& endWord, vector<string>& wordList, int n) {\n    return 0;\n}\n\nint main() {\n    int beginWord_size;\n    cin >> beginWord_size;\n    vector<int> beginWord(beginWord_size);\n    for (int i = 0; i < beginWord_size; i++) cin >> beginWord[i];\n    int endWord_size;\n    cin >> endWord_size;\n    vector<int> endWord(endWord_size);\n    for (int i = 0; i < endWord_size; i++) cin >> endWord[i];\n    int wordList_size;\n    cin >> wordList_size;\n    vector<string> wordList(wordList_size);\n    for (int i = 0; i < wordList_size; i++) cin >> wordList[i];\n    int n;\n    cin >> n;\n    cout << ladderLength(beginWord, endWord, wordList, n);\n    return 0;\n}\n",
        "expectedOutput": "5",
        "solution": "#include <iostream>\nusing namespace std;\nbool differs(char a[], char b[]) {\n    int diff = 0;\n    for(int i = 0; a[i] && b[i]; i++)\n        if(a[i] != b[i]) diff++;\n    return diff == 1;\n}\nbool equals(char a[], char b[]) {\n    for(int i = 0; a[i] || b[i]; i++)\n        if(a[i] != b[i]) return false;\n    return true;\n}\nint ladderLength(char beginWord[], char endWord[], char* wordList[], int n) {\n    char* queue[100]; int dist[100] = {}; bool visited[100] = {};\n    int front = 0, back = 0;\n    queue[back] = beginWord; dist[back++] = 1;\n    while(front < back) {\n        char* curr = queue[front]; int d = dist[front++];\n        if(equals(curr, endWord)) return d;\n        for(int i = 0; i < n; i++)\n            if(!visited[i] && differs(curr, wordList[i])) {\n                visited[i] = true;\n                queue[back] = wordList[i]; dist[back++] = d + 1;\n            }\n    }\n    return 0;\n}\nint main() { char* words[] = {\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog\"}; cout << ladderLength(\"hit\", \"cog\", words, 6); return 0; }",
        "explanation": {
            "approach": "BFS on word graph, edges connect words differing by one letter.",
            "steps": [
                "BFS from beginWord",
                "Find words differing by 1 letter",
                "Return distance when endWord found"
            ],
            "complexity": "Time: O(n²×L), Space: O(n)"
        },
        "testCases": [
            {
                "input": "hit->cog",
                "expectedOutput": "5",
                "explanation": "hit->hot->dot->dog->cog"
            },
            {
                "input": "hit->cog, no cog in list",
                "expectedOutput": "0",
                "explanation": "No path"
            },
            {
                "input": "Same start and end",
                "expectedOutput": "1",
                "explanation": "Already there"
            },
            {
                "input": "Direct connection",
                "expectedOutput": "2",
                "explanation": "One step"
            }
        ]
    },
    {
        "id": "core78",
        "title": "Number of Islands",
        "description": "Count connected components of '1's (land) in 2D grid.",
        "difficulty": "MEDIUM",
        "category": "DFS",
        "starterCode": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint numIslands(vector<vector<int>>& grid, int m, int n) {\n    return 0;\n}\n\nint main() {\n    int grid_rows, grid_cols;\n    cin >> grid_rows >> grid_cols;\n    vector<vector<int>> grid(grid_rows, vector<int>(grid_cols));\n    for (int i = 0; i < grid_rows; i++)\n        for (int j = 0; j < grid_cols; j++)\n            cin >> grid[i][j];\n    int m;\n    cin >> m;\n    int n;\n    cin >> n;\n    cout << numIslands(grid, m, n);\n    return 0;\n}\n",
        "expectedOutput": "1",
        "solution": "#include <iostream>\nusing namespace std;\nvoid dfs(char grid[][5], int m, int n, int i, int j) {\n    if(i < 0 || i >= m || j < 0 || j >= n || grid[i][j] != '1') return;\n    grid[i][j] = '0';\n    dfs(grid, m, n, i+1, j); dfs(grid, m, n, i-1, j);\n    dfs(grid, m, n, i, j+1); dfs(grid, m, n, i, j-1);\n}\nint numIslands(char grid[][5], int m, int n) {\n    int count = 0;\n    for(int i = 0; i < m; i++)\n        for(int j = 0; j < n; j++)\n            if(grid[i][j] == '1') { count++; dfs(grid, m, n, i, j); }\n    return count;\n}\nint main() { char g[][5] = {{\"11110\"}, {\"11010\"}, {\"11000\"}, {\"00000\"}}; cout << numIslands(g, 4, 5); return 0; }",
        "explanation": {
            "approach": "DFS to sink each island when found.",
            "steps": [
                "Find '1'",
                "Count++, DFS to mark all connected as visited"
            ],
            "complexity": "Time: O(m×n), Space: O(m×n)"
        },
        "testCases": [
            {
                "input": "One large island",
                "expectedOutput": "1",
                "explanation": "All connected"
            },
            {
                "input": "3 separate islands",
                "expectedOutput": "3",
                "explanation": "Three components"
            },
            {
                "input": "All water",
                "expectedOutput": "0",
                "explanation": "No land"
            },
            {
                "input": "Diagonal doesn't connect",
                "expectedOutput": "4",
                "explanation": "Corners are separate"
            }
        ]
    },
    {
        "id": "core79",
        "title": "Course Schedule",
        "description": "Check if all courses can be completed (no circular dependencies).",
        "difficulty": "MEDIUM",
        "category": "Graph",
        "starterCode": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nbool canFinish(int numCourses, vector<vector<int>>& prereq, int n) {\n    return false;\n}\n\nint main() {\n    int numCourses;\n    cin >> numCourses;\n    int prereq_rows, prereq_cols;\n    cin >> prereq_rows >> prereq_cols;\n    vector<vector<int>> prereq(prereq_rows, vector<int>(prereq_cols));\n    for (int i = 0; i < prereq_rows; i++)\n        for (int j = 0; j < prereq_cols; j++)\n            cin >> prereq[i][j];\n    int n;\n    cin >> n;\n    cout << canFinish(numCourses, prereq, n);\n    return 0;\n}\n",
        "expectedOutput": "1",
        "solution": "#include <iostream>\nusing namespace std;\nint adj[10][10], adjSize[10] = {};\nint state[10];\nbool hasCycle(int node) {\n    if(state[node] == 1) return true;\n    if(state[node] == 2) return false;\n    state[node] = 1;\n    for(int i = 0; i < adjSize[node]; i++)\n        if(hasCycle(adj[node][i])) return true;\n    state[node] = 2;\n    return false;\n}\nbool canFinish(int numCourses, int prereq[][2], int n) {\n    for(int i = 0; i < numCourses; i++) adjSize[i] = 0;\n    for(int i = 0; i < n; i++) {\n        int a = prereq[i][0], b = prereq[i][1];\n        adj[b][adjSize[b]++] = a;\n    }\n    for(int i = 0; i < numCourses; i++) state[i] = 0;\n    for(int i = 0; i < numCourses; i++)\n        if(hasCycle(i)) return false;\n    return true;\n}\nint main() { int p[][2] = {{1, 0}}; cout << canFinish(2, p, 1); return 0; }",
        "explanation": {
            "approach": "Detect cycle in directed graph using DFS with 3 states.",
            "steps": [
                "0=unvisited, 1=visiting, 2=done",
                "If hit node with state=1, cycle"
            ],
            "complexity": "Time: O(V+E), Space: O(V)"
        },
        "testCases": [
            {
                "input": "2 courses, 1->0",
                "expectedOutput": "1",
                "explanation": "Take 0 then 1"
            },
            {
                "input": "Cycle: 0->1->0",
                "expectedOutput": "0",
                "explanation": "Impossible"
            },
            {
                "input": "No prerequisites",
                "expectedOutput": "1",
                "explanation": "All independent"
            },
            {
                "input": "Chain: 0->1->2->3",
                "expectedOutput": "1",
                "explanation": "Valid order exists"
            }
        ]
    },
    {
        "id": "core80",
        "title": "Clone Graph",
        "description": "Deep copy an undirected graph.",
        "difficulty": "MEDIUM",
        "category": "Graph",
        "starterCode": "#include <iostream>\nusing namespace std;\nstruct Node { int val; Node* adj[10]; int n; Node(): val(0), n(0) {} Node(int v): val(v), n(0) {} };\nNode* cloneGraph(Node* node) { return nullptr; }\nint main() { Node* n = new Node(1); cout << \"Clone Graph\"; return 0; }",
        "expectedOutput": "Clone Graph",
        "solution": "#include <iostream>\nusing namespace std;\nstruct Node { int val; Node* adj[10]; int n; Node(): val(0), n(0) {} Node(int v): val(v), n(0) {} };\nNode* cloned[101] = {};\nNode* cloneGraph(Node* node) {\n    if(!node) return nullptr;\n    if(cloned[node->val]) return cloned[node->val];\n    Node* copy = new Node(node->val);\n    cloned[node->val] = copy;\n    for(int i = 0; i < node->n; i++)\n        copy->adj[copy->n++] = cloneGraph(node->adj[i]);\n    return copy;\n}\nint main() { Node* n = new Node(1); cout << \"Clone Graph\"; return 0; }",
        "explanation": {
            "approach": "DFS with hash map to track original→clone.",
            "steps": [
                "If already cloned, return clone",
                "Create clone, recurse on neighbors"
            ],
            "complexity": "Time: O(V+E), Space: O(V)"
        },
        "testCases": [
            {
                "input": "4-node cycle graph",
                "expectedOutput": "Cloned graph",
                "explanation": "Deep copy with same structure"
            },
            {
                "input": "Single node",
                "expectedOutput": "Single node copy",
                "explanation": "Clone 1 node"
            },
            {
                "input": "Empty graph",
                "expectedOutput": "null",
                "explanation": "Nothing to clone"
            },
            {
                "input": "Complete graph K4",
                "expectedOutput": "Cloned K4",
                "explanation": "All connections preserved"
            }
        ]
    }
]