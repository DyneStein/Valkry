[
    {
        "id": "h17",
        "title": "Regular Expression Matching",
        "description": "Full regex with . and *.",
        "difficulty": "HARD",
        "category": "DP",
        "starterCode": "#include <iostream>\nusing namespace std;\nbool isMatch(char s[], char p[]) { return false; }\nint main() { cout << isMatch(\"aa\",\"a*\"); return 0; }",
        "expectedOutput": "1",
        "solution": "#include <iostream>\nusing namespace std;\nbool isMatch(char s[], char p[]) { int m=0,n=0; while(s[m]) m++; while(p[n]) n++; bool dp[m+1][n+1]; for(int i=0;i<=m;i++) for(int j=0;j<=n;j++) dp[i][j]=false; dp[0][0]=true; for(int j=2;j<=n;j++) if(p[j-1]=='*') dp[0][j]=dp[0][j-2]; for(int i=1;i<=m;i++) for(int j=1;j<=n;j++) { if(p[j-1]=='*') { dp[i][j]=dp[i][j-2]; if(p[j-2]=='.'||p[j-2]==s[i-1]) dp[i][j]=dp[i][j]||dp[i-1][j]; } else if(p[j-1]=='.'||p[j-1]==s[i-1]) dp[i][j]=dp[i-1][j-1]; } return dp[m][n]; }\nint main() { cout << isMatch(\"aa\",\"a*\"); return 0; }",
        "explanation": {
            "approach": "DP for pattern matching.",
            "steps": [
                "dp[i][j] = s[0..i] matches p[0..j]",
                "Handle * for 0 or more"
            ],
            "complexity": "Time: O(mn), Space: O(mn)"
        }
    },
    {
        "id": "h18",
        "title": "Wildcard Matching",
        "description": "Match with ? and *.",
        "difficulty": "HARD",
        "category": "DP",
        "starterCode": "#include <iostream>\nusing namespace std;\nbool isMatch(char s[], char p[]) { return false; }\nint main() { cout << isMatch(\"adceb\",\"*a*b\"); return 0; }",
        "expectedOutput": "1",
        "solution": "#include <iostream>\nusing namespace std;\nbool isMatch(char s[], char p[]) { int m=0,n=0; while(s[m]) m++; while(p[n]) n++; bool dp[m+1][n+1]; for(int i=0;i<=m;i++) for(int j=0;j<=n;j++) dp[i][j]=false; dp[0][0]=true; for(int j=1;j<=n&&p[j-1]=='*';j++) dp[0][j]=true; for(int i=1;i<=m;i++) for(int j=1;j<=n;j++) { if(p[j-1]=='*') dp[i][j]=dp[i-1][j]||dp[i][j-1]; else if(p[j-1]=='?'||p[j-1]==s[i-1]) dp[i][j]=dp[i-1][j-1]; } return dp[m][n]; }\nint main() { cout << isMatch(\"adceb\",\"*a*b\"); return 0; }",
        "explanation": {
            "approach": "DP for wildcard matching.",
            "steps": [
                "* matches any sequence",
                "? matches one char"
            ],
            "complexity": "Time: O(mn), Space: O(mn)"
        }
    },
    {
        "id": "h19",
        "title": "Longest Valid Parentheses",
        "description": "Longest valid substring.",
        "difficulty": "HARD",
        "category": "DP",
        "starterCode": "#include <iostream>\nusing namespace std;\nint longestValidParentheses(char s[]) { return 0; }\nint main() { cout << longestValidParentheses(\"(()\"); return 0; }",
        "expectedOutput": "2",
        "solution": "#include <iostream>\nusing namespace std;\nint longestValidParentheses(char s[]) { int n=0; while(s[n]) n++; int stk[n+1],top=0,mx=0; stk[top++]=-1; for(int i=0;i<n;i++) { if(s[i]=='(') stk[top++]=i; else { top--; if(top==0) stk[top++]=i; else mx=max(mx,i-stk[top-1]); } } return mx; }\nint main() { cout << longestValidParentheses(\"(()\"); return 0; }",
        "explanation": {
            "approach": "Stack to track valid ranges.",
            "steps": [
                "Push ( indices",
                "Pop on ), calculate length"
            ],
            "complexity": "Time: O(n), Space: O(n)"
        }
    },
    {
        "id": "h20",
        "title": "Palindrome Partitioning II",
        "description": "Min cuts for palindrome partition.",
        "difficulty": "HARD",
        "category": "DP",
        "starterCode": "#include <iostream>\nusing namespace std;\nint minCut(char s[]) { return 0; }\nint main() { cout << minCut(\"aab\"); return 0; }",
        "expectedOutput": "1",
        "solution": "#include <iostream>\nusing namespace std;\nint minCut(char s[]) { int n=0; while(s[n]) n++; bool pal[n][n]={}; int dp[n]; for(int i=0;i<n;i++) dp[i]=i; for(int i=0;i<n;i++) { for(int j=0;j<=i;j++) { if(s[j]==s[i]&&(i-j<2||pal[j+1][i-1])) { pal[j][i]=true; dp[i]=j==0?0:min(dp[i],dp[j-1]+1); } } } return dp[n-1]; }\nint main() { cout << minCut(\"aab\"); return 0; }",
        "explanation": {
            "approach": "DP with palindrome check.",
            "steps": [
                "Precompute palindromes",
                "dp[i] = min cuts for s[0..i]"
            ],
            "complexity": "Time: O(n²), Space: O(n²)"
        }
    },
    {
        "id": "h21",
        "title": "Scramble String",
        "description": "Check if s2 is scramble of s1.",
        "difficulty": "HARD",
        "category": "DP",
        "starterCode": "#include <iostream>\nusing namespace std;\nbool isScramble(char s1[], char s2[]) { return false; }\nint main() { cout << isScramble(\"great\",\"rgeat\"); return 0; }",
        "expectedOutput": "1",
        "solution": "#include <iostream>\nusing namespace std;\nbool eq(char a[], char b[], int l) { for(int i=0;i<l;i++) if(a[i]!=b[i]) return false; return true; }\nbool isScramble(char s1[], char s2[]) { int n=0; while(s1[n]) n++; if(eq(s1,s2,n)) return true; int cnt[26]={}; for(int i=0;i<n;i++) { cnt[s1[i]-'a']++; cnt[s2[i]-'a']--; } for(int i=0;i<26;i++) if(cnt[i]) return false; for(int i=1;i<n;i++) if((isScramble(s1,s2)&&isScramble(s1+i,s2+i))||(isScramble(s1,s2+n-i)&&isScramble(s1+i,s2))) return true; return false; }\nint main() { cout << isScramble(\"great\",\"rgeat\"); return 0; }",
        "explanation": {
            "approach": "Recursive check with char validation.",
            "steps": [
                "Check if anagrams first",
                "Try all split points"
            ],
            "complexity": "Time: O(4^n), Space: O(n)"
        }
    },
    {
        "id": "h22",
        "title": "Edit Distance",
        "description": "Min operations to transform.",
        "difficulty": "HARD",
        "category": "DP",
        "starterCode": "#include <iostream>\nusing namespace std;\nint minDistance(char a[], char b[]) { return 0; }\nint main() { cout << minDistance(\"horse\",\"ros\"); return 0; }",
        "expectedOutput": "3",
        "solution": "#include <iostream>\nusing namespace std;\nint minDistance(char a[], char b[]) { int m=0,n=0; while(a[m]) m++; while(b[n]) n++; int dp[m+1][n+1]; for(int i=0;i<=m;i++) dp[i][0]=i; for(int j=0;j<=n;j++) dp[0][j]=j; for(int i=1;i<=m;i++) for(int j=1;j<=n;j++) if(a[i-1]==b[j-1]) dp[i][j]=dp[i-1][j-1]; else dp[i][j]=1+min(dp[i-1][j],min(dp[i][j-1],dp[i-1][j-1])); return dp[m][n]; }\nint main() { cout << minDistance(\"horse\",\"ros\"); return 0; }",
        "explanation": {
            "approach": "DP for min operations.",
            "steps": [
                "Insert, delete, or replace",
                "Take minimum of 3 options"
            ],
            "complexity": "Time: O(mn), Space: O(mn)"
        }
    },
    {
        "id": "h23",
        "title": "Minimum Window Substring",
        "description": "Smallest window with all chars.",
        "difficulty": "HARD",
        "category": "Sliding Window",
        "starterCode": "#include <iostream>\nusing namespace std;\nvoid minWindow(char s[], char t[]) {}\nint main() { minWindow(\"ADOBECODEBANC\",\"ABC\"); return 0; }",
        "expectedOutput": "BANC",
        "solution": "#include <iostream>\nusing namespace std;\nvoid minWindow(char s[], char t[]) { int need[256]={},have[256]={},req=0; for(int i=0;t[i];i++) if(need[(int)t[i]]++==0) req++; int l=0,minL=1e9,start=0,formed=0,n=0; while(s[n]) n++; for(int r=0;r<n;r++) { have[(int)s[r]]++; if(need[(int)s[r]]&&have[(int)s[r]]==need[(int)s[r]]) formed++; while(formed==req) { if(r-l+1<minL) { minL=r-l+1; start=l; } have[(int)s[l]]--; if(need[(int)s[l]]&&have[(int)s[l]]<need[(int)s[l]]) formed--; l++; } } if(minL<1e9) for(int i=start;i<start+minL;i++) cout<<s[i]; }\nint main() { minWindow(\"ADOBECODEBANC\",\"ABC\"); return 0; }",
        "explanation": {
            "approach": "Sliding window with char counts.",
            "steps": [
                "Expand right until valid",
                "Shrink left while valid"
            ],
            "complexity": "Time: O(n), Space: O(1)"
        }
    },
    {
        "id": "h24",
        "title": "Substring with Concatenation",
        "description": "All starting indices.",
        "difficulty": "HARD",
        "category": "Sliding Window",
        "starterCode": "#include <iostream>\nusing namespace std;\nvoid findSubstring(char s[], char words[][10], int n) {}\nint main() { char w[][10]={\"foo\",\"bar\"}; findSubstring(\"barfoothefoobarman\",w,2); return 0; }",
        "expectedOutput": "0 9",
        "solution": "#include <iostream>\nusing namespace std;\nbool eq(char a[], char b[]) { int i=0; while(a[i]&&a[i]==b[i]) i++; return !a[i]&&!b[i]; }\nvoid findSubstring(char s[], char words[][10], int n) { if(n==0) return; int wl=0; while(words[0][wl]) wl++; int slen=0; while(s[slen]) slen++; int total=n*wl; for(int i=0;i<=slen-total;i++) { int used[10]={}; int matched=0; for(int j=0;j<n;j++) { char sub[11]; for(int k=0;k<wl;k++) sub[k]=s[i+j*wl+k]; sub[wl]=0; bool found=false; for(int k=0;k<n;k++) if(!used[k]&&eq(sub,words[k])) { used[k]=1; found=true; matched++; break; } if(!found) break; } if(matched==n) cout<<i<<\" \"; } }\nint main() { char w[][10]={\"foo\",\"bar\"}; findSubstring(\"barfoothefoobarman\",w,2); return 0; }",
        "explanation": {
            "approach": "Check each starting position.",
            "steps": [
                "For each start, check all words",
                "Track used words"
            ],
            "complexity": "Time: O(L × n × wl), Space: O(n)"
        }
    }
]