[
    {
        "id": "h17",
        "title": "Regular Expression Matching",
        "description": "Full regex with . and *.",
        "difficulty": "HARD",
        "category": "DP",
        "starterCode": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nbool isMatch(vector<int>& s, vector<int>& p) {\n    return false;\n}\n\nint main() {\n    int s_size;\n    cin >> s_size;\n    vector<int> s(s_size);\n    for (int i = 0; i < s_size; i++) cin >> s[i];\n    int p_size;\n    cin >> p_size;\n    vector<int> p(p_size);\n    for (int i = 0; i < p_size; i++) cin >> p[i];\n    cout << isMatch(s, p);\n    return 0;\n}\n",
        "expectedOutput": "1",
        "solution": "#include <iostream>\nusing namespace std;\nbool isMatch(char s[], char p[]) { int m=0,n=0; while(s[m]) m++; while(p[n]) n++; bool dp[m+1][n+1]; for(int i=0;i<=m;i++) for(int j=0;j<=n;j++) dp[i][j]=false; dp[0][0]=true; for(int j=2;j<=n;j++) if(p[j-1]=='*') dp[0][j]=dp[0][j-2]; for(int i=1;i<=m;i++) for(int j=1;j<=n;j++) { if(p[j-1]=='*') { dp[i][j]=dp[i][j-2]; if(p[j-2]=='.'||p[j-2]==s[i-1]) dp[i][j]=dp[i][j]||dp[i-1][j]; } else if(p[j-1]=='.'||p[j-1]==s[i-1]) dp[i][j]=dp[i-1][j-1]; } return dp[m][n]; }\nint main() { cout << isMatch(\"aa\",\"a*\"); return 0; }",
        "explanation": {
            "approach": "DP for pattern matching.",
            "steps": [
                "dp[i][j] = s[0..i] matches p[0..j]",
                "Handle * for 0 or more"
            ],
            "complexity": "Time: O(mn), Space: O(mn)"
        },
        "testCases": [
            {
                "input": "s=\"aa\", p=\"a*\"",
                "expectedOutput": "1",
                "explanation": "a* matches aa (zero or more a's)"
            },
            {
                "input": "s=\"ab\", p=\".*\"",
                "expectedOutput": "1",
                "explanation": ".* matches any string"
            },
            {
                "input": "s=\"aab\", p=\"c*a*b\"",
                "expectedOutput": "1",
                "explanation": "c* matches empty, a* matches aa"
            },
            {
                "input": "s=\"mississippi\", p=\"mis*is*p*.\"",
                "expectedOutput": "0",
                "explanation": "Pattern cannot match full string"
            }
        ]
    },
    {
        "id": "h18",
        "title": "Wildcard Matching",
        "description": "Match with ? and *.",
        "difficulty": "HARD",
        "category": "DP",
        "starterCode": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nbool isMatch(vector<int>& s, vector<int>& p) {\n    return false;\n}\n\nint main() {\n    int s_size;\n    cin >> s_size;\n    vector<int> s(s_size);\n    for (int i = 0; i < s_size; i++) cin >> s[i];\n    int p_size;\n    cin >> p_size;\n    vector<int> p(p_size);\n    for (int i = 0; i < p_size; i++) cin >> p[i];\n    cout << isMatch(s, p);\n    return 0;\n}\n",
        "expectedOutput": "1",
        "solution": "#include <iostream>\nusing namespace std;\nbool isMatch(char s[], char p[]) { int m=0,n=0; while(s[m]) m++; while(p[n]) n++; bool dp[m+1][n+1]; for(int i=0;i<=m;i++) for(int j=0;j<=n;j++) dp[i][j]=false; dp[0][0]=true; for(int j=1;j<=n&&p[j-1]=='*';j++) dp[0][j]=true; for(int i=1;i<=m;i++) for(int j=1;j<=n;j++) { if(p[j-1]=='*') dp[i][j]=dp[i-1][j]||dp[i][j-1]; else if(p[j-1]=='?'||p[j-1]==s[i-1]) dp[i][j]=dp[i-1][j-1]; } return dp[m][n]; }\nint main() { cout << isMatch(\"adceb\",\"*a*b\"); return 0; }",
        "explanation": {
            "approach": "DP for wildcard matching.",
            "steps": [
                "* matches any sequence",
                "? matches one char"
            ],
            "complexity": "Time: O(mn), Space: O(mn)"
        },
        "testCases": [
            {
                "input": "s=\"adceb\", p=\"*a*b\"",
                "expectedOutput": "1",
                "explanation": "* matches ad, a matches a, * matches ce, b matches b"
            },
            {
                "input": "s=\"acdcb\", p=\"a*c?b\"",
                "expectedOutput": "0",
                "explanation": "Cannot match properly"
            },
            {
                "input": "s=\"cb\", p=\"?a\"",
                "expectedOutput": "0",
                "explanation": "Second char doesn't match"
            },
            {
                "input": "s=\"\", p=\"*\"",
                "expectedOutput": "1",
                "explanation": "Star matches empty string"
            }
        ]
    },
    {
        "id": "h19",
        "title": "Longest Valid Parentheses",
        "description": "Longest valid substring.",
        "difficulty": "HARD",
        "category": "DP",
        "starterCode": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint longestValidParentheses(vector<int>& s) {\n    return 0;\n}\n\nint main() {\n    int s_size;\n    cin >> s_size;\n    vector<int> s(s_size);\n    for (int i = 0; i < s_size; i++) cin >> s[i];\n    cout << longestValidParentheses(s);\n    return 0;\n}\n",
        "expectedOutput": "2",
        "solution": "#include <iostream>\nusing namespace std;\nint longestValidParentheses(char s[]) { int n=0; while(s[n]) n++; int stk[n+1],top=0,mx=0; stk[top++]=-1; for(int i=0;i<n;i++) { if(s[i]=='(') stk[top++]=i; else { top--; if(top==0) stk[top++]=i; else mx=max(mx,i-stk[top-1]); } } return mx; }\nint main() { cout << longestValidParentheses(\"(()\"); return 0; }",
        "explanation": {
            "approach": "Stack to track valid ranges.",
            "steps": [
                "Push ( indices",
                "Pop on ), calculate length"
            ],
            "complexity": "Time: O(n), Space: O(n)"
        },
        "testCases": [
            {
                "input": "\"(()\"",
                "expectedOutput": "2",
                "explanation": "() at end is longest valid"
            },
            {
                "input": "\")()())\"",
                "expectedOutput": "4",
                "explanation": "()() in middle is longest"
            },
            {
                "input": "\"\"",
                "expectedOutput": "0",
                "explanation": "Empty string"
            },
            {
                "input": "\"()(()\"",
                "expectedOutput": "2",
                "explanation": "Either () at start or () inside - both length 2"
            }
        ]
    },
    {
        "id": "h20",
        "title": "Palindrome Partitioning II",
        "description": "Min cuts for palindrome partition.",
        "difficulty": "HARD",
        "category": "DP",
        "starterCode": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint minCut(vector<int>& s) {\n    return 0;\n}\n\nint main() {\n    int s_size;\n    cin >> s_size;\n    vector<int> s(s_size);\n    for (int i = 0; i < s_size; i++) cin >> s[i];\n    cout << minCut(s);\n    return 0;\n}\n",
        "expectedOutput": "1",
        "solution": "#include <iostream>\nusing namespace std;\nint minCut(char s[]) { int n=0; while(s[n]) n++; bool pal[n][n]={}; int dp[n]; for(int i=0;i<n;i++) dp[i]=i; for(int i=0;i<n;i++) { for(int j=0;j<=i;j++) { if(s[j]==s[i]&&(i-j<2||pal[j+1][i-1])) { pal[j][i]=true; dp[i]=j==0?0:min(dp[i],dp[j-1]+1); } } } return dp[n-1]; }\nint main() { cout << minCut(\"aab\"); return 0; }",
        "explanation": {
            "approach": "DP with palindrome check.",
            "steps": [
                "Precompute palindromes",
                "dp[i] = min cuts for s[0..i]"
            ],
            "complexity": "Time: O(n²), Space: O(n²)"
        },
        "testCases": [
            {
                "input": "\"aab\"",
                "expectedOutput": "1",
                "explanation": "Cut between aa|b"
            },
            {
                "input": "\"a\"",
                "expectedOutput": "0",
                "explanation": "Single char needs no cuts"
            },
            {
                "input": "\"ab\"",
                "expectedOutput": "1",
                "explanation": "One cut needed: a|b"
            },
            {
                "input": "\"aba\"",
                "expectedOutput": "0",
                "explanation": "Already a palindrome, no cuts needed"
            }
        ]
    },
    {
        "id": "h21",
        "title": "Scramble String",
        "description": "Check if s2 is scramble of s1.",
        "difficulty": "HARD",
        "category": "DP",
        "starterCode": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nbool isScramble(vector<int>& s1, vector<int>& s2) {\n    return false;\n}\n\nint main() {\n    int s1_size;\n    cin >> s1_size;\n    vector<int> s1(s1_size);\n    for (int i = 0; i < s1_size; i++) cin >> s1[i];\n    int s2_size;\n    cin >> s2_size;\n    vector<int> s2(s2_size);\n    for (int i = 0; i < s2_size; i++) cin >> s2[i];\n    cout << isScramble(s1, s2);\n    return 0;\n}\n",
        "expectedOutput": "1",
        "solution": "#include <iostream>\nusing namespace std;\nbool eq(char a[], char b[], int l) { for(int i=0;i<l;i++) if(a[i]!=b[i]) return false; return true; }\nbool isScramble(char s1[], char s2[]) { int n=0; while(s1[n]) n++; if(eq(s1,s2,n)) return true; int cnt[26]={}; for(int i=0;i<n;i++) { cnt[s1[i]-'a']++; cnt[s2[i]-'a']--; } for(int i=0;i<26;i++) if(cnt[i]) return false; for(int i=1;i<n;i++) if((isScramble(s1,s2)&&isScramble(s1+i,s2+i))||(isScramble(s1,s2+n-i)&&isScramble(s1+i,s2))) return true; return false; }\nint main() { cout << isScramble(\"great\",\"rgeat\"); return 0; }",
        "explanation": {
            "approach": "Recursive check with char validation.",
            "steps": [
                "Check if anagrams first",
                "Try all split points"
            ],
            "complexity": "Time: O(4^n), Space: O(n)"
        },
        "testCases": [
            {
                "input": "s1=\"great\", s2=\"rgeat\"",
                "expectedOutput": "1",
                "explanation": "rgeat is a scramble of great"
            },
            {
                "input": "s1=\"abcde\", s2=\"caebd\"",
                "expectedOutput": "0",
                "explanation": "Not a valid scramble"
            },
            {
                "input": "s1=\"a\", s2=\"a\"",
                "expectedOutput": "1",
                "explanation": "Same single char"
            },
            {
                "input": "s1=\"abc\", s2=\"bca\"",
                "expectedOutput": "1",
                "explanation": "bca is a valid scramble of abc"
            }
        ]
    },
    {
        "id": "h22",
        "title": "Edit Distance",
        "description": "Min operations to transform.",
        "difficulty": "HARD",
        "category": "DP",
        "starterCode": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint minDistance(vector<int>& a, vector<int>& b) {\n    return 0;\n}\n\nint main() {\n    int a_size;\n    cin >> a_size;\n    vector<int> a(a_size);\n    for (int i = 0; i < a_size; i++) cin >> a[i];\n    int b_size;\n    cin >> b_size;\n    vector<int> b(b_size);\n    for (int i = 0; i < b_size; i++) cin >> b[i];\n    cout << minDistance(a, b);\n    return 0;\n}\n",
        "expectedOutput": "3",
        "solution": "#include <iostream>\nusing namespace std;\nint minDistance(char a[], char b[]) { int m=0,n=0; while(a[m]) m++; while(b[n]) n++; int dp[m+1][n+1]; for(int i=0;i<=m;i++) dp[i][0]=i; for(int j=0;j<=n;j++) dp[0][j]=j; for(int i=1;i<=m;i++) for(int j=1;j<=n;j++) if(a[i-1]==b[j-1]) dp[i][j]=dp[i-1][j-1]; else dp[i][j]=1+min(dp[i-1][j],min(dp[i][j-1],dp[i-1][j-1])); return dp[m][n]; }\nint main() { cout << minDistance(\"horse\",\"ros\"); return 0; }",
        "explanation": {
            "approach": "DP for min operations.",
            "steps": [
                "Insert, delete, or replace",
                "Take minimum of 3 options"
            ],
            "complexity": "Time: O(mn), Space: O(mn)"
        },
        "testCases": [
            {
                "input": "a=\"horse\", b=\"ros\"",
                "expectedOutput": "3",
                "explanation": "horse → rorse → rose → ros"
            },
            {
                "input": "a=\"intention\", b=\"execution\"",
                "expectedOutput": "5",
                "explanation": "5 operations needed"
            },
            {
                "input": "a=\"\", b=\"abc\"",
                "expectedOutput": "3",
                "explanation": "3 insertions"
            },
            {
                "input": "a=\"abc\", b=\"abc\"",
                "expectedOutput": "0",
                "explanation": "Strings are identical"
            }
        ]
    },
    {
        "id": "h23",
        "title": "Minimum Window Substring",
        "description": "Smallest window with all chars.",
        "difficulty": "HARD",
        "category": "Sliding Window",
        "starterCode": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nvoid minWindow(vector<int>& s, vector<int>& t) {\n    // TODO\n}\n\nint main() {\n    int s_size;\n    cin >> s_size;\n    vector<int> s(s_size);\n    for (int i = 0; i < s_size; i++) cin >> s[i];\n    int t_size;\n    cin >> t_size;\n    vector<int> t(t_size);\n    for (int i = 0; i < t_size; i++) cin >> t[i];\n    minWindow(s, t);\n    return 0;\n}\n",
        "expectedOutput": "BANC",
        "solution": "#include <iostream>\nusing namespace std;\nvoid minWindow(char s[], char t[]) { int need[256]={},have[256]={},req=0; for(int i=0;t[i];i++) if(need[(int)t[i]]++==0) req++; int l=0,minL=1e9,start=0,formed=0,n=0; while(s[n]) n++; for(int r=0;r<n;r++) { have[(int)s[r]]++; if(need[(int)s[r]]&&have[(int)s[r]]==need[(int)s[r]]) formed++; while(formed==req) { if(r-l+1<minL) { minL=r-l+1; start=l; } have[(int)s[l]]--; if(need[(int)s[l]]&&have[(int)s[l]]<need[(int)s[l]]) formed--; l++; } } if(minL<1e9) for(int i=start;i<start+minL;i++) cout<<s[i]; }\nint main() { minWindow(\"ADOBECODEBANC\",\"ABC\"); return 0; }",
        "explanation": {
            "approach": "Sliding window with char counts.",
            "steps": [
                "Expand right until valid",
                "Shrink left while valid"
            ],
            "complexity": "Time: O(n), Space: O(1)"
        },
        "testCases": [
            {
                "input": "s=\"ADOBECODEBANC\", t=\"ABC\"",
                "expectedOutput": "BANC",
                "explanation": "BANC contains A, B, C"
            },
            {
                "input": "s=\"a\", t=\"a\"",
                "expectedOutput": "a",
                "explanation": "Single char match"
            },
            {
                "input": "s=\"a\", t=\"aa\"",
                "expectedOutput": "",
                "explanation": "Not enough chars"
            },
            {
                "input": "s=\"ab\", t=\"b\"",
                "expectedOutput": "b",
                "explanation": "Smallest window is just b"
            }
        ]
    },
    {
        "id": "h24",
        "title": "Substring with Concatenation",
        "description": "All starting indices.",
        "difficulty": "HARD",
        "category": "Sliding Window",
        "starterCode": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nvoid findSubstring(vector<int>& s, vector<vector<int>>& words, int n) {\n    // TODO\n}\n\nint main() {\n    int s_size;\n    cin >> s_size;\n    vector<int> s(s_size);\n    for (int i = 0; i < s_size; i++) cin >> s[i];\n    int words_rows, words_cols;\n    cin >> words_rows >> words_cols;\n    vector<vector<int>> words(words_rows, vector<int>(words_cols));\n    for (int i = 0; i < words_rows; i++)\n        for (int j = 0; j < words_cols; j++)\n            cin >> words[i][j];\n    int n;\n    cin >> n;\n    findSubstring(s, words, n);\n    return 0;\n}\n",
        "expectedOutput": "0 9",
        "solution": "#include <iostream>\nusing namespace std;\nbool eq(char a[], char b[]) { int i=0; while(a[i]&&a[i]==b[i]) i++; return !a[i]&&!b[i]; }\nvoid findSubstring(char s[], char words[][10], int n) { if(n==0) return; int wl=0; while(words[0][wl]) wl++; int slen=0; while(s[slen]) slen++; int total=n*wl; for(int i=0;i<=slen-total;i++) { int used[10]={}; int matched=0; for(int j=0;j<n;j++) { char sub[11]; for(int k=0;k<wl;k++) sub[k]=s[i+j*wl+k]; sub[wl]=0; bool found=false; for(int k=0;k<n;k++) if(!used[k]&&eq(sub,words[k])) { used[k]=1; found=true; matched++; break; } if(!found) break; } if(matched==n) cout<<i<<\" \"; } }\nint main() { char w[][10]={\"foo\",\"bar\"}; findSubstring(\"barfoothefoobarman\",w,2); return 0; }",
        "explanation": {
            "approach": "Check each starting position.",
            "steps": [
                "For each start, check all words",
                "Track used words"
            ],
            "complexity": "Time: O(L × n × wl), Space: O(n)"
        },
        "testCases": [
            {
                "input": "\"barfoothefoobarman\", [\"foo\",\"bar\"]",
                "expectedOutput": "0 9",
                "explanation": "barfoo at 0, foobar at 9"
            },
            {
                "input": "\"wordgoodgoodgoodbestword\", [\"word\",\"good\",\"best\",\"word\"]",
                "expectedOutput": "",
                "explanation": "No valid concatenation"
            },
            {
                "input": "\"barfoofoobarthefoobarman\", [\"bar\",\"foo\",\"the\"]",
                "expectedOutput": "6 9 12",
                "explanation": "Multiple matches"
            },
            {
                "input": "\"wordwordword\", [\"word\",\"word\"]",
                "expectedOutput": "0 4",
                "explanation": "Overlapping word matches"
            }
        ]
    }
]