[
    {
        "id": "prac21",
        "title": "Pointers Swap",
        "description": "Swap using pointers.",
        "difficulty": "EASY",
        "category": "Pointers",
        "starterCode": "#include <iostream>\nusing namespace std;\nvoid swapPtr(int *a, int *b) {}\nint main() { int x=5,y=10; swapPtr(&x,&y); cout<<x<<\" \"<<y; return 0; }",
        "expectedOutput": "10 5",
        "solution": "#include <iostream>\nusing namespace std;\nvoid swapPtr(int *a, int *b) { int t=*a; *a=*b; *b=t; }\nint main() { int x=5,y=10; swapPtr(&x,&y); cout<<x<<\" \"<<y; return 0; }",
        "explanation": {
            "approach": "Use pointers to swap values.",
            "analogy": "Dereference to access values.",
            "steps": [
                "Save *a",
                "Assign *b to *a",
                "Assign saved to *b"
            ],
            "complexity": "Time: O(1), Space: O(1)"
        },
        "testCases": [
            {
                "input": "x=5, y=10",
                "expectedOutput": "10 5",
                "explanation": "Swapped successfully"
            },
            {
                "input": "x=0, y=0",
                "expectedOutput": "0 0",
                "explanation": "Same values unchanged"
            },
            {
                "input": "x=-1, y=1",
                "expectedOutput": "1 -1",
                "explanation": "Negative and positive swapped"
            },
            {
                "input": "x=100, y=200",
                "expectedOutput": "200 100",
                "explanation": "Larger values swapped"
            }
        ]
    },
    {
        "id": "prac22",
        "title": "Pointer Arithmetic",
        "description": "Traverse array with pointer.",
        "difficulty": "EASY",
        "category": "Pointers",
        "starterCode": "#include <iostream>\nusing namespace std;\nvoid printArr(int *a, int n) {}\nint main() { int a[]={1,2,3,4,5}; printArr(a,5); return 0; }",
        "expectedOutput": "1 2 3 4 5",
        "solution": "#include <iostream>\nusing namespace std;\nvoid printArr(int *a, int n) { for(int i=0;i<n;i++) cout<<*(a+i)<<\" \"; }\nint main() { int a[]={1,2,3,4,5}; printArr(a,5); return 0; }",
        "explanation": {
            "approach": "Use pointer arithmetic to traverse.",
            "analogy": "a+i points to ith element.",
            "steps": [
                "*(a+i) gives value at index i"
            ],
            "complexity": "Time: O(n), Space: O(1)"
        },
        "testCases": [
            {
                "input": "{1,2,3,4,5}",
                "expectedOutput": "1 2 3 4 5",
                "explanation": "All elements printed"
            },
            {
                "input": "{42}",
                "expectedOutput": "42",
                "explanation": "Single element"
            },
            {
                "input": "{-1,0,1}",
                "expectedOutput": "-1 0 1",
                "explanation": "Mixed values"
            },
            {
                "input": "{10,20,30,40}",
                "expectedOutput": "10 20 30 40",
                "explanation": "Multiple elements"
            }
        ]
    },
    {
        "id": "prac23",
        "title": "Function Overloading",
        "description": "Overload add function.",
        "difficulty": "EASY",
        "category": "OOP",
        "starterCode": "#include <iostream>\nusing namespace std;\nint add2(int a, int b) { return 0; }\nint add3(int a, int b, int c) { return 0; }\nint main() { cout<<add2(1,2)<<\" \"<<add3(1,2,3); return 0; }",
        "expectedOutput": "3 6",
        "solution": "#include <iostream>\nusing namespace std;\nint add2(int a, int b) { return a+b; }\nint add3(int a, int b, int c) { return a+b+c; }\nint main() { cout<<add2(1,2)<<\" \"<<add3(1,2,3); return 0; }",
        "explanation": {
            "approach": "Same function name, different parameters.",
            "analogy": "Choose version based on arguments.",
            "steps": [
                "2-param version adds 2",
                "3-param adds 3"
            ],
            "complexity": "Time: O(1), Space: O(1)"
        },
        "testCases": [
            {
                "input": "add2(1,2), add3(1,2,3)",
                "expectedOutput": "3 6",
                "explanation": "Both overloads work"
            },
            {
                "input": "add2(0,0)",
                "expectedOutput": "0",
                "explanation": "Zero sum"
            },
            {
                "input": "add3(10,20,30)",
                "expectedOutput": "60",
                "explanation": "Larger values"
            },
            {
                "input": "add2(-5,5)",
                "expectedOutput": "0",
                "explanation": "Opposite numbers"
            }
        ]
    },
    {
        "id": "prac24",
        "title": "Constructor Example",
        "description": "Class with constructor.",
        "difficulty": "EASY",
        "category": "OOP",
        "starterCode": "#include <iostream>\nusing namespace std;\nclass Box { int w,h; public: Box(int w, int h) : w(0), h(0) {} int area() { return 0; } };\nint main() { Box b(5,3); cout<<b.area(); return 0; }",
        "expectedOutput": "15",
        "solution": "#include <iostream>\nusing namespace std;\nclass Box { int w,h; public: Box(int w, int h) : w(w), h(h) {} int area() { return w*h; } };\nint main() { Box b(5,3); cout<<b.area(); return 0; }",
        "explanation": {
            "approach": "Initialize members in constructor.",
            "analogy": "Constructor sets up object.",
            "steps": [
                "Constructor initializes w and h",
                "area() returns w×h"
            ],
            "complexity": "Time: O(1), Space: O(1)"
        },
        "testCases": [
            {
                "input": "Box(5,3)",
                "expectedOutput": "15",
                "explanation": "5 × 3 = 15"
            },
            {
                "input": "Box(10,10)",
                "expectedOutput": "100",
                "explanation": "Square box"
            },
            {
                "input": "Box(1,1)",
                "expectedOutput": "1",
                "explanation": "Minimum size"
            },
            {
                "input": "Box(7,4)",
                "expectedOutput": "28",
                "explanation": "7 × 4 = 28"
            }
        ]
    },
    {
        "id": "prac25",
        "title": "Inheritance Example",
        "description": "Basic inheritance.",
        "difficulty": "EASY",
        "category": "OOP",
        "starterCode": "#include <iostream>\nusing namespace std;\nclass Animal { public: void speak() {} };\nclass Dog : public Animal { public: void speak() {} };\nint main() { Dog d; d.speak(); return 0; }",
        "expectedOutput": "Woof",
        "solution": "#include <iostream>\nusing namespace std;\nclass Animal { public: virtual void speak() { cout<<\"Sound\"; } };\nclass Dog : public Animal { public: void speak() override { cout<<\"Woof\"; } };\nint main() { Dog d; d.speak(); return 0; }",
        "explanation": {
            "approach": "Child overrides parent method.",
            "analogy": "Dog is-a Animal.",
            "steps": [
                "Dog inherits from Animal",
                "Dog overrides speak()"
            ],
            "complexity": "Time: O(1), Space: O(1)"
        },
        "testCases": [
            {
                "input": "Dog d; d.speak()",
                "expectedOutput": "Woof",
                "explanation": "Dog speaks Woof"
            },
            {
                "input": "Animal a; a.speak()",
                "expectedOutput": "Sound",
                "explanation": "Base class sound"
            },
            {
                "input": "polymorphism test",
                "expectedOutput": "Woof",
                "explanation": "Virtual dispatch works"
            },
            {
                "input": "Dog* dp; dp->speak()",
                "expectedOutput": "Woof",
                "explanation": "Pointer to Dog"
            }
        ]
    },
    {
        "id": "extra11",
        "title": "Minimum Difference BST",
        "description": "Min difference between nodes.",
        "difficulty": "MEDIUM",
        "category": "Trees",
        "starterCode": "#include <iostream>\nusing namespace std;\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\nint minDiff(Node* r) { return 0; }\nint main() { Node* r=new Node(4); r->l=new Node(2); r->r=new Node(6); r->l->l=new Node(1); r->l->r=new Node(3); cout<<minDiff(r); return 0; }",
        "expectedOutput": "1",
        "solution": "#include <iostream>\nusing namespace std;\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\nint prev_val=-1,minD=1e9;\nvoid inorder(Node* r) { if(!r) return; inorder(r->l); if(prev_val>=0) minD=min(minD,r->v-prev_val); prev_val=r->v; inorder(r->r); }\nint minDiff(Node* r) { prev_val=-1; minD=1e9; inorder(r); return minD; }\nint main() { Node* r=new Node(4); r->l=new Node(2); r->r=new Node(6); r->l->l=new Node(1); r->l->r=new Node(3); cout<<minDiff(r); return 0; }",
        "explanation": {
            "approach": "Inorder gives sorted, check consecutive.",
            "analogy": "Adjacent in sorted order.",
            "steps": [
                "Inorder traversal",
                "Track previous and diff"
            ],
            "complexity": "Time: O(n), Space: O(h)"
        },
        "testCases": [
            {
                "input": "[4,2,6,1,3]",
                "expectedOutput": "1",
                "explanation": "Min diff between consecutive nodes"
            },
            {
                "input": "[1,null,3,2]",
                "expectedOutput": "1",
                "explanation": "Diff between 1-2 or 2-3"
            },
            {
                "input": "[1,null,5]",
                "expectedOutput": "4",
                "explanation": "Only two nodes"
            },
            {
                "input": "[10,5,15]",
                "expectedOutput": "5",
                "explanation": "Consecutive diffs of 5"
            }
        ]
    },
    {
        "id": "extra12",
        "title": "Serialize Binary Tree",
        "description": "Encode tree to string.",
        "difficulty": "HARD",
        "category": "Trees",
        "starterCode": "#include <iostream>\nusing namespace std;\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\nvoid serialize(Node* r) {}\nint main() { Node* r=new Node(1); r->l=new Node(2); r->r=new Node(3); r->r->l=new Node(4); r->r->r=new Node(5); serialize(r); return 0; }",
        "expectedOutput": "1 2 # # 3 4 # # 5 # #",
        "solution": "#include <iostream>\nusing namespace std;\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\nvoid serialize(Node* r) { if(!r) { cout<<\"# \"; return; } cout<<r->v<<\" \"; serialize(r->l); serialize(r->r); }\nint main() { Node* r=new Node(1); r->l=new Node(2); r->r=new Node(3); r->r->l=new Node(4); r->r->r=new Node(5); serialize(r); return 0; }",
        "explanation": {
            "approach": "Preorder with null markers.",
            "analogy": "Encode structure with placeholders.",
            "steps": [
                "Print value or # for null",
                "Recurse left then right"
            ],
            "complexity": "Time: O(n), Space: O(n)"
        },
        "testCases": [
            {
                "input": "[1,2,3,null,null,4,5]",
                "expectedOutput": "1 2 # # 3 4 # # 5 # #",
                "explanation": "Preorder with null markers"
            },
            {
                "input": "[1]",
                "expectedOutput": "1 # #",
                "explanation": "Single node"
            },
            {
                "input": "[]",
                "expectedOutput": "#",
                "explanation": "Empty tree"
            },
            {
                "input": "[1,2,3]",
                "expectedOutput": "1 2 # # 3 # #",
                "explanation": "Complete binary tree"
            }
        ]
    },
    {
        "id": "extra13",
        "title": "Sliding Window Max",
        "description": "Maximum in each window.",
        "difficulty": "HARD",
        "category": "Sliding Window",
        "starterCode": "#include <iostream>\nusing namespace std;\nvoid maxSliding(int a[], int n, int k) {}\nint main() { int a[]={1,3,-1,-3,5,3,6,7}; maxSliding(a,8,3); return 0; }",
        "expectedOutput": "3 3 5 5 6 7",
        "solution": "#include <iostream>\nusing namespace std;\nvoid maxSliding(int a[], int n, int k) { int dq[n],f=0,r=0; for(int i=0;i<n;i++) { while(f<r && dq[f]<=i-k) f++; while(f<r && a[dq[r-1]]<=a[i]) r--; dq[r++]=i; if(i>=k-1) cout<<a[dq[f]]<<\" \"; } }\nint main() { int a[]={1,3,-1,-3,5,3,6,7}; maxSliding(a,8,3); return 0; }",
        "explanation": {
            "approach": "Monotonic deque.",
            "analogy": "Keep only useful candidates.",
            "steps": [
                "Remove out of window",
                "Remove smaller from back",
                "Front is max"
            ],
            "complexity": "Time: O(n), Space: O(k)"
        },
        "testCases": [
            {
                "input": "{1,3,-1,-3,5,3,6,7}, k=3",
                "expectedOutput": "3 3 5 5 6 7",
                "explanation": "Max in each window of 3"
            },
            {
                "input": "{1,2,3,4,5}, k=2",
                "expectedOutput": "2 3 4 5",
                "explanation": "Increasing array"
            },
            {
                "input": "{9,8,7,6}, k=2",
                "expectedOutput": "9 8 7",
                "explanation": "Decreasing array"
            },
            {
                "input": "{1}, k=1",
                "expectedOutput": "1",
                "explanation": "Single element"
            }
        ]
    },
    {
        "id": "extra14",
        "title": "Subarray Sum K",
        "description": "Count subarrays with sum k.",
        "difficulty": "MEDIUM",
        "category": "Hashing",
        "starterCode": "#include <iostream>\nusing namespace std;\nint subarraySum(int a[], int n, int k) { return 0; }\nint main() { int a[]={1,1,1}; cout<<subarraySum(a,3,2); return 0; }",
        "expectedOutput": "2",
        "solution": "#include <iostream>\nusing namespace std;\nint subarraySum(int a[], int n, int k) { int c=0; for(int i=0;i<n;i++) { int s=0; for(int j=i;j<n;j++) { s+=a[j]; if(s==k) c++; } } return c; }\nint main() { int a[]={1,1,1}; cout<<subarraySum(a,3,2); return 0; }",
        "explanation": {
            "approach": "Check all subarrays.",
            "analogy": "Count matching sums.",
            "steps": [
                "For each start, sum to each end"
            ],
            "complexity": "Time: O(n²), Space: O(1)"
        },
        "testCases": [
            {
                "input": "{1,1,1}, k=2",
                "expectedOutput": "2",
                "explanation": "[0:1] and [1:2] sum to 2"
            },
            {
                "input": "{1,2,3}, k=3",
                "expectedOutput": "2",
                "explanation": "[0:1] and [2] sum to 3"
            },
            {
                "input": "{1}, k=0",
                "expectedOutput": "0",
                "explanation": "No subarray sums to 0"
            },
            {
                "input": "{3,-3,3}, k=3",
                "expectedOutput": "2",
                "explanation": "[0] and [0:2] and [2]"
            }
        ]
    },
    {
        "id": "extra15",
        "title": "Longest Substring No Repeat",
        "description": "Longest unique char substring.",
        "difficulty": "MEDIUM",
        "category": "Sliding Window",
        "starterCode": "#include <iostream>\nusing namespace std;\nint lengthOfLongest(char s[]) { return 0; }\nint main() { cout<<lengthOfLongest(\"abcabcbb\"); return 0; }",
        "expectedOutput": "3",
        "solution": "#include <iostream>\nusing namespace std;\nint lengthOfLongest(char s[]) { int seen[256]={}; int mx=0,l=0; for(int r=0;s[r];r++) { while(seen[(int)s[r]]) { seen[(int)s[l]]=0; l++; } seen[(int)s[r]]=1; mx=max(mx,r-l+1); } return mx; }\nint main() { cout<<lengthOfLongest(\"abcabcbb\"); return 0; }",
        "explanation": {
            "approach": "Sliding window with set.",
            "analogy": "Shrink when duplicate found.",
            "steps": [
                "Expand right",
                "Shrink left until unique"
            ],
            "complexity": "Time: O(n), Space: O(1)"
        },
        "testCases": [
            {
                "input": "\"abcabcbb\"",
                "expectedOutput": "3",
                "explanation": "abc is longest unique"
            },
            {
                "input": "\"bbbbb\"",
                "expectedOutput": "1",
                "explanation": "All same chars"
            },
            {
                "input": "\"pwwkew\"",
                "expectedOutput": "3",
                "explanation": "wke is longest"
            },
            {
                "input": "\"\"",
                "expectedOutput": "0",
                "explanation": "Empty string"
            }
        ]
    }
]