[
    {
        "id": "core46",
        "title": "N Queens Count",
        "description": "Count N-Queens solutions.",
        "difficulty": "HARD",
        "category": "Backtracking",
        "starterCode": "#include <iostream>\nusing namespace std;\nint solveNQueens(int n) { return 0; }\nint main() { cout<<solveNQueens(4); return 0; }",
        "expectedOutput": "2",
        "solution": "#include <iostream>\nusing namespace std;\nint cnt; bool col[20],d1[40],d2[40];\nvoid solve(int r, int n) { if(r==n){cnt++;return;} for(int c=0;c<n;c++) if(!col[c]&&!d1[r-c+n]&&!d2[r+c]) { col[c]=d1[r-c+n]=d2[r+c]=1; solve(r+1,n); col[c]=d1[r-c+n]=d2[r+c]=0; } }\nint solveNQueens(int n) { cnt=0; solve(0,n); return cnt; }\nint main() { cout<<solveNQueens(4); return 0; }",
        "explanation": {
            "approach": "Backtracking with column and diagonal tracking.",
            "steps": [
                "Place queen in each valid column",
                "Check column and diagonals"
            ],
            "complexity": "Time: O(n!), Space: O(n)"
        },
        "testCases": [
            {
                "input": "n=4",
                "expectedOutput": "2",
                "explanation": "Two distinct solutions"
            },
            {
                "input": "n=1",
                "expectedOutput": "1",
                "explanation": "Single cell, single queen"
            },
            {
                "input": "n=8",
                "expectedOutput": "92",
                "explanation": "Classic 8-queens"
            },
            {
                "input": "n=2",
                "expectedOutput": "0",
                "explanation": "No valid arrangement"
            }
        ]
    },
    {
        "id": "core47",
        "title": "Sudoku Solver",
        "description": "Solve sudoku puzzle.",
        "difficulty": "HARD",
        "category": "Backtracking",
        "starterCode": "#include <iostream>\nusing namespace std;\nbool solveSudoku(int b[][9]) { return false; }\nint main() { int b[9][9]={{5,3,0,0,7,0,0,0,0},{6,0,0,1,9,5,0,0,0},{0,9,8,0,0,0,0,6,0},{8,0,0,0,6,0,0,0,3},{4,0,0,8,0,3,0,0,1},{7,0,0,0,2,0,0,0,6},{0,6,0,0,0,0,2,8,0},{0,0,0,4,1,9,0,0,5},{0,0,0,0,8,0,0,7,9}}; cout<<solveSudoku(b); return 0; }",
        "expectedOutput": "1",
        "solution": "#include <iostream>\nusing namespace std;\nbool isValid(int b[][9], int r, int c, int n) { for(int i=0;i<9;i++) if(b[r][i]==n||b[i][c]==n) return false; int br=r-r%3, bc=c-c%3; for(int i=0;i<3;i++) for(int j=0;j<3;j++) if(b[br+i][bc+j]==n) return false; return true; }\nbool solve(int b[][9]) { for(int r=0;r<9;r++) for(int c=0;c<9;c++) if(b[r][c]==0) { for(int n=1;n<=9;n++) if(isValid(b,r,c,n)) { b[r][c]=n; if(solve(b)) return true; b[r][c]=0; } return false; } return true; }\nbool solveSudoku(int b[][9]) { return solve(b); }\nint main() { int b[9][9]={{5,3,0,0,7,0,0,0,0},{6,0,0,1,9,5,0,0,0},{0,9,8,0,0,0,0,6,0},{8,0,0,0,6,0,0,0,3},{4,0,0,8,0,3,0,0,1},{7,0,0,0,2,0,0,0,6},{0,6,0,0,0,0,2,8,0},{0,0,0,4,1,9,0,0,5},{0,0,0,0,8,0,0,7,9}}; cout<<solveSudoku(b); return 0; }",
        "explanation": {
            "approach": "Backtracking with constraint checking.",
            "steps": [
                "Find empty cell",
                "Try 1-9",
                "Backtrack if invalid"
            ],
            "complexity": "Time: O(9^81), Space: O(81)"
        },
        "testCases": [
            {
                "input": "Valid sudoku puzzle",
                "expectedOutput": "1",
                "explanation": "Solvable puzzle"
            },
            {
                "input": "Already solved sudoku",
                "expectedOutput": "1",
                "explanation": "No empty cells"
            },
            {
                "input": "Easy puzzle (few blanks)",
                "expectedOutput": "1",
                "explanation": "Quick solve"
            },
            {
                "input": "Hard puzzle (many blanks)",
                "expectedOutput": "1",
                "explanation": "More backtracking"
            }
        ]
    },
    {
        "id": "core48",
        "title": "Generate Parentheses",
        "description": "All valid parentheses for n pairs.",
        "difficulty": "MEDIUM",
        "category": "Backtracking",
        "starterCode": "#include <iostream>\nusing namespace std;\nvoid generate(int n) {}\nint main() { generate(3); return 0; }",
        "expectedOutput": "((()))(()())(())()(())()(())",
        "solution": "#include <iostream>\nusing namespace std;\nvoid gen(char s[], int i, int o, int c, int n) { if(i==2*n) { s[i]=0; cout<<s; return; } if(o<n) { s[i]='('; gen(s,i+1,o+1,c,n); } if(c<o) { s[i]=')'; gen(s,i+1,o,c+1,n); } }\nvoid generate(int n) { char s[20]; gen(s,0,0,0,n); }\nint main() { generate(3); return 0; }",
        "explanation": {
            "approach": "Track open and close counts.",
            "steps": [
                "Add ( if open < n",
                "Add ) if close < open"
            ],
            "complexity": "Time: O(4^n/√n), Space: O(n)"
        },
        "testCases": [
            {
                "input": "n=3",
                "expectedOutput": "((()))(()())(())()(())()(())",
                "explanation": "5 combinations for 3 pairs"
            },
            {
                "input": "n=1",
                "expectedOutput": "()",
                "explanation": "Only one way"
            },
            {
                "input": "n=2",
                "expectedOutput": "(())()()",
                "explanation": "Two combinations"
            },
            {
                "input": "n=0",
                "expectedOutput": "",
                "explanation": "No parentheses"
            }
        ]
    },
    {
        "id": "core49",
        "title": "Combination Sum",
        "description": "Find combinations summing to target (can reuse).",
        "difficulty": "MEDIUM",
        "category": "Backtracking",
        "starterCode": "#include <iostream>\nusing namespace std;\nvoid combSum(int a[], int n, int t) {}\nint main() { int a[]={2,3,6,7}; combSum(a,4,7); return 0; }",
        "expectedOutput": "2 2 3 7",
        "solution": "#include <iostream>\nusing namespace std;\nvoid solve(int a[], int n, int t, int i, int c[], int k) { if(t==0) { for(int j=0;j<k;j++) cout<<c[j]<<\" \"; return; } if(t<0||i>=n) return; c[k]=a[i]; solve(a,n,t-a[i],i,c,k+1); solve(a,n,t,i+1,c,k); }\nvoid combSum(int a[], int n, int t) { int c[20]; solve(a,n,t,0,c,0); }\nint main() { int a[]={2,3,6,7}; combSum(a,4,7); return 0; }",
        "explanation": {
            "approach": "Include (possibly multiple) or skip.",
            "steps": [
                "Include current, stay at index",
                "Or skip to next"
            ],
            "complexity": "Time: O(2^target), Space: O(target)"
        },
        "testCases": [
            {
                "input": "a=[2,3,6,7], t=7",
                "expectedOutput": "2 2 3 7",
                "explanation": "2+2+3=7 and 7=7"
            },
            {
                "input": "a=[2,3,5], t=8",
                "expectedOutput": "2 2 2 2 2 3 3 3 5",
                "explanation": "Multiple combos"
            },
            {
                "input": "a=[2], t=1",
                "expectedOutput": "",
                "explanation": "No valid combination"
            },
            {
                "input": "a=[1], t=2",
                "expectedOutput": "1 1",
                "explanation": "Use 1 twice"
            }
        ]
    },
    {
        "id": "core50",
        "title": "Permutations",
        "description": "Generate all permutations of array.",
        "difficulty": "MEDIUM",
        "category": "Backtracking",
        "starterCode": "#include <iostream>\nusing namespace std;\nvoid permute(int a[], int n) {}\nint main() { int a[]={1,2,3}; permute(a,3); return 0; }",
        "expectedOutput": "1 2 3 1 3 2 2 1 3 2 3 1 3 2 1 3 1 2",
        "solution": "#include <iostream>\nusing namespace std;\nvoid perm(int a[], int l, int r) { if(l==r) { for(int i=0;i<=r;i++) cout<<a[i]<<\" \"; return; } for(int i=l;i<=r;i++) { swap(a[l],a[i]); perm(a,l+1,r); swap(a[l],a[i]); } }\nvoid permute(int a[], int n) { perm(a,0,n-1); }\nint main() { int a[]={1,2,3}; permute(a,3); return 0; }",
        "explanation": {
            "approach": "Swap each element to front, permute rest.",
            "steps": [
                "Swap current with each position",
                "Recurse on rest"
            ],
            "complexity": "Time: O(n!), Space: O(n)"
        },
        "testCases": [
            {
                "input": "[1,2,3]",
                "expectedOutput": "6 permutations",
                "explanation": "3!=6 arrangements"
            },
            {
                "input": "[1,2]",
                "expectedOutput": "1 2 2 1",
                "explanation": "2 permutations"
            },
            {
                "input": "[1]",
                "expectedOutput": "1",
                "explanation": "Single element"
            },
            {
                "input": "[1,2,3,4]",
                "expectedOutput": "24 permutations",
                "explanation": "4!=24"
            }
        ]
    },
    {
        "id": "core51",
        "title": "Word Search",
        "description": "Find word in character grid.",
        "difficulty": "MEDIUM",
        "category": "Backtracking",
        "starterCode": "#include <iostream>\nusing namespace std;\nbool exist(char b[][4], int r, int c, char w[]) { return false; }\nint main() { char b[][4]={{'A','B','C','E'},{'S','F','C','S'},{'A','D','E','E'}}; cout<<exist(b,3,4,\"ABCCED\"); return 0; }",
        "expectedOutput": "1",
        "solution": "#include <iostream>\nusing namespace std;\nbool dfs(char b[][4], int r, int c, int i, int j, char w[], int k) { if(!w[k]) return true; if(i<0||i>=r||j<0||j>=c||b[i][j]!=w[k]) return false; char t=b[i][j]; b[i][j]='#'; bool f=dfs(b,r,c,i+1,j,w,k+1)||dfs(b,r,c,i-1,j,w,k+1)||dfs(b,r,c,i,j+1,w,k+1)||dfs(b,r,c,i,j-1,w,k+1); b[i][j]=t; return f; }\nbool exist(char b[][4], int r, int c, char w[]) { for(int i=0;i<r;i++) for(int j=0;j<c;j++) if(dfs(b,r,c,i,j,w,0)) return true; return false; }\nint main() { char b[][4]={{'A','B','C','E'},{'S','F','C','S'},{'A','D','E','E'}}; cout<<exist(b,3,4,\"ABCCED\"); return 0; }",
        "explanation": {
            "approach": "DFS from each cell, mark visited.",
            "steps": [
                "Try each starting cell",
                "DFS in 4 directions"
            ],
            "complexity": "Time: O(r×c×4^L), Space: O(L)"
        },
        "testCases": [
            {
                "input": "grid with 'ABCCED'",
                "expectedOutput": "1",
                "explanation": "Word exists"
            },
            {
                "input": "grid with 'SEE'",
                "expectedOutput": "1",
                "explanation": "Another word"
            },
            {
                "input": "grid with 'ABCB'",
                "expectedOutput": "0",
                "explanation": "Can't reuse cells"
            },
            {
                "input": "single cell 'A', word='A'",
                "expectedOutput": "1",
                "explanation": "Match"
            }
        ]
    },
    {
        "id": "core52",
        "title": "Palindrome Partitioning",
        "description": "Find all palindrome partitions of string.",
        "difficulty": "MEDIUM",
        "category": "Backtracking",
        "starterCode": "#include <iostream>\nusing namespace std;\nvoid partition(char s[]) {}\nint main() { partition(\"aab\"); return 0; }",
        "expectedOutput": "a a b aa b",
        "solution": "#include <iostream>\nusing namespace std;\nbool isPalin(char s[], int l, int r) { while(l<r) if(s[l++]!=s[r--]) return false; return true; }\nvoid solve(char s[], int start, char cur[][10], int k, int n) { if(start>=n) { for(int i=0;i<k;i++) cout<<cur[i]<<\" \"; return; } for(int end=start;end<n;end++) if(isPalin(s,start,end)) { int len=0; for(int i=start;i<=end;i++) cur[k][len++]=s[i]; cur[k][len]=0; solve(s,end+1,cur,k+1,n); } }\nvoid partition(char s[]) { int n=0; while(s[n]) n++; char cur[10][10]; solve(s,0,cur,0,n); }\nint main() { partition(\"aab\"); return 0; }",
        "explanation": {
            "approach": "Try all palindrome substrings.",
            "steps": [
                "For each position, try all palindrome cuts"
            ],
            "complexity": "Time: O(n × 2^n), Space: O(n)"
        },
        "testCases": [
            {
                "input": "s='aab'",
                "expectedOutput": "[a,a,b] [aa,b]",
                "explanation": "Two valid partitions"
            },
            {
                "input": "s='a'",
                "expectedOutput": "[a]",
                "explanation": "Single char"
            },
            {
                "input": "s='aba'",
                "expectedOutput": "[a,b,a] [aba]",
                "explanation": "Whole string is palindrome"
            },
            {
                "input": "s='abc'",
                "expectedOutput": "[a,b,c]",
                "explanation": "No multi-char palindromes"
            }
        ]
    },
    {
        "id": "core53",
        "title": "Letter Combinations",
        "description": "Phone number letter combinations.",
        "difficulty": "MEDIUM",
        "category": "Backtracking",
        "starterCode": "#include <iostream>\nusing namespace std;\nvoid letterCombos(char d[]) {}\nint main() { letterCombos(\"23\"); return 0; }",
        "expectedOutput": "ad ae af bd be bf cd ce cf",
        "solution": "#include <iostream>\nusing namespace std;\nconst char* map[]={\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\nvoid solve(char d[], int i, char r[], int k, int n) { if(i==n) { r[k]=0; cout<<r<<\" \"; return; } const char* letters=map[d[i]-'2']; for(int j=0;letters[j];j++) { r[k]=letters[j]; solve(d,i+1,r,k+1,n); } }\nvoid letterCombos(char d[]) { int n=0; while(d[n]) n++; if(n==0) return; char r[10]; solve(d,0,r,0,n); }\nint main() { letterCombos(\"23\"); return 0; }",
        "explanation": {
            "approach": "Map digits to letters, generate combos.",
            "steps": [
                "Map each digit to letters",
                "Try each letter, recurse"
            ],
            "complexity": "Time: O(4^n), Space: O(n)"
        },
        "testCases": [
            {
                "input": "d='23'",
                "expectedOutput": "ad ae af bd be bf cd ce cf",
                "explanation": "9 combinations"
            },
            {
                "input": "d='2'",
                "expectedOutput": "a b c",
                "explanation": "3 letters for digit 2"
            },
            {
                "input": "d=''",
                "expectedOutput": "",
                "explanation": "Empty input"
            },
            {
                "input": "d='7'",
                "expectedOutput": "p q r s",
                "explanation": "4 letters for digit 7"
            }
        ]
    },
    {
        "id": "core54",
        "title": "Subsets II",
        "description": "Generate subsets with duplicates.",
        "difficulty": "MEDIUM",
        "category": "Backtracking",
        "starterCode": "#include <iostream>\nusing namespace std;\nvoid subsetsWithDup(int a[], int n) {}\nint main() { int a[]={1,2,2}; subsetsWithDup(a,3); return 0; }",
        "expectedOutput": "{} {1} {1 2} {1 2 2} {2} {2 2}",
        "solution": "#include <iostream>\nusing namespace std;\nvoid solve(int a[], int n, int i, int c[], int k) { cout<<\"{\"; for(int j=0;j<k;j++) cout<<(j?\" \":\"\")<<c[j]; cout<<\"} \"; for(int j=i;j<n;j++) { if(j>i && a[j]==a[j-1]) continue; c[k]=a[j]; solve(a,n,j+1,c,k+1); } }\nvoid subsetsWithDup(int a[], int n) { for(int i=0;i<n-1;i++) for(int j=0;j<n-i-1;j++) if(a[j]>a[j+1]) swap(a[j],a[j+1]); int c[10]; solve(a,n,0,c,0); }\nint main() { int a[]={1,2,2}; subsetsWithDup(a,3); return 0; }",
        "explanation": {
            "approach": "Sort and skip consecutive duplicates.",
            "steps": [
                "Sort array",
                "Skip if same as previous at same level"
            ],
            "complexity": "Time: O(2^n), Space: O(n)"
        },
        "testCases": [
            {
                "input": "[1,2,2]",
                "expectedOutput": "6 unique subsets",
                "explanation": "Handles duplicates"
            },
            {
                "input": "[0]",
                "expectedOutput": "{} {0}",
                "explanation": "Single element"
            },
            {
                "input": "[1,1,1]",
                "expectedOutput": "{} {1} {1,1} {1,1,1}",
                "explanation": "All same"
            },
            {
                "input": "[1,2,3]",
                "expectedOutput": "8 subsets",
                "explanation": "No dups, all combos"
            }
        ]
    },
    {
        "id": "core55",
        "title": "Combination Sum III",
        "description": "Find k numbers from 1-9 summing to n.",
        "difficulty": "MEDIUM",
        "category": "Backtracking",
        "starterCode": "#include <iostream>\nusing namespace std;\nvoid combSum3(int k, int n) {}\nint main() { combSum3(3,9); return 0; }",
        "expectedOutput": "1 2 6 1 3 5 2 3 4",
        "solution": "#include <iostream>\nusing namespace std;\nvoid solve(int k, int n, int start, int c[], int cnt) { if(cnt==k && n==0) { for(int i=0;i<k;i++) cout<<c[i]<<\" \"; return; } if(cnt>=k||n<=0) return; for(int i=start;i<=9;i++) { c[cnt]=i; solve(k,n-i,i+1,c,cnt+1); } }\nvoid combSum3(int k, int n) { int c[10]; solve(k,n,1,c,0); }\nint main() { combSum3(3,9); return 0; }",
        "explanation": {
            "approach": "Pick k numbers from 1-9 summing to n.",
            "steps": [
                "Try each number 1-9",
                "Track count and sum"
            ],
            "complexity": "Time: O(C(9,k)), Space: O(k)"
        },
        "testCases": [
            {
                "input": "k=3, n=9",
                "expectedOutput": "[1,2,6] [1,3,5] [2,3,4]",
                "explanation": "Three combos"
            },
            {
                "input": "k=3, n=7",
                "expectedOutput": "[1,2,4]",
                "explanation": "Only one combo"
            },
            {
                "input": "k=2, n=18",
                "expectedOutput": "",
                "explanation": "Max is 8+9=17"
            },
            {
                "input": "k=1, n=5",
                "expectedOutput": "[5]",
                "explanation": "Single number"
            }
        ]
    }
]