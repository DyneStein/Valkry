[
    {
        "id": "fin21",
        "title": "Climbing Stairs Memoized",
        "description": "Ways to climb n stairs with memo.",
        "difficulty": "EASY",
        "category": "DP",
        "starterCode": "#include <iostream>\nusing namespace std;\nint climbStairs(int n) { return 0; }\nint main() { cout<<climbStairs(10); return 0; }",
        "expectedOutput": "89",
        "solution": "#include <iostream>\nusing namespace std;\nint dp[100];\nint solve(int n) { if(n<=1) return 1; if(dp[n]) return dp[n]; return dp[n]=solve(n-1)+solve(n-2); }\nint climbStairs(int n) { for(int i=0;i<100;i++) dp[i]=0; return solve(n); }\nint main() { cout<<climbStairs(10); return 0; }",
        "explanation": {
            "approach": "DP with memoization.",
            "analogy": "Cache computed results.",
            "steps": [
                "If computed, return cached",
                "Else compute and cache"
            ],
            "complexity": "Time: O(n), Space: O(n)"
        },
        "testCases": [
            {
                "input": "n=10",
                "expectedOutput": "89",
                "explanation": "Fibonacci pattern: 89 ways to climb 10 stairs"
            },
            {
                "input": "n=2",
                "expectedOutput": "2",
                "explanation": "Either 1+1 or 2 steps"
            },
            {
                "input": "n=5",
                "expectedOutput": "8",
                "explanation": "8 different ways to climb 5 stairs"
            },
            {
                "input": "n=1",
                "expectedOutput": "1",
                "explanation": "Only one way to climb 1 stair"
            }
        ]
    },
    {
        "id": "fin22",
        "title": "Min Cost Climbing Stairs",
        "description": "Min cost to reach top.",
        "difficulty": "EASY",
        "category": "DP",
        "starterCode": "#include <iostream>\nusing namespace std;\nint minCostClimbing(int cost[], int n) { return 0; }\nint main() { int cost[]={10,15,20}; cout<<minCostClimbing(cost,3); return 0; }",
        "expectedOutput": "15",
        "solution": "#include <iostream>\nusing namespace std;\nint minCostClimbing(int cost[], int n) { int dp[n+1]={}; for(int i=2;i<=n;i++) dp[i]=min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2]); return dp[n]; }\nint main() { int cost[]={10,15,20}; cout<<minCostClimbing(cost,3); return 0; }",
        "explanation": {
            "approach": "DP - min cost at each step.",
            "analogy": "From step i-1 or i-2.",
            "steps": [
                "dp[i] = min cost to reach step i"
            ],
            "complexity": "Time: O(n), Space: O(n)"
        },
        "testCases": [
            {
                "input": "{10,15,20}",
                "expectedOutput": "15",
                "explanation": "Pay 15 to step on index 1, then jump to top"
            },
            {
                "input": "{1,100,1,1,1,100,1,1,100,1}",
                "expectedOutput": "6",
                "explanation": "Optimal path avoids 100s"
            },
            {
                "input": "{0,0,0}",
                "expectedOutput": "0",
                "explanation": "All free steps"
            },
            {
                "input": "{10,15}",
                "expectedOutput": "10",
                "explanation": "Start at 0, pay 10, jump to top"
            }
        ]
    },
    {
        "id": "fin23",
        "title": "Number of 1 Bits",
        "description": "Count set bits.",
        "difficulty": "EASY",
        "category": "Bits",
        "starterCode": "#include <iostream>\nusing namespace std;\nint hammingWeight(unsigned int n) { return 0; }\nint main() { cout<<hammingWeight(11); return 0; }",
        "expectedOutput": "3",
        "solution": "#include <iostream>\nusing namespace std;\nint hammingWeight(unsigned int n) { int c=0; while(n) { c+=n&1; n>>=1; } return c; }\nint main() { cout<<hammingWeight(11); return 0; }",
        "explanation": {
            "approach": "Count LSB, shift right.",
            "analogy": "Pop off bits one by one.",
            "steps": [
                "Add n&1 to count",
                "Shift right"
            ],
            "complexity": "Time: O(log n), Space: O(1)"
        },
        "testCases": [
            {
                "input": "n=11 (1011 in binary)",
                "expectedOutput": "3",
                "explanation": "Binary 1011 has three 1s"
            },
            {
                "input": "n=128 (10000000)",
                "expectedOutput": "1",
                "explanation": "Power of 2 has one 1"
            },
            {
                "input": "n=255 (11111111)",
                "expectedOutput": "8",
                "explanation": "All 8 bits set"
            },
            {
                "input": "n=0",
                "expectedOutput": "0",
                "explanation": "Zero has no 1 bits"
            }
        ]
    },
    {
        "id": "fin24",
        "title": "Counting Bits",
        "description": "Count bits for 0 to n.",
        "difficulty": "EASY",
        "category": "Bits",
        "starterCode": "#include <iostream>\nusing namespace std;\nvoid countBits(int n) {}\nint main() { countBits(5); return 0; }",
        "expectedOutput": "0 1 1 2 1 2",
        "solution": "#include <iostream>\nusing namespace std;\nvoid countBits(int n) { int dp[n+1]; dp[0]=0; for(int i=1;i<=n;i++) dp[i]=dp[i>>1]+(i&1); for(int i=0;i<=n;i++) cout<<dp[i]<<\" \"; }\nint main() { countBits(5); return 0; }",
        "explanation": {
            "approach": "DP using i/2.",
            "analogy": "bits(i) = bits(i/2) + last bit.",
            "steps": [
                "dp[i] = dp[i>>1] + (i&1)"
            ],
            "complexity": "Time: O(n), Space: O(n)"
        },
        "testCases": [
            {
                "input": "n=5",
                "expectedOutput": "0 1 1 2 1 2",
                "explanation": "0=0,1=1,2=1,3=2,4=1,5=2 ones"
            },
            {
                "input": "n=2",
                "expectedOutput": "0 1 1",
                "explanation": "0,1,2 have 0,1,1 bits"
            },
            {
                "input": "n=0",
                "expectedOutput": "0",
                "explanation": "Only zero"
            },
            {
                "input": "n=8",
                "expectedOutput": "0 1 1 2 1 2 2 3 1",
                "explanation": "Bits for 0-8"
            }
        ]
    },
    {
        "id": "fin25",
        "title": "Reverse Bits",
        "description": "Reverse 32-bit integer.",
        "difficulty": "EASY",
        "category": "Bits",
        "starterCode": "#include <iostream>\nusing namespace std;\nunsigned int reverseBits(unsigned int n) { return 0; }\nint main() { cout<<reverseBits(43261596); return 0; }",
        "expectedOutput": "964176192",
        "solution": "#include <iostream>\nusing namespace std;\nunsigned int reverseBits(unsigned int n) { unsigned int r=0; for(int i=0;i<32;i++) { r=(r<<1)|(n&1); n>>=1; } return r; }\nint main() { cout<<reverseBits(43261596); return 0; }",
        "explanation": {
            "approach": "Build reversed bit by bit.",
            "analogy": "Take LSB, put in result MSB position.",
            "steps": [
                "Get LSB of n",
                "Put in result",
                "Shift both"
            ],
            "complexity": "Time: O(32), Space: O(1)"
        },
        "testCases": [
            {
                "input": "43261596",
                "expectedOutput": "964176192",
                "explanation": "Binary reversed"
            },
            {
                "input": "1",
                "expectedOutput": "2147483648",
                "explanation": "LSB becomes MSB"
            },
            {
                "input": "0",
                "expectedOutput": "0",
                "explanation": "Zero reversed is zero"
            },
            {
                "input": "4294967295",
                "expectedOutput": "4294967295",
                "explanation": "All 1s reversed is still all 1s"
            }
        ]
    },
    {
        "id": "fin26",
        "title": "Missing Number",
        "description": "Find missing in 0 to n.",
        "difficulty": "EASY",
        "category": "Bits",
        "starterCode": "#include <iostream>\nusing namespace std;\nint missingNumber(int a[], int n) { return 0; }\nint main() { int a[]={3,0,1}; cout<<missingNumber(a,3); return 0; }",
        "expectedOutput": "2",
        "solution": "#include <iostream>\nusing namespace std;\nint missingNumber(int a[], int n) { int x=n; for(int i=0;i<n;i++) x^=i^a[i]; return x; }\nint main() { int a[]={3,0,1}; cout<<missingNumber(a,3); return 0; }",
        "explanation": {
            "approach": "XOR all indices and values.",
            "analogy": "Pairs cancel out.",
            "steps": [
                "XOR n and all i and a[i]",
                "Missing number remains"
            ],
            "complexity": "Time: O(n), Space: O(1)"
        },
        "testCases": [
            {
                "input": "{3,0,1}",
                "expectedOutput": "2",
                "explanation": "0,1,3 present, 2 is missing"
            },
            {
                "input": "{0,1}",
                "expectedOutput": "2",
                "explanation": "0,1 present, 2 is missing"
            },
            {
                "input": "{9,6,4,2,3,5,7,0,1}",
                "expectedOutput": "8",
                "explanation": "8 is missing from 0-9"
            },
            {
                "input": "{0}",
                "expectedOutput": "1",
                "explanation": "Only 0 present, 1 is missing"
            }
        ]
    },
    {
        "id": "fin27",
        "title": "Sum of Two Integers",
        "description": "Add without + or -.",
        "difficulty": "MEDIUM",
        "category": "Bits",
        "starterCode": "#include <iostream>\nusing namespace std;\nint getSum(int a, int b) { return 0; }\nint main() { cout<<getSum(5,3); return 0; }",
        "expectedOutput": "8",
        "solution": "#include <iostream>\nusing namespace std;\nint getSum(int a, int b) { while(b) { int c=(unsigned)(a&b)<<1; a=a^b; b=c; } return a; }\nint main() { cout<<getSum(5,3); return 0; }",
        "explanation": {
            "approach": "XOR for sum, AND for carry.",
            "analogy": "Binary addition manually.",
            "steps": [
                "XOR = sum without carry",
                "AND<<1 = carry",
                "Repeat until no carry"
            ],
            "complexity": "Time: O(32), Space: O(1)"
        },
        "testCases": [
            {
                "input": "a=5, b=3",
                "expectedOutput": "8",
                "explanation": "5+3=8 using bit operations"
            },
            {
                "input": "a=2, b=3",
                "expectedOutput": "5",
                "explanation": "2+3=5"
            },
            {
                "input": "a=-2, b=3",
                "expectedOutput": "1",
                "explanation": "Works with negatives too"
            },
            {
                "input": "a=0, b=0",
                "expectedOutput": "0",
                "explanation": "0+0=0"
            }
        ]
    },
    {
        "id": "fin28",
        "title": "House Robber II",
        "description": "Circular house robber.",
        "difficulty": "MEDIUM",
        "category": "DP",
        "starterCode": "#include <iostream>\nusing namespace std;\nint rob(int a[], int n) { return 0; }\nint main() { int a[]={2,3,2}; cout<<rob(a,3); return 0; }",
        "expectedOutput": "3",
        "solution": "#include <iostream>\nusing namespace std;\nint robRange(int a[], int l, int r) { int p=0,c=0; for(int i=l;i<=r;i++) { int t=max(c,p+a[i]); p=c; c=t; } return c; }\nint rob(int a[], int n) { if(n==1) return a[0]; return max(robRange(a,0,n-2),robRange(a,1,n-1)); }\nint main() { int a[]={2,3,2}; cout<<rob(a,3); return 0; }",
        "explanation": {
            "approach": "Two cases: skip first or last.",
            "analogy": "Circle means first and last are adjacent.",
            "steps": [
                "Rob houses 0 to n-2",
                "Or rob houses 1 to n-1",
                "Return max"
            ],
            "complexity": "Time: O(n), Space: O(1)"
        },
        "testCases": [
            {
                "input": "{2,3,2}",
                "expectedOutput": "3",
                "explanation": "Rob house 1 only, can't rob adjacent 0 and 2"
            },
            {
                "input": "{1,2,3,1}",
                "expectedOutput": "4",
                "explanation": "Rob houses 0 and 2 for 1+3=4"
            },
            {
                "input": "{1}",
                "expectedOutput": "1",
                "explanation": "Single house, rob it"
            },
            {
                "input": "{1,2}",
                "expectedOutput": "2",
                "explanation": "Rob the larger house"
            }
        ]
    },
    {
        "id": "fin29",
        "title": "Palindrome Linked List",
        "description": "Check if list is palindrome.",
        "difficulty": "EASY",
        "category": "Linked List",
        "starterCode": "#include <iostream>\nusing namespace std;\nstruct Node { int v; Node* n; Node(int x):v(x),n(0){} };\nbool isPalindrome(Node* h) { return false; }\nint main() { Node* h=new Node(1); h->n=new Node(2); h->n->n=new Node(2); h->n->n->n=new Node(1); cout<<isPalindrome(h); return 0; }",
        "expectedOutput": "1",
        "solution": "#include <iostream>\nusing namespace std;\nstruct Node { int v; Node* n; Node(int x):v(x),n(0){} };\nNode* rev(Node* h) { Node* p=0; while(h) { Node* t=h->n; h->n=p; p=h; h=t; } return p; }\nbool isPalindrome(Node* h) { Node* s=h,*f=h; while(f&&f->n) { s=s->n; f=f->n->n; } s=rev(s); while(s) { if(h->v!=s->v) return false; h=h->n; s=s->n; } return true; }\nint main() { Node* h=new Node(1); h->n=new Node(2); h->n->n=new Node(2); h->n->n->n=new Node(1); cout<<isPalindrome(h); return 0; }",
        "explanation": {
            "approach": "Reverse second half, compare.",
            "analogy": "Compare first half with reversed second.",
            "steps": [
                "Find middle",
                "Reverse second half",
                "Compare"
            ],
            "complexity": "Time: O(n), Space: O(1)"
        },
        "testCases": [
            {
                "input": "1->2->2->1",
                "expectedOutput": "1",
                "explanation": "Reads same forwards and backwards"
            },
            {
                "input": "1->2",
                "expectedOutput": "0",
                "explanation": "Not a palindrome"
            },
            {
                "input": "1->2->1",
                "expectedOutput": "1",
                "explanation": "Odd length palindrome"
            },
            {
                "input": "1",
                "expectedOutput": "1",
                "explanation": "Single element is palindrome"
            }
        ]
    },
    {
        "id": "fin30",
        "title": "Linked List Cycle",
        "description": "Detect cycle in list.",
        "difficulty": "EASY",
        "category": "Linked List",
        "starterCode": "#include <iostream>\nusing namespace std;\nstruct Node { int v; Node* n; Node(int x):v(x),n(0){} };\nbool hasCycle(Node* h) { return false; }\nint main() { Node* h=new Node(3); h->n=new Node(2); h->n->n=new Node(0); h->n->n->n=new Node(-4); h->n->n->n->n=h->n; cout<<hasCycle(h); return 0; }",
        "expectedOutput": "1",
        "solution": "#include <iostream>\nusing namespace std;\nstruct Node { int v; Node* n; Node(int x):v(x),n(0){} };\nbool hasCycle(Node* h) { Node* s=h,*f=h; while(f&&f->n) { s=s->n; f=f->n->n; if(s==f) return true; } return false; }\nint main() { Node* h=new Node(3); h->n=new Node(2); h->n->n=new Node(0); h->n->n->n=new Node(-4); h->n->n->n->n=h->n; cout<<hasCycle(h); return 0; }",
        "explanation": {
            "approach": "Floyd's tortoise and hare.",
            "analogy": "Fast catches slow if cycle exists.",
            "steps": [
                "Slow moves 1, fast moves 2",
                "If they meet, cycle exists"
            ],
            "complexity": "Time: O(n), Space: O(1)"
        },
        "testCases": [
            {
                "input": "3->2->0->-4->back to 2",
                "expectedOutput": "1",
                "explanation": "Cycle exists, tail connects to node 2"
            },
            {
                "input": "1->2 (no cycle)",
                "expectedOutput": "0",
                "explanation": "Linear list, no cycle"
            },
            {
                "input": "1->self",
                "expectedOutput": "1",
                "explanation": "Single node pointing to itself"
            },
            {
                "input": "null",
                "expectedOutput": "0",
                "explanation": "Empty list has no cycle"
            }
        ]
    }
]