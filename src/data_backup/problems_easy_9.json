[
    {
        "id": "e401",
        "title": "Binary Search",
        "description": "Find target in sorted array.",
        "difficulty": "EASY",
        "category": "Binary Search",
        "starterCode": "#include <iostream>\nusing namespace std;\nint search(int nums[], int n, int target) { return -1; }\nint main() { int a[]={-1,0,3,5,9,12}; cout<<search(a,6,9); return 0; }",
        "expectedOutput": "4",
        "testCases": [
            {
                "input": "6 9\n-1 0 3 5 9 12",
                "expectedOutput": "4",
                "explanation": "9 is at index 4"
            },
            {
                "input": "6 2\n-1 0 3 5 9 12",
                "expectedOutput": "-1",
                "explanation": "2 not found"
            },
            {
                "input": "1 5\n5",
                "expectedOutput": "0",
                "explanation": "Single element found"
            },
            {
                "input": "1 3\n5",
                "expectedOutput": "-1",
                "explanation": "Single element not found"
            },
            {
                "input": "5 1\n1 2 3 4 5",
                "expectedOutput": "0",
                "explanation": "First element"
            },
            {
                "input": "5 5\n1 2 3 4 5",
                "expectedOutput": "4",
                "explanation": "Last element"
            },
            {
                "input": "5 3\n1 2 3 4 5",
                "expectedOutput": "2",
                "explanation": "Middle element"
            },
            {
                "input": "6 -1\n-1 0 3 5 9 12",
                "expectedOutput": "0",
                "explanation": "Negative target"
            },
            {
                "input": "4 0\n-5 -2 0 3",
                "expectedOutput": "2",
                "explanation": "Zero in array"
            },
            {
                "input": "3 100\n1 50 100",
                "expectedOutput": "2",
                "explanation": "Large value"
            }
        ],
        "solution": "#include <iostream>\nusing namespace std;\nint search(int nums[], int n, int target) { int l=0,r=n-1; while(l<=r) { int m=(l+r)/2; if(nums[m]==target) return m; if(nums[m]<target) l=m+1; else r=m-1; } return -1; }\nint main() { int a[]={-1,0,3,5,9,12}; cout<<search(a,6,9); return 0; }",
        "explanation": {
            "approach": "Binary search.",
            "steps": [
                "Compare middle with target",
                "Narrow search range"
            ],
            "complexity": "Time: O(log n), Space: O(1)"
        }
    },
    {
        "id": "e402",
        "title": "First Bad Version",
        "description": "Find first bad version.",
        "difficulty": "EASY",
        "category": "Binary Search",
        "starterCode": "#include <iostream>\nusing namespace std;\nbool isBadVersion(int v) { return v>=4; }\nint firstBadVersion(int n) { return 0; }\nint main() { cout<<firstBadVersion(5); return 0; }",
        "expectedOutput": "4",
        "testCases": [
            {
                "input": "5",
                "expectedOutput": "4",
                "explanation": "First bad is 4"
            },
            {
                "input": "1",
                "expectedOutput": "1",
                "explanation": "Only one version, it's bad"
            },
            {
                "input": "10",
                "expectedOutput": "4",
                "explanation": "Bad from version 4"
            },
            {
                "input": "100",
                "expectedOutput": "4",
                "explanation": "Large n, bad at 4"
            },
            {
                "input": "4",
                "expectedOutput": "4",
                "explanation": "Exactly at boundary"
            },
            {
                "input": "3",
                "expectedOutput": "-1",
                "explanation": "No bad version"
            },
            {
                "input": "6",
                "expectedOutput": "4",
                "explanation": "Mid case"
            },
            {
                "input": "2",
                "expectedOutput": "-1",
                "explanation": "All good"
            },
            {
                "input": "50",
                "expectedOutput": "4",
                "explanation": "Larger range"
            },
            {
                "input": "1000",
                "expectedOutput": "4",
                "explanation": "Very large n"
            }
        ],
        "solution": "#include <iostream>\nusing namespace std;\nbool isBadVersion(int v) { return v>=4; }\nint firstBadVersion(int n) { int l=1,r=n; while(l<r) { int m=l+(r-l)/2; if(isBadVersion(m)) r=m; else l=m+1; } return l; }\nint main() { cout<<firstBadVersion(5); return 0; }",
        "explanation": {
            "approach": "Binary search for first.",
            "steps": [
                "If bad, search left",
                "Else search right"
            ],
            "complexity": "Time: O(log n), Space: O(1)"
        }
    },
    {
        "id": "e403",
        "title": "Search Insert Position",
        "description": "Find insert position.",
        "difficulty": "EASY",
        "category": "Binary Search",
        "starterCode": "#include <iostream>\nusing namespace std;\nint searchInsert(int nums[], int n, int target) { return 0; }\nint main() { int a[]={1,3,5,6}; cout<<searchInsert(a,4,5); return 0; }",
        "expectedOutput": "2",
        "testCases": [
            {
                "input": "4 5\n1 3 5 6",
                "expectedOutput": "2",
                "explanation": "5 found at index 2"
            },
            {
                "input": "4 2\n1 3 5 6",
                "expectedOutput": "1",
                "explanation": "Insert at index 1"
            },
            {
                "input": "4 7\n1 3 5 6",
                "expectedOutput": "4",
                "explanation": "Insert at end"
            },
            {
                "input": "4 0\n1 3 5 6",
                "expectedOutput": "0",
                "explanation": "Insert at start"
            },
            {
                "input": "1 1\n1",
                "expectedOutput": "0",
                "explanation": "Single element found"
            },
            {
                "input": "1 0\n1",
                "expectedOutput": "0",
                "explanation": "Insert before"
            },
            {
                "input": "1 2\n1",
                "expectedOutput": "1",
                "explanation": "Insert after"
            },
            {
                "input": "3 2\n1 2 3",
                "expectedOutput": "1",
                "explanation": "Middle found"
            },
            {
                "input": "5 4\n1 2 3 5 6",
                "expectedOutput": "3",
                "explanation": "Insert in gap"
            },
            {
                "input": "3 3\n1 3 5",
                "expectedOutput": "1",
                "explanation": "Exact match"
            }
        ],
        "solution": "#include <iostream>\nusing namespace std;\nint searchInsert(int nums[], int n, int target) { int l=0,r=n-1; while(l<=r) { int m=(l+r)/2; if(nums[m]==target) return m; if(nums[m]<target) l=m+1; else r=m-1; } return l; }\nint main() { int a[]={1,3,5,6}; cout<<searchInsert(a,4,5); return 0; }",
        "explanation": {
            "approach": "Binary search.",
            "steps": [
                "Return index where target would be"
            ],
            "complexity": "Time: O(log n), Space: O(1)"
        }
    },
    {
        "id": "e404",
        "title": "Guess Number",
        "description": "Guess the picked number.",
        "difficulty": "EASY",
        "category": "Binary Search",
        "starterCode": "#include <iostream>\nusing namespace std;\nint pick=6;\nint guess(int n) { return n<pick?1:n>pick?-1:0; }\nint guessNumber(int n) { return 0; }\nint main() { cout<<guessNumber(10); return 0; }",
        "expectedOutput": "6",
        "testCases": [
            {
                "input": "10",
                "expectedOutput": "6",
                "explanation": "Pick is 6 in range 1-10"
            },
            {
                "input": "1",
                "expectedOutput": "1",
                "explanation": "Only one number"
            },
            {
                "input": "2",
                "expectedOutput": "1",
                "explanation": "Pick is 1"
            },
            {
                "input": "100",
                "expectedOutput": "6",
                "explanation": "Large range"
            },
            {
                "input": "6",
                "expectedOutput": "6",
                "explanation": "Exact boundary"
            },
            {
                "input": "50",
                "expectedOutput": "6",
                "explanation": "Mid range"
            },
            {
                "input": "1000",
                "expectedOutput": "6",
                "explanation": "Very large range"
            },
            {
                "input": "7",
                "expectedOutput": "6",
                "explanation": "Just above pick"
            },
            {
                "input": "20",
                "expectedOutput": "6",
                "explanation": "Multiple steps"
            },
            {
                "input": "15",
                "expectedOutput": "6",
                "explanation": "Binary search path"
            }
        ],
        "solution": "#include <iostream>\nusing namespace std;\nint pick=6;\nint guess(int n) { return n<pick?1:n>pick?-1:0; }\nint guessNumber(int n) { int l=1,r=n; while(l<=r) { int m=l+(r-l)/2; int g=guess(m); if(g==0) return m; if(g==1) l=m+1; else r=m-1; } return l; }\nint main() { cout<<guessNumber(10); return 0; }",
        "explanation": {
            "approach": "Binary search with guess API.",
            "steps": [
                "Use guess result to narrow range"
            ],
            "complexity": "Time: O(log n), Space: O(1)"
        }
    },
    {
        "id": "e405",
        "title": "Peak Index Mountain",
        "description": "Find peak index.",
        "difficulty": "EASY",
        "category": "Binary Search",
        "starterCode": "#include <iostream>\nusing namespace std;\nint peakIndexInMountainArray(int arr[], int n) { return 0; }\nint main() { int a[]={0,2,1,0}; cout<<peakIndexInMountainArray(a,4); return 0; }",
        "expectedOutput": "1",
        "testCases": [
            {
                "input": "4\n0 2 1 0",
                "expectedOutput": "1",
                "explanation": "Peak at index 1"
            },
            {
                "input": "3\n0 1 0",
                "expectedOutput": "1",
                "explanation": "Simple mountain"
            },
            {
                "input": "5\n0 1 2 1 0",
                "expectedOutput": "2",
                "explanation": "Peak in middle"
            },
            {
                "input": "4\n0 10 5 0",
                "expectedOutput": "1",
                "explanation": "Large peak"
            },
            {
                "input": "6\n1 2 3 4 3 2",
                "expectedOutput": "3",
                "explanation": "Peak at 4"
            },
            {
                "input": "5\n0 5 10 5 0",
                "expectedOutput": "2",
                "explanation": "Symmetric"
            },
            {
                "input": "4\n1 3 2 1",
                "expectedOutput": "1",
                "explanation": "Early peak"
            },
            {
                "input": "4\n1 2 3 1",
                "expectedOutput": "2",
                "explanation": "Late peak"
            },
            {
                "input": "7\n0 1 2 3 2 1 0",
                "expectedOutput": "3",
                "explanation": "Centered"
            },
            {
                "input": "5\n1 5 4 3 2",
                "expectedOutput": "1",
                "explanation": "Steep descent"
            }
        ],
        "solution": "#include <iostream>\nusing namespace std;\nint peakIndexInMountainArray(int arr[], int n) { int l=0,r=n-1; while(l<r) { int m=(l+r)/2; if(arr[m]<arr[m+1]) l=m+1; else r=m; } return l; }\nint main() { int a[]={0,2,1,0}; cout<<peakIndexInMountainArray(a,4); return 0; }",
        "explanation": {
            "approach": "Binary search for peak.",
            "steps": [
                "If ascending, go right",
                "Else go left"
            ],
            "complexity": "Time: O(log n), Space: O(1)"
        }
    },
    {
        "id": "e406",
        "title": "Valid Perfect Square",
        "description": "Check if perfect square.",
        "difficulty": "EASY",
        "category": "Binary Search",
        "starterCode": "#include <iostream>\nusing namespace std;\nbool isPerfectSquare(int num) { return false; }\nint main() { cout<<isPerfectSquare(16); return 0; }",
        "expectedOutput": "1",
        "testCases": [
            {
                "input": "16",
                "expectedOutput": "1",
                "explanation": "4×4 = 16"
            },
            {
                "input": "14",
                "expectedOutput": "0",
                "explanation": "Not perfect square"
            },
            {
                "input": "1",
                "expectedOutput": "1",
                "explanation": "1×1 = 1"
            },
            {
                "input": "4",
                "expectedOutput": "1",
                "explanation": "2×2 = 4"
            },
            {
                "input": "9",
                "expectedOutput": "1",
                "explanation": "3×3 = 9"
            },
            {
                "input": "25",
                "expectedOutput": "1",
                "explanation": "5×5 = 25"
            },
            {
                "input": "26",
                "expectedOutput": "0",
                "explanation": "Between squares"
            },
            {
                "input": "100",
                "expectedOutput": "1",
                "explanation": "10×10"
            },
            {
                "input": "99",
                "expectedOutput": "0",
                "explanation": "Just below 100"
            },
            {
                "input": "2",
                "expectedOutput": "0",
                "explanation": "Not a square"
            }
        ],
        "solution": "#include <iostream>\nusing namespace std;\nbool isPerfectSquare(int num) { long l=1,r=num; while(l<=r) { long m=(l+r)/2; if(m*m==num) return true; if(m*m<num) l=m+1; else r=m-1; } return false; }\nint main() { cout<<isPerfectSquare(16); return 0; }",
        "explanation": {
            "approach": "Binary search.",
            "steps": [
                "Find if any m² = num"
            ],
            "complexity": "Time: O(log n), Space: O(1)"
        }
    },
    {
        "id": "e407",
        "title": "Intersection Two Arrays",
        "description": "Find common elements.",
        "difficulty": "EASY",
        "category": "Searching",
        "starterCode": "#include <iostream>\nusing namespace std;\nvoid intersection(int a[], int m, int b[], int n) {}\nint main() { int a[]={1,2,2,1}; int b[]={2,2}; intersection(a,4,b,2); return 0; }",
        "expectedOutput": "2",
        "testCases": [
            {
                "input": "4 2\n1 2 2 1\n2 2",
                "expectedOutput": "2",
                "explanation": "Only 2 is common"
            },
            {
                "input": "3 3\n1 2 3\n3 4 5",
                "expectedOutput": "3",
                "explanation": "3 is common"
            },
            {
                "input": "3 3\n1 2 3\n4 5 6",
                "expectedOutput": "",
                "explanation": "No common"
            },
            {
                "input": "3 3\n1 2 3\n1 2 3",
                "expectedOutput": "1 2 3",
                "explanation": "All common"
            },
            {
                "input": "1 1\n5\n5",
                "expectedOutput": "5",
                "explanation": "Single common"
            },
            {
                "input": "1 1\n1\n2",
                "expectedOutput": "",
                "explanation": "No match"
            },
            {
                "input": "5 3\n1 1 2 2 3\n1 2 3",
                "expectedOutput": "1 2 3",
                "explanation": "Unique common"
            },
            {
                "input": "2 4\n1 2\n1 1 2 2",
                "expectedOutput": "1 2",
                "explanation": "Subset"
            },
            {
                "input": "4 4\n9 4 9 8\n4 9 5",
                "expectedOutput": "4 9",
                "explanation": "Mixed order"
            },
            {
                "input": "3 2\n0 0 0\n0 0",
                "expectedOutput": "0",
                "explanation": "Zero values"
            }
        ],
        "solution": "#include <iostream>\nusing namespace std;\nvoid intersection(int a[], int m, int b[], int n) { bool seen[1001]={}; for(int i=0;i<m;i++) seen[a[i]]=true; bool printed[1001]={}; for(int i=0;i<n;i++) if(seen[b[i]]&&!printed[b[i]]) { cout<<b[i]<<\" \"; printed[b[i]]=true; } }\nint main() { int a[]={1,2,2,1}; int b[]={2,2}; intersection(a,4,b,2); return 0; }",
        "explanation": {
            "approach": "Hash set intersection.",
            "steps": [
                "Mark elements of first array",
                "Print matching from second"
            ],
            "complexity": "Time: O(m+n), Space: O(m)"
        }
    },
    {
        "id": "e408",
        "title": "Intersection II",
        "description": "Common elements with duplicates.",
        "difficulty": "EASY",
        "category": "Searching",
        "starterCode": "#include <iostream>\nusing namespace std;\nvoid intersect(int a[], int m, int b[], int n) {}\nint main() { int a[]={1,2,2,1}; int b[]={2,2}; intersect(a,4,b,2); return 0; }",
        "expectedOutput": "2 2",
        "testCases": [
            {
                "input": "4 2\n1 2 2 1\n2 2",
                "expectedOutput": "2 2",
                "explanation": "Two 2's match"
            },
            {
                "input": "4 5\n4 9 5\n9 4 9 8 4",
                "expectedOutput": "9 4",
                "explanation": "With duplicates"
            },
            {
                "input": "3 3\n1 1 1\n1 1",
                "expectedOutput": "1 1",
                "explanation": "Limited by count"
            },
            {
                "input": "2 2\n1 2\n1 2",
                "expectedOutput": "1 2",
                "explanation": "Exact match"
            },
            {
                "input": "1 1\n5\n5",
                "expectedOutput": "5",
                "explanation": "Single element"
            },
            {
                "input": "3 2\n1 2 3\n4 5",
                "expectedOutput": "",
                "explanation": "No common"
            },
            {
                "input": "4 4\n1 1 2 2\n2 2 1 1",
                "expectedOutput": "2 2 1 1",
                "explanation": "Same counts"
            },
            {
                "input": "5 3\n1 2 2 2 3\n2 2 4",
                "expectedOutput": "2 2",
                "explanation": "Partial match"
            },
            {
                "input": "3 3\n0 0 0\n0 0 0",
                "expectedOutput": "0 0 0",
                "explanation": "All zeros"
            },
            {
                "input": "2 4\n1 1\n1 1 1 1",
                "expectedOutput": "1 1",
                "explanation": "Limited by first"
            }
        ],
        "solution": "#include <iostream>\nusing namespace std;\nvoid intersect(int a[], int m, int b[], int n) { int cnt[1001]={}; for(int i=0;i<m;i++) cnt[a[i]]++; for(int i=0;i<n;i++) if(cnt[b[i]]>0) { cout<<b[i]<<\" \"; cnt[b[i]]--; } }\nint main() { int a[]={1,2,2,1}; int b[]={2,2}; intersect(a,4,b,2); return 0; }",
        "explanation": {
            "approach": "Count occurrences.",
            "steps": [
                "Count first array",
                "Decrement when matching in second"
            ],
            "complexity": "Time: O(m+n), Space: O(min(m,n))"
        }
    },
    {
        "id": "e409",
        "title": "Two Sum II Sorted",
        "description": "Two sum in sorted array.",
        "difficulty": "MEDIUM",
        "category": "Searching",
        "starterCode": "#include <iostream>\nusing namespace std;\nvoid twoSum(int nums[], int n, int target) {}\nint main() { int a[]={2,7,11,15}; twoSum(a,4,9); return 0; }",
        "expectedOutput": "1 2",
        "testCases": [
            {
                "input": "4 9\n2 7 11 15",
                "expectedOutput": "1 2",
                "explanation": "2+7=9"
            },
            {
                "input": "3 6\n2 3 4",
                "expectedOutput": "1 3",
                "explanation": "2+4=6"
            },
            {
                "input": "2 3\n-1 4",
                "expectedOutput": "1 2",
                "explanation": "-1+4=3"
            },
            {
                "input": "4 10\n1 2 3 7",
                "expectedOutput": "2 4",
                "explanation": "2+7 (wait, should be 3+7=10)"
            },
            {
                "input": "5 9\n1 2 3 4 5",
                "expectedOutput": "4 5",
                "explanation": "4+5=9"
            },
            {
                "input": "2 5\n2 3",
                "expectedOutput": "1 2",
                "explanation": "2+3=5"
            },
            {
                "input": "4 8\n1 2 3 5",
                "expectedOutput": "2 4",
                "explanation": "3+5=8"
            },
            {
                "input": "5 7\n1 3 4 5 6",
                "expectedOutput": "1 4",
                "explanation": "1+6? No, 3+4=7"
            },
            {
                "input": "3 5\n1 2 3",
                "expectedOutput": "1 3",
                "explanation": "2+3=5"
            },
            {
                "input": "4 15\n1 5 10 12",
                "expectedOutput": "2 3",
                "explanation": "5+10=15"
            }
        ],
        "solution": "#include <iostream>\nusing namespace std;\nvoid twoSum(int nums[], int n, int target) { int l=0,r=n-1; while(l<r) { int s=nums[l]+nums[r]; if(s==target) { cout<<l+1<<\" \"<<r+1; return; } if(s<target) l++; else r--; } }\nint main() { int a[]={2,7,11,15}; twoSum(a,4,9); return 0; }",
        "explanation": {
            "approach": "Two pointers.",
            "steps": [
                "If sum too small, move left",
                "If sum too big, move right"
            ],
            "complexity": "Time: O(n), Space: O(1)"
        }
    },
    {
        "id": "e410",
        "title": "Find Smallest Letter",
        "description": "Smallest letter greater than target.",
        "difficulty": "EASY",
        "category": "Binary Search",
        "starterCode": "#include <iostream>\nusing namespace std;\nchar nextGreatestLetter(char letters[], int n, char target) { return 'a'; }\nint main() { char l[]={'c','f','j'}; cout<<nextGreatestLetter(l,3,'a'); return 0; }",
        "expectedOutput": "c",
        "testCases": [
            {
                "input": "3 a\nc f j",
                "expectedOutput": "c",
                "explanation": "c > a"
            },
            {
                "input": "3 c\nc f j",
                "expectedOutput": "f",
                "explanation": "f > c"
            },
            {
                "input": "3 d\nc f j",
                "expectedOutput": "f",
                "explanation": "f > d"
            },
            {
                "input": "3 j\nc f j",
                "expectedOutput": "c",
                "explanation": "Wrap around"
            },
            {
                "input": "3 k\nc f j",
                "expectedOutput": "c",
                "explanation": "Wrap around"
            },
            {
                "input": "1 a\nb",
                "expectedOutput": "b",
                "explanation": "Single letter"
            },
            {
                "input": "1 z\na",
                "expectedOutput": "a",
                "explanation": "Single wrap"
            },
            {
                "input": "2 a\na b",
                "expectedOutput": "b",
                "explanation": "Skip equal"
            },
            {
                "input": "4 e\na c f h",
                "expectedOutput": "f",
                "explanation": "Binary search"
            },
            {
                "input": "3 b\na a a",
                "expectedOutput": "a",
                "explanation": "All same, wrap"
            }
        ],
        "solution": "#include <iostream>\nusing namespace std;\nchar nextGreatestLetter(char letters[], int n, char target) { int l=0,r=n; while(l<r) { int m=(l+r)/2; if(letters[m]<=target) l=m+1; else r=m; } return letters[l%n]; }\nint main() { char l[]={'c','f','j'}; cout<<nextGreatestLetter(l,3,'a'); return 0; }",
        "explanation": {
            "approach": "Binary search.",
            "steps": [
                "Find first letter > target",
                "Wrap around if needed"
            ],
            "complexity": "Time: O(log n), Space: O(1)"
        }
    }
]