(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const o of document.querySelectorAll('link[rel="modulepreload"]'))a(o);new MutationObserver(o=>{for(const c of o)if(c.type==="childList")for(const d of c.addedNodes)d.tagName==="LINK"&&d.rel==="modulepreload"&&a(d)}).observe(document,{childList:!0,subtree:!0});function i(o){const c={};return o.integrity&&(c.integrity=o.integrity),o.referrerPolicy&&(c.referrerPolicy=o.referrerPolicy),o.crossOrigin==="use-credentials"?c.credentials="include":o.crossOrigin==="anonymous"?c.credentials="omit":c.credentials="same-origin",c}function a(o){if(o.ep)return;o.ep=!0;const c=i(o);fetch(o.href,c)}})();function VC(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}var Zp={exports:{}},uo={};var f1;function WC(){if(f1)return uo;f1=1;var n=Symbol.for("react.transitional.element"),e=Symbol.for("react.fragment");function i(a,o,c){var d=null;if(c!==void 0&&(d=""+c),o.key!==void 0&&(d=""+o.key),"key"in o){c={};for(var m in o)m!=="key"&&(c[m]=o[m])}else c=o;return o=c.ref,{$$typeof:n,type:a,key:d,ref:o!==void 0?o:null,props:c}}return uo.Fragment=e,uo.jsx=i,uo.jsxs=i,uo}var h1;function KC(){return h1||(h1=1,Zp.exports=WC()),Zp.exports}var y=KC(),Jp={exports:{}},le={};var g1;function QC(){if(g1)return le;g1=1;var n=Symbol.for("react.transitional.element"),e=Symbol.for("react.portal"),i=Symbol.for("react.fragment"),a=Symbol.for("react.strict_mode"),o=Symbol.for("react.profiler"),c=Symbol.for("react.consumer"),d=Symbol.for("react.context"),m=Symbol.for("react.forward_ref"),f=Symbol.for("react.suspense"),h=Symbol.for("react.memo"),x=Symbol.for("react.lazy"),v=Symbol.for("react.activity"),b=Symbol.iterator;function _(O){return O===null||typeof O!="object"?null:(O=b&&O[b]||O["@@iterator"],typeof O=="function"?O:null)}var N={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},D=Object.assign,q={};function F(O,L,Y){this.props=O,this.context=L,this.refs=q,this.updater=Y||N}F.prototype.isReactComponent={},F.prototype.setState=function(O,L){if(typeof O!="object"&&typeof O!="function"&&O!=null)throw Error("takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,O,L,"setState")},F.prototype.forceUpdate=function(O){this.updater.enqueueForceUpdate(this,O,"forceUpdate")};function I(){}I.prototype=F.prototype;function H(O,L,Y){this.props=O,this.context=L,this.refs=q,this.updater=Y||N}var z=H.prototype=new I;z.constructor=H,D(z,F.prototype),z.isPureReactComponent=!0;var X=Array.isArray;function Z(){}var K={H:null,A:null,T:null,S:null},fe=Object.prototype.hasOwnProperty;function se(O,L,Y){var W=Y.ref;return{$$typeof:n,type:O,key:L,ref:W!==void 0?W:null,props:Y}}function te(O,L){return se(O.type,L,O.props)}function Me(O){return typeof O=="object"&&O!==null&&O.$$typeof===n}function qe(O){var L={"=":"=0",":":"=2"};return"$"+O.replace(/[=:]/g,function(Y){return L[Y]})}var Dt=/\/+/g;function st(O,L){return typeof O=="object"&&O!==null&&O.key!=null?qe(""+O.key):L.toString(36)}function he(O){switch(O.status){case"fulfilled":return O.value;case"rejected":throw O.reason;default:switch(typeof O.status=="string"?O.then(Z,Z):(O.status="pending",O.then(function(L){O.status==="pending"&&(O.status="fulfilled",O.value=L)},function(L){O.status==="pending"&&(O.status="rejected",O.reason=L)})),O.status){case"fulfilled":return O.value;case"rejected":throw O.reason}}throw O}function M(O,L,Y,W,oe){var ce=typeof O;(ce==="undefined"||ce==="boolean")&&(O=null);var ke=!1;if(O===null)ke=!0;else switch(ce){case"bigint":case"string":case"number":ke=!0;break;case"object":switch(O.$$typeof){case n:case e:ke=!0;break;case x:return ke=O._init,M(ke(O._payload),L,Y,W,oe)}}if(ke)return oe=oe(O),ke=W===""?"."+st(O,0):W,X(oe)?(Y="",ke!=null&&(Y=ke.replace(Dt,"$&/")+"/"),M(oe,L,Y,"",function(pr){return pr})):oe!=null&&(Me(oe)&&(oe=te(oe,Y+(oe.key==null||O&&O.key===oe.key?"":(""+oe.key).replace(Dt,"$&/")+"/")+ke)),L.push(oe)),1;ke=0;var dt=W===""?".":W+":";if(X(O))for(var We=0;We<O.length;We++)W=O[We],ce=dt+st(W,We),ke+=M(W,L,Y,ce,oe);else if(We=_(O),typeof We=="function")for(O=We.call(O),We=0;!(W=O.next()).done;)W=W.value,ce=dt+st(W,We++),ke+=M(W,L,Y,ce,oe);else if(ce==="object"){if(typeof O.then=="function")return M(he(O),L,Y,W,oe);throw L=String(O),Error("Objects are not valid as a React child (found: "+(L==="[object Object]"?"object with keys {"+Object.keys(O).join(", ")+"}":L)+"). If you meant to render a collection of children, use an array instead.")}return ke}function V(O,L,Y){if(O==null)return O;var W=[],oe=0;return M(O,W,"","",function(ce){return L.call(Y,ce,oe++)}),W}function J(O){if(O._status===-1){var L=O._result;L=L(),L.then(function(Y){(O._status===0||O._status===-1)&&(O._status=1,O._result=Y)},function(Y){(O._status===0||O._status===-1)&&(O._status=2,O._result=Y)}),O._status===-1&&(O._status=0,O._result=L)}if(O._status===1)return O._result.default;throw O._result}var ve=typeof reportError=="function"?reportError:function(O){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var L=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof O=="object"&&O!==null&&typeof O.message=="string"?String(O.message):String(O),error:O});if(!window.dispatchEvent(L))return}else if(typeof process=="object"&&typeof process.emit=="function"){process.emit("uncaughtException",O);return}console.error(O)},Ce={map:V,forEach:function(O,L,Y){V(O,function(){L.apply(this,arguments)},Y)},count:function(O){var L=0;return V(O,function(){L++}),L},toArray:function(O){return V(O,function(L){return L})||[]},only:function(O){if(!Me(O))throw Error("React.Children.only expected to receive a single React element child.");return O}};return le.Activity=v,le.Children=Ce,le.Component=F,le.Fragment=i,le.Profiler=o,le.PureComponent=H,le.StrictMode=a,le.Suspense=f,le.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=K,le.__COMPILER_RUNTIME={__proto__:null,c:function(O){return K.H.useMemoCache(O)}},le.cache=function(O){return function(){return O.apply(null,arguments)}},le.cacheSignal=function(){return null},le.cloneElement=function(O,L,Y){if(O==null)throw Error("The argument must be a React element, but you passed "+O+".");var W=D({},O.props),oe=O.key;if(L!=null)for(ce in L.key!==void 0&&(oe=""+L.key),L)!fe.call(L,ce)||ce==="key"||ce==="__self"||ce==="__source"||ce==="ref"&&L.ref===void 0||(W[ce]=L[ce]);var ce=arguments.length-2;if(ce===1)W.children=Y;else if(1<ce){for(var ke=Array(ce),dt=0;dt<ce;dt++)ke[dt]=arguments[dt+2];W.children=ke}return se(O.type,oe,W)},le.createContext=function(O){return O={$$typeof:d,_currentValue:O,_currentValue2:O,_threadCount:0,Provider:null,Consumer:null},O.Provider=O,O.Consumer={$$typeof:c,_context:O},O},le.createElement=function(O,L,Y){var W,oe={},ce=null;if(L!=null)for(W in L.key!==void 0&&(ce=""+L.key),L)fe.call(L,W)&&W!=="key"&&W!=="__self"&&W!=="__source"&&(oe[W]=L[W]);var ke=arguments.length-2;if(ke===1)oe.children=Y;else if(1<ke){for(var dt=Array(ke),We=0;We<ke;We++)dt[We]=arguments[We+2];oe.children=dt}if(O&&O.defaultProps)for(W in ke=O.defaultProps,ke)oe[W]===void 0&&(oe[W]=ke[W]);return se(O,ce,oe)},le.createRef=function(){return{current:null}},le.forwardRef=function(O){return{$$typeof:m,render:O}},le.isValidElement=Me,le.lazy=function(O){return{$$typeof:x,_payload:{_status:-1,_result:O},_init:J}},le.memo=function(O,L){return{$$typeof:h,type:O,compare:L===void 0?null:L}},le.startTransition=function(O){var L=K.T,Y={};K.T=Y;try{var W=O(),oe=K.S;oe!==null&&oe(Y,W),typeof W=="object"&&W!==null&&typeof W.then=="function"&&W.then(Z,ve)}catch(ce){ve(ce)}finally{L!==null&&Y.types!==null&&(L.types=Y.types),K.T=L}},le.unstable_useCacheRefresh=function(){return K.H.useCacheRefresh()},le.use=function(O){return K.H.use(O)},le.useActionState=function(O,L,Y){return K.H.useActionState(O,L,Y)},le.useCallback=function(O,L){return K.H.useCallback(O,L)},le.useContext=function(O){return K.H.useContext(O)},le.useDebugValue=function(){},le.useDeferredValue=function(O,L){return K.H.useDeferredValue(O,L)},le.useEffect=function(O,L){return K.H.useEffect(O,L)},le.useEffectEvent=function(O){return K.H.useEffectEvent(O)},le.useId=function(){return K.H.useId()},le.useImperativeHandle=function(O,L,Y){return K.H.useImperativeHandle(O,L,Y)},le.useInsertionEffect=function(O,L){return K.H.useInsertionEffect(O,L)},le.useLayoutEffect=function(O,L){return K.H.useLayoutEffect(O,L)},le.useMemo=function(O,L){return K.H.useMemo(O,L)},le.useOptimistic=function(O,L){return K.H.useOptimistic(O,L)},le.useReducer=function(O,L,Y){return K.H.useReducer(O,L,Y)},le.useRef=function(O){return K.H.useRef(O)},le.useState=function(O){return K.H.useState(O)},le.useSyncExternalStore=function(O,L,Y){return K.H.useSyncExternalStore(O,L,Y)},le.useTransition=function(){return K.H.useTransition()},le.version="19.2.3",le}var y1;function tf(){return y1||(y1=1,Jp.exports=QC()),Jp.exports}var S=tf();const Pr=VC(S);var em={exports:{}},po={},tm={exports:{}},nm={};var v1;function XC(){return v1||(v1=1,(function(n){function e(M,V){var J=M.length;M.push(V);e:for(;0<J;){var ve=J-1>>>1,Ce=M[ve];if(0<o(Ce,V))M[ve]=V,M[J]=Ce,J=ve;else break e}}function i(M){return M.length===0?null:M[0]}function a(M){if(M.length===0)return null;var V=M[0],J=M.pop();if(J!==V){M[0]=J;e:for(var ve=0,Ce=M.length,O=Ce>>>1;ve<O;){var L=2*(ve+1)-1,Y=M[L],W=L+1,oe=M[W];if(0>o(Y,J))W<Ce&&0>o(oe,Y)?(M[ve]=oe,M[W]=J,ve=W):(M[ve]=Y,M[L]=J,ve=L);else if(W<Ce&&0>o(oe,J))M[ve]=oe,M[W]=J,ve=W;else break e}}return V}function o(M,V){var J=M.sortIndex-V.sortIndex;return J!==0?J:M.id-V.id}if(n.unstable_now=void 0,typeof performance=="object"&&typeof performance.now=="function"){var c=performance;n.unstable_now=function(){return c.now()}}else{var d=Date,m=d.now();n.unstable_now=function(){return d.now()-m}}var f=[],h=[],x=1,v=null,b=3,_=!1,N=!1,D=!1,q=!1,F=typeof setTimeout=="function"?setTimeout:null,I=typeof clearTimeout=="function"?clearTimeout:null,H=typeof setImmediate<"u"?setImmediate:null;function z(M){for(var V=i(h);V!==null;){if(V.callback===null)a(h);else if(V.startTime<=M)a(h),V.sortIndex=V.expirationTime,e(f,V);else break;V=i(h)}}function X(M){if(D=!1,z(M),!N)if(i(f)!==null)N=!0,Z||(Z=!0,qe());else{var V=i(h);V!==null&&he(X,V.startTime-M)}}var Z=!1,K=-1,fe=5,se=-1;function te(){return q?!0:!(n.unstable_now()-se<fe)}function Me(){if(q=!1,Z){var M=n.unstable_now();se=M;var V=!0;try{e:{N=!1,D&&(D=!1,I(K),K=-1),_=!0;var J=b;try{t:{for(z(M),v=i(f);v!==null&&!(v.expirationTime>M&&te());){var ve=v.callback;if(typeof ve=="function"){v.callback=null,b=v.priorityLevel;var Ce=ve(v.expirationTime<=M);if(M=n.unstable_now(),typeof Ce=="function"){v.callback=Ce,z(M),V=!0;break t}v===i(f)&&a(f),z(M)}else a(f);v=i(f)}if(v!==null)V=!0;else{var O=i(h);O!==null&&he(X,O.startTime-M),V=!1}}break e}finally{v=null,b=J,_=!1}V=void 0}}finally{V?qe():Z=!1}}}var qe;if(typeof H=="function")qe=function(){H(Me)};else if(typeof MessageChannel<"u"){var Dt=new MessageChannel,st=Dt.port2;Dt.port1.onmessage=Me,qe=function(){st.postMessage(null)}}else qe=function(){F(Me,0)};function he(M,V){K=F(function(){M(n.unstable_now())},V)}n.unstable_IdlePriority=5,n.unstable_ImmediatePriority=1,n.unstable_LowPriority=4,n.unstable_NormalPriority=3,n.unstable_Profiling=null,n.unstable_UserBlockingPriority=2,n.unstable_cancelCallback=function(M){M.callback=null},n.unstable_forceFrameRate=function(M){0>M||125<M?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):fe=0<M?Math.floor(1e3/M):5},n.unstable_getCurrentPriorityLevel=function(){return b},n.unstable_next=function(M){switch(b){case 1:case 2:case 3:var V=3;break;default:V=b}var J=b;b=V;try{return M()}finally{b=J}},n.unstable_requestPaint=function(){q=!0},n.unstable_runWithPriority=function(M,V){switch(M){case 1:case 2:case 3:case 4:case 5:break;default:M=3}var J=b;b=M;try{return V()}finally{b=J}},n.unstable_scheduleCallback=function(M,V,J){var ve=n.unstable_now();switch(typeof J=="object"&&J!==null?(J=J.delay,J=typeof J=="number"&&0<J?ve+J:ve):J=ve,M){case 1:var Ce=-1;break;case 2:Ce=250;break;case 5:Ce=1073741823;break;case 4:Ce=1e4;break;default:Ce=5e3}return Ce=J+Ce,M={id:x++,callback:V,priorityLevel:M,startTime:J,expirationTime:Ce,sortIndex:-1},J>ve?(M.sortIndex=J,e(h,M),i(f)===null&&M===i(h)&&(D?(I(K),K=-1):D=!0,he(X,J-ve))):(M.sortIndex=Ce,e(f,M),N||_||(N=!0,Z||(Z=!0,qe()))),M},n.unstable_shouldYield=te,n.unstable_wrapCallback=function(M){var V=b;return function(){var J=b;b=V;try{return M.apply(this,arguments)}finally{b=J}}}})(nm)),nm}var x1;function $C(){return x1||(x1=1,tm.exports=XC()),tm.exports}var im={exports:{}},_t={};var b1;function ZC(){if(b1)return _t;b1=1;var n=tf();function e(f){var h="https://react.dev/errors/"+f;if(1<arguments.length){h+="?args[]="+encodeURIComponent(arguments[1]);for(var x=2;x<arguments.length;x++)h+="&args[]="+encodeURIComponent(arguments[x])}return"Minified React error #"+f+"; visit "+h+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function i(){}var a={d:{f:i,r:function(){throw Error(e(522))},D:i,C:i,L:i,m:i,X:i,S:i,M:i},p:0,findDOMNode:null},o=Symbol.for("react.portal");function c(f,h,x){var v=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:o,key:v==null?null:""+v,children:f,containerInfo:h,implementation:x}}var d=n.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;function m(f,h){if(f==="font")return"";if(typeof h=="string")return h==="use-credentials"?h:""}return _t.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=a,_t.createPortal=function(f,h){var x=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!h||h.nodeType!==1&&h.nodeType!==9&&h.nodeType!==11)throw Error(e(299));return c(f,h,null,x)},_t.flushSync=function(f){var h=d.T,x=a.p;try{if(d.T=null,a.p=2,f)return f()}finally{d.T=h,a.p=x,a.d.f()}},_t.preconnect=function(f,h){typeof f=="string"&&(h?(h=h.crossOrigin,h=typeof h=="string"?h==="use-credentials"?h:"":void 0):h=null,a.d.C(f,h))},_t.prefetchDNS=function(f){typeof f=="string"&&a.d.D(f)},_t.preinit=function(f,h){if(typeof f=="string"&&h&&typeof h.as=="string"){var x=h.as,v=m(x,h.crossOrigin),b=typeof h.integrity=="string"?h.integrity:void 0,_=typeof h.fetchPriority=="string"?h.fetchPriority:void 0;x==="style"?a.d.S(f,typeof h.precedence=="string"?h.precedence:void 0,{crossOrigin:v,integrity:b,fetchPriority:_}):x==="script"&&a.d.X(f,{crossOrigin:v,integrity:b,fetchPriority:_,nonce:typeof h.nonce=="string"?h.nonce:void 0})}},_t.preinitModule=function(f,h){if(typeof f=="string")if(typeof h=="object"&&h!==null){if(h.as==null||h.as==="script"){var x=m(h.as,h.crossOrigin);a.d.M(f,{crossOrigin:x,integrity:typeof h.integrity=="string"?h.integrity:void 0,nonce:typeof h.nonce=="string"?h.nonce:void 0})}}else h==null&&a.d.M(f)},_t.preload=function(f,h){if(typeof f=="string"&&typeof h=="object"&&h!==null&&typeof h.as=="string"){var x=h.as,v=m(x,h.crossOrigin);a.d.L(f,x,{crossOrigin:v,integrity:typeof h.integrity=="string"?h.integrity:void 0,nonce:typeof h.nonce=="string"?h.nonce:void 0,type:typeof h.type=="string"?h.type:void 0,fetchPriority:typeof h.fetchPriority=="string"?h.fetchPriority:void 0,referrerPolicy:typeof h.referrerPolicy=="string"?h.referrerPolicy:void 0,imageSrcSet:typeof h.imageSrcSet=="string"?h.imageSrcSet:void 0,imageSizes:typeof h.imageSizes=="string"?h.imageSizes:void 0,media:typeof h.media=="string"?h.media:void 0})}},_t.preloadModule=function(f,h){if(typeof f=="string")if(h){var x=m(h.as,h.crossOrigin);a.d.m(f,{as:typeof h.as=="string"&&h.as!=="script"?h.as:void 0,crossOrigin:x,integrity:typeof h.integrity=="string"?h.integrity:void 0})}else a.d.m(f)},_t.requestFormReset=function(f){a.d.r(f)},_t.unstable_batchedUpdates=function(f,h){return f(h)},_t.useFormState=function(f,h,x){return d.H.useFormState(f,h,x)},_t.useFormStatus=function(){return d.H.useHostTransitionStatus()},_t.version="19.2.3",_t}var w1;function JC(){if(w1)return im.exports;w1=1;function n(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n)}catch(e){console.error(e)}}return n(),im.exports=ZC(),im.exports}var S1;function eO(){if(S1)return po;S1=1;var n=$C(),e=tf(),i=JC();function a(t){var r="https://react.dev/errors/"+t;if(1<arguments.length){r+="?args[]="+encodeURIComponent(arguments[1]);for(var s=2;s<arguments.length;s++)r+="&args[]="+encodeURIComponent(arguments[s])}return"Minified React error #"+t+"; visit "+r+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function o(t){return!(!t||t.nodeType!==1&&t.nodeType!==9&&t.nodeType!==11)}function c(t){var r=t,s=t;if(t.alternate)for(;r.return;)r=r.return;else{t=r;do r=t,(r.flags&4098)!==0&&(s=r.return),t=r.return;while(t)}return r.tag===3?s:null}function d(t){if(t.tag===13){var r=t.memoizedState;if(r===null&&(t=t.alternate,t!==null&&(r=t.memoizedState)),r!==null)return r.dehydrated}return null}function m(t){if(t.tag===31){var r=t.memoizedState;if(r===null&&(t=t.alternate,t!==null&&(r=t.memoizedState)),r!==null)return r.dehydrated}return null}function f(t){if(c(t)!==t)throw Error(a(188))}function h(t){var r=t.alternate;if(!r){if(r=c(t),r===null)throw Error(a(188));return r!==t?null:t}for(var s=t,l=r;;){var u=s.return;if(u===null)break;var p=u.alternate;if(p===null){if(l=u.return,l!==null){s=l;continue}break}if(u.child===p.child){for(p=u.child;p;){if(p===s)return f(u),t;if(p===l)return f(u),r;p=p.sibling}throw Error(a(188))}if(s.return!==l.return)s=u,l=p;else{for(var g=!1,w=u.child;w;){if(w===s){g=!0,s=u,l=p;break}if(w===l){g=!0,l=u,s=p;break}w=w.sibling}if(!g){for(w=p.child;w;){if(w===s){g=!0,s=p,l=u;break}if(w===l){g=!0,l=p,s=u;break}w=w.sibling}if(!g)throw Error(a(189))}}if(s.alternate!==l)throw Error(a(190))}if(s.tag!==3)throw Error(a(188));return s.stateNode.current===s?t:r}function x(t){var r=t.tag;if(r===5||r===26||r===27||r===6)return t;for(t=t.child;t!==null;){if(r=x(t),r!==null)return r;t=t.sibling}return null}var v=Object.assign,b=Symbol.for("react.element"),_=Symbol.for("react.transitional.element"),N=Symbol.for("react.portal"),D=Symbol.for("react.fragment"),q=Symbol.for("react.strict_mode"),F=Symbol.for("react.profiler"),I=Symbol.for("react.consumer"),H=Symbol.for("react.context"),z=Symbol.for("react.forward_ref"),X=Symbol.for("react.suspense"),Z=Symbol.for("react.suspense_list"),K=Symbol.for("react.memo"),fe=Symbol.for("react.lazy"),se=Symbol.for("react.activity"),te=Symbol.for("react.memo_cache_sentinel"),Me=Symbol.iterator;function qe(t){return t===null||typeof t!="object"?null:(t=Me&&t[Me]||t["@@iterator"],typeof t=="function"?t:null)}var Dt=Symbol.for("react.client.reference");function st(t){if(t==null)return null;if(typeof t=="function")return t.$$typeof===Dt?null:t.displayName||t.name||null;if(typeof t=="string")return t;switch(t){case D:return"Fragment";case F:return"Profiler";case q:return"StrictMode";case X:return"Suspense";case Z:return"SuspenseList";case se:return"Activity"}if(typeof t=="object")switch(t.$$typeof){case N:return"Portal";case H:return t.displayName||"Context";case I:return(t._context.displayName||"Context")+".Consumer";case z:var r=t.render;return t=t.displayName,t||(t=r.displayName||r.name||"",t=t!==""?"ForwardRef("+t+")":"ForwardRef"),t;case K:return r=t.displayName||null,r!==null?r:st(t.type)||"Memo";case fe:r=t._payload,t=t._init;try{return st(t(r))}catch{}}return null}var he=Array.isArray,M=e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,V=i.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,J={pending:!1,data:null,method:null,action:null},ve=[],Ce=-1;function O(t){return{current:t}}function L(t){0>Ce||(t.current=ve[Ce],ve[Ce]=null,Ce--)}function Y(t,r){Ce++,ve[Ce]=t.current,t.current=r}var W=O(null),oe=O(null),ce=O(null),ke=O(null);function dt(t,r){switch(Y(ce,r),Y(oe,t),Y(W,null),r.nodeType){case 9:case 11:t=(t=r.documentElement)&&(t=t.namespaceURI)?Ly(t):0;break;default:if(t=r.tagName,r=r.namespaceURI)r=Ly(r),t=Uy(r,t);else switch(t){case"svg":t=1;break;case"math":t=2;break;default:t=0}}L(W),Y(W,t)}function We(){L(W),L(oe),L(ce)}function pr(t){t.memoizedState!==null&&Y(ke,t);var r=W.current,s=Uy(r,t.type);r!==s&&(Y(oe,t),Y(W,s))}function Zr(t){oe.current===t&&(L(W),L(oe)),ke.current===t&&(L(ke),so._currentValue=J)}var ms,sl;function Bn(t){if(ms===void 0)try{throw Error()}catch(s){var r=s.stack.trim().match(/\n( *(at )?)/);ms=r&&r[1]||"",sl=-1<s.stack.indexOf(`
    at`)?" (<anonymous>)":-1<s.stack.indexOf("@")?"@unknown:0:0":""}return`
`+ms+t+sl}var fs=!1;function hs(t,r){if(!t||fs)return"";fs=!0;var s=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{var l={DetermineComponentFrameRoot:function(){try{if(r){var B=function(){throw Error()};if(Object.defineProperty(B.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(B,[])}catch(R){var A=R}Reflect.construct(t,[],B)}else{try{B.call()}catch(R){A=R}t.call(B.prototype)}}else{try{throw Error()}catch(R){A=R}(B=t())&&typeof B.catch=="function"&&B.catch(function(){})}}catch(R){if(R&&A&&typeof R.stack=="string")return[R.stack,A.stack]}return[null,null]}};l.DetermineComponentFrameRoot.displayName="DetermineComponentFrameRoot";var u=Object.getOwnPropertyDescriptor(l.DetermineComponentFrameRoot,"name");u&&u.configurable&&Object.defineProperty(l.DetermineComponentFrameRoot,"name",{value:"DetermineComponentFrameRoot"});var p=l.DetermineComponentFrameRoot(),g=p[0],w=p[1];if(g&&w){var C=g.split(`
`),j=w.split(`
`);for(u=l=0;l<C.length&&!C[l].includes("DetermineComponentFrameRoot");)l++;for(;u<j.length&&!j[u].includes("DetermineComponentFrameRoot");)u++;if(l===C.length||u===j.length)for(l=C.length-1,u=j.length-1;1<=l&&0<=u&&C[l]!==j[u];)u--;for(;1<=l&&0<=u;l--,u--)if(C[l]!==j[u]){if(l!==1||u!==1)do if(l--,u--,0>u||C[l]!==j[u]){var P=`
`+C[l].replace(" at new "," at ");return t.displayName&&P.includes("<anonymous>")&&(P=P.replace("<anonymous>",t.displayName)),P}while(1<=l&&0<=u);break}}}finally{fs=!1,Error.prepareStackTrace=s}return(s=t?t.displayName||t.name:"")?Bn(s):""}function Uu(t,r){switch(t.tag){case 26:case 27:case 5:return Bn(t.type);case 16:return Bn("Lazy");case 13:return t.child!==r&&r!==null?Bn("Suspense Fallback"):Bn("Suspense");case 19:return Bn("SuspenseList");case 0:case 15:return hs(t.type,!1);case 11:return hs(t.type.render,!1);case 1:return hs(t.type,!0);case 31:return Bn("Activity");default:return""}}function ol(t){try{var r="",s=null;do r+=Uu(t,s),s=t,t=t.return;while(t);return r}catch(l){return`
Error generating stack: `+l.message+`
`+l.stack}}var xi=Object.prototype.hasOwnProperty,ne=n.unstable_scheduleCallback,He=n.unstable_cancelCallback,It=n.unstable_shouldYield,Jr=n.unstable_requestPaint,kt=n.unstable_now,bi=n.unstable_getCurrentPriorityLevel,ll=n.unstable_ImmediatePriority,gs=n.unstable_UserBlockingPriority,ea=n.unstable_NormalPriority,Bu=n.unstable_LowPriority,ys=n.unstable_IdlePriority,NS=n.log,ES=n.unstable_setDisableYieldValue,vs=null,Gt=null;function wi(t){if(typeof NS=="function"&&ES(t),Gt&&typeof Gt.setStrictMode=="function")try{Gt.setStrictMode(vs,t)}catch{}}var Vt=Math.clz32?Math.clz32:MS,jS=Math.log,AS=Math.LN2;function MS(t){return t>>>=0,t===0?32:31-(jS(t)/AS|0)|0}var cl=256,ul=262144,dl=4194304;function mr(t){var r=t&42;if(r!==0)return r;switch(t&-t){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:return 64;case 128:return 128;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:return t&261888;case 262144:case 524288:case 1048576:case 2097152:return t&3932160;case 4194304:case 8388608:case 16777216:case 33554432:return t&62914560;case 67108864:return 67108864;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 0;default:return t}}function pl(t,r,s){var l=t.pendingLanes;if(l===0)return 0;var u=0,p=t.suspendedLanes,g=t.pingedLanes;t=t.warmLanes;var w=l&134217727;return w!==0?(l=w&~p,l!==0?u=mr(l):(g&=w,g!==0?u=mr(g):s||(s=w&~t,s!==0&&(u=mr(s))))):(w=l&~p,w!==0?u=mr(w):g!==0?u=mr(g):s||(s=l&~t,s!==0&&(u=mr(s)))),u===0?0:r!==0&&r!==u&&(r&p)===0&&(p=u&-u,s=r&-r,p>=s||p===32&&(s&4194048)!==0)?r:u}function xs(t,r){return(t.pendingLanes&~(t.suspendedLanes&~t.pingedLanes)&r)===0}function RS(t,r){switch(t){case 1:case 2:case 4:case 8:case 64:return r+250;case 16:case 32:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return r+5e3;case 4194304:case 8388608:case 16777216:case 33554432:return-1;case 67108864:case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function vh(){var t=dl;return dl<<=1,(dl&62914560)===0&&(dl=4194304),t}function zu(t){for(var r=[],s=0;31>s;s++)r.push(t);return r}function bs(t,r){t.pendingLanes|=r,r!==268435456&&(t.suspendedLanes=0,t.pingedLanes=0,t.warmLanes=0)}function DS(t,r,s,l,u,p){var g=t.pendingLanes;t.pendingLanes=s,t.suspendedLanes=0,t.pingedLanes=0,t.warmLanes=0,t.expiredLanes&=s,t.entangledLanes&=s,t.errorRecoveryDisabledLanes&=s,t.shellSuspendCounter=0;var w=t.entanglements,C=t.expirationTimes,j=t.hiddenUpdates;for(s=g&~s;0<s;){var P=31-Vt(s),B=1<<P;w[P]=0,C[P]=-1;var A=j[P];if(A!==null)for(j[P]=null,P=0;P<A.length;P++){var R=A[P];R!==null&&(R.lane&=-536870913)}s&=~B}l!==0&&xh(t,l,0),p!==0&&u===0&&t.tag!==0&&(t.suspendedLanes|=p&~(g&~r))}function xh(t,r,s){t.pendingLanes|=r,t.suspendedLanes&=~r;var l=31-Vt(r);t.entangledLanes|=r,t.entanglements[l]=t.entanglements[l]|1073741824|s&261930}function bh(t,r){var s=t.entangledLanes|=r;for(t=t.entanglements;s;){var l=31-Vt(s),u=1<<l;u&r|t[l]&r&&(t[l]|=r),s&=~u}}function wh(t,r){var s=r&-r;return s=(s&42)!==0?1:Fu(s),(s&(t.suspendedLanes|r))!==0?0:s}function Fu(t){switch(t){case 2:t=1;break;case 8:t=4;break;case 32:t=16;break;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:t=128;break;case 268435456:t=134217728;break;default:t=0}return t}function qu(t){return t&=-t,2<t?8<t?(t&134217727)!==0?32:268435456:8:2}function Sh(){var t=V.p;return t!==0?t:(t=window.event,t===void 0?32:o1(t.type))}function Ch(t,r){var s=V.p;try{return V.p=t,r()}finally{V.p=s}}var Si=Math.random().toString(36).slice(2),bt="__reactFiber$"+Si,Pt="__reactProps$"+Si,ta="__reactContainer$"+Si,Hu="__reactEvents$"+Si,IS="__reactListeners$"+Si,PS="__reactHandles$"+Si,Oh="__reactResources$"+Si,ws="__reactMarker$"+Si;function Yu(t){delete t[bt],delete t[Pt],delete t[Hu],delete t[IS],delete t[PS]}function na(t){var r=t[bt];if(r)return r;for(var s=t.parentNode;s;){if(r=s[ta]||s[bt]){if(s=r.alternate,r.child!==null||s!==null&&s.child!==null)for(t=Gy(t);t!==null;){if(s=t[bt])return s;t=Gy(t)}return r}t=s,s=t.parentNode}return null}function ia(t){if(t=t[bt]||t[ta]){var r=t.tag;if(r===5||r===6||r===13||r===31||r===26||r===27||r===3)return t}return null}function Ss(t){var r=t.tag;if(r===5||r===26||r===27||r===6)return t.stateNode;throw Error(a(33))}function ra(t){var r=t[Oh];return r||(r=t[Oh]={hoistableStyles:new Map,hoistableScripts:new Map}),r}function ft(t){t[ws]=!0}var _h=new Set,Th={};function fr(t,r){aa(t,r),aa(t+"Capture",r)}function aa(t,r){for(Th[t]=r,t=0;t<r.length;t++)_h.add(r[t])}var LS=RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"),kh={},Nh={};function US(t){return xi.call(Nh,t)?!0:xi.call(kh,t)?!1:LS.test(t)?Nh[t]=!0:(kh[t]=!0,!1)}function ml(t,r,s){if(US(r))if(s===null)t.removeAttribute(r);else{switch(typeof s){case"undefined":case"function":case"symbol":t.removeAttribute(r);return;case"boolean":var l=r.toLowerCase().slice(0,5);if(l!=="data-"&&l!=="aria-"){t.removeAttribute(r);return}}t.setAttribute(r,""+s)}}function fl(t,r,s){if(s===null)t.removeAttribute(r);else{switch(typeof s){case"undefined":case"function":case"symbol":case"boolean":t.removeAttribute(r);return}t.setAttribute(r,""+s)}}function zn(t,r,s,l){if(l===null)t.removeAttribute(s);else{switch(typeof l){case"undefined":case"function":case"symbol":case"boolean":t.removeAttribute(s);return}t.setAttributeNS(r,s,""+l)}}function rn(t){switch(typeof t){case"bigint":case"boolean":case"number":case"string":case"undefined":return t;case"object":return t;default:return""}}function Eh(t){var r=t.type;return(t=t.nodeName)&&t.toLowerCase()==="input"&&(r==="checkbox"||r==="radio")}function BS(t,r,s){var l=Object.getOwnPropertyDescriptor(t.constructor.prototype,r);if(!t.hasOwnProperty(r)&&typeof l<"u"&&typeof l.get=="function"&&typeof l.set=="function"){var u=l.get,p=l.set;return Object.defineProperty(t,r,{configurable:!0,get:function(){return u.call(this)},set:function(g){s=""+g,p.call(this,g)}}),Object.defineProperty(t,r,{enumerable:l.enumerable}),{getValue:function(){return s},setValue:function(g){s=""+g},stopTracking:function(){t._valueTracker=null,delete t[r]}}}}function Gu(t){if(!t._valueTracker){var r=Eh(t)?"checked":"value";t._valueTracker=BS(t,r,""+t[r])}}function jh(t){if(!t)return!1;var r=t._valueTracker;if(!r)return!0;var s=r.getValue(),l="";return t&&(l=Eh(t)?t.checked?"true":"false":t.value),t=l,t!==s?(r.setValue(t),!0):!1}function hl(t){if(t=t||(typeof document<"u"?document:void 0),typeof t>"u")return null;try{return t.activeElement||t.body}catch{return t.body}}var zS=/[\n"\\]/g;function an(t){return t.replace(zS,function(r){return"\\"+r.charCodeAt(0).toString(16)+" "})}function Vu(t,r,s,l,u,p,g,w){t.name="",g!=null&&typeof g!="function"&&typeof g!="symbol"&&typeof g!="boolean"?t.type=g:t.removeAttribute("type"),r!=null?g==="number"?(r===0&&t.value===""||t.value!=r)&&(t.value=""+rn(r)):t.value!==""+rn(r)&&(t.value=""+rn(r)):g!=="submit"&&g!=="reset"||t.removeAttribute("value"),r!=null?Wu(t,g,rn(r)):s!=null?Wu(t,g,rn(s)):l!=null&&t.removeAttribute("value"),u==null&&p!=null&&(t.defaultChecked=!!p),u!=null&&(t.checked=u&&typeof u!="function"&&typeof u!="symbol"),w!=null&&typeof w!="function"&&typeof w!="symbol"&&typeof w!="boolean"?t.name=""+rn(w):t.removeAttribute("name")}function Ah(t,r,s,l,u,p,g,w){if(p!=null&&typeof p!="function"&&typeof p!="symbol"&&typeof p!="boolean"&&(t.type=p),r!=null||s!=null){if(!(p!=="submit"&&p!=="reset"||r!=null)){Gu(t);return}s=s!=null?""+rn(s):"",r=r!=null?""+rn(r):s,w||r===t.value||(t.value=r),t.defaultValue=r}l=l??u,l=typeof l!="function"&&typeof l!="symbol"&&!!l,t.checked=w?t.checked:!!l,t.defaultChecked=!!l,g!=null&&typeof g!="function"&&typeof g!="symbol"&&typeof g!="boolean"&&(t.name=g),Gu(t)}function Wu(t,r,s){r==="number"&&hl(t.ownerDocument)===t||t.defaultValue===""+s||(t.defaultValue=""+s)}function sa(t,r,s,l){if(t=t.options,r){r={};for(var u=0;u<s.length;u++)r["$"+s[u]]=!0;for(s=0;s<t.length;s++)u=r.hasOwnProperty("$"+t[s].value),t[s].selected!==u&&(t[s].selected=u),u&&l&&(t[s].defaultSelected=!0)}else{for(s=""+rn(s),r=null,u=0;u<t.length;u++){if(t[u].value===s){t[u].selected=!0,l&&(t[u].defaultSelected=!0);return}r!==null||t[u].disabled||(r=t[u])}r!==null&&(r.selected=!0)}}function Mh(t,r,s){if(r!=null&&(r=""+rn(r),r!==t.value&&(t.value=r),s==null)){t.defaultValue!==r&&(t.defaultValue=r);return}t.defaultValue=s!=null?""+rn(s):""}function Rh(t,r,s,l){if(r==null){if(l!=null){if(s!=null)throw Error(a(92));if(he(l)){if(1<l.length)throw Error(a(93));l=l[0]}s=l}s==null&&(s=""),r=s}s=rn(r),t.defaultValue=s,l=t.textContent,l===s&&l!==""&&l!==null&&(t.value=l),Gu(t)}function oa(t,r){if(r){var s=t.firstChild;if(s&&s===t.lastChild&&s.nodeType===3){s.nodeValue=r;return}}t.textContent=r}var FS=new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));function Dh(t,r,s){var l=r.indexOf("--")===0;s==null||typeof s=="boolean"||s===""?l?t.setProperty(r,""):r==="float"?t.cssFloat="":t[r]="":l?t.setProperty(r,s):typeof s!="number"||s===0||FS.has(r)?r==="float"?t.cssFloat=s:t[r]=(""+s).trim():t[r]=s+"px"}function Ih(t,r,s){if(r!=null&&typeof r!="object")throw Error(a(62));if(t=t.style,s!=null){for(var l in s)!s.hasOwnProperty(l)||r!=null&&r.hasOwnProperty(l)||(l.indexOf("--")===0?t.setProperty(l,""):l==="float"?t.cssFloat="":t[l]="");for(var u in r)l=r[u],r.hasOwnProperty(u)&&s[u]!==l&&Dh(t,u,l)}else for(var p in r)r.hasOwnProperty(p)&&Dh(t,p,r[p])}function Ku(t){if(t.indexOf("-")===-1)return!1;switch(t){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var qS=new Map([["acceptCharset","accept-charset"],["htmlFor","for"],["httpEquiv","http-equiv"],["crossOrigin","crossorigin"],["accentHeight","accent-height"],["alignmentBaseline","alignment-baseline"],["arabicForm","arabic-form"],["baselineShift","baseline-shift"],["capHeight","cap-height"],["clipPath","clip-path"],["clipRule","clip-rule"],["colorInterpolation","color-interpolation"],["colorInterpolationFilters","color-interpolation-filters"],["colorProfile","color-profile"],["colorRendering","color-rendering"],["dominantBaseline","dominant-baseline"],["enableBackground","enable-background"],["fillOpacity","fill-opacity"],["fillRule","fill-rule"],["floodColor","flood-color"],["floodOpacity","flood-opacity"],["fontFamily","font-family"],["fontSize","font-size"],["fontSizeAdjust","font-size-adjust"],["fontStretch","font-stretch"],["fontStyle","font-style"],["fontVariant","font-variant"],["fontWeight","font-weight"],["glyphName","glyph-name"],["glyphOrientationHorizontal","glyph-orientation-horizontal"],["glyphOrientationVertical","glyph-orientation-vertical"],["horizAdvX","horiz-adv-x"],["horizOriginX","horiz-origin-x"],["imageRendering","image-rendering"],["letterSpacing","letter-spacing"],["lightingColor","lighting-color"],["markerEnd","marker-end"],["markerMid","marker-mid"],["markerStart","marker-start"],["overlinePosition","overline-position"],["overlineThickness","overline-thickness"],["paintOrder","paint-order"],["panose-1","panose-1"],["pointerEvents","pointer-events"],["renderingIntent","rendering-intent"],["shapeRendering","shape-rendering"],["stopColor","stop-color"],["stopOpacity","stop-opacity"],["strikethroughPosition","strikethrough-position"],["strikethroughThickness","strikethrough-thickness"],["strokeDasharray","stroke-dasharray"],["strokeDashoffset","stroke-dashoffset"],["strokeLinecap","stroke-linecap"],["strokeLinejoin","stroke-linejoin"],["strokeMiterlimit","stroke-miterlimit"],["strokeOpacity","stroke-opacity"],["strokeWidth","stroke-width"],["textAnchor","text-anchor"],["textDecoration","text-decoration"],["textRendering","text-rendering"],["transformOrigin","transform-origin"],["underlinePosition","underline-position"],["underlineThickness","underline-thickness"],["unicodeBidi","unicode-bidi"],["unicodeRange","unicode-range"],["unitsPerEm","units-per-em"],["vAlphabetic","v-alphabetic"],["vHanging","v-hanging"],["vIdeographic","v-ideographic"],["vMathematical","v-mathematical"],["vectorEffect","vector-effect"],["vertAdvY","vert-adv-y"],["vertOriginX","vert-origin-x"],["vertOriginY","vert-origin-y"],["wordSpacing","word-spacing"],["writingMode","writing-mode"],["xmlnsXlink","xmlns:xlink"],["xHeight","x-height"]]),HS=/^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;function gl(t){return HS.test(""+t)?"javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')":t}function Fn(){}var Qu=null;function Xu(t){return t=t.target||t.srcElement||window,t.correspondingUseElement&&(t=t.correspondingUseElement),t.nodeType===3?t.parentNode:t}var la=null,ca=null;function Ph(t){var r=ia(t);if(r&&(t=r.stateNode)){var s=t[Pt]||null;e:switch(t=r.stateNode,r.type){case"input":if(Vu(t,s.value,s.defaultValue,s.defaultValue,s.checked,s.defaultChecked,s.type,s.name),r=s.name,s.type==="radio"&&r!=null){for(s=t;s.parentNode;)s=s.parentNode;for(s=s.querySelectorAll('input[name="'+an(""+r)+'"][type="radio"]'),r=0;r<s.length;r++){var l=s[r];if(l!==t&&l.form===t.form){var u=l[Pt]||null;if(!u)throw Error(a(90));Vu(l,u.value,u.defaultValue,u.defaultValue,u.checked,u.defaultChecked,u.type,u.name)}}for(r=0;r<s.length;r++)l=s[r],l.form===t.form&&jh(l)}break e;case"textarea":Mh(t,s.value,s.defaultValue);break e;case"select":r=s.value,r!=null&&sa(t,!!s.multiple,r,!1)}}}var $u=!1;function Lh(t,r,s){if($u)return t(r,s);$u=!0;try{var l=t(r);return l}finally{if($u=!1,(la!==null||ca!==null)&&(ic(),la&&(r=la,t=ca,ca=la=null,Ph(r),t)))for(r=0;r<t.length;r++)Ph(t[r])}}function Cs(t,r){var s=t.stateNode;if(s===null)return null;var l=s[Pt]||null;if(l===null)return null;s=l[r];e:switch(r){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(l=!l.disabled)||(t=t.type,l=!(t==="button"||t==="input"||t==="select"||t==="textarea")),t=!l;break e;default:t=!1}if(t)return null;if(s&&typeof s!="function")throw Error(a(231,r,typeof s));return s}var qn=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),Zu=!1;if(qn)try{var Os={};Object.defineProperty(Os,"passive",{get:function(){Zu=!0}}),window.addEventListener("test",Os,Os),window.removeEventListener("test",Os,Os)}catch{Zu=!1}var Ci=null,Ju=null,yl=null;function Uh(){if(yl)return yl;var t,r=Ju,s=r.length,l,u="value"in Ci?Ci.value:Ci.textContent,p=u.length;for(t=0;t<s&&r[t]===u[t];t++);var g=s-t;for(l=1;l<=g&&r[s-l]===u[p-l];l++);return yl=u.slice(t,1<l?1-l:void 0)}function vl(t){var r=t.keyCode;return"charCode"in t?(t=t.charCode,t===0&&r===13&&(t=13)):t=r,t===10&&(t=13),32<=t||t===13?t:0}function xl(){return!0}function Bh(){return!1}function Lt(t){function r(s,l,u,p,g){this._reactName=s,this._targetInst=u,this.type=l,this.nativeEvent=p,this.target=g,this.currentTarget=null;for(var w in t)t.hasOwnProperty(w)&&(s=t[w],this[w]=s?s(p):p[w]);return this.isDefaultPrevented=(p.defaultPrevented!=null?p.defaultPrevented:p.returnValue===!1)?xl:Bh,this.isPropagationStopped=Bh,this}return v(r.prototype,{preventDefault:function(){this.defaultPrevented=!0;var s=this.nativeEvent;s&&(s.preventDefault?s.preventDefault():typeof s.returnValue!="unknown"&&(s.returnValue=!1),this.isDefaultPrevented=xl)},stopPropagation:function(){var s=this.nativeEvent;s&&(s.stopPropagation?s.stopPropagation():typeof s.cancelBubble!="unknown"&&(s.cancelBubble=!0),this.isPropagationStopped=xl)},persist:function(){},isPersistent:xl}),r}var hr={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(t){return t.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},bl=Lt(hr),_s=v({},hr,{view:0,detail:0}),YS=Lt(_s),ed,td,Ts,wl=v({},_s,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:id,button:0,buttons:0,relatedTarget:function(t){return t.relatedTarget===void 0?t.fromElement===t.srcElement?t.toElement:t.fromElement:t.relatedTarget},movementX:function(t){return"movementX"in t?t.movementX:(t!==Ts&&(Ts&&t.type==="mousemove"?(ed=t.screenX-Ts.screenX,td=t.screenY-Ts.screenY):td=ed=0,Ts=t),ed)},movementY:function(t){return"movementY"in t?t.movementY:td}}),zh=Lt(wl),GS=v({},wl,{dataTransfer:0}),VS=Lt(GS),WS=v({},_s,{relatedTarget:0}),nd=Lt(WS),KS=v({},hr,{animationName:0,elapsedTime:0,pseudoElement:0}),QS=Lt(KS),XS=v({},hr,{clipboardData:function(t){return"clipboardData"in t?t.clipboardData:window.clipboardData}}),$S=Lt(XS),ZS=v({},hr,{data:0}),Fh=Lt(ZS),JS={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},e2={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},t2={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function n2(t){var r=this.nativeEvent;return r.getModifierState?r.getModifierState(t):(t=t2[t])?!!r[t]:!1}function id(){return n2}var i2=v({},_s,{key:function(t){if(t.key){var r=JS[t.key]||t.key;if(r!=="Unidentified")return r}return t.type==="keypress"?(t=vl(t),t===13?"Enter":String.fromCharCode(t)):t.type==="keydown"||t.type==="keyup"?e2[t.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:id,charCode:function(t){return t.type==="keypress"?vl(t):0},keyCode:function(t){return t.type==="keydown"||t.type==="keyup"?t.keyCode:0},which:function(t){return t.type==="keypress"?vl(t):t.type==="keydown"||t.type==="keyup"?t.keyCode:0}}),r2=Lt(i2),a2=v({},wl,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),qh=Lt(a2),s2=v({},_s,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:id}),o2=Lt(s2),l2=v({},hr,{propertyName:0,elapsedTime:0,pseudoElement:0}),c2=Lt(l2),u2=v({},wl,{deltaX:function(t){return"deltaX"in t?t.deltaX:"wheelDeltaX"in t?-t.wheelDeltaX:0},deltaY:function(t){return"deltaY"in t?t.deltaY:"wheelDeltaY"in t?-t.wheelDeltaY:"wheelDelta"in t?-t.wheelDelta:0},deltaZ:0,deltaMode:0}),d2=Lt(u2),p2=v({},hr,{newState:0,oldState:0}),m2=Lt(p2),f2=[9,13,27,32],rd=qn&&"CompositionEvent"in window,ks=null;qn&&"documentMode"in document&&(ks=document.documentMode);var h2=qn&&"TextEvent"in window&&!ks,Hh=qn&&(!rd||ks&&8<ks&&11>=ks),Yh=" ",Gh=!1;function Vh(t,r){switch(t){case"keyup":return f2.indexOf(r.keyCode)!==-1;case"keydown":return r.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function Wh(t){return t=t.detail,typeof t=="object"&&"data"in t?t.data:null}var ua=!1;function g2(t,r){switch(t){case"compositionend":return Wh(r);case"keypress":return r.which!==32?null:(Gh=!0,Yh);case"textInput":return t=r.data,t===Yh&&Gh?null:t;default:return null}}function y2(t,r){if(ua)return t==="compositionend"||!rd&&Vh(t,r)?(t=Uh(),yl=Ju=Ci=null,ua=!1,t):null;switch(t){case"paste":return null;case"keypress":if(!(r.ctrlKey||r.altKey||r.metaKey)||r.ctrlKey&&r.altKey){if(r.char&&1<r.char.length)return r.char;if(r.which)return String.fromCharCode(r.which)}return null;case"compositionend":return Hh&&r.locale!=="ko"?null:r.data;default:return null}}var v2={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function Kh(t){var r=t&&t.nodeName&&t.nodeName.toLowerCase();return r==="input"?!!v2[t.type]:r==="textarea"}function Qh(t,r,s,l){la?ca?ca.push(l):ca=[l]:la=l,r=uc(r,"onChange"),0<r.length&&(s=new bl("onChange","change",null,s,l),t.push({event:s,listeners:r}))}var Ns=null,Es=null;function x2(t){Ay(t,0)}function Sl(t){var r=Ss(t);if(jh(r))return t}function Xh(t,r){if(t==="change")return r}var $h=!1;if(qn){var ad;if(qn){var sd="oninput"in document;if(!sd){var Zh=document.createElement("div");Zh.setAttribute("oninput","return;"),sd=typeof Zh.oninput=="function"}ad=sd}else ad=!1;$h=ad&&(!document.documentMode||9<document.documentMode)}function Jh(){Ns&&(Ns.detachEvent("onpropertychange",eg),Es=Ns=null)}function eg(t){if(t.propertyName==="value"&&Sl(Es)){var r=[];Qh(r,Es,t,Xu(t)),Lh(x2,r)}}function b2(t,r,s){t==="focusin"?(Jh(),Ns=r,Es=s,Ns.attachEvent("onpropertychange",eg)):t==="focusout"&&Jh()}function w2(t){if(t==="selectionchange"||t==="keyup"||t==="keydown")return Sl(Es)}function S2(t,r){if(t==="click")return Sl(r)}function C2(t,r){if(t==="input"||t==="change")return Sl(r)}function O2(t,r){return t===r&&(t!==0||1/t===1/r)||t!==t&&r!==r}var Wt=typeof Object.is=="function"?Object.is:O2;function js(t,r){if(Wt(t,r))return!0;if(typeof t!="object"||t===null||typeof r!="object"||r===null)return!1;var s=Object.keys(t),l=Object.keys(r);if(s.length!==l.length)return!1;for(l=0;l<s.length;l++){var u=s[l];if(!xi.call(r,u)||!Wt(t[u],r[u]))return!1}return!0}function tg(t){for(;t&&t.firstChild;)t=t.firstChild;return t}function ng(t,r){var s=tg(t);t=0;for(var l;s;){if(s.nodeType===3){if(l=t+s.textContent.length,t<=r&&l>=r)return{node:s,offset:r-t};t=l}e:{for(;s;){if(s.nextSibling){s=s.nextSibling;break e}s=s.parentNode}s=void 0}s=tg(s)}}function ig(t,r){return t&&r?t===r?!0:t&&t.nodeType===3?!1:r&&r.nodeType===3?ig(t,r.parentNode):"contains"in t?t.contains(r):t.compareDocumentPosition?!!(t.compareDocumentPosition(r)&16):!1:!1}function rg(t){t=t!=null&&t.ownerDocument!=null&&t.ownerDocument.defaultView!=null?t.ownerDocument.defaultView:window;for(var r=hl(t.document);r instanceof t.HTMLIFrameElement;){try{var s=typeof r.contentWindow.location.href=="string"}catch{s=!1}if(s)t=r.contentWindow;else break;r=hl(t.document)}return r}function od(t){var r=t&&t.nodeName&&t.nodeName.toLowerCase();return r&&(r==="input"&&(t.type==="text"||t.type==="search"||t.type==="tel"||t.type==="url"||t.type==="password")||r==="textarea"||t.contentEditable==="true")}var _2=qn&&"documentMode"in document&&11>=document.documentMode,da=null,ld=null,As=null,cd=!1;function ag(t,r,s){var l=s.window===s?s.document:s.nodeType===9?s:s.ownerDocument;cd||da==null||da!==hl(l)||(l=da,"selectionStart"in l&&od(l)?l={start:l.selectionStart,end:l.selectionEnd}:(l=(l.ownerDocument&&l.ownerDocument.defaultView||window).getSelection(),l={anchorNode:l.anchorNode,anchorOffset:l.anchorOffset,focusNode:l.focusNode,focusOffset:l.focusOffset}),As&&js(As,l)||(As=l,l=uc(ld,"onSelect"),0<l.length&&(r=new bl("onSelect","select",null,r,s),t.push({event:r,listeners:l}),r.target=da)))}function gr(t,r){var s={};return s[t.toLowerCase()]=r.toLowerCase(),s["Webkit"+t]="webkit"+r,s["Moz"+t]="moz"+r,s}var pa={animationend:gr("Animation","AnimationEnd"),animationiteration:gr("Animation","AnimationIteration"),animationstart:gr("Animation","AnimationStart"),transitionrun:gr("Transition","TransitionRun"),transitionstart:gr("Transition","TransitionStart"),transitioncancel:gr("Transition","TransitionCancel"),transitionend:gr("Transition","TransitionEnd")},ud={},sg={};qn&&(sg=document.createElement("div").style,"AnimationEvent"in window||(delete pa.animationend.animation,delete pa.animationiteration.animation,delete pa.animationstart.animation),"TransitionEvent"in window||delete pa.transitionend.transition);function yr(t){if(ud[t])return ud[t];if(!pa[t])return t;var r=pa[t],s;for(s in r)if(r.hasOwnProperty(s)&&s in sg)return ud[t]=r[s];return t}var og=yr("animationend"),lg=yr("animationiteration"),cg=yr("animationstart"),T2=yr("transitionrun"),k2=yr("transitionstart"),N2=yr("transitioncancel"),ug=yr("transitionend"),dg=new Map,dd="abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");dd.push("scrollEnd");function vn(t,r){dg.set(t,r),fr(r,[t])}var Cl=typeof reportError=="function"?reportError:function(t){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var r=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof t=="object"&&t!==null&&typeof t.message=="string"?String(t.message):String(t),error:t});if(!window.dispatchEvent(r))return}else if(typeof process=="object"&&typeof process.emit=="function"){process.emit("uncaughtException",t);return}console.error(t)},sn=[],ma=0,pd=0;function Ol(){for(var t=ma,r=pd=ma=0;r<t;){var s=sn[r];sn[r++]=null;var l=sn[r];sn[r++]=null;var u=sn[r];sn[r++]=null;var p=sn[r];if(sn[r++]=null,l!==null&&u!==null){var g=l.pending;g===null?u.next=u:(u.next=g.next,g.next=u),l.pending=u}p!==0&&pg(s,u,p)}}function _l(t,r,s,l){sn[ma++]=t,sn[ma++]=r,sn[ma++]=s,sn[ma++]=l,pd|=l,t.lanes|=l,t=t.alternate,t!==null&&(t.lanes|=l)}function md(t,r,s,l){return _l(t,r,s,l),Tl(t)}function vr(t,r){return _l(t,null,null,r),Tl(t)}function pg(t,r,s){t.lanes|=s;var l=t.alternate;l!==null&&(l.lanes|=s);for(var u=!1,p=t.return;p!==null;)p.childLanes|=s,l=p.alternate,l!==null&&(l.childLanes|=s),p.tag===22&&(t=p.stateNode,t===null||t._visibility&1||(u=!0)),t=p,p=p.return;return t.tag===3?(p=t.stateNode,u&&r!==null&&(u=31-Vt(s),t=p.hiddenUpdates,l=t[u],l===null?t[u]=[r]:l.push(r),r.lane=s|536870912),p):null}function Tl(t){if(50<Js)throw Js=0,Sp=null,Error(a(185));for(var r=t.return;r!==null;)t=r,r=t.return;return t.tag===3?t.stateNode:null}var fa={};function E2(t,r,s,l){this.tag=t,this.key=s,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.refCleanup=this.ref=null,this.pendingProps=r,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=l,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function Kt(t,r,s,l){return new E2(t,r,s,l)}function fd(t){return t=t.prototype,!(!t||!t.isReactComponent)}function Hn(t,r){var s=t.alternate;return s===null?(s=Kt(t.tag,r,t.key,t.mode),s.elementType=t.elementType,s.type=t.type,s.stateNode=t.stateNode,s.alternate=t,t.alternate=s):(s.pendingProps=r,s.type=t.type,s.flags=0,s.subtreeFlags=0,s.deletions=null),s.flags=t.flags&65011712,s.childLanes=t.childLanes,s.lanes=t.lanes,s.child=t.child,s.memoizedProps=t.memoizedProps,s.memoizedState=t.memoizedState,s.updateQueue=t.updateQueue,r=t.dependencies,s.dependencies=r===null?null:{lanes:r.lanes,firstContext:r.firstContext},s.sibling=t.sibling,s.index=t.index,s.ref=t.ref,s.refCleanup=t.refCleanup,s}function mg(t,r){t.flags&=65011714;var s=t.alternate;return s===null?(t.childLanes=0,t.lanes=r,t.child=null,t.subtreeFlags=0,t.memoizedProps=null,t.memoizedState=null,t.updateQueue=null,t.dependencies=null,t.stateNode=null):(t.childLanes=s.childLanes,t.lanes=s.lanes,t.child=s.child,t.subtreeFlags=0,t.deletions=null,t.memoizedProps=s.memoizedProps,t.memoizedState=s.memoizedState,t.updateQueue=s.updateQueue,t.type=s.type,r=s.dependencies,t.dependencies=r===null?null:{lanes:r.lanes,firstContext:r.firstContext}),t}function kl(t,r,s,l,u,p){var g=0;if(l=t,typeof t=="function")fd(t)&&(g=1);else if(typeof t=="string")g=DC(t,s,W.current)?26:t==="html"||t==="head"||t==="body"?27:5;else e:switch(t){case se:return t=Kt(31,s,r,u),t.elementType=se,t.lanes=p,t;case D:return xr(s.children,u,p,r);case q:g=8,u|=24;break;case F:return t=Kt(12,s,r,u|2),t.elementType=F,t.lanes=p,t;case X:return t=Kt(13,s,r,u),t.elementType=X,t.lanes=p,t;case Z:return t=Kt(19,s,r,u),t.elementType=Z,t.lanes=p,t;default:if(typeof t=="object"&&t!==null)switch(t.$$typeof){case H:g=10;break e;case I:g=9;break e;case z:g=11;break e;case K:g=14;break e;case fe:g=16,l=null;break e}g=29,s=Error(a(130,t===null?"null":typeof t,"")),l=null}return r=Kt(g,s,r,u),r.elementType=t,r.type=l,r.lanes=p,r}function xr(t,r,s,l){return t=Kt(7,t,l,r),t.lanes=s,t}function hd(t,r,s){return t=Kt(6,t,null,r),t.lanes=s,t}function fg(t){var r=Kt(18,null,null,0);return r.stateNode=t,r}function gd(t,r,s){return r=Kt(4,t.children!==null?t.children:[],t.key,r),r.lanes=s,r.stateNode={containerInfo:t.containerInfo,pendingChildren:null,implementation:t.implementation},r}var hg=new WeakMap;function on(t,r){if(typeof t=="object"&&t!==null){var s=hg.get(t);return s!==void 0?s:(r={value:t,source:r,stack:ol(r)},hg.set(t,r),r)}return{value:t,source:r,stack:ol(r)}}var ha=[],ga=0,Nl=null,Ms=0,ln=[],cn=0,Oi=null,kn=1,Nn="";function Yn(t,r){ha[ga++]=Ms,ha[ga++]=Nl,Nl=t,Ms=r}function gg(t,r,s){ln[cn++]=kn,ln[cn++]=Nn,ln[cn++]=Oi,Oi=t;var l=kn;t=Nn;var u=32-Vt(l)-1;l&=~(1<<u),s+=1;var p=32-Vt(r)+u;if(30<p){var g=u-u%5;p=(l&(1<<g)-1).toString(32),l>>=g,u-=g,kn=1<<32-Vt(r)+u|s<<u|l,Nn=p+t}else kn=1<<p|s<<u|l,Nn=t}function yd(t){t.return!==null&&(Yn(t,1),gg(t,1,0))}function vd(t){for(;t===Nl;)Nl=ha[--ga],ha[ga]=null,Ms=ha[--ga],ha[ga]=null;for(;t===Oi;)Oi=ln[--cn],ln[cn]=null,Nn=ln[--cn],ln[cn]=null,kn=ln[--cn],ln[cn]=null}function yg(t,r){ln[cn++]=kn,ln[cn++]=Nn,ln[cn++]=Oi,kn=r.id,Nn=r.overflow,Oi=t}var wt=null,Ge=null,Oe=!1,_i=null,un=!1,xd=Error(a(519));function Ti(t){var r=Error(a(418,1<arguments.length&&arguments[1]!==void 0&&arguments[1]?"text":"HTML",""));throw Rs(on(r,t)),xd}function vg(t){var r=t.stateNode,s=t.type,l=t.memoizedProps;switch(r[bt]=t,r[Pt]=l,s){case"dialog":be("cancel",r),be("close",r);break;case"iframe":case"object":case"embed":be("load",r);break;case"video":case"audio":for(s=0;s<to.length;s++)be(to[s],r);break;case"source":be("error",r);break;case"img":case"image":case"link":be("error",r),be("load",r);break;case"details":be("toggle",r);break;case"input":be("invalid",r),Ah(r,l.value,l.defaultValue,l.checked,l.defaultChecked,l.type,l.name,!0);break;case"select":be("invalid",r);break;case"textarea":be("invalid",r),Rh(r,l.value,l.defaultValue,l.children)}s=l.children,typeof s!="string"&&typeof s!="number"&&typeof s!="bigint"||r.textContent===""+s||l.suppressHydrationWarning===!0||Iy(r.textContent,s)?(l.popover!=null&&(be("beforetoggle",r),be("toggle",r)),l.onScroll!=null&&be("scroll",r),l.onScrollEnd!=null&&be("scrollend",r),l.onClick!=null&&(r.onclick=Fn),r=!0):r=!1,r||Ti(t,!0)}function xg(t){for(wt=t.return;wt;)switch(wt.tag){case 5:case 31:case 13:un=!1;return;case 27:case 3:un=!0;return;default:wt=wt.return}}function ya(t){if(t!==wt)return!1;if(!Oe)return xg(t),Oe=!0,!1;var r=t.tag,s;if((s=r!==3&&r!==27)&&((s=r===5)&&(s=t.type,s=!(s!=="form"&&s!=="button")||Lp(t.type,t.memoizedProps)),s=!s),s&&Ge&&Ti(t),xg(t),r===13){if(t=t.memoizedState,t=t!==null?t.dehydrated:null,!t)throw Error(a(317));Ge=Yy(t)}else if(r===31){if(t=t.memoizedState,t=t!==null?t.dehydrated:null,!t)throw Error(a(317));Ge=Yy(t)}else r===27?(r=Ge,zi(t.type)?(t=qp,qp=null,Ge=t):Ge=r):Ge=wt?pn(t.stateNode.nextSibling):null;return!0}function br(){Ge=wt=null,Oe=!1}function bd(){var t=_i;return t!==null&&(Ft===null?Ft=t:Ft.push.apply(Ft,t),_i=null),t}function Rs(t){_i===null?_i=[t]:_i.push(t)}var wd=O(null),wr=null,Gn=null;function ki(t,r,s){Y(wd,r._currentValue),r._currentValue=s}function Vn(t){t._currentValue=wd.current,L(wd)}function Sd(t,r,s){for(;t!==null;){var l=t.alternate;if((t.childLanes&r)!==r?(t.childLanes|=r,l!==null&&(l.childLanes|=r)):l!==null&&(l.childLanes&r)!==r&&(l.childLanes|=r),t===s)break;t=t.return}}function Cd(t,r,s,l){var u=t.child;for(u!==null&&(u.return=t);u!==null;){var p=u.dependencies;if(p!==null){var g=u.child;p=p.firstContext;e:for(;p!==null;){var w=p;p=u;for(var C=0;C<r.length;C++)if(w.context===r[C]){p.lanes|=s,w=p.alternate,w!==null&&(w.lanes|=s),Sd(p.return,s,t),l||(g=null);break e}p=w.next}}else if(u.tag===18){if(g=u.return,g===null)throw Error(a(341));g.lanes|=s,p=g.alternate,p!==null&&(p.lanes|=s),Sd(g,s,t),g=null}else g=u.child;if(g!==null)g.return=u;else for(g=u;g!==null;){if(g===t){g=null;break}if(u=g.sibling,u!==null){u.return=g.return,g=u;break}g=g.return}u=g}}function va(t,r,s,l){t=null;for(var u=r,p=!1;u!==null;){if(!p){if((u.flags&524288)!==0)p=!0;else if((u.flags&262144)!==0)break}if(u.tag===10){var g=u.alternate;if(g===null)throw Error(a(387));if(g=g.memoizedProps,g!==null){var w=u.type;Wt(u.pendingProps.value,g.value)||(t!==null?t.push(w):t=[w])}}else if(u===ke.current){if(g=u.alternate,g===null)throw Error(a(387));g.memoizedState.memoizedState!==u.memoizedState.memoizedState&&(t!==null?t.push(so):t=[so])}u=u.return}t!==null&&Cd(r,t,s,l),r.flags|=262144}function El(t){for(t=t.firstContext;t!==null;){if(!Wt(t.context._currentValue,t.memoizedValue))return!0;t=t.next}return!1}function Sr(t){wr=t,Gn=null,t=t.dependencies,t!==null&&(t.firstContext=null)}function St(t){return bg(wr,t)}function jl(t,r){return wr===null&&Sr(t),bg(t,r)}function bg(t,r){var s=r._currentValue;if(r={context:r,memoizedValue:s,next:null},Gn===null){if(t===null)throw Error(a(308));Gn=r,t.dependencies={lanes:0,firstContext:r},t.flags|=524288}else Gn=Gn.next=r;return s}var j2=typeof AbortController<"u"?AbortController:function(){var t=[],r=this.signal={aborted:!1,addEventListener:function(s,l){t.push(l)}};this.abort=function(){r.aborted=!0,t.forEach(function(s){return s()})}},A2=n.unstable_scheduleCallback,M2=n.unstable_NormalPriority,ot={$$typeof:H,Consumer:null,Provider:null,_currentValue:null,_currentValue2:null,_threadCount:0};function Od(){return{controller:new j2,data:new Map,refCount:0}}function Ds(t){t.refCount--,t.refCount===0&&A2(M2,function(){t.controller.abort()})}var Is=null,_d=0,xa=0,ba=null;function R2(t,r){if(Is===null){var s=Is=[];_d=0,xa=Np(),ba={status:"pending",value:void 0,then:function(l){s.push(l)}}}return _d++,r.then(wg,wg),r}function wg(){if(--_d===0&&Is!==null){ba!==null&&(ba.status="fulfilled");var t=Is;Is=null,xa=0,ba=null;for(var r=0;r<t.length;r++)(0,t[r])()}}function D2(t,r){var s=[],l={status:"pending",value:null,reason:null,then:function(u){s.push(u)}};return t.then(function(){l.status="fulfilled",l.value=r;for(var u=0;u<s.length;u++)(0,s[u])(r)},function(u){for(l.status="rejected",l.reason=u,u=0;u<s.length;u++)(0,s[u])(void 0)}),l}var Sg=M.S;M.S=function(t,r){ay=kt(),typeof r=="object"&&r!==null&&typeof r.then=="function"&&R2(t,r),Sg!==null&&Sg(t,r)};var Cr=O(null);function Td(){var t=Cr.current;return t!==null?t:ze.pooledCache}function Al(t,r){r===null?Y(Cr,Cr.current):Y(Cr,r.pool)}function Cg(){var t=Td();return t===null?null:{parent:ot._currentValue,pool:t}}var wa=Error(a(460)),kd=Error(a(474)),Ml=Error(a(542)),Rl={then:function(){}};function Og(t){return t=t.status,t==="fulfilled"||t==="rejected"}function _g(t,r,s){switch(s=t[s],s===void 0?t.push(r):s!==r&&(r.then(Fn,Fn),r=s),r.status){case"fulfilled":return r.value;case"rejected":throw t=r.reason,kg(t),t;default:if(typeof r.status=="string")r.then(Fn,Fn);else{if(t=ze,t!==null&&100<t.shellSuspendCounter)throw Error(a(482));t=r,t.status="pending",t.then(function(l){if(r.status==="pending"){var u=r;u.status="fulfilled",u.value=l}},function(l){if(r.status==="pending"){var u=r;u.status="rejected",u.reason=l}})}switch(r.status){case"fulfilled":return r.value;case"rejected":throw t=r.reason,kg(t),t}throw _r=r,wa}}function Or(t){try{var r=t._init;return r(t._payload)}catch(s){throw s!==null&&typeof s=="object"&&typeof s.then=="function"?(_r=s,wa):s}}var _r=null;function Tg(){if(_r===null)throw Error(a(459));var t=_r;return _r=null,t}function kg(t){if(t===wa||t===Ml)throw Error(a(483))}var Sa=null,Ps=0;function Dl(t){var r=Ps;return Ps+=1,Sa===null&&(Sa=[]),_g(Sa,t,r)}function Ls(t,r){r=r.props.ref,t.ref=r!==void 0?r:null}function Il(t,r){throw r.$$typeof===b?Error(a(525)):(t=Object.prototype.toString.call(r),Error(a(31,t==="[object Object]"?"object with keys {"+Object.keys(r).join(", ")+"}":t)))}function Ng(t){function r(k,T){if(t){var E=k.deletions;E===null?(k.deletions=[T],k.flags|=16):E.push(T)}}function s(k,T){if(!t)return null;for(;T!==null;)r(k,T),T=T.sibling;return null}function l(k){for(var T=new Map;k!==null;)k.key!==null?T.set(k.key,k):T.set(k.index,k),k=k.sibling;return T}function u(k,T){return k=Hn(k,T),k.index=0,k.sibling=null,k}function p(k,T,E){return k.index=E,t?(E=k.alternate,E!==null?(E=E.index,E<T?(k.flags|=67108866,T):E):(k.flags|=67108866,T)):(k.flags|=1048576,T)}function g(k){return t&&k.alternate===null&&(k.flags|=67108866),k}function w(k,T,E,U){return T===null||T.tag!==6?(T=hd(E,k.mode,U),T.return=k,T):(T=u(T,E),T.return=k,T)}function C(k,T,E,U){var ee=E.type;return ee===D?P(k,T,E.props.children,U,E.key):T!==null&&(T.elementType===ee||typeof ee=="object"&&ee!==null&&ee.$$typeof===fe&&Or(ee)===T.type)?(T=u(T,E.props),Ls(T,E),T.return=k,T):(T=kl(E.type,E.key,E.props,null,k.mode,U),Ls(T,E),T.return=k,T)}function j(k,T,E,U){return T===null||T.tag!==4||T.stateNode.containerInfo!==E.containerInfo||T.stateNode.implementation!==E.implementation?(T=gd(E,k.mode,U),T.return=k,T):(T=u(T,E.children||[]),T.return=k,T)}function P(k,T,E,U,ee){return T===null||T.tag!==7?(T=xr(E,k.mode,U,ee),T.return=k,T):(T=u(T,E),T.return=k,T)}function B(k,T,E){if(typeof T=="string"&&T!==""||typeof T=="number"||typeof T=="bigint")return T=hd(""+T,k.mode,E),T.return=k,T;if(typeof T=="object"&&T!==null){switch(T.$$typeof){case _:return E=kl(T.type,T.key,T.props,null,k.mode,E),Ls(E,T),E.return=k,E;case N:return T=gd(T,k.mode,E),T.return=k,T;case fe:return T=Or(T),B(k,T,E)}if(he(T)||qe(T))return T=xr(T,k.mode,E,null),T.return=k,T;if(typeof T.then=="function")return B(k,Dl(T),E);if(T.$$typeof===H)return B(k,jl(k,T),E);Il(k,T)}return null}function A(k,T,E,U){var ee=T!==null?T.key:null;if(typeof E=="string"&&E!==""||typeof E=="number"||typeof E=="bigint")return ee!==null?null:w(k,T,""+E,U);if(typeof E=="object"&&E!==null){switch(E.$$typeof){case _:return E.key===ee?C(k,T,E,U):null;case N:return E.key===ee?j(k,T,E,U):null;case fe:return E=Or(E),A(k,T,E,U)}if(he(E)||qe(E))return ee!==null?null:P(k,T,E,U,null);if(typeof E.then=="function")return A(k,T,Dl(E),U);if(E.$$typeof===H)return A(k,T,jl(k,E),U);Il(k,E)}return null}function R(k,T,E,U,ee){if(typeof U=="string"&&U!==""||typeof U=="number"||typeof U=="bigint")return k=k.get(E)||null,w(T,k,""+U,ee);if(typeof U=="object"&&U!==null){switch(U.$$typeof){case _:return k=k.get(U.key===null?E:U.key)||null,C(T,k,U,ee);case N:return k=k.get(U.key===null?E:U.key)||null,j(T,k,U,ee);case fe:return U=Or(U),R(k,T,E,U,ee)}if(he(U)||qe(U))return k=k.get(E)||null,P(T,k,U,ee,null);if(typeof U.then=="function")return R(k,T,E,Dl(U),ee);if(U.$$typeof===H)return R(k,T,E,jl(T,U),ee);Il(T,U)}return null}function Q(k,T,E,U){for(var ee=null,Ne=null,$=T,de=T=0,Se=null;$!==null&&de<E.length;de++){$.index>de?(Se=$,$=null):Se=$.sibling;var Ee=A(k,$,E[de],U);if(Ee===null){$===null&&($=Se);break}t&&$&&Ee.alternate===null&&r(k,$),T=p(Ee,T,de),Ne===null?ee=Ee:Ne.sibling=Ee,Ne=Ee,$=Se}if(de===E.length)return s(k,$),Oe&&Yn(k,de),ee;if($===null){for(;de<E.length;de++)$=B(k,E[de],U),$!==null&&(T=p($,T,de),Ne===null?ee=$:Ne.sibling=$,Ne=$);return Oe&&Yn(k,de),ee}for($=l($);de<E.length;de++)Se=R($,k,de,E[de],U),Se!==null&&(t&&Se.alternate!==null&&$.delete(Se.key===null?de:Se.key),T=p(Se,T,de),Ne===null?ee=Se:Ne.sibling=Se,Ne=Se);return t&&$.forEach(function(Gi){return r(k,Gi)}),Oe&&Yn(k,de),ee}function ie(k,T,E,U){if(E==null)throw Error(a(151));for(var ee=null,Ne=null,$=T,de=T=0,Se=null,Ee=E.next();$!==null&&!Ee.done;de++,Ee=E.next()){$.index>de?(Se=$,$=null):Se=$.sibling;var Gi=A(k,$,Ee.value,U);if(Gi===null){$===null&&($=Se);break}t&&$&&Gi.alternate===null&&r(k,$),T=p(Gi,T,de),Ne===null?ee=Gi:Ne.sibling=Gi,Ne=Gi,$=Se}if(Ee.done)return s(k,$),Oe&&Yn(k,de),ee;if($===null){for(;!Ee.done;de++,Ee=E.next())Ee=B(k,Ee.value,U),Ee!==null&&(T=p(Ee,T,de),Ne===null?ee=Ee:Ne.sibling=Ee,Ne=Ee);return Oe&&Yn(k,de),ee}for($=l($);!Ee.done;de++,Ee=E.next())Ee=R($,k,de,Ee.value,U),Ee!==null&&(t&&Ee.alternate!==null&&$.delete(Ee.key===null?de:Ee.key),T=p(Ee,T,de),Ne===null?ee=Ee:Ne.sibling=Ee,Ne=Ee);return t&&$.forEach(function(GC){return r(k,GC)}),Oe&&Yn(k,de),ee}function Ue(k,T,E,U){if(typeof E=="object"&&E!==null&&E.type===D&&E.key===null&&(E=E.props.children),typeof E=="object"&&E!==null){switch(E.$$typeof){case _:e:{for(var ee=E.key;T!==null;){if(T.key===ee){if(ee=E.type,ee===D){if(T.tag===7){s(k,T.sibling),U=u(T,E.props.children),U.return=k,k=U;break e}}else if(T.elementType===ee||typeof ee=="object"&&ee!==null&&ee.$$typeof===fe&&Or(ee)===T.type){s(k,T.sibling),U=u(T,E.props),Ls(U,E),U.return=k,k=U;break e}s(k,T);break}else r(k,T);T=T.sibling}E.type===D?(U=xr(E.props.children,k.mode,U,E.key),U.return=k,k=U):(U=kl(E.type,E.key,E.props,null,k.mode,U),Ls(U,E),U.return=k,k=U)}return g(k);case N:e:{for(ee=E.key;T!==null;){if(T.key===ee)if(T.tag===4&&T.stateNode.containerInfo===E.containerInfo&&T.stateNode.implementation===E.implementation){s(k,T.sibling),U=u(T,E.children||[]),U.return=k,k=U;break e}else{s(k,T);break}else r(k,T);T=T.sibling}U=gd(E,k.mode,U),U.return=k,k=U}return g(k);case fe:return E=Or(E),Ue(k,T,E,U)}if(he(E))return Q(k,T,E,U);if(qe(E)){if(ee=qe(E),typeof ee!="function")throw Error(a(150));return E=ee.call(E),ie(k,T,E,U)}if(typeof E.then=="function")return Ue(k,T,Dl(E),U);if(E.$$typeof===H)return Ue(k,T,jl(k,E),U);Il(k,E)}return typeof E=="string"&&E!==""||typeof E=="number"||typeof E=="bigint"?(E=""+E,T!==null&&T.tag===6?(s(k,T.sibling),U=u(T,E),U.return=k,k=U):(s(k,T),U=hd(E,k.mode,U),U.return=k,k=U),g(k)):s(k,T)}return function(k,T,E,U){try{Ps=0;var ee=Ue(k,T,E,U);return Sa=null,ee}catch($){if($===wa||$===Ml)throw $;var Ne=Kt(29,$,null,k.mode);return Ne.lanes=U,Ne.return=k,Ne}}}var Tr=Ng(!0),Eg=Ng(!1),Ni=!1;function Nd(t){t.updateQueue={baseState:t.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,lanes:0,hiddenCallbacks:null},callbacks:null}}function Ed(t,r){t=t.updateQueue,r.updateQueue===t&&(r.updateQueue={baseState:t.baseState,firstBaseUpdate:t.firstBaseUpdate,lastBaseUpdate:t.lastBaseUpdate,shared:t.shared,callbacks:null})}function Ei(t){return{lane:t,tag:0,payload:null,callback:null,next:null}}function ji(t,r,s){var l=t.updateQueue;if(l===null)return null;if(l=l.shared,(Ae&2)!==0){var u=l.pending;return u===null?r.next=r:(r.next=u.next,u.next=r),l.pending=r,r=Tl(t),pg(t,null,s),r}return _l(t,l,r,s),Tl(t)}function Us(t,r,s){if(r=r.updateQueue,r!==null&&(r=r.shared,(s&4194048)!==0)){var l=r.lanes;l&=t.pendingLanes,s|=l,r.lanes=s,bh(t,s)}}function jd(t,r){var s=t.updateQueue,l=t.alternate;if(l!==null&&(l=l.updateQueue,s===l)){var u=null,p=null;if(s=s.firstBaseUpdate,s!==null){do{var g={lane:s.lane,tag:s.tag,payload:s.payload,callback:null,next:null};p===null?u=p=g:p=p.next=g,s=s.next}while(s!==null);p===null?u=p=r:p=p.next=r}else u=p=r;s={baseState:l.baseState,firstBaseUpdate:u,lastBaseUpdate:p,shared:l.shared,callbacks:l.callbacks},t.updateQueue=s;return}t=s.lastBaseUpdate,t===null?s.firstBaseUpdate=r:t.next=r,s.lastBaseUpdate=r}var Ad=!1;function Bs(){if(Ad){var t=ba;if(t!==null)throw t}}function zs(t,r,s,l){Ad=!1;var u=t.updateQueue;Ni=!1;var p=u.firstBaseUpdate,g=u.lastBaseUpdate,w=u.shared.pending;if(w!==null){u.shared.pending=null;var C=w,j=C.next;C.next=null,g===null?p=j:g.next=j,g=C;var P=t.alternate;P!==null&&(P=P.updateQueue,w=P.lastBaseUpdate,w!==g&&(w===null?P.firstBaseUpdate=j:w.next=j,P.lastBaseUpdate=C))}if(p!==null){var B=u.baseState;g=0,P=j=C=null,w=p;do{var A=w.lane&-536870913,R=A!==w.lane;if(R?(we&A)===A:(l&A)===A){A!==0&&A===xa&&(Ad=!0),P!==null&&(P=P.next={lane:0,tag:w.tag,payload:w.payload,callback:null,next:null});e:{var Q=t,ie=w;A=r;var Ue=s;switch(ie.tag){case 1:if(Q=ie.payload,typeof Q=="function"){B=Q.call(Ue,B,A);break e}B=Q;break e;case 3:Q.flags=Q.flags&-65537|128;case 0:if(Q=ie.payload,A=typeof Q=="function"?Q.call(Ue,B,A):Q,A==null)break e;B=v({},B,A);break e;case 2:Ni=!0}}A=w.callback,A!==null&&(t.flags|=64,R&&(t.flags|=8192),R=u.callbacks,R===null?u.callbacks=[A]:R.push(A))}else R={lane:A,tag:w.tag,payload:w.payload,callback:w.callback,next:null},P===null?(j=P=R,C=B):P=P.next=R,g|=A;if(w=w.next,w===null){if(w=u.shared.pending,w===null)break;R=w,w=R.next,R.next=null,u.lastBaseUpdate=R,u.shared.pending=null}}while(!0);P===null&&(C=B),u.baseState=C,u.firstBaseUpdate=j,u.lastBaseUpdate=P,p===null&&(u.shared.lanes=0),Ii|=g,t.lanes=g,t.memoizedState=B}}function jg(t,r){if(typeof t!="function")throw Error(a(191,t));t.call(r)}function Ag(t,r){var s=t.callbacks;if(s!==null)for(t.callbacks=null,t=0;t<s.length;t++)jg(s[t],r)}var Ca=O(null),Pl=O(0);function Mg(t,r){t=ti,Y(Pl,t),Y(Ca,r),ti=t|r.baseLanes}function Md(){Y(Pl,ti),Y(Ca,Ca.current)}function Rd(){ti=Pl.current,L(Ca),L(Pl)}var Qt=O(null),dn=null;function Ai(t){var r=t.alternate;Y(rt,rt.current&1),Y(Qt,t),dn===null&&(r===null||Ca.current!==null||r.memoizedState!==null)&&(dn=t)}function Dd(t){Y(rt,rt.current),Y(Qt,t),dn===null&&(dn=t)}function Rg(t){t.tag===22?(Y(rt,rt.current),Y(Qt,t),dn===null&&(dn=t)):Mi()}function Mi(){Y(rt,rt.current),Y(Qt,Qt.current)}function Xt(t){L(Qt),dn===t&&(dn=null),L(rt)}var rt=O(0);function Ll(t){for(var r=t;r!==null;){if(r.tag===13){var s=r.memoizedState;if(s!==null&&(s=s.dehydrated,s===null||zp(s)||Fp(s)))return r}else if(r.tag===19&&(r.memoizedProps.revealOrder==="forwards"||r.memoizedProps.revealOrder==="backwards"||r.memoizedProps.revealOrder==="unstable_legacy-backwards"||r.memoizedProps.revealOrder==="together")){if((r.flags&128)!==0)return r}else if(r.child!==null){r.child.return=r,r=r.child;continue}if(r===t)break;for(;r.sibling===null;){if(r.return===null||r.return===t)return null;r=r.return}r.sibling.return=r.return,r=r.sibling}return null}var Wn=0,ue=null,Pe=null,lt=null,Ul=!1,Oa=!1,kr=!1,Bl=0,Fs=0,_a=null,I2=0;function Ze(){throw Error(a(321))}function Id(t,r){if(r===null)return!1;for(var s=0;s<r.length&&s<t.length;s++)if(!Wt(t[s],r[s]))return!1;return!0}function Pd(t,r,s,l,u,p){return Wn=p,ue=r,r.memoizedState=null,r.updateQueue=null,r.lanes=0,M.H=t===null||t.memoizedState===null?g0:$d,kr=!1,p=s(l,u),kr=!1,Oa&&(p=Ig(r,s,l,u)),Dg(t),p}function Dg(t){M.H=Ys;var r=Pe!==null&&Pe.next!==null;if(Wn=0,lt=Pe=ue=null,Ul=!1,Fs=0,_a=null,r)throw Error(a(300));t===null||ct||(t=t.dependencies,t!==null&&El(t)&&(ct=!0))}function Ig(t,r,s,l){ue=t;var u=0;do{if(Oa&&(_a=null),Fs=0,Oa=!1,25<=u)throw Error(a(301));if(u+=1,lt=Pe=null,t.updateQueue!=null){var p=t.updateQueue;p.lastEffect=null,p.events=null,p.stores=null,p.memoCache!=null&&(p.memoCache.index=0)}M.H=y0,p=r(s,l)}while(Oa);return p}function P2(){var t=M.H,r=t.useState()[0];return r=typeof r.then=="function"?qs(r):r,t=t.useState()[0],(Pe!==null?Pe.memoizedState:null)!==t&&(ue.flags|=1024),r}function Ld(){var t=Bl!==0;return Bl=0,t}function Ud(t,r,s){r.updateQueue=t.updateQueue,r.flags&=-2053,t.lanes&=~s}function Bd(t){if(Ul){for(t=t.memoizedState;t!==null;){var r=t.queue;r!==null&&(r.pending=null),t=t.next}Ul=!1}Wn=0,lt=Pe=ue=null,Oa=!1,Fs=Bl=0,_a=null}function Nt(){var t={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return lt===null?ue.memoizedState=lt=t:lt=lt.next=t,lt}function at(){if(Pe===null){var t=ue.alternate;t=t!==null?t.memoizedState:null}else t=Pe.next;var r=lt===null?ue.memoizedState:lt.next;if(r!==null)lt=r,Pe=t;else{if(t===null)throw ue.alternate===null?Error(a(467)):Error(a(310));Pe=t,t={memoizedState:Pe.memoizedState,baseState:Pe.baseState,baseQueue:Pe.baseQueue,queue:Pe.queue,next:null},lt===null?ue.memoizedState=lt=t:lt=lt.next=t}return lt}function zl(){return{lastEffect:null,events:null,stores:null,memoCache:null}}function qs(t){var r=Fs;return Fs+=1,_a===null&&(_a=[]),t=_g(_a,t,r),r=ue,(lt===null?r.memoizedState:lt.next)===null&&(r=r.alternate,M.H=r===null||r.memoizedState===null?g0:$d),t}function Fl(t){if(t!==null&&typeof t=="object"){if(typeof t.then=="function")return qs(t);if(t.$$typeof===H)return St(t)}throw Error(a(438,String(t)))}function zd(t){var r=null,s=ue.updateQueue;if(s!==null&&(r=s.memoCache),r==null){var l=ue.alternate;l!==null&&(l=l.updateQueue,l!==null&&(l=l.memoCache,l!=null&&(r={data:l.data.map(function(u){return u.slice()}),index:0})))}if(r==null&&(r={data:[],index:0}),s===null&&(s=zl(),ue.updateQueue=s),s.memoCache=r,s=r.data[r.index],s===void 0)for(s=r.data[r.index]=Array(t),l=0;l<t;l++)s[l]=te;return r.index++,s}function Kn(t,r){return typeof r=="function"?r(t):r}function ql(t){var r=at();return Fd(r,Pe,t)}function Fd(t,r,s){var l=t.queue;if(l===null)throw Error(a(311));l.lastRenderedReducer=s;var u=t.baseQueue,p=l.pending;if(p!==null){if(u!==null){var g=u.next;u.next=p.next,p.next=g}r.baseQueue=u=p,l.pending=null}if(p=t.baseState,u===null)t.memoizedState=p;else{r=u.next;var w=g=null,C=null,j=r,P=!1;do{var B=j.lane&-536870913;if(B!==j.lane?(we&B)===B:(Wn&B)===B){var A=j.revertLane;if(A===0)C!==null&&(C=C.next={lane:0,revertLane:0,gesture:null,action:j.action,hasEagerState:j.hasEagerState,eagerState:j.eagerState,next:null}),B===xa&&(P=!0);else if((Wn&A)===A){j=j.next,A===xa&&(P=!0);continue}else B={lane:0,revertLane:j.revertLane,gesture:null,action:j.action,hasEagerState:j.hasEagerState,eagerState:j.eagerState,next:null},C===null?(w=C=B,g=p):C=C.next=B,ue.lanes|=A,Ii|=A;B=j.action,kr&&s(p,B),p=j.hasEagerState?j.eagerState:s(p,B)}else A={lane:B,revertLane:j.revertLane,gesture:j.gesture,action:j.action,hasEagerState:j.hasEagerState,eagerState:j.eagerState,next:null},C===null?(w=C=A,g=p):C=C.next=A,ue.lanes|=B,Ii|=B;j=j.next}while(j!==null&&j!==r);if(C===null?g=p:C.next=w,!Wt(p,t.memoizedState)&&(ct=!0,P&&(s=ba,s!==null)))throw s;t.memoizedState=p,t.baseState=g,t.baseQueue=C,l.lastRenderedState=p}return u===null&&(l.lanes=0),[t.memoizedState,l.dispatch]}function qd(t){var r=at(),s=r.queue;if(s===null)throw Error(a(311));s.lastRenderedReducer=t;var l=s.dispatch,u=s.pending,p=r.memoizedState;if(u!==null){s.pending=null;var g=u=u.next;do p=t(p,g.action),g=g.next;while(g!==u);Wt(p,r.memoizedState)||(ct=!0),r.memoizedState=p,r.baseQueue===null&&(r.baseState=p),s.lastRenderedState=p}return[p,l]}function Pg(t,r,s){var l=ue,u=at(),p=Oe;if(p){if(s===void 0)throw Error(a(407));s=s()}else s=r();var g=!Wt((Pe||u).memoizedState,s);if(g&&(u.memoizedState=s,ct=!0),u=u.queue,Gd(Bg.bind(null,l,u,t),[t]),u.getSnapshot!==r||g||lt!==null&&lt.memoizedState.tag&1){if(l.flags|=2048,Ta(9,{destroy:void 0},Ug.bind(null,l,u,s,r),null),ze===null)throw Error(a(349));p||(Wn&127)!==0||Lg(l,r,s)}return s}function Lg(t,r,s){t.flags|=16384,t={getSnapshot:r,value:s},r=ue.updateQueue,r===null?(r=zl(),ue.updateQueue=r,r.stores=[t]):(s=r.stores,s===null?r.stores=[t]:s.push(t))}function Ug(t,r,s,l){r.value=s,r.getSnapshot=l,zg(r)&&Fg(t)}function Bg(t,r,s){return s(function(){zg(r)&&Fg(t)})}function zg(t){var r=t.getSnapshot;t=t.value;try{var s=r();return!Wt(t,s)}catch{return!0}}function Fg(t){var r=vr(t,2);r!==null&&qt(r,t,2)}function Hd(t){var r=Nt();if(typeof t=="function"){var s=t;if(t=s(),kr){wi(!0);try{s()}finally{wi(!1)}}}return r.memoizedState=r.baseState=t,r.queue={pending:null,lanes:0,dispatch:null,lastRenderedReducer:Kn,lastRenderedState:t},r}function qg(t,r,s,l){return t.baseState=s,Fd(t,Pe,typeof l=="function"?l:Kn)}function L2(t,r,s,l,u){if(Gl(t))throw Error(a(485));if(t=r.action,t!==null){var p={payload:u,action:t,next:null,isTransition:!0,status:"pending",value:null,reason:null,listeners:[],then:function(g){p.listeners.push(g)}};M.T!==null?s(!0):p.isTransition=!1,l(p),s=r.pending,s===null?(p.next=r.pending=p,Hg(r,p)):(p.next=s.next,r.pending=s.next=p)}}function Hg(t,r){var s=r.action,l=r.payload,u=t.state;if(r.isTransition){var p=M.T,g={};M.T=g;try{var w=s(u,l),C=M.S;C!==null&&C(g,w),Yg(t,r,w)}catch(j){Yd(t,r,j)}finally{p!==null&&g.types!==null&&(p.types=g.types),M.T=p}}else try{p=s(u,l),Yg(t,r,p)}catch(j){Yd(t,r,j)}}function Yg(t,r,s){s!==null&&typeof s=="object"&&typeof s.then=="function"?s.then(function(l){Gg(t,r,l)},function(l){return Yd(t,r,l)}):Gg(t,r,s)}function Gg(t,r,s){r.status="fulfilled",r.value=s,Vg(r),t.state=s,r=t.pending,r!==null&&(s=r.next,s===r?t.pending=null:(s=s.next,r.next=s,Hg(t,s)))}function Yd(t,r,s){var l=t.pending;if(t.pending=null,l!==null){l=l.next;do r.status="rejected",r.reason=s,Vg(r),r=r.next;while(r!==l)}t.action=null}function Vg(t){t=t.listeners;for(var r=0;r<t.length;r++)(0,t[r])()}function Wg(t,r){return r}function Kg(t,r){if(Oe){var s=ze.formState;if(s!==null){e:{var l=ue;if(Oe){if(Ge){t:{for(var u=Ge,p=un;u.nodeType!==8;){if(!p){u=null;break t}if(u=pn(u.nextSibling),u===null){u=null;break t}}p=u.data,u=p==="F!"||p==="F"?u:null}if(u){Ge=pn(u.nextSibling),l=u.data==="F!";break e}}Ti(l)}l=!1}l&&(r=s[0])}}return s=Nt(),s.memoizedState=s.baseState=r,l={pending:null,lanes:0,dispatch:null,lastRenderedReducer:Wg,lastRenderedState:r},s.queue=l,s=m0.bind(null,ue,l),l.dispatch=s,l=Hd(!1),p=Xd.bind(null,ue,!1,l.queue),l=Nt(),u={state:r,dispatch:null,action:t,pending:null},l.queue=u,s=L2.bind(null,ue,u,p,s),u.dispatch=s,l.memoizedState=t,[r,s,!1]}function Qg(t){var r=at();return Xg(r,Pe,t)}function Xg(t,r,s){if(r=Fd(t,r,Wg)[0],t=ql(Kn)[0],typeof r=="object"&&r!==null&&typeof r.then=="function")try{var l=qs(r)}catch(g){throw g===wa?Ml:g}else l=r;r=at();var u=r.queue,p=u.dispatch;return s!==r.memoizedState&&(ue.flags|=2048,Ta(9,{destroy:void 0},U2.bind(null,u,s),null)),[l,p,t]}function U2(t,r){t.action=r}function $g(t){var r=at(),s=Pe;if(s!==null)return Xg(r,s,t);at(),r=r.memoizedState,s=at();var l=s.queue.dispatch;return s.memoizedState=t,[r,l,!1]}function Ta(t,r,s,l){return t={tag:t,create:s,deps:l,inst:r,next:null},r=ue.updateQueue,r===null&&(r=zl(),ue.updateQueue=r),s=r.lastEffect,s===null?r.lastEffect=t.next=t:(l=s.next,s.next=t,t.next=l,r.lastEffect=t),t}function Zg(){return at().memoizedState}function Hl(t,r,s,l){var u=Nt();ue.flags|=t,u.memoizedState=Ta(1|r,{destroy:void 0},s,l===void 0?null:l)}function Yl(t,r,s,l){var u=at();l=l===void 0?null:l;var p=u.memoizedState.inst;Pe!==null&&l!==null&&Id(l,Pe.memoizedState.deps)?u.memoizedState=Ta(r,p,s,l):(ue.flags|=t,u.memoizedState=Ta(1|r,p,s,l))}function Jg(t,r){Hl(8390656,8,t,r)}function Gd(t,r){Yl(2048,8,t,r)}function B2(t){ue.flags|=4;var r=ue.updateQueue;if(r===null)r=zl(),ue.updateQueue=r,r.events=[t];else{var s=r.events;s===null?r.events=[t]:s.push(t)}}function e0(t){var r=at().memoizedState;return B2({ref:r,nextImpl:t}),function(){if((Ae&2)!==0)throw Error(a(440));return r.impl.apply(void 0,arguments)}}function t0(t,r){return Yl(4,2,t,r)}function n0(t,r){return Yl(4,4,t,r)}function i0(t,r){if(typeof r=="function"){t=t();var s=r(t);return function(){typeof s=="function"?s():r(null)}}if(r!=null)return t=t(),r.current=t,function(){r.current=null}}function r0(t,r,s){s=s!=null?s.concat([t]):null,Yl(4,4,i0.bind(null,r,t),s)}function Vd(){}function a0(t,r){var s=at();r=r===void 0?null:r;var l=s.memoizedState;return r!==null&&Id(r,l[1])?l[0]:(s.memoizedState=[t,r],t)}function s0(t,r){var s=at();r=r===void 0?null:r;var l=s.memoizedState;if(r!==null&&Id(r,l[1]))return l[0];if(l=t(),kr){wi(!0);try{t()}finally{wi(!1)}}return s.memoizedState=[l,r],l}function Wd(t,r,s){return s===void 0||(Wn&1073741824)!==0&&(we&261930)===0?t.memoizedState=r:(t.memoizedState=s,t=oy(),ue.lanes|=t,Ii|=t,s)}function o0(t,r,s,l){return Wt(s,r)?s:Ca.current!==null?(t=Wd(t,s,l),Wt(t,r)||(ct=!0),t):(Wn&42)===0||(Wn&1073741824)!==0&&(we&261930)===0?(ct=!0,t.memoizedState=s):(t=oy(),ue.lanes|=t,Ii|=t,r)}function l0(t,r,s,l,u){var p=V.p;V.p=p!==0&&8>p?p:8;var g=M.T,w={};M.T=w,Xd(t,!1,r,s);try{var C=u(),j=M.S;if(j!==null&&j(w,C),C!==null&&typeof C=="object"&&typeof C.then=="function"){var P=D2(C,l);Hs(t,r,P,Jt(t))}else Hs(t,r,l,Jt(t))}catch(B){Hs(t,r,{then:function(){},status:"rejected",reason:B},Jt())}finally{V.p=p,g!==null&&w.types!==null&&(g.types=w.types),M.T=g}}function z2(){}function Kd(t,r,s,l){if(t.tag!==5)throw Error(a(476));var u=c0(t).queue;l0(t,u,r,J,s===null?z2:function(){return u0(t),s(l)})}function c0(t){var r=t.memoizedState;if(r!==null)return r;r={memoizedState:J,baseState:J,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:Kn,lastRenderedState:J},next:null};var s={};return r.next={memoizedState:s,baseState:s,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:Kn,lastRenderedState:s},next:null},t.memoizedState=r,t=t.alternate,t!==null&&(t.memoizedState=r),r}function u0(t){var r=c0(t);r.next===null&&(r=t.alternate.memoizedState),Hs(t,r.next.queue,{},Jt())}function Qd(){return St(so)}function d0(){return at().memoizedState}function p0(){return at().memoizedState}function F2(t){for(var r=t.return;r!==null;){switch(r.tag){case 24:case 3:var s=Jt();t=Ei(s);var l=ji(r,t,s);l!==null&&(qt(l,r,s),Us(l,r,s)),r={cache:Od()},t.payload=r;return}r=r.return}}function q2(t,r,s){var l=Jt();s={lane:l,revertLane:0,gesture:null,action:s,hasEagerState:!1,eagerState:null,next:null},Gl(t)?f0(r,s):(s=md(t,r,s,l),s!==null&&(qt(s,t,l),h0(s,r,l)))}function m0(t,r,s){var l=Jt();Hs(t,r,s,l)}function Hs(t,r,s,l){var u={lane:l,revertLane:0,gesture:null,action:s,hasEagerState:!1,eagerState:null,next:null};if(Gl(t))f0(r,u);else{var p=t.alternate;if(t.lanes===0&&(p===null||p.lanes===0)&&(p=r.lastRenderedReducer,p!==null))try{var g=r.lastRenderedState,w=p(g,s);if(u.hasEagerState=!0,u.eagerState=w,Wt(w,g))return _l(t,r,u,0),ze===null&&Ol(),!1}catch{}if(s=md(t,r,u,l),s!==null)return qt(s,t,l),h0(s,r,l),!0}return!1}function Xd(t,r,s,l){if(l={lane:2,revertLane:Np(),gesture:null,action:l,hasEagerState:!1,eagerState:null,next:null},Gl(t)){if(r)throw Error(a(479))}else r=md(t,s,l,2),r!==null&&qt(r,t,2)}function Gl(t){var r=t.alternate;return t===ue||r!==null&&r===ue}function f0(t,r){Oa=Ul=!0;var s=t.pending;s===null?r.next=r:(r.next=s.next,s.next=r),t.pending=r}function h0(t,r,s){if((s&4194048)!==0){var l=r.lanes;l&=t.pendingLanes,s|=l,r.lanes=s,bh(t,s)}}var Ys={readContext:St,use:Fl,useCallback:Ze,useContext:Ze,useEffect:Ze,useImperativeHandle:Ze,useLayoutEffect:Ze,useInsertionEffect:Ze,useMemo:Ze,useReducer:Ze,useRef:Ze,useState:Ze,useDebugValue:Ze,useDeferredValue:Ze,useTransition:Ze,useSyncExternalStore:Ze,useId:Ze,useHostTransitionStatus:Ze,useFormState:Ze,useActionState:Ze,useOptimistic:Ze,useMemoCache:Ze,useCacheRefresh:Ze};Ys.useEffectEvent=Ze;var g0={readContext:St,use:Fl,useCallback:function(t,r){return Nt().memoizedState=[t,r===void 0?null:r],t},useContext:St,useEffect:Jg,useImperativeHandle:function(t,r,s){s=s!=null?s.concat([t]):null,Hl(4194308,4,i0.bind(null,r,t),s)},useLayoutEffect:function(t,r){return Hl(4194308,4,t,r)},useInsertionEffect:function(t,r){Hl(4,2,t,r)},useMemo:function(t,r){var s=Nt();r=r===void 0?null:r;var l=t();if(kr){wi(!0);try{t()}finally{wi(!1)}}return s.memoizedState=[l,r],l},useReducer:function(t,r,s){var l=Nt();if(s!==void 0){var u=s(r);if(kr){wi(!0);try{s(r)}finally{wi(!1)}}}else u=r;return l.memoizedState=l.baseState=u,t={pending:null,lanes:0,dispatch:null,lastRenderedReducer:t,lastRenderedState:u},l.queue=t,t=t.dispatch=q2.bind(null,ue,t),[l.memoizedState,t]},useRef:function(t){var r=Nt();return t={current:t},r.memoizedState=t},useState:function(t){t=Hd(t);var r=t.queue,s=m0.bind(null,ue,r);return r.dispatch=s,[t.memoizedState,s]},useDebugValue:Vd,useDeferredValue:function(t,r){var s=Nt();return Wd(s,t,r)},useTransition:function(){var t=Hd(!1);return t=l0.bind(null,ue,t.queue,!0,!1),Nt().memoizedState=t,[!1,t]},useSyncExternalStore:function(t,r,s){var l=ue,u=Nt();if(Oe){if(s===void 0)throw Error(a(407));s=s()}else{if(s=r(),ze===null)throw Error(a(349));(we&127)!==0||Lg(l,r,s)}u.memoizedState=s;var p={value:s,getSnapshot:r};return u.queue=p,Jg(Bg.bind(null,l,p,t),[t]),l.flags|=2048,Ta(9,{destroy:void 0},Ug.bind(null,l,p,s,r),null),s},useId:function(){var t=Nt(),r=ze.identifierPrefix;if(Oe){var s=Nn,l=kn;s=(l&~(1<<32-Vt(l)-1)).toString(32)+s,r="_"+r+"R_"+s,s=Bl++,0<s&&(r+="H"+s.toString(32)),r+="_"}else s=I2++,r="_"+r+"r_"+s.toString(32)+"_";return t.memoizedState=r},useHostTransitionStatus:Qd,useFormState:Kg,useActionState:Kg,useOptimistic:function(t){var r=Nt();r.memoizedState=r.baseState=t;var s={pending:null,lanes:0,dispatch:null,lastRenderedReducer:null,lastRenderedState:null};return r.queue=s,r=Xd.bind(null,ue,!0,s),s.dispatch=r,[t,r]},useMemoCache:zd,useCacheRefresh:function(){return Nt().memoizedState=F2.bind(null,ue)},useEffectEvent:function(t){var r=Nt(),s={impl:t};return r.memoizedState=s,function(){if((Ae&2)!==0)throw Error(a(440));return s.impl.apply(void 0,arguments)}}},$d={readContext:St,use:Fl,useCallback:a0,useContext:St,useEffect:Gd,useImperativeHandle:r0,useInsertionEffect:t0,useLayoutEffect:n0,useMemo:s0,useReducer:ql,useRef:Zg,useState:function(){return ql(Kn)},useDebugValue:Vd,useDeferredValue:function(t,r){var s=at();return o0(s,Pe.memoizedState,t,r)},useTransition:function(){var t=ql(Kn)[0],r=at().memoizedState;return[typeof t=="boolean"?t:qs(t),r]},useSyncExternalStore:Pg,useId:d0,useHostTransitionStatus:Qd,useFormState:Qg,useActionState:Qg,useOptimistic:function(t,r){var s=at();return qg(s,Pe,t,r)},useMemoCache:zd,useCacheRefresh:p0};$d.useEffectEvent=e0;var y0={readContext:St,use:Fl,useCallback:a0,useContext:St,useEffect:Gd,useImperativeHandle:r0,useInsertionEffect:t0,useLayoutEffect:n0,useMemo:s0,useReducer:qd,useRef:Zg,useState:function(){return qd(Kn)},useDebugValue:Vd,useDeferredValue:function(t,r){var s=at();return Pe===null?Wd(s,t,r):o0(s,Pe.memoizedState,t,r)},useTransition:function(){var t=qd(Kn)[0],r=at().memoizedState;return[typeof t=="boolean"?t:qs(t),r]},useSyncExternalStore:Pg,useId:d0,useHostTransitionStatus:Qd,useFormState:$g,useActionState:$g,useOptimistic:function(t,r){var s=at();return Pe!==null?qg(s,Pe,t,r):(s.baseState=t,[t,s.queue.dispatch])},useMemoCache:zd,useCacheRefresh:p0};y0.useEffectEvent=e0;function Zd(t,r,s,l){r=t.memoizedState,s=s(l,r),s=s==null?r:v({},r,s),t.memoizedState=s,t.lanes===0&&(t.updateQueue.baseState=s)}var Jd={enqueueSetState:function(t,r,s){t=t._reactInternals;var l=Jt(),u=Ei(l);u.payload=r,s!=null&&(u.callback=s),r=ji(t,u,l),r!==null&&(qt(r,t,l),Us(r,t,l))},enqueueReplaceState:function(t,r,s){t=t._reactInternals;var l=Jt(),u=Ei(l);u.tag=1,u.payload=r,s!=null&&(u.callback=s),r=ji(t,u,l),r!==null&&(qt(r,t,l),Us(r,t,l))},enqueueForceUpdate:function(t,r){t=t._reactInternals;var s=Jt(),l=Ei(s);l.tag=2,r!=null&&(l.callback=r),r=ji(t,l,s),r!==null&&(qt(r,t,s),Us(r,t,s))}};function v0(t,r,s,l,u,p,g){return t=t.stateNode,typeof t.shouldComponentUpdate=="function"?t.shouldComponentUpdate(l,p,g):r.prototype&&r.prototype.isPureReactComponent?!js(s,l)||!js(u,p):!0}function x0(t,r,s,l){t=r.state,typeof r.componentWillReceiveProps=="function"&&r.componentWillReceiveProps(s,l),typeof r.UNSAFE_componentWillReceiveProps=="function"&&r.UNSAFE_componentWillReceiveProps(s,l),r.state!==t&&Jd.enqueueReplaceState(r,r.state,null)}function Nr(t,r){var s=r;if("ref"in r){s={};for(var l in r)l!=="ref"&&(s[l]=r[l])}if(t=t.defaultProps){s===r&&(s=v({},s));for(var u in t)s[u]===void 0&&(s[u]=t[u])}return s}function b0(t){Cl(t)}function w0(t){console.error(t)}function S0(t){Cl(t)}function Vl(t,r){try{var s=t.onUncaughtError;s(r.value,{componentStack:r.stack})}catch(l){setTimeout(function(){throw l})}}function C0(t,r,s){try{var l=t.onCaughtError;l(s.value,{componentStack:s.stack,errorBoundary:r.tag===1?r.stateNode:null})}catch(u){setTimeout(function(){throw u})}}function ep(t,r,s){return s=Ei(s),s.tag=3,s.payload={element:null},s.callback=function(){Vl(t,r)},s}function O0(t){return t=Ei(t),t.tag=3,t}function _0(t,r,s,l){var u=s.type.getDerivedStateFromError;if(typeof u=="function"){var p=l.value;t.payload=function(){return u(p)},t.callback=function(){C0(r,s,l)}}var g=s.stateNode;g!==null&&typeof g.componentDidCatch=="function"&&(t.callback=function(){C0(r,s,l),typeof u!="function"&&(Pi===null?Pi=new Set([this]):Pi.add(this));var w=l.stack;this.componentDidCatch(l.value,{componentStack:w!==null?w:""})})}function H2(t,r,s,l,u){if(s.flags|=32768,l!==null&&typeof l=="object"&&typeof l.then=="function"){if(r=s.alternate,r!==null&&va(r,s,u,!0),s=Qt.current,s!==null){switch(s.tag){case 31:case 13:return dn===null?rc():s.alternate===null&&Je===0&&(Je=3),s.flags&=-257,s.flags|=65536,s.lanes=u,l===Rl?s.flags|=16384:(r=s.updateQueue,r===null?s.updateQueue=new Set([l]):r.add(l),_p(t,l,u)),!1;case 22:return s.flags|=65536,l===Rl?s.flags|=16384:(r=s.updateQueue,r===null?(r={transitions:null,markerInstances:null,retryQueue:new Set([l])},s.updateQueue=r):(s=r.retryQueue,s===null?r.retryQueue=new Set([l]):s.add(l)),_p(t,l,u)),!1}throw Error(a(435,s.tag))}return _p(t,l,u),rc(),!1}if(Oe)return r=Qt.current,r!==null?((r.flags&65536)===0&&(r.flags|=256),r.flags|=65536,r.lanes=u,l!==xd&&(t=Error(a(422),{cause:l}),Rs(on(t,s)))):(l!==xd&&(r=Error(a(423),{cause:l}),Rs(on(r,s))),t=t.current.alternate,t.flags|=65536,u&=-u,t.lanes|=u,l=on(l,s),u=ep(t.stateNode,l,u),jd(t,u),Je!==4&&(Je=2)),!1;var p=Error(a(520),{cause:l});if(p=on(p,s),Zs===null?Zs=[p]:Zs.push(p),Je!==4&&(Je=2),r===null)return!0;l=on(l,s),s=r;do{switch(s.tag){case 3:return s.flags|=65536,t=u&-u,s.lanes|=t,t=ep(s.stateNode,l,t),jd(s,t),!1;case 1:if(r=s.type,p=s.stateNode,(s.flags&128)===0&&(typeof r.getDerivedStateFromError=="function"||p!==null&&typeof p.componentDidCatch=="function"&&(Pi===null||!Pi.has(p))))return s.flags|=65536,u&=-u,s.lanes|=u,u=O0(u),_0(u,t,s,l),jd(s,u),!1}s=s.return}while(s!==null);return!1}var tp=Error(a(461)),ct=!1;function Ct(t,r,s,l){r.child=t===null?Eg(r,null,s,l):Tr(r,t.child,s,l)}function T0(t,r,s,l,u){s=s.render;var p=r.ref;if("ref"in l){var g={};for(var w in l)w!=="ref"&&(g[w]=l[w])}else g=l;return Sr(r),l=Pd(t,r,s,g,p,u),w=Ld(),t!==null&&!ct?(Ud(t,r,u),Qn(t,r,u)):(Oe&&w&&yd(r),r.flags|=1,Ct(t,r,l,u),r.child)}function k0(t,r,s,l,u){if(t===null){var p=s.type;return typeof p=="function"&&!fd(p)&&p.defaultProps===void 0&&s.compare===null?(r.tag=15,r.type=p,N0(t,r,p,l,u)):(t=kl(s.type,null,l,r,r.mode,u),t.ref=r.ref,t.return=r,r.child=t)}if(p=t.child,!cp(t,u)){var g=p.memoizedProps;if(s=s.compare,s=s!==null?s:js,s(g,l)&&t.ref===r.ref)return Qn(t,r,u)}return r.flags|=1,t=Hn(p,l),t.ref=r.ref,t.return=r,r.child=t}function N0(t,r,s,l,u){if(t!==null){var p=t.memoizedProps;if(js(p,l)&&t.ref===r.ref)if(ct=!1,r.pendingProps=l=p,cp(t,u))(t.flags&131072)!==0&&(ct=!0);else return r.lanes=t.lanes,Qn(t,r,u)}return np(t,r,s,l,u)}function E0(t,r,s,l){var u=l.children,p=t!==null?t.memoizedState:null;if(t===null&&r.stateNode===null&&(r.stateNode={_visibility:1,_pendingMarkers:null,_retryCache:null,_transitions:null}),l.mode==="hidden"){if((r.flags&128)!==0){if(p=p!==null?p.baseLanes|s:s,t!==null){for(l=r.child=t.child,u=0;l!==null;)u=u|l.lanes|l.childLanes,l=l.sibling;l=u&~p}else l=0,r.child=null;return j0(t,r,p,s,l)}if((s&536870912)!==0)r.memoizedState={baseLanes:0,cachePool:null},t!==null&&Al(r,p!==null?p.cachePool:null),p!==null?Mg(r,p):Md(),Rg(r);else return l=r.lanes=536870912,j0(t,r,p!==null?p.baseLanes|s:s,s,l)}else p!==null?(Al(r,p.cachePool),Mg(r,p),Mi(),r.memoizedState=null):(t!==null&&Al(r,null),Md(),Mi());return Ct(t,r,u,s),r.child}function Gs(t,r){return t!==null&&t.tag===22||r.stateNode!==null||(r.stateNode={_visibility:1,_pendingMarkers:null,_retryCache:null,_transitions:null}),r.sibling}function j0(t,r,s,l,u){var p=Td();return p=p===null?null:{parent:ot._currentValue,pool:p},r.memoizedState={baseLanes:s,cachePool:p},t!==null&&Al(r,null),Md(),Rg(r),t!==null&&va(t,r,l,!0),r.childLanes=u,null}function Wl(t,r){return r=Ql({mode:r.mode,children:r.children},t.mode),r.ref=t.ref,t.child=r,r.return=t,r}function A0(t,r,s){return Tr(r,t.child,null,s),t=Wl(r,r.pendingProps),t.flags|=2,Xt(r),r.memoizedState=null,t}function Y2(t,r,s){var l=r.pendingProps,u=(r.flags&128)!==0;if(r.flags&=-129,t===null){if(Oe){if(l.mode==="hidden")return t=Wl(r,l),r.lanes=536870912,Gs(null,t);if(Dd(r),(t=Ge)?(t=Hy(t,un),t=t!==null&&t.data==="&"?t:null,t!==null&&(r.memoizedState={dehydrated:t,treeContext:Oi!==null?{id:kn,overflow:Nn}:null,retryLane:536870912,hydrationErrors:null},s=fg(t),s.return=r,r.child=s,wt=r,Ge=null)):t=null,t===null)throw Ti(r);return r.lanes=536870912,null}return Wl(r,l)}var p=t.memoizedState;if(p!==null){var g=p.dehydrated;if(Dd(r),u)if(r.flags&256)r.flags&=-257,r=A0(t,r,s);else if(r.memoizedState!==null)r.child=t.child,r.flags|=128,r=null;else throw Error(a(558));else if(ct||va(t,r,s,!1),u=(s&t.childLanes)!==0,ct||u){if(l=ze,l!==null&&(g=wh(l,s),g!==0&&g!==p.retryLane))throw p.retryLane=g,vr(t,g),qt(l,t,g),tp;rc(),r=A0(t,r,s)}else t=p.treeContext,Ge=pn(g.nextSibling),wt=r,Oe=!0,_i=null,un=!1,t!==null&&yg(r,t),r=Wl(r,l),r.flags|=4096;return r}return t=Hn(t.child,{mode:l.mode,children:l.children}),t.ref=r.ref,r.child=t,t.return=r,t}function Kl(t,r){var s=r.ref;if(s===null)t!==null&&t.ref!==null&&(r.flags|=4194816);else{if(typeof s!="function"&&typeof s!="object")throw Error(a(284));(t===null||t.ref!==s)&&(r.flags|=4194816)}}function np(t,r,s,l,u){return Sr(r),s=Pd(t,r,s,l,void 0,u),l=Ld(),t!==null&&!ct?(Ud(t,r,u),Qn(t,r,u)):(Oe&&l&&yd(r),r.flags|=1,Ct(t,r,s,u),r.child)}function M0(t,r,s,l,u,p){return Sr(r),r.updateQueue=null,s=Ig(r,l,s,u),Dg(t),l=Ld(),t!==null&&!ct?(Ud(t,r,p),Qn(t,r,p)):(Oe&&l&&yd(r),r.flags|=1,Ct(t,r,s,p),r.child)}function R0(t,r,s,l,u){if(Sr(r),r.stateNode===null){var p=fa,g=s.contextType;typeof g=="object"&&g!==null&&(p=St(g)),p=new s(l,p),r.memoizedState=p.state!==null&&p.state!==void 0?p.state:null,p.updater=Jd,r.stateNode=p,p._reactInternals=r,p=r.stateNode,p.props=l,p.state=r.memoizedState,p.refs={},Nd(r),g=s.contextType,p.context=typeof g=="object"&&g!==null?St(g):fa,p.state=r.memoizedState,g=s.getDerivedStateFromProps,typeof g=="function"&&(Zd(r,s,g,l),p.state=r.memoizedState),typeof s.getDerivedStateFromProps=="function"||typeof p.getSnapshotBeforeUpdate=="function"||typeof p.UNSAFE_componentWillMount!="function"&&typeof p.componentWillMount!="function"||(g=p.state,typeof p.componentWillMount=="function"&&p.componentWillMount(),typeof p.UNSAFE_componentWillMount=="function"&&p.UNSAFE_componentWillMount(),g!==p.state&&Jd.enqueueReplaceState(p,p.state,null),zs(r,l,p,u),Bs(),p.state=r.memoizedState),typeof p.componentDidMount=="function"&&(r.flags|=4194308),l=!0}else if(t===null){p=r.stateNode;var w=r.memoizedProps,C=Nr(s,w);p.props=C;var j=p.context,P=s.contextType;g=fa,typeof P=="object"&&P!==null&&(g=St(P));var B=s.getDerivedStateFromProps;P=typeof B=="function"||typeof p.getSnapshotBeforeUpdate=="function",w=r.pendingProps!==w,P||typeof p.UNSAFE_componentWillReceiveProps!="function"&&typeof p.componentWillReceiveProps!="function"||(w||j!==g)&&x0(r,p,l,g),Ni=!1;var A=r.memoizedState;p.state=A,zs(r,l,p,u),Bs(),j=r.memoizedState,w||A!==j||Ni?(typeof B=="function"&&(Zd(r,s,B,l),j=r.memoizedState),(C=Ni||v0(r,s,C,l,A,j,g))?(P||typeof p.UNSAFE_componentWillMount!="function"&&typeof p.componentWillMount!="function"||(typeof p.componentWillMount=="function"&&p.componentWillMount(),typeof p.UNSAFE_componentWillMount=="function"&&p.UNSAFE_componentWillMount()),typeof p.componentDidMount=="function"&&(r.flags|=4194308)):(typeof p.componentDidMount=="function"&&(r.flags|=4194308),r.memoizedProps=l,r.memoizedState=j),p.props=l,p.state=j,p.context=g,l=C):(typeof p.componentDidMount=="function"&&(r.flags|=4194308),l=!1)}else{p=r.stateNode,Ed(t,r),g=r.memoizedProps,P=Nr(s,g),p.props=P,B=r.pendingProps,A=p.context,j=s.contextType,C=fa,typeof j=="object"&&j!==null&&(C=St(j)),w=s.getDerivedStateFromProps,(j=typeof w=="function"||typeof p.getSnapshotBeforeUpdate=="function")||typeof p.UNSAFE_componentWillReceiveProps!="function"&&typeof p.componentWillReceiveProps!="function"||(g!==B||A!==C)&&x0(r,p,l,C),Ni=!1,A=r.memoizedState,p.state=A,zs(r,l,p,u),Bs();var R=r.memoizedState;g!==B||A!==R||Ni||t!==null&&t.dependencies!==null&&El(t.dependencies)?(typeof w=="function"&&(Zd(r,s,w,l),R=r.memoizedState),(P=Ni||v0(r,s,P,l,A,R,C)||t!==null&&t.dependencies!==null&&El(t.dependencies))?(j||typeof p.UNSAFE_componentWillUpdate!="function"&&typeof p.componentWillUpdate!="function"||(typeof p.componentWillUpdate=="function"&&p.componentWillUpdate(l,R,C),typeof p.UNSAFE_componentWillUpdate=="function"&&p.UNSAFE_componentWillUpdate(l,R,C)),typeof p.componentDidUpdate=="function"&&(r.flags|=4),typeof p.getSnapshotBeforeUpdate=="function"&&(r.flags|=1024)):(typeof p.componentDidUpdate!="function"||g===t.memoizedProps&&A===t.memoizedState||(r.flags|=4),typeof p.getSnapshotBeforeUpdate!="function"||g===t.memoizedProps&&A===t.memoizedState||(r.flags|=1024),r.memoizedProps=l,r.memoizedState=R),p.props=l,p.state=R,p.context=C,l=P):(typeof p.componentDidUpdate!="function"||g===t.memoizedProps&&A===t.memoizedState||(r.flags|=4),typeof p.getSnapshotBeforeUpdate!="function"||g===t.memoizedProps&&A===t.memoizedState||(r.flags|=1024),l=!1)}return p=l,Kl(t,r),l=(r.flags&128)!==0,p||l?(p=r.stateNode,s=l&&typeof s.getDerivedStateFromError!="function"?null:p.render(),r.flags|=1,t!==null&&l?(r.child=Tr(r,t.child,null,u),r.child=Tr(r,null,s,u)):Ct(t,r,s,u),r.memoizedState=p.state,t=r.child):t=Qn(t,r,u),t}function D0(t,r,s,l){return br(),r.flags|=256,Ct(t,r,s,l),r.child}var ip={dehydrated:null,treeContext:null,retryLane:0,hydrationErrors:null};function rp(t){return{baseLanes:t,cachePool:Cg()}}function ap(t,r,s){return t=t!==null?t.childLanes&~s:0,r&&(t|=Zt),t}function I0(t,r,s){var l=r.pendingProps,u=!1,p=(r.flags&128)!==0,g;if((g=p)||(g=t!==null&&t.memoizedState===null?!1:(rt.current&2)!==0),g&&(u=!0,r.flags&=-129),g=(r.flags&32)!==0,r.flags&=-33,t===null){if(Oe){if(u?Ai(r):Mi(),(t=Ge)?(t=Hy(t,un),t=t!==null&&t.data!=="&"?t:null,t!==null&&(r.memoizedState={dehydrated:t,treeContext:Oi!==null?{id:kn,overflow:Nn}:null,retryLane:536870912,hydrationErrors:null},s=fg(t),s.return=r,r.child=s,wt=r,Ge=null)):t=null,t===null)throw Ti(r);return Fp(t)?r.lanes=32:r.lanes=536870912,null}var w=l.children;return l=l.fallback,u?(Mi(),u=r.mode,w=Ql({mode:"hidden",children:w},u),l=xr(l,u,s,null),w.return=r,l.return=r,w.sibling=l,r.child=w,l=r.child,l.memoizedState=rp(s),l.childLanes=ap(t,g,s),r.memoizedState=ip,Gs(null,l)):(Ai(r),sp(r,w))}var C=t.memoizedState;if(C!==null&&(w=C.dehydrated,w!==null)){if(p)r.flags&256?(Ai(r),r.flags&=-257,r=op(t,r,s)):r.memoizedState!==null?(Mi(),r.child=t.child,r.flags|=128,r=null):(Mi(),w=l.fallback,u=r.mode,l=Ql({mode:"visible",children:l.children},u),w=xr(w,u,s,null),w.flags|=2,l.return=r,w.return=r,l.sibling=w,r.child=l,Tr(r,t.child,null,s),l=r.child,l.memoizedState=rp(s),l.childLanes=ap(t,g,s),r.memoizedState=ip,r=Gs(null,l));else if(Ai(r),Fp(w)){if(g=w.nextSibling&&w.nextSibling.dataset,g)var j=g.dgst;g=j,l=Error(a(419)),l.stack="",l.digest=g,Rs({value:l,source:null,stack:null}),r=op(t,r,s)}else if(ct||va(t,r,s,!1),g=(s&t.childLanes)!==0,ct||g){if(g=ze,g!==null&&(l=wh(g,s),l!==0&&l!==C.retryLane))throw C.retryLane=l,vr(t,l),qt(g,t,l),tp;zp(w)||rc(),r=op(t,r,s)}else zp(w)?(r.flags|=192,r.child=t.child,r=null):(t=C.treeContext,Ge=pn(w.nextSibling),wt=r,Oe=!0,_i=null,un=!1,t!==null&&yg(r,t),r=sp(r,l.children),r.flags|=4096);return r}return u?(Mi(),w=l.fallback,u=r.mode,C=t.child,j=C.sibling,l=Hn(C,{mode:"hidden",children:l.children}),l.subtreeFlags=C.subtreeFlags&65011712,j!==null?w=Hn(j,w):(w=xr(w,u,s,null),w.flags|=2),w.return=r,l.return=r,l.sibling=w,r.child=l,Gs(null,l),l=r.child,w=t.child.memoizedState,w===null?w=rp(s):(u=w.cachePool,u!==null?(C=ot._currentValue,u=u.parent!==C?{parent:C,pool:C}:u):u=Cg(),w={baseLanes:w.baseLanes|s,cachePool:u}),l.memoizedState=w,l.childLanes=ap(t,g,s),r.memoizedState=ip,Gs(t.child,l)):(Ai(r),s=t.child,t=s.sibling,s=Hn(s,{mode:"visible",children:l.children}),s.return=r,s.sibling=null,t!==null&&(g=r.deletions,g===null?(r.deletions=[t],r.flags|=16):g.push(t)),r.child=s,r.memoizedState=null,s)}function sp(t,r){return r=Ql({mode:"visible",children:r},t.mode),r.return=t,t.child=r}function Ql(t,r){return t=Kt(22,t,null,r),t.lanes=0,t}function op(t,r,s){return Tr(r,t.child,null,s),t=sp(r,r.pendingProps.children),t.flags|=2,r.memoizedState=null,t}function P0(t,r,s){t.lanes|=r;var l=t.alternate;l!==null&&(l.lanes|=r),Sd(t.return,r,s)}function lp(t,r,s,l,u,p){var g=t.memoizedState;g===null?t.memoizedState={isBackwards:r,rendering:null,renderingStartTime:0,last:l,tail:s,tailMode:u,treeForkCount:p}:(g.isBackwards=r,g.rendering=null,g.renderingStartTime=0,g.last=l,g.tail=s,g.tailMode=u,g.treeForkCount=p)}function L0(t,r,s){var l=r.pendingProps,u=l.revealOrder,p=l.tail;l=l.children;var g=rt.current,w=(g&2)!==0;if(w?(g=g&1|2,r.flags|=128):g&=1,Y(rt,g),Ct(t,r,l,s),l=Oe?Ms:0,!w&&t!==null&&(t.flags&128)!==0)e:for(t=r.child;t!==null;){if(t.tag===13)t.memoizedState!==null&&P0(t,s,r);else if(t.tag===19)P0(t,s,r);else if(t.child!==null){t.child.return=t,t=t.child;continue}if(t===r)break e;for(;t.sibling===null;){if(t.return===null||t.return===r)break e;t=t.return}t.sibling.return=t.return,t=t.sibling}switch(u){case"forwards":for(s=r.child,u=null;s!==null;)t=s.alternate,t!==null&&Ll(t)===null&&(u=s),s=s.sibling;s=u,s===null?(u=r.child,r.child=null):(u=s.sibling,s.sibling=null),lp(r,!1,u,s,p,l);break;case"backwards":case"unstable_legacy-backwards":for(s=null,u=r.child,r.child=null;u!==null;){if(t=u.alternate,t!==null&&Ll(t)===null){r.child=u;break}t=u.sibling,u.sibling=s,s=u,u=t}lp(r,!0,s,null,p,l);break;case"together":lp(r,!1,null,null,void 0,l);break;default:r.memoizedState=null}return r.child}function Qn(t,r,s){if(t!==null&&(r.dependencies=t.dependencies),Ii|=r.lanes,(s&r.childLanes)===0)if(t!==null){if(va(t,r,s,!1),(s&r.childLanes)===0)return null}else return null;if(t!==null&&r.child!==t.child)throw Error(a(153));if(r.child!==null){for(t=r.child,s=Hn(t,t.pendingProps),r.child=s,s.return=r;t.sibling!==null;)t=t.sibling,s=s.sibling=Hn(t,t.pendingProps),s.return=r;s.sibling=null}return r.child}function cp(t,r){return(t.lanes&r)!==0?!0:(t=t.dependencies,!!(t!==null&&El(t)))}function G2(t,r,s){switch(r.tag){case 3:dt(r,r.stateNode.containerInfo),ki(r,ot,t.memoizedState.cache),br();break;case 27:case 5:pr(r);break;case 4:dt(r,r.stateNode.containerInfo);break;case 10:ki(r,r.type,r.memoizedProps.value);break;case 31:if(r.memoizedState!==null)return r.flags|=128,Dd(r),null;break;case 13:var l=r.memoizedState;if(l!==null)return l.dehydrated!==null?(Ai(r),r.flags|=128,null):(s&r.child.childLanes)!==0?I0(t,r,s):(Ai(r),t=Qn(t,r,s),t!==null?t.sibling:null);Ai(r);break;case 19:var u=(t.flags&128)!==0;if(l=(s&r.childLanes)!==0,l||(va(t,r,s,!1),l=(s&r.childLanes)!==0),u){if(l)return L0(t,r,s);r.flags|=128}if(u=r.memoizedState,u!==null&&(u.rendering=null,u.tail=null,u.lastEffect=null),Y(rt,rt.current),l)break;return null;case 22:return r.lanes=0,E0(t,r,s,r.pendingProps);case 24:ki(r,ot,t.memoizedState.cache)}return Qn(t,r,s)}function U0(t,r,s){if(t!==null)if(t.memoizedProps!==r.pendingProps)ct=!0;else{if(!cp(t,s)&&(r.flags&128)===0)return ct=!1,G2(t,r,s);ct=(t.flags&131072)!==0}else ct=!1,Oe&&(r.flags&1048576)!==0&&gg(r,Ms,r.index);switch(r.lanes=0,r.tag){case 16:e:{var l=r.pendingProps;if(t=Or(r.elementType),r.type=t,typeof t=="function")fd(t)?(l=Nr(t,l),r.tag=1,r=R0(null,r,t,l,s)):(r.tag=0,r=np(null,r,t,l,s));else{if(t!=null){var u=t.$$typeof;if(u===z){r.tag=11,r=T0(null,r,t,l,s);break e}else if(u===K){r.tag=14,r=k0(null,r,t,l,s);break e}}throw r=st(t)||t,Error(a(306,r,""))}}return r;case 0:return np(t,r,r.type,r.pendingProps,s);case 1:return l=r.type,u=Nr(l,r.pendingProps),R0(t,r,l,u,s);case 3:e:{if(dt(r,r.stateNode.containerInfo),t===null)throw Error(a(387));l=r.pendingProps;var p=r.memoizedState;u=p.element,Ed(t,r),zs(r,l,null,s);var g=r.memoizedState;if(l=g.cache,ki(r,ot,l),l!==p.cache&&Cd(r,[ot],s,!0),Bs(),l=g.element,p.isDehydrated)if(p={element:l,isDehydrated:!1,cache:g.cache},r.updateQueue.baseState=p,r.memoizedState=p,r.flags&256){r=D0(t,r,l,s);break e}else if(l!==u){u=on(Error(a(424)),r),Rs(u),r=D0(t,r,l,s);break e}else for(t=r.stateNode.containerInfo,t.nodeType===9?t=t.body:t=t.nodeName==="HTML"?t.ownerDocument.body:t,Ge=pn(t.firstChild),wt=r,Oe=!0,_i=null,un=!0,s=Eg(r,null,l,s),r.child=s;s;)s.flags=s.flags&-3|4096,s=s.sibling;else{if(br(),l===u){r=Qn(t,r,s);break e}Ct(t,r,l,s)}r=r.child}return r;case 26:return Kl(t,r),t===null?(s=Qy(r.type,null,r.pendingProps,null))?r.memoizedState=s:Oe||(s=r.type,t=r.pendingProps,l=dc(ce.current).createElement(s),l[bt]=r,l[Pt]=t,Ot(l,s,t),ft(l),r.stateNode=l):r.memoizedState=Qy(r.type,t.memoizedProps,r.pendingProps,t.memoizedState),null;case 27:return pr(r),t===null&&Oe&&(l=r.stateNode=Vy(r.type,r.pendingProps,ce.current),wt=r,un=!0,u=Ge,zi(r.type)?(qp=u,Ge=pn(l.firstChild)):Ge=u),Ct(t,r,r.pendingProps.children,s),Kl(t,r),t===null&&(r.flags|=4194304),r.child;case 5:return t===null&&Oe&&((u=l=Ge)&&(l=wC(l,r.type,r.pendingProps,un),l!==null?(r.stateNode=l,wt=r,Ge=pn(l.firstChild),un=!1,u=!0):u=!1),u||Ti(r)),pr(r),u=r.type,p=r.pendingProps,g=t!==null?t.memoizedProps:null,l=p.children,Lp(u,p)?l=null:g!==null&&Lp(u,g)&&(r.flags|=32),r.memoizedState!==null&&(u=Pd(t,r,P2,null,null,s),so._currentValue=u),Kl(t,r),Ct(t,r,l,s),r.child;case 6:return t===null&&Oe&&((t=s=Ge)&&(s=SC(s,r.pendingProps,un),s!==null?(r.stateNode=s,wt=r,Ge=null,t=!0):t=!1),t||Ti(r)),null;case 13:return I0(t,r,s);case 4:return dt(r,r.stateNode.containerInfo),l=r.pendingProps,t===null?r.child=Tr(r,null,l,s):Ct(t,r,l,s),r.child;case 11:return T0(t,r,r.type,r.pendingProps,s);case 7:return Ct(t,r,r.pendingProps,s),r.child;case 8:return Ct(t,r,r.pendingProps.children,s),r.child;case 12:return Ct(t,r,r.pendingProps.children,s),r.child;case 10:return l=r.pendingProps,ki(r,r.type,l.value),Ct(t,r,l.children,s),r.child;case 9:return u=r.type._context,l=r.pendingProps.children,Sr(r),u=St(u),l=l(u),r.flags|=1,Ct(t,r,l,s),r.child;case 14:return k0(t,r,r.type,r.pendingProps,s);case 15:return N0(t,r,r.type,r.pendingProps,s);case 19:return L0(t,r,s);case 31:return Y2(t,r,s);case 22:return E0(t,r,s,r.pendingProps);case 24:return Sr(r),l=St(ot),t===null?(u=Td(),u===null&&(u=ze,p=Od(),u.pooledCache=p,p.refCount++,p!==null&&(u.pooledCacheLanes|=s),u=p),r.memoizedState={parent:l,cache:u},Nd(r),ki(r,ot,u)):((t.lanes&s)!==0&&(Ed(t,r),zs(r,null,null,s),Bs()),u=t.memoizedState,p=r.memoizedState,u.parent!==l?(u={parent:l,cache:l},r.memoizedState=u,r.lanes===0&&(r.memoizedState=r.updateQueue.baseState=u),ki(r,ot,l)):(l=p.cache,ki(r,ot,l),l!==u.cache&&Cd(r,[ot],s,!0))),Ct(t,r,r.pendingProps.children,s),r.child;case 29:throw r.pendingProps}throw Error(a(156,r.tag))}function Xn(t){t.flags|=4}function up(t,r,s,l,u){if((r=(t.mode&32)!==0)&&(r=!1),r){if(t.flags|=16777216,(u&335544128)===u)if(t.stateNode.complete)t.flags|=8192;else if(dy())t.flags|=8192;else throw _r=Rl,kd}else t.flags&=-16777217}function B0(t,r){if(r.type!=="stylesheet"||(r.state.loading&4)!==0)t.flags&=-16777217;else if(t.flags|=16777216,!e1(r))if(dy())t.flags|=8192;else throw _r=Rl,kd}function Xl(t,r){r!==null&&(t.flags|=4),t.flags&16384&&(r=t.tag!==22?vh():536870912,t.lanes|=r,ja|=r)}function Vs(t,r){if(!Oe)switch(t.tailMode){case"hidden":r=t.tail;for(var s=null;r!==null;)r.alternate!==null&&(s=r),r=r.sibling;s===null?t.tail=null:s.sibling=null;break;case"collapsed":s=t.tail;for(var l=null;s!==null;)s.alternate!==null&&(l=s),s=s.sibling;l===null?r||t.tail===null?t.tail=null:t.tail.sibling=null:l.sibling=null}}function Ve(t){var r=t.alternate!==null&&t.alternate.child===t.child,s=0,l=0;if(r)for(var u=t.child;u!==null;)s|=u.lanes|u.childLanes,l|=u.subtreeFlags&65011712,l|=u.flags&65011712,u.return=t,u=u.sibling;else for(u=t.child;u!==null;)s|=u.lanes|u.childLanes,l|=u.subtreeFlags,l|=u.flags,u.return=t,u=u.sibling;return t.subtreeFlags|=l,t.childLanes=s,r}function V2(t,r,s){var l=r.pendingProps;switch(vd(r),r.tag){case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return Ve(r),null;case 1:return Ve(r),null;case 3:return s=r.stateNode,l=null,t!==null&&(l=t.memoizedState.cache),r.memoizedState.cache!==l&&(r.flags|=2048),Vn(ot),We(),s.pendingContext&&(s.context=s.pendingContext,s.pendingContext=null),(t===null||t.child===null)&&(ya(r)?Xn(r):t===null||t.memoizedState.isDehydrated&&(r.flags&256)===0||(r.flags|=1024,bd())),Ve(r),null;case 26:var u=r.type,p=r.memoizedState;return t===null?(Xn(r),p!==null?(Ve(r),B0(r,p)):(Ve(r),up(r,u,null,l,s))):p?p!==t.memoizedState?(Xn(r),Ve(r),B0(r,p)):(Ve(r),r.flags&=-16777217):(t=t.memoizedProps,t!==l&&Xn(r),Ve(r),up(r,u,t,l,s)),null;case 27:if(Zr(r),s=ce.current,u=r.type,t!==null&&r.stateNode!=null)t.memoizedProps!==l&&Xn(r);else{if(!l){if(r.stateNode===null)throw Error(a(166));return Ve(r),null}t=W.current,ya(r)?vg(r):(t=Vy(u,l,s),r.stateNode=t,Xn(r))}return Ve(r),null;case 5:if(Zr(r),u=r.type,t!==null&&r.stateNode!=null)t.memoizedProps!==l&&Xn(r);else{if(!l){if(r.stateNode===null)throw Error(a(166));return Ve(r),null}if(p=W.current,ya(r))vg(r);else{var g=dc(ce.current);switch(p){case 1:p=g.createElementNS("http://www.w3.org/2000/svg",u);break;case 2:p=g.createElementNS("http://www.w3.org/1998/Math/MathML",u);break;default:switch(u){case"svg":p=g.createElementNS("http://www.w3.org/2000/svg",u);break;case"math":p=g.createElementNS("http://www.w3.org/1998/Math/MathML",u);break;case"script":p=g.createElement("div"),p.innerHTML="<script><\/script>",p=p.removeChild(p.firstChild);break;case"select":p=typeof l.is=="string"?g.createElement("select",{is:l.is}):g.createElement("select"),l.multiple?p.multiple=!0:l.size&&(p.size=l.size);break;default:p=typeof l.is=="string"?g.createElement(u,{is:l.is}):g.createElement(u)}}p[bt]=r,p[Pt]=l;e:for(g=r.child;g!==null;){if(g.tag===5||g.tag===6)p.appendChild(g.stateNode);else if(g.tag!==4&&g.tag!==27&&g.child!==null){g.child.return=g,g=g.child;continue}if(g===r)break e;for(;g.sibling===null;){if(g.return===null||g.return===r)break e;g=g.return}g.sibling.return=g.return,g=g.sibling}r.stateNode=p;e:switch(Ot(p,u,l),u){case"button":case"input":case"select":case"textarea":l=!!l.autoFocus;break e;case"img":l=!0;break e;default:l=!1}l&&Xn(r)}}return Ve(r),up(r,r.type,t===null?null:t.memoizedProps,r.pendingProps,s),null;case 6:if(t&&r.stateNode!=null)t.memoizedProps!==l&&Xn(r);else{if(typeof l!="string"&&r.stateNode===null)throw Error(a(166));if(t=ce.current,ya(r)){if(t=r.stateNode,s=r.memoizedProps,l=null,u=wt,u!==null)switch(u.tag){case 27:case 5:l=u.memoizedProps}t[bt]=r,t=!!(t.nodeValue===s||l!==null&&l.suppressHydrationWarning===!0||Iy(t.nodeValue,s)),t||Ti(r,!0)}else t=dc(t).createTextNode(l),t[bt]=r,r.stateNode=t}return Ve(r),null;case 31:if(s=r.memoizedState,t===null||t.memoizedState!==null){if(l=ya(r),s!==null){if(t===null){if(!l)throw Error(a(318));if(t=r.memoizedState,t=t!==null?t.dehydrated:null,!t)throw Error(a(557));t[bt]=r}else br(),(r.flags&128)===0&&(r.memoizedState=null),r.flags|=4;Ve(r),t=!1}else s=bd(),t!==null&&t.memoizedState!==null&&(t.memoizedState.hydrationErrors=s),t=!0;if(!t)return r.flags&256?(Xt(r),r):(Xt(r),null);if((r.flags&128)!==0)throw Error(a(558))}return Ve(r),null;case 13:if(l=r.memoizedState,t===null||t.memoizedState!==null&&t.memoizedState.dehydrated!==null){if(u=ya(r),l!==null&&l.dehydrated!==null){if(t===null){if(!u)throw Error(a(318));if(u=r.memoizedState,u=u!==null?u.dehydrated:null,!u)throw Error(a(317));u[bt]=r}else br(),(r.flags&128)===0&&(r.memoizedState=null),r.flags|=4;Ve(r),u=!1}else u=bd(),t!==null&&t.memoizedState!==null&&(t.memoizedState.hydrationErrors=u),u=!0;if(!u)return r.flags&256?(Xt(r),r):(Xt(r),null)}return Xt(r),(r.flags&128)!==0?(r.lanes=s,r):(s=l!==null,t=t!==null&&t.memoizedState!==null,s&&(l=r.child,u=null,l.alternate!==null&&l.alternate.memoizedState!==null&&l.alternate.memoizedState.cachePool!==null&&(u=l.alternate.memoizedState.cachePool.pool),p=null,l.memoizedState!==null&&l.memoizedState.cachePool!==null&&(p=l.memoizedState.cachePool.pool),p!==u&&(l.flags|=2048)),s!==t&&s&&(r.child.flags|=8192),Xl(r,r.updateQueue),Ve(r),null);case 4:return We(),t===null&&Mp(r.stateNode.containerInfo),Ve(r),null;case 10:return Vn(r.type),Ve(r),null;case 19:if(L(rt),l=r.memoizedState,l===null)return Ve(r),null;if(u=(r.flags&128)!==0,p=l.rendering,p===null)if(u)Vs(l,!1);else{if(Je!==0||t!==null&&(t.flags&128)!==0)for(t=r.child;t!==null;){if(p=Ll(t),p!==null){for(r.flags|=128,Vs(l,!1),t=p.updateQueue,r.updateQueue=t,Xl(r,t),r.subtreeFlags=0,t=s,s=r.child;s!==null;)mg(s,t),s=s.sibling;return Y(rt,rt.current&1|2),Oe&&Yn(r,l.treeForkCount),r.child}t=t.sibling}l.tail!==null&&kt()>tc&&(r.flags|=128,u=!0,Vs(l,!1),r.lanes=4194304)}else{if(!u)if(t=Ll(p),t!==null){if(r.flags|=128,u=!0,t=t.updateQueue,r.updateQueue=t,Xl(r,t),Vs(l,!0),l.tail===null&&l.tailMode==="hidden"&&!p.alternate&&!Oe)return Ve(r),null}else 2*kt()-l.renderingStartTime>tc&&s!==536870912&&(r.flags|=128,u=!0,Vs(l,!1),r.lanes=4194304);l.isBackwards?(p.sibling=r.child,r.child=p):(t=l.last,t!==null?t.sibling=p:r.child=p,l.last=p)}return l.tail!==null?(t=l.tail,l.rendering=t,l.tail=t.sibling,l.renderingStartTime=kt(),t.sibling=null,s=rt.current,Y(rt,u?s&1|2:s&1),Oe&&Yn(r,l.treeForkCount),t):(Ve(r),null);case 22:case 23:return Xt(r),Rd(),l=r.memoizedState!==null,t!==null?t.memoizedState!==null!==l&&(r.flags|=8192):l&&(r.flags|=8192),l?(s&536870912)!==0&&(r.flags&128)===0&&(Ve(r),r.subtreeFlags&6&&(r.flags|=8192)):Ve(r),s=r.updateQueue,s!==null&&Xl(r,s.retryQueue),s=null,t!==null&&t.memoizedState!==null&&t.memoizedState.cachePool!==null&&(s=t.memoizedState.cachePool.pool),l=null,r.memoizedState!==null&&r.memoizedState.cachePool!==null&&(l=r.memoizedState.cachePool.pool),l!==s&&(r.flags|=2048),t!==null&&L(Cr),null;case 24:return s=null,t!==null&&(s=t.memoizedState.cache),r.memoizedState.cache!==s&&(r.flags|=2048),Vn(ot),Ve(r),null;case 25:return null;case 30:return null}throw Error(a(156,r.tag))}function W2(t,r){switch(vd(r),r.tag){case 1:return t=r.flags,t&65536?(r.flags=t&-65537|128,r):null;case 3:return Vn(ot),We(),t=r.flags,(t&65536)!==0&&(t&128)===0?(r.flags=t&-65537|128,r):null;case 26:case 27:case 5:return Zr(r),null;case 31:if(r.memoizedState!==null){if(Xt(r),r.alternate===null)throw Error(a(340));br()}return t=r.flags,t&65536?(r.flags=t&-65537|128,r):null;case 13:if(Xt(r),t=r.memoizedState,t!==null&&t.dehydrated!==null){if(r.alternate===null)throw Error(a(340));br()}return t=r.flags,t&65536?(r.flags=t&-65537|128,r):null;case 19:return L(rt),null;case 4:return We(),null;case 10:return Vn(r.type),null;case 22:case 23:return Xt(r),Rd(),t!==null&&L(Cr),t=r.flags,t&65536?(r.flags=t&-65537|128,r):null;case 24:return Vn(ot),null;case 25:return null;default:return null}}function z0(t,r){switch(vd(r),r.tag){case 3:Vn(ot),We();break;case 26:case 27:case 5:Zr(r);break;case 4:We();break;case 31:r.memoizedState!==null&&Xt(r);break;case 13:Xt(r);break;case 19:L(rt);break;case 10:Vn(r.type);break;case 22:case 23:Xt(r),Rd(),t!==null&&L(Cr);break;case 24:Vn(ot)}}function Ws(t,r){try{var s=r.updateQueue,l=s!==null?s.lastEffect:null;if(l!==null){var u=l.next;s=u;do{if((s.tag&t)===t){l=void 0;var p=s.create,g=s.inst;l=p(),g.destroy=l}s=s.next}while(s!==u)}}catch(w){De(r,r.return,w)}}function Ri(t,r,s){try{var l=r.updateQueue,u=l!==null?l.lastEffect:null;if(u!==null){var p=u.next;l=p;do{if((l.tag&t)===t){var g=l.inst,w=g.destroy;if(w!==void 0){g.destroy=void 0,u=r;var C=s,j=w;try{j()}catch(P){De(u,C,P)}}}l=l.next}while(l!==p)}}catch(P){De(r,r.return,P)}}function F0(t){var r=t.updateQueue;if(r!==null){var s=t.stateNode;try{Ag(r,s)}catch(l){De(t,t.return,l)}}}function q0(t,r,s){s.props=Nr(t.type,t.memoizedProps),s.state=t.memoizedState;try{s.componentWillUnmount()}catch(l){De(t,r,l)}}function Ks(t,r){try{var s=t.ref;if(s!==null){switch(t.tag){case 26:case 27:case 5:var l=t.stateNode;break;case 30:l=t.stateNode;break;default:l=t.stateNode}typeof s=="function"?t.refCleanup=s(l):s.current=l}}catch(u){De(t,r,u)}}function En(t,r){var s=t.ref,l=t.refCleanup;if(s!==null)if(typeof l=="function")try{l()}catch(u){De(t,r,u)}finally{t.refCleanup=null,t=t.alternate,t!=null&&(t.refCleanup=null)}else if(typeof s=="function")try{s(null)}catch(u){De(t,r,u)}else s.current=null}function H0(t){var r=t.type,s=t.memoizedProps,l=t.stateNode;try{e:switch(r){case"button":case"input":case"select":case"textarea":s.autoFocus&&l.focus();break e;case"img":s.src?l.src=s.src:s.srcSet&&(l.srcset=s.srcSet)}}catch(u){De(t,t.return,u)}}function dp(t,r,s){try{var l=t.stateNode;hC(l,t.type,s,r),l[Pt]=r}catch(u){De(t,t.return,u)}}function Y0(t){return t.tag===5||t.tag===3||t.tag===26||t.tag===27&&zi(t.type)||t.tag===4}function pp(t){e:for(;;){for(;t.sibling===null;){if(t.return===null||Y0(t.return))return null;t=t.return}for(t.sibling.return=t.return,t=t.sibling;t.tag!==5&&t.tag!==6&&t.tag!==18;){if(t.tag===27&&zi(t.type)||t.flags&2||t.child===null||t.tag===4)continue e;t.child.return=t,t=t.child}if(!(t.flags&2))return t.stateNode}}function mp(t,r,s){var l=t.tag;if(l===5||l===6)t=t.stateNode,r?(s.nodeType===9?s.body:s.nodeName==="HTML"?s.ownerDocument.body:s).insertBefore(t,r):(r=s.nodeType===9?s.body:s.nodeName==="HTML"?s.ownerDocument.body:s,r.appendChild(t),s=s._reactRootContainer,s!=null||r.onclick!==null||(r.onclick=Fn));else if(l!==4&&(l===27&&zi(t.type)&&(s=t.stateNode,r=null),t=t.child,t!==null))for(mp(t,r,s),t=t.sibling;t!==null;)mp(t,r,s),t=t.sibling}function $l(t,r,s){var l=t.tag;if(l===5||l===6)t=t.stateNode,r?s.insertBefore(t,r):s.appendChild(t);else if(l!==4&&(l===27&&zi(t.type)&&(s=t.stateNode),t=t.child,t!==null))for($l(t,r,s),t=t.sibling;t!==null;)$l(t,r,s),t=t.sibling}function G0(t){var r=t.stateNode,s=t.memoizedProps;try{for(var l=t.type,u=r.attributes;u.length;)r.removeAttributeNode(u[0]);Ot(r,l,s),r[bt]=t,r[Pt]=s}catch(p){De(t,t.return,p)}}var $n=!1,ut=!1,fp=!1,V0=typeof WeakSet=="function"?WeakSet:Set,ht=null;function K2(t,r){if(t=t.containerInfo,Ip=vc,t=rg(t),od(t)){if("selectionStart"in t)var s={start:t.selectionStart,end:t.selectionEnd};else e:{s=(s=t.ownerDocument)&&s.defaultView||window;var l=s.getSelection&&s.getSelection();if(l&&l.rangeCount!==0){s=l.anchorNode;var u=l.anchorOffset,p=l.focusNode;l=l.focusOffset;try{s.nodeType,p.nodeType}catch{s=null;break e}var g=0,w=-1,C=-1,j=0,P=0,B=t,A=null;t:for(;;){for(var R;B!==s||u!==0&&B.nodeType!==3||(w=g+u),B!==p||l!==0&&B.nodeType!==3||(C=g+l),B.nodeType===3&&(g+=B.nodeValue.length),(R=B.firstChild)!==null;)A=B,B=R;for(;;){if(B===t)break t;if(A===s&&++j===u&&(w=g),A===p&&++P===l&&(C=g),(R=B.nextSibling)!==null)break;B=A,A=B.parentNode}B=R}s=w===-1||C===-1?null:{start:w,end:C}}else s=null}s=s||{start:0,end:0}}else s=null;for(Pp={focusedElem:t,selectionRange:s},vc=!1,ht=r;ht!==null;)if(r=ht,t=r.child,(r.subtreeFlags&1028)!==0&&t!==null)t.return=r,ht=t;else for(;ht!==null;){switch(r=ht,p=r.alternate,t=r.flags,r.tag){case 0:if((t&4)!==0&&(t=r.updateQueue,t=t!==null?t.events:null,t!==null))for(s=0;s<t.length;s++)u=t[s],u.ref.impl=u.nextImpl;break;case 11:case 15:break;case 1:if((t&1024)!==0&&p!==null){t=void 0,s=r,u=p.memoizedProps,p=p.memoizedState,l=s.stateNode;try{var Q=Nr(s.type,u);t=l.getSnapshotBeforeUpdate(Q,p),l.__reactInternalSnapshotBeforeUpdate=t}catch(ie){De(s,s.return,ie)}}break;case 3:if((t&1024)!==0){if(t=r.stateNode.containerInfo,s=t.nodeType,s===9)Bp(t);else if(s===1)switch(t.nodeName){case"HEAD":case"HTML":case"BODY":Bp(t);break;default:t.textContent=""}}break;case 5:case 26:case 27:case 6:case 4:case 17:break;default:if((t&1024)!==0)throw Error(a(163))}if(t=r.sibling,t!==null){t.return=r.return,ht=t;break}ht=r.return}}function W0(t,r,s){var l=s.flags;switch(s.tag){case 0:case 11:case 15:Jn(t,s),l&4&&Ws(5,s);break;case 1:if(Jn(t,s),l&4)if(t=s.stateNode,r===null)try{t.componentDidMount()}catch(g){De(s,s.return,g)}else{var u=Nr(s.type,r.memoizedProps);r=r.memoizedState;try{t.componentDidUpdate(u,r,t.__reactInternalSnapshotBeforeUpdate)}catch(g){De(s,s.return,g)}}l&64&&F0(s),l&512&&Ks(s,s.return);break;case 3:if(Jn(t,s),l&64&&(t=s.updateQueue,t!==null)){if(r=null,s.child!==null)switch(s.child.tag){case 27:case 5:r=s.child.stateNode;break;case 1:r=s.child.stateNode}try{Ag(t,r)}catch(g){De(s,s.return,g)}}break;case 27:r===null&&l&4&&G0(s);case 26:case 5:Jn(t,s),r===null&&l&4&&H0(s),l&512&&Ks(s,s.return);break;case 12:Jn(t,s);break;case 31:Jn(t,s),l&4&&X0(t,s);break;case 13:Jn(t,s),l&4&&$0(t,s),l&64&&(t=s.memoizedState,t!==null&&(t=t.dehydrated,t!==null&&(s=iC.bind(null,s),CC(t,s))));break;case 22:if(l=s.memoizedState!==null||$n,!l){r=r!==null&&r.memoizedState!==null||ut,u=$n;var p=ut;$n=l,(ut=r)&&!p?ei(t,s,(s.subtreeFlags&8772)!==0):Jn(t,s),$n=u,ut=p}break;case 30:break;default:Jn(t,s)}}function K0(t){var r=t.alternate;r!==null&&(t.alternate=null,K0(r)),t.child=null,t.deletions=null,t.sibling=null,t.tag===5&&(r=t.stateNode,r!==null&&Yu(r)),t.stateNode=null,t.return=null,t.dependencies=null,t.memoizedProps=null,t.memoizedState=null,t.pendingProps=null,t.stateNode=null,t.updateQueue=null}var Ke=null,Ut=!1;function Zn(t,r,s){for(s=s.child;s!==null;)Q0(t,r,s),s=s.sibling}function Q0(t,r,s){if(Gt&&typeof Gt.onCommitFiberUnmount=="function")try{Gt.onCommitFiberUnmount(vs,s)}catch{}switch(s.tag){case 26:ut||En(s,r),Zn(t,r,s),s.memoizedState?s.memoizedState.count--:s.stateNode&&(s=s.stateNode,s.parentNode.removeChild(s));break;case 27:ut||En(s,r);var l=Ke,u=Ut;zi(s.type)&&(Ke=s.stateNode,Ut=!1),Zn(t,r,s),io(s.stateNode),Ke=l,Ut=u;break;case 5:ut||En(s,r);case 6:if(l=Ke,u=Ut,Ke=null,Zn(t,r,s),Ke=l,Ut=u,Ke!==null)if(Ut)try{(Ke.nodeType===9?Ke.body:Ke.nodeName==="HTML"?Ke.ownerDocument.body:Ke).removeChild(s.stateNode)}catch(p){De(s,r,p)}else try{Ke.removeChild(s.stateNode)}catch(p){De(s,r,p)}break;case 18:Ke!==null&&(Ut?(t=Ke,Fy(t.nodeType===9?t.body:t.nodeName==="HTML"?t.ownerDocument.body:t,s.stateNode),Ua(t)):Fy(Ke,s.stateNode));break;case 4:l=Ke,u=Ut,Ke=s.stateNode.containerInfo,Ut=!0,Zn(t,r,s),Ke=l,Ut=u;break;case 0:case 11:case 14:case 15:Ri(2,s,r),ut||Ri(4,s,r),Zn(t,r,s);break;case 1:ut||(En(s,r),l=s.stateNode,typeof l.componentWillUnmount=="function"&&q0(s,r,l)),Zn(t,r,s);break;case 21:Zn(t,r,s);break;case 22:ut=(l=ut)||s.memoizedState!==null,Zn(t,r,s),ut=l;break;default:Zn(t,r,s)}}function X0(t,r){if(r.memoizedState===null&&(t=r.alternate,t!==null&&(t=t.memoizedState,t!==null))){t=t.dehydrated;try{Ua(t)}catch(s){De(r,r.return,s)}}}function $0(t,r){if(r.memoizedState===null&&(t=r.alternate,t!==null&&(t=t.memoizedState,t!==null&&(t=t.dehydrated,t!==null))))try{Ua(t)}catch(s){De(r,r.return,s)}}function Q2(t){switch(t.tag){case 31:case 13:case 19:var r=t.stateNode;return r===null&&(r=t.stateNode=new V0),r;case 22:return t=t.stateNode,r=t._retryCache,r===null&&(r=t._retryCache=new V0),r;default:throw Error(a(435,t.tag))}}function Zl(t,r){var s=Q2(t);r.forEach(function(l){if(!s.has(l)){s.add(l);var u=rC.bind(null,t,l);l.then(u,u)}})}function Bt(t,r){var s=r.deletions;if(s!==null)for(var l=0;l<s.length;l++){var u=s[l],p=t,g=r,w=g;e:for(;w!==null;){switch(w.tag){case 27:if(zi(w.type)){Ke=w.stateNode,Ut=!1;break e}break;case 5:Ke=w.stateNode,Ut=!1;break e;case 3:case 4:Ke=w.stateNode.containerInfo,Ut=!0;break e}w=w.return}if(Ke===null)throw Error(a(160));Q0(p,g,u),Ke=null,Ut=!1,p=u.alternate,p!==null&&(p.return=null),u.return=null}if(r.subtreeFlags&13886)for(r=r.child;r!==null;)Z0(r,t),r=r.sibling}var xn=null;function Z0(t,r){var s=t.alternate,l=t.flags;switch(t.tag){case 0:case 11:case 14:case 15:Bt(r,t),zt(t),l&4&&(Ri(3,t,t.return),Ws(3,t),Ri(5,t,t.return));break;case 1:Bt(r,t),zt(t),l&512&&(ut||s===null||En(s,s.return)),l&64&&$n&&(t=t.updateQueue,t!==null&&(l=t.callbacks,l!==null&&(s=t.shared.hiddenCallbacks,t.shared.hiddenCallbacks=s===null?l:s.concat(l))));break;case 26:var u=xn;if(Bt(r,t),zt(t),l&512&&(ut||s===null||En(s,s.return)),l&4){var p=s!==null?s.memoizedState:null;if(l=t.memoizedState,s===null)if(l===null)if(t.stateNode===null){e:{l=t.type,s=t.memoizedProps,u=u.ownerDocument||u;t:switch(l){case"title":p=u.getElementsByTagName("title")[0],(!p||p[ws]||p[bt]||p.namespaceURI==="http://www.w3.org/2000/svg"||p.hasAttribute("itemprop"))&&(p=u.createElement(l),u.head.insertBefore(p,u.querySelector("head > title"))),Ot(p,l,s),p[bt]=t,ft(p),l=p;break e;case"link":var g=Zy("link","href",u).get(l+(s.href||""));if(g){for(var w=0;w<g.length;w++)if(p=g[w],p.getAttribute("href")===(s.href==null||s.href===""?null:s.href)&&p.getAttribute("rel")===(s.rel==null?null:s.rel)&&p.getAttribute("title")===(s.title==null?null:s.title)&&p.getAttribute("crossorigin")===(s.crossOrigin==null?null:s.crossOrigin)){g.splice(w,1);break t}}p=u.createElement(l),Ot(p,l,s),u.head.appendChild(p);break;case"meta":if(g=Zy("meta","content",u).get(l+(s.content||""))){for(w=0;w<g.length;w++)if(p=g[w],p.getAttribute("content")===(s.content==null?null:""+s.content)&&p.getAttribute("name")===(s.name==null?null:s.name)&&p.getAttribute("property")===(s.property==null?null:s.property)&&p.getAttribute("http-equiv")===(s.httpEquiv==null?null:s.httpEquiv)&&p.getAttribute("charset")===(s.charSet==null?null:s.charSet)){g.splice(w,1);break t}}p=u.createElement(l),Ot(p,l,s),u.head.appendChild(p);break;default:throw Error(a(468,l))}p[bt]=t,ft(p),l=p}t.stateNode=l}else Jy(u,t.type,t.stateNode);else t.stateNode=$y(u,l,t.memoizedProps);else p!==l?(p===null?s.stateNode!==null&&(s=s.stateNode,s.parentNode.removeChild(s)):p.count--,l===null?Jy(u,t.type,t.stateNode):$y(u,l,t.memoizedProps)):l===null&&t.stateNode!==null&&dp(t,t.memoizedProps,s.memoizedProps)}break;case 27:Bt(r,t),zt(t),l&512&&(ut||s===null||En(s,s.return)),s!==null&&l&4&&dp(t,t.memoizedProps,s.memoizedProps);break;case 5:if(Bt(r,t),zt(t),l&512&&(ut||s===null||En(s,s.return)),t.flags&32){u=t.stateNode;try{oa(u,"")}catch(Q){De(t,t.return,Q)}}l&4&&t.stateNode!=null&&(u=t.memoizedProps,dp(t,u,s!==null?s.memoizedProps:u)),l&1024&&(fp=!0);break;case 6:if(Bt(r,t),zt(t),l&4){if(t.stateNode===null)throw Error(a(162));l=t.memoizedProps,s=t.stateNode;try{s.nodeValue=l}catch(Q){De(t,t.return,Q)}}break;case 3:if(fc=null,u=xn,xn=pc(r.containerInfo),Bt(r,t),xn=u,zt(t),l&4&&s!==null&&s.memoizedState.isDehydrated)try{Ua(r.containerInfo)}catch(Q){De(t,t.return,Q)}fp&&(fp=!1,J0(t));break;case 4:l=xn,xn=pc(t.stateNode.containerInfo),Bt(r,t),zt(t),xn=l;break;case 12:Bt(r,t),zt(t);break;case 31:Bt(r,t),zt(t),l&4&&(l=t.updateQueue,l!==null&&(t.updateQueue=null,Zl(t,l)));break;case 13:Bt(r,t),zt(t),t.child.flags&8192&&t.memoizedState!==null!=(s!==null&&s.memoizedState!==null)&&(ec=kt()),l&4&&(l=t.updateQueue,l!==null&&(t.updateQueue=null,Zl(t,l)));break;case 22:u=t.memoizedState!==null;var C=s!==null&&s.memoizedState!==null,j=$n,P=ut;if($n=j||u,ut=P||C,Bt(r,t),ut=P,$n=j,zt(t),l&8192)e:for(r=t.stateNode,r._visibility=u?r._visibility&-2:r._visibility|1,u&&(s===null||C||$n||ut||Er(t)),s=null,r=t;;){if(r.tag===5||r.tag===26){if(s===null){C=s=r;try{if(p=C.stateNode,u)g=p.style,typeof g.setProperty=="function"?g.setProperty("display","none","important"):g.display="none";else{w=C.stateNode;var B=C.memoizedProps.style,A=B!=null&&B.hasOwnProperty("display")?B.display:null;w.style.display=A==null||typeof A=="boolean"?"":(""+A).trim()}}catch(Q){De(C,C.return,Q)}}}else if(r.tag===6){if(s===null){C=r;try{C.stateNode.nodeValue=u?"":C.memoizedProps}catch(Q){De(C,C.return,Q)}}}else if(r.tag===18){if(s===null){C=r;try{var R=C.stateNode;u?qy(R,!0):qy(C.stateNode,!1)}catch(Q){De(C,C.return,Q)}}}else if((r.tag!==22&&r.tag!==23||r.memoizedState===null||r===t)&&r.child!==null){r.child.return=r,r=r.child;continue}if(r===t)break e;for(;r.sibling===null;){if(r.return===null||r.return===t)break e;s===r&&(s=null),r=r.return}s===r&&(s=null),r.sibling.return=r.return,r=r.sibling}l&4&&(l=t.updateQueue,l!==null&&(s=l.retryQueue,s!==null&&(l.retryQueue=null,Zl(t,s))));break;case 19:Bt(r,t),zt(t),l&4&&(l=t.updateQueue,l!==null&&(t.updateQueue=null,Zl(t,l)));break;case 30:break;case 21:break;default:Bt(r,t),zt(t)}}function zt(t){var r=t.flags;if(r&2){try{for(var s,l=t.return;l!==null;){if(Y0(l)){s=l;break}l=l.return}if(s==null)throw Error(a(160));switch(s.tag){case 27:var u=s.stateNode,p=pp(t);$l(t,p,u);break;case 5:var g=s.stateNode;s.flags&32&&(oa(g,""),s.flags&=-33);var w=pp(t);$l(t,w,g);break;case 3:case 4:var C=s.stateNode.containerInfo,j=pp(t);mp(t,j,C);break;default:throw Error(a(161))}}catch(P){De(t,t.return,P)}t.flags&=-3}r&4096&&(t.flags&=-4097)}function J0(t){if(t.subtreeFlags&1024)for(t=t.child;t!==null;){var r=t;J0(r),r.tag===5&&r.flags&1024&&r.stateNode.reset(),t=t.sibling}}function Jn(t,r){if(r.subtreeFlags&8772)for(r=r.child;r!==null;)W0(t,r.alternate,r),r=r.sibling}function Er(t){for(t=t.child;t!==null;){var r=t;switch(r.tag){case 0:case 11:case 14:case 15:Ri(4,r,r.return),Er(r);break;case 1:En(r,r.return);var s=r.stateNode;typeof s.componentWillUnmount=="function"&&q0(r,r.return,s),Er(r);break;case 27:io(r.stateNode);case 26:case 5:En(r,r.return),Er(r);break;case 22:r.memoizedState===null&&Er(r);break;case 30:Er(r);break;default:Er(r)}t=t.sibling}}function ei(t,r,s){for(s=s&&(r.subtreeFlags&8772)!==0,r=r.child;r!==null;){var l=r.alternate,u=t,p=r,g=p.flags;switch(p.tag){case 0:case 11:case 15:ei(u,p,s),Ws(4,p);break;case 1:if(ei(u,p,s),l=p,u=l.stateNode,typeof u.componentDidMount=="function")try{u.componentDidMount()}catch(j){De(l,l.return,j)}if(l=p,u=l.updateQueue,u!==null){var w=l.stateNode;try{var C=u.shared.hiddenCallbacks;if(C!==null)for(u.shared.hiddenCallbacks=null,u=0;u<C.length;u++)jg(C[u],w)}catch(j){De(l,l.return,j)}}s&&g&64&&F0(p),Ks(p,p.return);break;case 27:G0(p);case 26:case 5:ei(u,p,s),s&&l===null&&g&4&&H0(p),Ks(p,p.return);break;case 12:ei(u,p,s);break;case 31:ei(u,p,s),s&&g&4&&X0(u,p);break;case 13:ei(u,p,s),s&&g&4&&$0(u,p);break;case 22:p.memoizedState===null&&ei(u,p,s),Ks(p,p.return);break;case 30:break;default:ei(u,p,s)}r=r.sibling}}function hp(t,r){var s=null;t!==null&&t.memoizedState!==null&&t.memoizedState.cachePool!==null&&(s=t.memoizedState.cachePool.pool),t=null,r.memoizedState!==null&&r.memoizedState.cachePool!==null&&(t=r.memoizedState.cachePool.pool),t!==s&&(t!=null&&t.refCount++,s!=null&&Ds(s))}function gp(t,r){t=null,r.alternate!==null&&(t=r.alternate.memoizedState.cache),r=r.memoizedState.cache,r!==t&&(r.refCount++,t!=null&&Ds(t))}function bn(t,r,s,l){if(r.subtreeFlags&10256)for(r=r.child;r!==null;)ey(t,r,s,l),r=r.sibling}function ey(t,r,s,l){var u=r.flags;switch(r.tag){case 0:case 11:case 15:bn(t,r,s,l),u&2048&&Ws(9,r);break;case 1:bn(t,r,s,l);break;case 3:bn(t,r,s,l),u&2048&&(t=null,r.alternate!==null&&(t=r.alternate.memoizedState.cache),r=r.memoizedState.cache,r!==t&&(r.refCount++,t!=null&&Ds(t)));break;case 12:if(u&2048){bn(t,r,s,l),t=r.stateNode;try{var p=r.memoizedProps,g=p.id,w=p.onPostCommit;typeof w=="function"&&w(g,r.alternate===null?"mount":"update",t.passiveEffectDuration,-0)}catch(C){De(r,r.return,C)}}else bn(t,r,s,l);break;case 31:bn(t,r,s,l);break;case 13:bn(t,r,s,l);break;case 23:break;case 22:p=r.stateNode,g=r.alternate,r.memoizedState!==null?p._visibility&2?bn(t,r,s,l):Qs(t,r):p._visibility&2?bn(t,r,s,l):(p._visibility|=2,ka(t,r,s,l,(r.subtreeFlags&10256)!==0||!1)),u&2048&&hp(g,r);break;case 24:bn(t,r,s,l),u&2048&&gp(r.alternate,r);break;default:bn(t,r,s,l)}}function ka(t,r,s,l,u){for(u=u&&((r.subtreeFlags&10256)!==0||!1),r=r.child;r!==null;){var p=t,g=r,w=s,C=l,j=g.flags;switch(g.tag){case 0:case 11:case 15:ka(p,g,w,C,u),Ws(8,g);break;case 23:break;case 22:var P=g.stateNode;g.memoizedState!==null?P._visibility&2?ka(p,g,w,C,u):Qs(p,g):(P._visibility|=2,ka(p,g,w,C,u)),u&&j&2048&&hp(g.alternate,g);break;case 24:ka(p,g,w,C,u),u&&j&2048&&gp(g.alternate,g);break;default:ka(p,g,w,C,u)}r=r.sibling}}function Qs(t,r){if(r.subtreeFlags&10256)for(r=r.child;r!==null;){var s=t,l=r,u=l.flags;switch(l.tag){case 22:Qs(s,l),u&2048&&hp(l.alternate,l);break;case 24:Qs(s,l),u&2048&&gp(l.alternate,l);break;default:Qs(s,l)}r=r.sibling}}var Xs=8192;function Na(t,r,s){if(t.subtreeFlags&Xs)for(t=t.child;t!==null;)ty(t,r,s),t=t.sibling}function ty(t,r,s){switch(t.tag){case 26:Na(t,r,s),t.flags&Xs&&t.memoizedState!==null&&IC(s,xn,t.memoizedState,t.memoizedProps);break;case 5:Na(t,r,s);break;case 3:case 4:var l=xn;xn=pc(t.stateNode.containerInfo),Na(t,r,s),xn=l;break;case 22:t.memoizedState===null&&(l=t.alternate,l!==null&&l.memoizedState!==null?(l=Xs,Xs=16777216,Na(t,r,s),Xs=l):Na(t,r,s));break;default:Na(t,r,s)}}function ny(t){var r=t.alternate;if(r!==null&&(t=r.child,t!==null)){r.child=null;do r=t.sibling,t.sibling=null,t=r;while(t!==null)}}function $s(t){var r=t.deletions;if((t.flags&16)!==0){if(r!==null)for(var s=0;s<r.length;s++){var l=r[s];ht=l,ry(l,t)}ny(t)}if(t.subtreeFlags&10256)for(t=t.child;t!==null;)iy(t),t=t.sibling}function iy(t){switch(t.tag){case 0:case 11:case 15:$s(t),t.flags&2048&&Ri(9,t,t.return);break;case 3:$s(t);break;case 12:$s(t);break;case 22:var r=t.stateNode;t.memoizedState!==null&&r._visibility&2&&(t.return===null||t.return.tag!==13)?(r._visibility&=-3,Jl(t)):$s(t);break;default:$s(t)}}function Jl(t){var r=t.deletions;if((t.flags&16)!==0){if(r!==null)for(var s=0;s<r.length;s++){var l=r[s];ht=l,ry(l,t)}ny(t)}for(t=t.child;t!==null;){switch(r=t,r.tag){case 0:case 11:case 15:Ri(8,r,r.return),Jl(r);break;case 22:s=r.stateNode,s._visibility&2&&(s._visibility&=-3,Jl(r));break;default:Jl(r)}t=t.sibling}}function ry(t,r){for(;ht!==null;){var s=ht;switch(s.tag){case 0:case 11:case 15:Ri(8,s,r);break;case 23:case 22:if(s.memoizedState!==null&&s.memoizedState.cachePool!==null){var l=s.memoizedState.cachePool.pool;l!=null&&l.refCount++}break;case 24:Ds(s.memoizedState.cache)}if(l=s.child,l!==null)l.return=s,ht=l;else e:for(s=t;ht!==null;){l=ht;var u=l.sibling,p=l.return;if(K0(l),l===s){ht=null;break e}if(u!==null){u.return=p,ht=u;break e}ht=p}}}var X2={getCacheForType:function(t){var r=St(ot),s=r.data.get(t);return s===void 0&&(s=t(),r.data.set(t,s)),s},cacheSignal:function(){return St(ot).controller.signal}},$2=typeof WeakMap=="function"?WeakMap:Map,Ae=0,ze=null,xe=null,we=0,Re=0,$t=null,Di=!1,Ea=!1,yp=!1,ti=0,Je=0,Ii=0,jr=0,vp=0,Zt=0,ja=0,Zs=null,Ft=null,xp=!1,ec=0,ay=0,tc=1/0,nc=null,Pi=null,pt=0,Li=null,Aa=null,ni=0,bp=0,wp=null,sy=null,Js=0,Sp=null;function Jt(){return(Ae&2)!==0&&we!==0?we&-we:M.T!==null?Np():Sh()}function oy(){if(Zt===0)if((we&536870912)===0||Oe){var t=ul;ul<<=1,(ul&3932160)===0&&(ul=262144),Zt=t}else Zt=536870912;return t=Qt.current,t!==null&&(t.flags|=32),Zt}function qt(t,r,s){(t===ze&&(Re===2||Re===9)||t.cancelPendingCommit!==null)&&(Ma(t,0),Ui(t,we,Zt,!1)),bs(t,s),((Ae&2)===0||t!==ze)&&(t===ze&&((Ae&2)===0&&(jr|=s),Je===4&&Ui(t,we,Zt,!1)),jn(t))}function ly(t,r,s){if((Ae&6)!==0)throw Error(a(327));var l=!s&&(r&127)===0&&(r&t.expiredLanes)===0||xs(t,r),u=l?eC(t,r):Op(t,r,!0),p=l;do{if(u===0){Ea&&!l&&Ui(t,r,0,!1);break}else{if(s=t.current.alternate,p&&!Z2(s)){u=Op(t,r,!1),p=!1;continue}if(u===2){if(p=r,t.errorRecoveryDisabledLanes&p)var g=0;else g=t.pendingLanes&-536870913,g=g!==0?g:g&536870912?536870912:0;if(g!==0){r=g;e:{var w=t;u=Zs;var C=w.current.memoizedState.isDehydrated;if(C&&(Ma(w,g).flags|=256),g=Op(w,g,!1),g!==2){if(yp&&!C){w.errorRecoveryDisabledLanes|=p,jr|=p,u=4;break e}p=Ft,Ft=u,p!==null&&(Ft===null?Ft=p:Ft.push.apply(Ft,p))}u=g}if(p=!1,u!==2)continue}}if(u===1){Ma(t,0),Ui(t,r,0,!0);break}e:{switch(l=t,p=u,p){case 0:case 1:throw Error(a(345));case 4:if((r&4194048)!==r)break;case 6:Ui(l,r,Zt,!Di);break e;case 2:Ft=null;break;case 3:case 5:break;default:throw Error(a(329))}if((r&62914560)===r&&(u=ec+300-kt(),10<u)){if(Ui(l,r,Zt,!Di),pl(l,0,!0)!==0)break e;ni=r,l.timeoutHandle=By(cy.bind(null,l,s,Ft,nc,xp,r,Zt,jr,ja,Di,p,"Throttled",-0,0),u);break e}cy(l,s,Ft,nc,xp,r,Zt,jr,ja,Di,p,null,-0,0)}}break}while(!0);jn(t)}function cy(t,r,s,l,u,p,g,w,C,j,P,B,A,R){if(t.timeoutHandle=-1,B=r.subtreeFlags,B&8192||(B&16785408)===16785408){B={stylesheets:null,count:0,imgCount:0,imgBytes:0,suspenseyImages:[],waitingForImages:!0,waitingForViewTransition:!1,unsuspend:Fn},ty(r,p,B);var Q=(p&62914560)===p?ec-kt():(p&4194048)===p?ay-kt():0;if(Q=PC(B,Q),Q!==null){ni=p,t.cancelPendingCommit=Q(yy.bind(null,t,r,p,s,l,u,g,w,C,P,B,null,A,R)),Ui(t,p,g,!j);return}}yy(t,r,p,s,l,u,g,w,C)}function Z2(t){for(var r=t;;){var s=r.tag;if((s===0||s===11||s===15)&&r.flags&16384&&(s=r.updateQueue,s!==null&&(s=s.stores,s!==null)))for(var l=0;l<s.length;l++){var u=s[l],p=u.getSnapshot;u=u.value;try{if(!Wt(p(),u))return!1}catch{return!1}}if(s=r.child,r.subtreeFlags&16384&&s!==null)s.return=r,r=s;else{if(r===t)break;for(;r.sibling===null;){if(r.return===null||r.return===t)return!0;r=r.return}r.sibling.return=r.return,r=r.sibling}}return!0}function Ui(t,r,s,l){r&=~vp,r&=~jr,t.suspendedLanes|=r,t.pingedLanes&=~r,l&&(t.warmLanes|=r),l=t.expirationTimes;for(var u=r;0<u;){var p=31-Vt(u),g=1<<p;l[p]=-1,u&=~g}s!==0&&xh(t,s,r)}function ic(){return(Ae&6)===0?(eo(0),!1):!0}function Cp(){if(xe!==null){if(Re===0)var t=xe.return;else t=xe,Gn=wr=null,Bd(t),Sa=null,Ps=0,t=xe;for(;t!==null;)z0(t.alternate,t),t=t.return;xe=null}}function Ma(t,r){var s=t.timeoutHandle;s!==-1&&(t.timeoutHandle=-1,vC(s)),s=t.cancelPendingCommit,s!==null&&(t.cancelPendingCommit=null,s()),ni=0,Cp(),ze=t,xe=s=Hn(t.current,null),we=r,Re=0,$t=null,Di=!1,Ea=xs(t,r),yp=!1,ja=Zt=vp=jr=Ii=Je=0,Ft=Zs=null,xp=!1,(r&8)!==0&&(r|=r&32);var l=t.entangledLanes;if(l!==0)for(t=t.entanglements,l&=r;0<l;){var u=31-Vt(l),p=1<<u;r|=t[u],l&=~p}return ti=r,Ol(),s}function uy(t,r){ue=null,M.H=Ys,r===wa||r===Ml?(r=Tg(),Re=3):r===kd?(r=Tg(),Re=4):Re=r===tp?8:r!==null&&typeof r=="object"&&typeof r.then=="function"?6:1,$t=r,xe===null&&(Je=1,Vl(t,on(r,t.current)))}function dy(){var t=Qt.current;return t===null?!0:(we&4194048)===we?dn===null:(we&62914560)===we||(we&536870912)!==0?t===dn:!1}function py(){var t=M.H;return M.H=Ys,t===null?Ys:t}function my(){var t=M.A;return M.A=X2,t}function rc(){Je=4,Di||(we&4194048)!==we&&Qt.current!==null||(Ea=!0),(Ii&134217727)===0&&(jr&134217727)===0||ze===null||Ui(ze,we,Zt,!1)}function Op(t,r,s){var l=Ae;Ae|=2;var u=py(),p=my();(ze!==t||we!==r)&&(nc=null,Ma(t,r)),r=!1;var g=Je;e:do try{if(Re!==0&&xe!==null){var w=xe,C=$t;switch(Re){case 8:Cp(),g=6;break e;case 3:case 2:case 9:case 6:Qt.current===null&&(r=!0);var j=Re;if(Re=0,$t=null,Ra(t,w,C,j),s&&Ea){g=0;break e}break;default:j=Re,Re=0,$t=null,Ra(t,w,C,j)}}J2(),g=Je;break}catch(P){uy(t,P)}while(!0);return r&&t.shellSuspendCounter++,Gn=wr=null,Ae=l,M.H=u,M.A=p,xe===null&&(ze=null,we=0,Ol()),g}function J2(){for(;xe!==null;)fy(xe)}function eC(t,r){var s=Ae;Ae|=2;var l=py(),u=my();ze!==t||we!==r?(nc=null,tc=kt()+500,Ma(t,r)):Ea=xs(t,r);e:do try{if(Re!==0&&xe!==null){r=xe;var p=$t;t:switch(Re){case 1:Re=0,$t=null,Ra(t,r,p,1);break;case 2:case 9:if(Og(p)){Re=0,$t=null,hy(r);break}r=function(){Re!==2&&Re!==9||ze!==t||(Re=7),jn(t)},p.then(r,r);break e;case 3:Re=7;break e;case 4:Re=5;break e;case 7:Og(p)?(Re=0,$t=null,hy(r)):(Re=0,$t=null,Ra(t,r,p,7));break;case 5:var g=null;switch(xe.tag){case 26:g=xe.memoizedState;case 5:case 27:var w=xe;if(g?e1(g):w.stateNode.complete){Re=0,$t=null;var C=w.sibling;if(C!==null)xe=C;else{var j=w.return;j!==null?(xe=j,ac(j)):xe=null}break t}}Re=0,$t=null,Ra(t,r,p,5);break;case 6:Re=0,$t=null,Ra(t,r,p,6);break;case 8:Cp(),Je=6;break e;default:throw Error(a(462))}}tC();break}catch(P){uy(t,P)}while(!0);return Gn=wr=null,M.H=l,M.A=u,Ae=s,xe!==null?0:(ze=null,we=0,Ol(),Je)}function tC(){for(;xe!==null&&!It();)fy(xe)}function fy(t){var r=U0(t.alternate,t,ti);t.memoizedProps=t.pendingProps,r===null?ac(t):xe=r}function hy(t){var r=t,s=r.alternate;switch(r.tag){case 15:case 0:r=M0(s,r,r.pendingProps,r.type,void 0,we);break;case 11:r=M0(s,r,r.pendingProps,r.type.render,r.ref,we);break;case 5:Bd(r);default:z0(s,r),r=xe=mg(r,ti),r=U0(s,r,ti)}t.memoizedProps=t.pendingProps,r===null?ac(t):xe=r}function Ra(t,r,s,l){Gn=wr=null,Bd(r),Sa=null,Ps=0;var u=r.return;try{if(H2(t,u,r,s,we)){Je=1,Vl(t,on(s,t.current)),xe=null;return}}catch(p){if(u!==null)throw xe=u,p;Je=1,Vl(t,on(s,t.current)),xe=null;return}r.flags&32768?(Oe||l===1?t=!0:Ea||(we&536870912)!==0?t=!1:(Di=t=!0,(l===2||l===9||l===3||l===6)&&(l=Qt.current,l!==null&&l.tag===13&&(l.flags|=16384))),gy(r,t)):ac(r)}function ac(t){var r=t;do{if((r.flags&32768)!==0){gy(r,Di);return}t=r.return;var s=V2(r.alternate,r,ti);if(s!==null){xe=s;return}if(r=r.sibling,r!==null){xe=r;return}xe=r=t}while(r!==null);Je===0&&(Je=5)}function gy(t,r){do{var s=W2(t.alternate,t);if(s!==null){s.flags&=32767,xe=s;return}if(s=t.return,s!==null&&(s.flags|=32768,s.subtreeFlags=0,s.deletions=null),!r&&(t=t.sibling,t!==null)){xe=t;return}xe=t=s}while(t!==null);Je=6,xe=null}function yy(t,r,s,l,u,p,g,w,C){t.cancelPendingCommit=null;do sc();while(pt!==0);if((Ae&6)!==0)throw Error(a(327));if(r!==null){if(r===t.current)throw Error(a(177));if(p=r.lanes|r.childLanes,p|=pd,DS(t,s,p,g,w,C),t===ze&&(xe=ze=null,we=0),Aa=r,Li=t,ni=s,bp=p,wp=u,sy=l,(r.subtreeFlags&10256)!==0||(r.flags&10256)!==0?(t.callbackNode=null,t.callbackPriority=0,aC(ea,function(){return Sy(),null})):(t.callbackNode=null,t.callbackPriority=0),l=(r.flags&13878)!==0,(r.subtreeFlags&13878)!==0||l){l=M.T,M.T=null,u=V.p,V.p=2,g=Ae,Ae|=4;try{K2(t,r,s)}finally{Ae=g,V.p=u,M.T=l}}pt=1,vy(),xy(),by()}}function vy(){if(pt===1){pt=0;var t=Li,r=Aa,s=(r.flags&13878)!==0;if((r.subtreeFlags&13878)!==0||s){s=M.T,M.T=null;var l=V.p;V.p=2;var u=Ae;Ae|=4;try{Z0(r,t);var p=Pp,g=rg(t.containerInfo),w=p.focusedElem,C=p.selectionRange;if(g!==w&&w&&w.ownerDocument&&ig(w.ownerDocument.documentElement,w)){if(C!==null&&od(w)){var j=C.start,P=C.end;if(P===void 0&&(P=j),"selectionStart"in w)w.selectionStart=j,w.selectionEnd=Math.min(P,w.value.length);else{var B=w.ownerDocument||document,A=B&&B.defaultView||window;if(A.getSelection){var R=A.getSelection(),Q=w.textContent.length,ie=Math.min(C.start,Q),Ue=C.end===void 0?ie:Math.min(C.end,Q);!R.extend&&ie>Ue&&(g=Ue,Ue=ie,ie=g);var k=ng(w,ie),T=ng(w,Ue);if(k&&T&&(R.rangeCount!==1||R.anchorNode!==k.node||R.anchorOffset!==k.offset||R.focusNode!==T.node||R.focusOffset!==T.offset)){var E=B.createRange();E.setStart(k.node,k.offset),R.removeAllRanges(),ie>Ue?(R.addRange(E),R.extend(T.node,T.offset)):(E.setEnd(T.node,T.offset),R.addRange(E))}}}}for(B=[],R=w;R=R.parentNode;)R.nodeType===1&&B.push({element:R,left:R.scrollLeft,top:R.scrollTop});for(typeof w.focus=="function"&&w.focus(),w=0;w<B.length;w++){var U=B[w];U.element.scrollLeft=U.left,U.element.scrollTop=U.top}}vc=!!Ip,Pp=Ip=null}finally{Ae=u,V.p=l,M.T=s}}t.current=r,pt=2}}function xy(){if(pt===2){pt=0;var t=Li,r=Aa,s=(r.flags&8772)!==0;if((r.subtreeFlags&8772)!==0||s){s=M.T,M.T=null;var l=V.p;V.p=2;var u=Ae;Ae|=4;try{W0(t,r.alternate,r)}finally{Ae=u,V.p=l,M.T=s}}pt=3}}function by(){if(pt===4||pt===3){pt=0,Jr();var t=Li,r=Aa,s=ni,l=sy;(r.subtreeFlags&10256)!==0||(r.flags&10256)!==0?pt=5:(pt=0,Aa=Li=null,wy(t,t.pendingLanes));var u=t.pendingLanes;if(u===0&&(Pi=null),qu(s),r=r.stateNode,Gt&&typeof Gt.onCommitFiberRoot=="function")try{Gt.onCommitFiberRoot(vs,r,void 0,(r.current.flags&128)===128)}catch{}if(l!==null){r=M.T,u=V.p,V.p=2,M.T=null;try{for(var p=t.onRecoverableError,g=0;g<l.length;g++){var w=l[g];p(w.value,{componentStack:w.stack})}}finally{M.T=r,V.p=u}}(ni&3)!==0&&sc(),jn(t),u=t.pendingLanes,(s&261930)!==0&&(u&42)!==0?t===Sp?Js++:(Js=0,Sp=t):Js=0,eo(0)}}function wy(t,r){(t.pooledCacheLanes&=r)===0&&(r=t.pooledCache,r!=null&&(t.pooledCache=null,Ds(r)))}function sc(){return vy(),xy(),by(),Sy()}function Sy(){if(pt!==5)return!1;var t=Li,r=bp;bp=0;var s=qu(ni),l=M.T,u=V.p;try{V.p=32>s?32:s,M.T=null,s=wp,wp=null;var p=Li,g=ni;if(pt=0,Aa=Li=null,ni=0,(Ae&6)!==0)throw Error(a(331));var w=Ae;if(Ae|=4,iy(p.current),ey(p,p.current,g,s),Ae=w,eo(0,!1),Gt&&typeof Gt.onPostCommitFiberRoot=="function")try{Gt.onPostCommitFiberRoot(vs,p)}catch{}return!0}finally{V.p=u,M.T=l,wy(t,r)}}function Cy(t,r,s){r=on(s,r),r=ep(t.stateNode,r,2),t=ji(t,r,2),t!==null&&(bs(t,2),jn(t))}function De(t,r,s){if(t.tag===3)Cy(t,t,s);else for(;r!==null;){if(r.tag===3){Cy(r,t,s);break}else if(r.tag===1){var l=r.stateNode;if(typeof r.type.getDerivedStateFromError=="function"||typeof l.componentDidCatch=="function"&&(Pi===null||!Pi.has(l))){t=on(s,t),s=O0(2),l=ji(r,s,2),l!==null&&(_0(s,l,r,t),bs(l,2),jn(l));break}}r=r.return}}function _p(t,r,s){var l=t.pingCache;if(l===null){l=t.pingCache=new $2;var u=new Set;l.set(r,u)}else u=l.get(r),u===void 0&&(u=new Set,l.set(r,u));u.has(s)||(yp=!0,u.add(s),t=nC.bind(null,t,r,s),r.then(t,t))}function nC(t,r,s){var l=t.pingCache;l!==null&&l.delete(r),t.pingedLanes|=t.suspendedLanes&s,t.warmLanes&=~s,ze===t&&(we&s)===s&&(Je===4||Je===3&&(we&62914560)===we&&300>kt()-ec?(Ae&2)===0&&Ma(t,0):vp|=s,ja===we&&(ja=0)),jn(t)}function Oy(t,r){r===0&&(r=vh()),t=vr(t,r),t!==null&&(bs(t,r),jn(t))}function iC(t){var r=t.memoizedState,s=0;r!==null&&(s=r.retryLane),Oy(t,s)}function rC(t,r){var s=0;switch(t.tag){case 31:case 13:var l=t.stateNode,u=t.memoizedState;u!==null&&(s=u.retryLane);break;case 19:l=t.stateNode;break;case 22:l=t.stateNode._retryCache;break;default:throw Error(a(314))}l!==null&&l.delete(r),Oy(t,s)}function aC(t,r){return ne(t,r)}var oc=null,Da=null,Tp=!1,lc=!1,kp=!1,Bi=0;function jn(t){t!==Da&&t.next===null&&(Da===null?oc=Da=t:Da=Da.next=t),lc=!0,Tp||(Tp=!0,oC())}function eo(t,r){if(!kp&&lc){kp=!0;do for(var s=!1,l=oc;l!==null;){if(t!==0){var u=l.pendingLanes;if(u===0)var p=0;else{var g=l.suspendedLanes,w=l.pingedLanes;p=(1<<31-Vt(42|t)+1)-1,p&=u&~(g&~w),p=p&201326741?p&201326741|1:p?p|2:0}p!==0&&(s=!0,Ny(l,p))}else p=we,p=pl(l,l===ze?p:0,l.cancelPendingCommit!==null||l.timeoutHandle!==-1),(p&3)===0||xs(l,p)||(s=!0,Ny(l,p));l=l.next}while(s);kp=!1}}function sC(){_y()}function _y(){lc=Tp=!1;var t=0;Bi!==0&&yC()&&(t=Bi);for(var r=kt(),s=null,l=oc;l!==null;){var u=l.next,p=Ty(l,r);p===0?(l.next=null,s===null?oc=u:s.next=u,u===null&&(Da=s)):(s=l,(t!==0||(p&3)!==0)&&(lc=!0)),l=u}pt!==0&&pt!==5||eo(t),Bi!==0&&(Bi=0)}function Ty(t,r){for(var s=t.suspendedLanes,l=t.pingedLanes,u=t.expirationTimes,p=t.pendingLanes&-62914561;0<p;){var g=31-Vt(p),w=1<<g,C=u[g];C===-1?((w&s)===0||(w&l)!==0)&&(u[g]=RS(w,r)):C<=r&&(t.expiredLanes|=w),p&=~w}if(r=ze,s=we,s=pl(t,t===r?s:0,t.cancelPendingCommit!==null||t.timeoutHandle!==-1),l=t.callbackNode,s===0||t===r&&(Re===2||Re===9)||t.cancelPendingCommit!==null)return l!==null&&l!==null&&He(l),t.callbackNode=null,t.callbackPriority=0;if((s&3)===0||xs(t,s)){if(r=s&-s,r===t.callbackPriority)return r;switch(l!==null&&He(l),qu(s)){case 2:case 8:s=gs;break;case 32:s=ea;break;case 268435456:s=ys;break;default:s=ea}return l=ky.bind(null,t),s=ne(s,l),t.callbackPriority=r,t.callbackNode=s,r}return l!==null&&l!==null&&He(l),t.callbackPriority=2,t.callbackNode=null,2}function ky(t,r){if(pt!==0&&pt!==5)return t.callbackNode=null,t.callbackPriority=0,null;var s=t.callbackNode;if(sc()&&t.callbackNode!==s)return null;var l=we;return l=pl(t,t===ze?l:0,t.cancelPendingCommit!==null||t.timeoutHandle!==-1),l===0?null:(ly(t,l,r),Ty(t,kt()),t.callbackNode!=null&&t.callbackNode===s?ky.bind(null,t):null)}function Ny(t,r){if(sc())return null;ly(t,r,!0)}function oC(){xC(function(){(Ae&6)!==0?ne(ll,sC):_y()})}function Np(){if(Bi===0){var t=xa;t===0&&(t=cl,cl<<=1,(cl&261888)===0&&(cl=256)),Bi=t}return Bi}function Ey(t){return t==null||typeof t=="symbol"||typeof t=="boolean"?null:typeof t=="function"?t:gl(""+t)}function jy(t,r){var s=r.ownerDocument.createElement("input");return s.name=r.name,s.value=r.value,t.id&&s.setAttribute("form",t.id),r.parentNode.insertBefore(s,r),t=new FormData(t),s.parentNode.removeChild(s),t}function lC(t,r,s,l,u){if(r==="submit"&&s&&s.stateNode===u){var p=Ey((u[Pt]||null).action),g=l.submitter;g&&(r=(r=g[Pt]||null)?Ey(r.formAction):g.getAttribute("formAction"),r!==null&&(p=r,g=null));var w=new bl("action","action",null,l,u);t.push({event:w,listeners:[{instance:null,listener:function(){if(l.defaultPrevented){if(Bi!==0){var C=g?jy(u,g):new FormData(u);Kd(s,{pending:!0,data:C,method:u.method,action:p},null,C)}}else typeof p=="function"&&(w.preventDefault(),C=g?jy(u,g):new FormData(u),Kd(s,{pending:!0,data:C,method:u.method,action:p},p,C))},currentTarget:u}]})}}for(var Ep=0;Ep<dd.length;Ep++){var jp=dd[Ep],cC=jp.toLowerCase(),uC=jp[0].toUpperCase()+jp.slice(1);vn(cC,"on"+uC)}vn(og,"onAnimationEnd"),vn(lg,"onAnimationIteration"),vn(cg,"onAnimationStart"),vn("dblclick","onDoubleClick"),vn("focusin","onFocus"),vn("focusout","onBlur"),vn(T2,"onTransitionRun"),vn(k2,"onTransitionStart"),vn(N2,"onTransitionCancel"),vn(ug,"onTransitionEnd"),aa("onMouseEnter",["mouseout","mouseover"]),aa("onMouseLeave",["mouseout","mouseover"]),aa("onPointerEnter",["pointerout","pointerover"]),aa("onPointerLeave",["pointerout","pointerover"]),fr("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),fr("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),fr("onBeforeInput",["compositionend","keypress","textInput","paste"]),fr("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),fr("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),fr("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var to="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),dC=new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(to));function Ay(t,r){r=(r&4)!==0;for(var s=0;s<t.length;s++){var l=t[s],u=l.event;l=l.listeners;e:{var p=void 0;if(r)for(var g=l.length-1;0<=g;g--){var w=l[g],C=w.instance,j=w.currentTarget;if(w=w.listener,C!==p&&u.isPropagationStopped())break e;p=w,u.currentTarget=j;try{p(u)}catch(P){Cl(P)}u.currentTarget=null,p=C}else for(g=0;g<l.length;g++){if(w=l[g],C=w.instance,j=w.currentTarget,w=w.listener,C!==p&&u.isPropagationStopped())break e;p=w,u.currentTarget=j;try{p(u)}catch(P){Cl(P)}u.currentTarget=null,p=C}}}}function be(t,r){var s=r[Hu];s===void 0&&(s=r[Hu]=new Set);var l=t+"__bubble";s.has(l)||(My(r,t,2,!1),s.add(l))}function Ap(t,r,s){var l=0;r&&(l|=4),My(s,t,l,r)}var cc="_reactListening"+Math.random().toString(36).slice(2);function Mp(t){if(!t[cc]){t[cc]=!0,_h.forEach(function(s){s!=="selectionchange"&&(dC.has(s)||Ap(s,!1,t),Ap(s,!0,t))});var r=t.nodeType===9?t:t.ownerDocument;r===null||r[cc]||(r[cc]=!0,Ap("selectionchange",!1,r))}}function My(t,r,s,l){switch(o1(r)){case 2:var u=BC;break;case 8:u=zC;break;default:u=Wp}s=u.bind(null,r,s,t),u=void 0,!Zu||r!=="touchstart"&&r!=="touchmove"&&r!=="wheel"||(u=!0),l?u!==void 0?t.addEventListener(r,s,{capture:!0,passive:u}):t.addEventListener(r,s,!0):u!==void 0?t.addEventListener(r,s,{passive:u}):t.addEventListener(r,s,!1)}function Rp(t,r,s,l,u){var p=l;if((r&1)===0&&(r&2)===0&&l!==null)e:for(;;){if(l===null)return;var g=l.tag;if(g===3||g===4){var w=l.stateNode.containerInfo;if(w===u)break;if(g===4)for(g=l.return;g!==null;){var C=g.tag;if((C===3||C===4)&&g.stateNode.containerInfo===u)return;g=g.return}for(;w!==null;){if(g=na(w),g===null)return;if(C=g.tag,C===5||C===6||C===26||C===27){l=p=g;continue e}w=w.parentNode}}l=l.return}Lh(function(){var j=p,P=Xu(s),B=[];e:{var A=dg.get(t);if(A!==void 0){var R=bl,Q=t;switch(t){case"keypress":if(vl(s)===0)break e;case"keydown":case"keyup":R=r2;break;case"focusin":Q="focus",R=nd;break;case"focusout":Q="blur",R=nd;break;case"beforeblur":case"afterblur":R=nd;break;case"click":if(s.button===2)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":R=zh;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":R=VS;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":R=o2;break;case og:case lg:case cg:R=QS;break;case ug:R=c2;break;case"scroll":case"scrollend":R=YS;break;case"wheel":R=d2;break;case"copy":case"cut":case"paste":R=$S;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":R=qh;break;case"toggle":case"beforetoggle":R=m2}var ie=(r&4)!==0,Ue=!ie&&(t==="scroll"||t==="scrollend"),k=ie?A!==null?A+"Capture":null:A;ie=[];for(var T=j,E;T!==null;){var U=T;if(E=U.stateNode,U=U.tag,U!==5&&U!==26&&U!==27||E===null||k===null||(U=Cs(T,k),U!=null&&ie.push(no(T,U,E))),Ue)break;T=T.return}0<ie.length&&(A=new R(A,Q,null,s,P),B.push({event:A,listeners:ie}))}}if((r&7)===0){e:{if(A=t==="mouseover"||t==="pointerover",R=t==="mouseout"||t==="pointerout",A&&s!==Qu&&(Q=s.relatedTarget||s.fromElement)&&(na(Q)||Q[ta]))break e;if((R||A)&&(A=P.window===P?P:(A=P.ownerDocument)?A.defaultView||A.parentWindow:window,R?(Q=s.relatedTarget||s.toElement,R=j,Q=Q?na(Q):null,Q!==null&&(Ue=c(Q),ie=Q.tag,Q!==Ue||ie!==5&&ie!==27&&ie!==6)&&(Q=null)):(R=null,Q=j),R!==Q)){if(ie=zh,U="onMouseLeave",k="onMouseEnter",T="mouse",(t==="pointerout"||t==="pointerover")&&(ie=qh,U="onPointerLeave",k="onPointerEnter",T="pointer"),Ue=R==null?A:Ss(R),E=Q==null?A:Ss(Q),A=new ie(U,T+"leave",R,s,P),A.target=Ue,A.relatedTarget=E,U=null,na(P)===j&&(ie=new ie(k,T+"enter",Q,s,P),ie.target=E,ie.relatedTarget=Ue,U=ie),Ue=U,R&&Q)t:{for(ie=pC,k=R,T=Q,E=0,U=k;U;U=ie(U))E++;U=0;for(var ee=T;ee;ee=ie(ee))U++;for(;0<E-U;)k=ie(k),E--;for(;0<U-E;)T=ie(T),U--;for(;E--;){if(k===T||T!==null&&k===T.alternate){ie=k;break t}k=ie(k),T=ie(T)}ie=null}else ie=null;R!==null&&Ry(B,A,R,ie,!1),Q!==null&&Ue!==null&&Ry(B,Ue,Q,ie,!0)}}e:{if(A=j?Ss(j):window,R=A.nodeName&&A.nodeName.toLowerCase(),R==="select"||R==="input"&&A.type==="file")var Ne=Xh;else if(Kh(A))if($h)Ne=C2;else{Ne=w2;var $=b2}else R=A.nodeName,!R||R.toLowerCase()!=="input"||A.type!=="checkbox"&&A.type!=="radio"?j&&Ku(j.elementType)&&(Ne=Xh):Ne=S2;if(Ne&&(Ne=Ne(t,j))){Qh(B,Ne,s,P);break e}$&&$(t,A,j),t==="focusout"&&j&&A.type==="number"&&j.memoizedProps.value!=null&&Wu(A,"number",A.value)}switch($=j?Ss(j):window,t){case"focusin":(Kh($)||$.contentEditable==="true")&&(da=$,ld=j,As=null);break;case"focusout":As=ld=da=null;break;case"mousedown":cd=!0;break;case"contextmenu":case"mouseup":case"dragend":cd=!1,ag(B,s,P);break;case"selectionchange":if(_2)break;case"keydown":case"keyup":ag(B,s,P)}var de;if(rd)e:{switch(t){case"compositionstart":var Se="onCompositionStart";break e;case"compositionend":Se="onCompositionEnd";break e;case"compositionupdate":Se="onCompositionUpdate";break e}Se=void 0}else ua?Vh(t,s)&&(Se="onCompositionEnd"):t==="keydown"&&s.keyCode===229&&(Se="onCompositionStart");Se&&(Hh&&s.locale!=="ko"&&(ua||Se!=="onCompositionStart"?Se==="onCompositionEnd"&&ua&&(de=Uh()):(Ci=P,Ju="value"in Ci?Ci.value:Ci.textContent,ua=!0)),$=uc(j,Se),0<$.length&&(Se=new Fh(Se,t,null,s,P),B.push({event:Se,listeners:$}),de?Se.data=de:(de=Wh(s),de!==null&&(Se.data=de)))),(de=h2?g2(t,s):y2(t,s))&&(Se=uc(j,"onBeforeInput"),0<Se.length&&($=new Fh("onBeforeInput","beforeinput",null,s,P),B.push({event:$,listeners:Se}),$.data=de)),lC(B,t,j,s,P)}Ay(B,r)})}function no(t,r,s){return{instance:t,listener:r,currentTarget:s}}function uc(t,r){for(var s=r+"Capture",l=[];t!==null;){var u=t,p=u.stateNode;if(u=u.tag,u!==5&&u!==26&&u!==27||p===null||(u=Cs(t,s),u!=null&&l.unshift(no(t,u,p)),u=Cs(t,r),u!=null&&l.push(no(t,u,p))),t.tag===3)return l;t=t.return}return[]}function pC(t){if(t===null)return null;do t=t.return;while(t&&t.tag!==5&&t.tag!==27);return t||null}function Ry(t,r,s,l,u){for(var p=r._reactName,g=[];s!==null&&s!==l;){var w=s,C=w.alternate,j=w.stateNode;if(w=w.tag,C!==null&&C===l)break;w!==5&&w!==26&&w!==27||j===null||(C=j,u?(j=Cs(s,p),j!=null&&g.unshift(no(s,j,C))):u||(j=Cs(s,p),j!=null&&g.push(no(s,j,C)))),s=s.return}g.length!==0&&t.push({event:r,listeners:g})}var mC=/\r\n?/g,fC=/\u0000|\uFFFD/g;function Dy(t){return(typeof t=="string"?t:""+t).replace(mC,`
`).replace(fC,"")}function Iy(t,r){return r=Dy(r),Dy(t)===r}function Le(t,r,s,l,u,p){switch(s){case"children":typeof l=="string"?r==="body"||r==="textarea"&&l===""||oa(t,l):(typeof l=="number"||typeof l=="bigint")&&r!=="body"&&oa(t,""+l);break;case"className":fl(t,"class",l);break;case"tabIndex":fl(t,"tabindex",l);break;case"dir":case"role":case"viewBox":case"width":case"height":fl(t,s,l);break;case"style":Ih(t,l,p);break;case"data":if(r!=="object"){fl(t,"data",l);break}case"src":case"href":if(l===""&&(r!=="a"||s!=="href")){t.removeAttribute(s);break}if(l==null||typeof l=="function"||typeof l=="symbol"||typeof l=="boolean"){t.removeAttribute(s);break}l=gl(""+l),t.setAttribute(s,l);break;case"action":case"formAction":if(typeof l=="function"){t.setAttribute(s,"javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");break}else typeof p=="function"&&(s==="formAction"?(r!=="input"&&Le(t,r,"name",u.name,u,null),Le(t,r,"formEncType",u.formEncType,u,null),Le(t,r,"formMethod",u.formMethod,u,null),Le(t,r,"formTarget",u.formTarget,u,null)):(Le(t,r,"encType",u.encType,u,null),Le(t,r,"method",u.method,u,null),Le(t,r,"target",u.target,u,null)));if(l==null||typeof l=="symbol"||typeof l=="boolean"){t.removeAttribute(s);break}l=gl(""+l),t.setAttribute(s,l);break;case"onClick":l!=null&&(t.onclick=Fn);break;case"onScroll":l!=null&&be("scroll",t);break;case"onScrollEnd":l!=null&&be("scrollend",t);break;case"dangerouslySetInnerHTML":if(l!=null){if(typeof l!="object"||!("__html"in l))throw Error(a(61));if(s=l.__html,s!=null){if(u.children!=null)throw Error(a(60));t.innerHTML=s}}break;case"multiple":t.multiple=l&&typeof l!="function"&&typeof l!="symbol";break;case"muted":t.muted=l&&typeof l!="function"&&typeof l!="symbol";break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"defaultValue":case"defaultChecked":case"innerHTML":case"ref":break;case"autoFocus":break;case"xlinkHref":if(l==null||typeof l=="function"||typeof l=="boolean"||typeof l=="symbol"){t.removeAttribute("xlink:href");break}s=gl(""+l),t.setAttributeNS("http://www.w3.org/1999/xlink","xlink:href",s);break;case"contentEditable":case"spellCheck":case"draggable":case"value":case"autoReverse":case"externalResourcesRequired":case"focusable":case"preserveAlpha":l!=null&&typeof l!="function"&&typeof l!="symbol"?t.setAttribute(s,""+l):t.removeAttribute(s);break;case"inert":case"allowFullScreen":case"async":case"autoPlay":case"controls":case"default":case"defer":case"disabled":case"disablePictureInPicture":case"disableRemotePlayback":case"formNoValidate":case"hidden":case"loop":case"noModule":case"noValidate":case"open":case"playsInline":case"readOnly":case"required":case"reversed":case"scoped":case"seamless":case"itemScope":l&&typeof l!="function"&&typeof l!="symbol"?t.setAttribute(s,""):t.removeAttribute(s);break;case"capture":case"download":l===!0?t.setAttribute(s,""):l!==!1&&l!=null&&typeof l!="function"&&typeof l!="symbol"?t.setAttribute(s,l):t.removeAttribute(s);break;case"cols":case"rows":case"size":case"span":l!=null&&typeof l!="function"&&typeof l!="symbol"&&!isNaN(l)&&1<=l?t.setAttribute(s,l):t.removeAttribute(s);break;case"rowSpan":case"start":l==null||typeof l=="function"||typeof l=="symbol"||isNaN(l)?t.removeAttribute(s):t.setAttribute(s,l);break;case"popover":be("beforetoggle",t),be("toggle",t),ml(t,"popover",l);break;case"xlinkActuate":zn(t,"http://www.w3.org/1999/xlink","xlink:actuate",l);break;case"xlinkArcrole":zn(t,"http://www.w3.org/1999/xlink","xlink:arcrole",l);break;case"xlinkRole":zn(t,"http://www.w3.org/1999/xlink","xlink:role",l);break;case"xlinkShow":zn(t,"http://www.w3.org/1999/xlink","xlink:show",l);break;case"xlinkTitle":zn(t,"http://www.w3.org/1999/xlink","xlink:title",l);break;case"xlinkType":zn(t,"http://www.w3.org/1999/xlink","xlink:type",l);break;case"xmlBase":zn(t,"http://www.w3.org/XML/1998/namespace","xml:base",l);break;case"xmlLang":zn(t,"http://www.w3.org/XML/1998/namespace","xml:lang",l);break;case"xmlSpace":zn(t,"http://www.w3.org/XML/1998/namespace","xml:space",l);break;case"is":ml(t,"is",l);break;case"innerText":case"textContent":break;default:(!(2<s.length)||s[0]!=="o"&&s[0]!=="O"||s[1]!=="n"&&s[1]!=="N")&&(s=qS.get(s)||s,ml(t,s,l))}}function Dp(t,r,s,l,u,p){switch(s){case"style":Ih(t,l,p);break;case"dangerouslySetInnerHTML":if(l!=null){if(typeof l!="object"||!("__html"in l))throw Error(a(61));if(s=l.__html,s!=null){if(u.children!=null)throw Error(a(60));t.innerHTML=s}}break;case"children":typeof l=="string"?oa(t,l):(typeof l=="number"||typeof l=="bigint")&&oa(t,""+l);break;case"onScroll":l!=null&&be("scroll",t);break;case"onScrollEnd":l!=null&&be("scrollend",t);break;case"onClick":l!=null&&(t.onclick=Fn);break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"innerHTML":case"ref":break;case"innerText":case"textContent":break;default:if(!Th.hasOwnProperty(s))e:{if(s[0]==="o"&&s[1]==="n"&&(u=s.endsWith("Capture"),r=s.slice(2,u?s.length-7:void 0),p=t[Pt]||null,p=p!=null?p[s]:null,typeof p=="function"&&t.removeEventListener(r,p,u),typeof l=="function")){typeof p!="function"&&p!==null&&(s in t?t[s]=null:t.hasAttribute(s)&&t.removeAttribute(s)),t.addEventListener(r,l,u);break e}s in t?t[s]=l:l===!0?t.setAttribute(s,""):ml(t,s,l)}}}function Ot(t,r,s){switch(r){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"img":be("error",t),be("load",t);var l=!1,u=!1,p;for(p in s)if(s.hasOwnProperty(p)){var g=s[p];if(g!=null)switch(p){case"src":l=!0;break;case"srcSet":u=!0;break;case"children":case"dangerouslySetInnerHTML":throw Error(a(137,r));default:Le(t,r,p,g,s,null)}}u&&Le(t,r,"srcSet",s.srcSet,s,null),l&&Le(t,r,"src",s.src,s,null);return;case"input":be("invalid",t);var w=p=g=u=null,C=null,j=null;for(l in s)if(s.hasOwnProperty(l)){var P=s[l];if(P!=null)switch(l){case"name":u=P;break;case"type":g=P;break;case"checked":C=P;break;case"defaultChecked":j=P;break;case"value":p=P;break;case"defaultValue":w=P;break;case"children":case"dangerouslySetInnerHTML":if(P!=null)throw Error(a(137,r));break;default:Le(t,r,l,P,s,null)}}Ah(t,p,w,C,j,g,u,!1);return;case"select":be("invalid",t),l=g=p=null;for(u in s)if(s.hasOwnProperty(u)&&(w=s[u],w!=null))switch(u){case"value":p=w;break;case"defaultValue":g=w;break;case"multiple":l=w;default:Le(t,r,u,w,s,null)}r=p,s=g,t.multiple=!!l,r!=null?sa(t,!!l,r,!1):s!=null&&sa(t,!!l,s,!0);return;case"textarea":be("invalid",t),p=u=l=null;for(g in s)if(s.hasOwnProperty(g)&&(w=s[g],w!=null))switch(g){case"value":l=w;break;case"defaultValue":u=w;break;case"children":p=w;break;case"dangerouslySetInnerHTML":if(w!=null)throw Error(a(91));break;default:Le(t,r,g,w,s,null)}Rh(t,l,u,p);return;case"option":for(C in s)s.hasOwnProperty(C)&&(l=s[C],l!=null)&&(C==="selected"?t.selected=l&&typeof l!="function"&&typeof l!="symbol":Le(t,r,C,l,s,null));return;case"dialog":be("beforetoggle",t),be("toggle",t),be("cancel",t),be("close",t);break;case"iframe":case"object":be("load",t);break;case"video":case"audio":for(l=0;l<to.length;l++)be(to[l],t);break;case"image":be("error",t),be("load",t);break;case"details":be("toggle",t);break;case"embed":case"source":case"link":be("error",t),be("load",t);case"area":case"base":case"br":case"col":case"hr":case"keygen":case"meta":case"param":case"track":case"wbr":case"menuitem":for(j in s)if(s.hasOwnProperty(j)&&(l=s[j],l!=null))switch(j){case"children":case"dangerouslySetInnerHTML":throw Error(a(137,r));default:Le(t,r,j,l,s,null)}return;default:if(Ku(r)){for(P in s)s.hasOwnProperty(P)&&(l=s[P],l!==void 0&&Dp(t,r,P,l,s,void 0));return}}for(w in s)s.hasOwnProperty(w)&&(l=s[w],l!=null&&Le(t,r,w,l,s,null))}function hC(t,r,s,l){switch(r){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"input":var u=null,p=null,g=null,w=null,C=null,j=null,P=null;for(R in s){var B=s[R];if(s.hasOwnProperty(R)&&B!=null)switch(R){case"checked":break;case"value":break;case"defaultValue":C=B;default:l.hasOwnProperty(R)||Le(t,r,R,null,l,B)}}for(var A in l){var R=l[A];if(B=s[A],l.hasOwnProperty(A)&&(R!=null||B!=null))switch(A){case"type":p=R;break;case"name":u=R;break;case"checked":j=R;break;case"defaultChecked":P=R;break;case"value":g=R;break;case"defaultValue":w=R;break;case"children":case"dangerouslySetInnerHTML":if(R!=null)throw Error(a(137,r));break;default:R!==B&&Le(t,r,A,R,l,B)}}Vu(t,g,w,C,j,P,p,u);return;case"select":R=g=w=A=null;for(p in s)if(C=s[p],s.hasOwnProperty(p)&&C!=null)switch(p){case"value":break;case"multiple":R=C;default:l.hasOwnProperty(p)||Le(t,r,p,null,l,C)}for(u in l)if(p=l[u],C=s[u],l.hasOwnProperty(u)&&(p!=null||C!=null))switch(u){case"value":A=p;break;case"defaultValue":w=p;break;case"multiple":g=p;default:p!==C&&Le(t,r,u,p,l,C)}r=w,s=g,l=R,A!=null?sa(t,!!s,A,!1):!!l!=!!s&&(r!=null?sa(t,!!s,r,!0):sa(t,!!s,s?[]:"",!1));return;case"textarea":R=A=null;for(w in s)if(u=s[w],s.hasOwnProperty(w)&&u!=null&&!l.hasOwnProperty(w))switch(w){case"value":break;case"children":break;default:Le(t,r,w,null,l,u)}for(g in l)if(u=l[g],p=s[g],l.hasOwnProperty(g)&&(u!=null||p!=null))switch(g){case"value":A=u;break;case"defaultValue":R=u;break;case"children":break;case"dangerouslySetInnerHTML":if(u!=null)throw Error(a(91));break;default:u!==p&&Le(t,r,g,u,l,p)}Mh(t,A,R);return;case"option":for(var Q in s)A=s[Q],s.hasOwnProperty(Q)&&A!=null&&!l.hasOwnProperty(Q)&&(Q==="selected"?t.selected=!1:Le(t,r,Q,null,l,A));for(C in l)A=l[C],R=s[C],l.hasOwnProperty(C)&&A!==R&&(A!=null||R!=null)&&(C==="selected"?t.selected=A&&typeof A!="function"&&typeof A!="symbol":Le(t,r,C,A,l,R));return;case"img":case"link":case"area":case"base":case"br":case"col":case"embed":case"hr":case"keygen":case"meta":case"param":case"source":case"track":case"wbr":case"menuitem":for(var ie in s)A=s[ie],s.hasOwnProperty(ie)&&A!=null&&!l.hasOwnProperty(ie)&&Le(t,r,ie,null,l,A);for(j in l)if(A=l[j],R=s[j],l.hasOwnProperty(j)&&A!==R&&(A!=null||R!=null))switch(j){case"children":case"dangerouslySetInnerHTML":if(A!=null)throw Error(a(137,r));break;default:Le(t,r,j,A,l,R)}return;default:if(Ku(r)){for(var Ue in s)A=s[Ue],s.hasOwnProperty(Ue)&&A!==void 0&&!l.hasOwnProperty(Ue)&&Dp(t,r,Ue,void 0,l,A);for(P in l)A=l[P],R=s[P],!l.hasOwnProperty(P)||A===R||A===void 0&&R===void 0||Dp(t,r,P,A,l,R);return}}for(var k in s)A=s[k],s.hasOwnProperty(k)&&A!=null&&!l.hasOwnProperty(k)&&Le(t,r,k,null,l,A);for(B in l)A=l[B],R=s[B],!l.hasOwnProperty(B)||A===R||A==null&&R==null||Le(t,r,B,A,l,R)}function Py(t){switch(t){case"css":case"script":case"font":case"img":case"image":case"input":case"link":return!0;default:return!1}}function gC(){if(typeof performance.getEntriesByType=="function"){for(var t=0,r=0,s=performance.getEntriesByType("resource"),l=0;l<s.length;l++){var u=s[l],p=u.transferSize,g=u.initiatorType,w=u.duration;if(p&&w&&Py(g)){for(g=0,w=u.responseEnd,l+=1;l<s.length;l++){var C=s[l],j=C.startTime;if(j>w)break;var P=C.transferSize,B=C.initiatorType;P&&Py(B)&&(C=C.responseEnd,g+=P*(C<w?1:(w-j)/(C-j)))}if(--l,r+=8*(p+g)/(u.duration/1e3),t++,10<t)break}}if(0<t)return r/t/1e6}return navigator.connection&&(t=navigator.connection.downlink,typeof t=="number")?t:5}var Ip=null,Pp=null;function dc(t){return t.nodeType===9?t:t.ownerDocument}function Ly(t){switch(t){case"http://www.w3.org/2000/svg":return 1;case"http://www.w3.org/1998/Math/MathML":return 2;default:return 0}}function Uy(t,r){if(t===0)switch(r){case"svg":return 1;case"math":return 2;default:return 0}return t===1&&r==="foreignObject"?0:t}function Lp(t,r){return t==="textarea"||t==="noscript"||typeof r.children=="string"||typeof r.children=="number"||typeof r.children=="bigint"||typeof r.dangerouslySetInnerHTML=="object"&&r.dangerouslySetInnerHTML!==null&&r.dangerouslySetInnerHTML.__html!=null}var Up=null;function yC(){var t=window.event;return t&&t.type==="popstate"?t===Up?!1:(Up=t,!0):(Up=null,!1)}var By=typeof setTimeout=="function"?setTimeout:void 0,vC=typeof clearTimeout=="function"?clearTimeout:void 0,zy=typeof Promise=="function"?Promise:void 0,xC=typeof queueMicrotask=="function"?queueMicrotask:typeof zy<"u"?function(t){return zy.resolve(null).then(t).catch(bC)}:By;function bC(t){setTimeout(function(){throw t})}function zi(t){return t==="head"}function Fy(t,r){var s=r,l=0;do{var u=s.nextSibling;if(t.removeChild(s),u&&u.nodeType===8)if(s=u.data,s==="/$"||s==="/&"){if(l===0){t.removeChild(u),Ua(r);return}l--}else if(s==="$"||s==="$?"||s==="$~"||s==="$!"||s==="&")l++;else if(s==="html")io(t.ownerDocument.documentElement);else if(s==="head"){s=t.ownerDocument.head,io(s);for(var p=s.firstChild;p;){var g=p.nextSibling,w=p.nodeName;p[ws]||w==="SCRIPT"||w==="STYLE"||w==="LINK"&&p.rel.toLowerCase()==="stylesheet"||s.removeChild(p),p=g}}else s==="body"&&io(t.ownerDocument.body);s=u}while(s);Ua(r)}function qy(t,r){var s=t;t=0;do{var l=s.nextSibling;if(s.nodeType===1?r?(s._stashedDisplay=s.style.display,s.style.display="none"):(s.style.display=s._stashedDisplay||"",s.getAttribute("style")===""&&s.removeAttribute("style")):s.nodeType===3&&(r?(s._stashedText=s.nodeValue,s.nodeValue=""):s.nodeValue=s._stashedText||""),l&&l.nodeType===8)if(s=l.data,s==="/$"){if(t===0)break;t--}else s!=="$"&&s!=="$?"&&s!=="$~"&&s!=="$!"||t++;s=l}while(s)}function Bp(t){var r=t.firstChild;for(r&&r.nodeType===10&&(r=r.nextSibling);r;){var s=r;switch(r=r.nextSibling,s.nodeName){case"HTML":case"HEAD":case"BODY":Bp(s),Yu(s);continue;case"SCRIPT":case"STYLE":continue;case"LINK":if(s.rel.toLowerCase()==="stylesheet")continue}t.removeChild(s)}}function wC(t,r,s,l){for(;t.nodeType===1;){var u=s;if(t.nodeName.toLowerCase()!==r.toLowerCase()){if(!l&&(t.nodeName!=="INPUT"||t.type!=="hidden"))break}else if(l){if(!t[ws])switch(r){case"meta":if(!t.hasAttribute("itemprop"))break;return t;case"link":if(p=t.getAttribute("rel"),p==="stylesheet"&&t.hasAttribute("data-precedence"))break;if(p!==u.rel||t.getAttribute("href")!==(u.href==null||u.href===""?null:u.href)||t.getAttribute("crossorigin")!==(u.crossOrigin==null?null:u.crossOrigin)||t.getAttribute("title")!==(u.title==null?null:u.title))break;return t;case"style":if(t.hasAttribute("data-precedence"))break;return t;case"script":if(p=t.getAttribute("src"),(p!==(u.src==null?null:u.src)||t.getAttribute("type")!==(u.type==null?null:u.type)||t.getAttribute("crossorigin")!==(u.crossOrigin==null?null:u.crossOrigin))&&p&&t.hasAttribute("async")&&!t.hasAttribute("itemprop"))break;return t;default:return t}}else if(r==="input"&&t.type==="hidden"){var p=u.name==null?null:""+u.name;if(u.type==="hidden"&&t.getAttribute("name")===p)return t}else return t;if(t=pn(t.nextSibling),t===null)break}return null}function SC(t,r,s){if(r==="")return null;for(;t.nodeType!==3;)if((t.nodeType!==1||t.nodeName!=="INPUT"||t.type!=="hidden")&&!s||(t=pn(t.nextSibling),t===null))return null;return t}function Hy(t,r){for(;t.nodeType!==8;)if((t.nodeType!==1||t.nodeName!=="INPUT"||t.type!=="hidden")&&!r||(t=pn(t.nextSibling),t===null))return null;return t}function zp(t){return t.data==="$?"||t.data==="$~"}function Fp(t){return t.data==="$!"||t.data==="$?"&&t.ownerDocument.readyState!=="loading"}function CC(t,r){var s=t.ownerDocument;if(t.data==="$~")t._reactRetry=r;else if(t.data!=="$?"||s.readyState!=="loading")r();else{var l=function(){r(),s.removeEventListener("DOMContentLoaded",l)};s.addEventListener("DOMContentLoaded",l),t._reactRetry=l}}function pn(t){for(;t!=null;t=t.nextSibling){var r=t.nodeType;if(r===1||r===3)break;if(r===8){if(r=t.data,r==="$"||r==="$!"||r==="$?"||r==="$~"||r==="&"||r==="F!"||r==="F")break;if(r==="/$"||r==="/&")return null}}return t}var qp=null;function Yy(t){t=t.nextSibling;for(var r=0;t;){if(t.nodeType===8){var s=t.data;if(s==="/$"||s==="/&"){if(r===0)return pn(t.nextSibling);r--}else s!=="$"&&s!=="$!"&&s!=="$?"&&s!=="$~"&&s!=="&"||r++}t=t.nextSibling}return null}function Gy(t){t=t.previousSibling;for(var r=0;t;){if(t.nodeType===8){var s=t.data;if(s==="$"||s==="$!"||s==="$?"||s==="$~"||s==="&"){if(r===0)return t;r--}else s!=="/$"&&s!=="/&"||r++}t=t.previousSibling}return null}function Vy(t,r,s){switch(r=dc(s),t){case"html":if(t=r.documentElement,!t)throw Error(a(452));return t;case"head":if(t=r.head,!t)throw Error(a(453));return t;case"body":if(t=r.body,!t)throw Error(a(454));return t;default:throw Error(a(451))}}function io(t){for(var r=t.attributes;r.length;)t.removeAttributeNode(r[0]);Yu(t)}var mn=new Map,Wy=new Set;function pc(t){return typeof t.getRootNode=="function"?t.getRootNode():t.nodeType===9?t:t.ownerDocument}var ii=V.d;V.d={f:OC,r:_C,D:TC,C:kC,L:NC,m:EC,X:AC,S:jC,M:MC};function OC(){var t=ii.f(),r=ic();return t||r}function _C(t){var r=ia(t);r!==null&&r.tag===5&&r.type==="form"?u0(r):ii.r(t)}var Ia=typeof document>"u"?null:document;function Ky(t,r,s){var l=Ia;if(l&&typeof r=="string"&&r){var u=an(r);u='link[rel="'+t+'"][href="'+u+'"]',typeof s=="string"&&(u+='[crossorigin="'+s+'"]'),Wy.has(u)||(Wy.add(u),t={rel:t,crossOrigin:s,href:r},l.querySelector(u)===null&&(r=l.createElement("link"),Ot(r,"link",t),ft(r),l.head.appendChild(r)))}}function TC(t){ii.D(t),Ky("dns-prefetch",t,null)}function kC(t,r){ii.C(t,r),Ky("preconnect",t,r)}function NC(t,r,s){ii.L(t,r,s);var l=Ia;if(l&&t&&r){var u='link[rel="preload"][as="'+an(r)+'"]';r==="image"&&s&&s.imageSrcSet?(u+='[imagesrcset="'+an(s.imageSrcSet)+'"]',typeof s.imageSizes=="string"&&(u+='[imagesizes="'+an(s.imageSizes)+'"]')):u+='[href="'+an(t)+'"]';var p=u;switch(r){case"style":p=Pa(t);break;case"script":p=La(t)}mn.has(p)||(t=v({rel:"preload",href:r==="image"&&s&&s.imageSrcSet?void 0:t,as:r},s),mn.set(p,t),l.querySelector(u)!==null||r==="style"&&l.querySelector(ro(p))||r==="script"&&l.querySelector(ao(p))||(r=l.createElement("link"),Ot(r,"link",t),ft(r),l.head.appendChild(r)))}}function EC(t,r){ii.m(t,r);var s=Ia;if(s&&t){var l=r&&typeof r.as=="string"?r.as:"script",u='link[rel="modulepreload"][as="'+an(l)+'"][href="'+an(t)+'"]',p=u;switch(l){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":p=La(t)}if(!mn.has(p)&&(t=v({rel:"modulepreload",href:t},r),mn.set(p,t),s.querySelector(u)===null)){switch(l){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":if(s.querySelector(ao(p)))return}l=s.createElement("link"),Ot(l,"link",t),ft(l),s.head.appendChild(l)}}}function jC(t,r,s){ii.S(t,r,s);var l=Ia;if(l&&t){var u=ra(l).hoistableStyles,p=Pa(t);r=r||"default";var g=u.get(p);if(!g){var w={loading:0,preload:null};if(g=l.querySelector(ro(p)))w.loading=5;else{t=v({rel:"stylesheet",href:t,"data-precedence":r},s),(s=mn.get(p))&&Hp(t,s);var C=g=l.createElement("link");ft(C),Ot(C,"link",t),C._p=new Promise(function(j,P){C.onload=j,C.onerror=P}),C.addEventListener("load",function(){w.loading|=1}),C.addEventListener("error",function(){w.loading|=2}),w.loading|=4,mc(g,r,l)}g={type:"stylesheet",instance:g,count:1,state:w},u.set(p,g)}}}function AC(t,r){ii.X(t,r);var s=Ia;if(s&&t){var l=ra(s).hoistableScripts,u=La(t),p=l.get(u);p||(p=s.querySelector(ao(u)),p||(t=v({src:t,async:!0},r),(r=mn.get(u))&&Yp(t,r),p=s.createElement("script"),ft(p),Ot(p,"link",t),s.head.appendChild(p)),p={type:"script",instance:p,count:1,state:null},l.set(u,p))}}function MC(t,r){ii.M(t,r);var s=Ia;if(s&&t){var l=ra(s).hoistableScripts,u=La(t),p=l.get(u);p||(p=s.querySelector(ao(u)),p||(t=v({src:t,async:!0,type:"module"},r),(r=mn.get(u))&&Yp(t,r),p=s.createElement("script"),ft(p),Ot(p,"link",t),s.head.appendChild(p)),p={type:"script",instance:p,count:1,state:null},l.set(u,p))}}function Qy(t,r,s,l){var u=(u=ce.current)?pc(u):null;if(!u)throw Error(a(446));switch(t){case"meta":case"title":return null;case"style":return typeof s.precedence=="string"&&typeof s.href=="string"?(r=Pa(s.href),s=ra(u).hoistableStyles,l=s.get(r),l||(l={type:"style",instance:null,count:0,state:null},s.set(r,l)),l):{type:"void",instance:null,count:0,state:null};case"link":if(s.rel==="stylesheet"&&typeof s.href=="string"&&typeof s.precedence=="string"){t=Pa(s.href);var p=ra(u).hoistableStyles,g=p.get(t);if(g||(u=u.ownerDocument||u,g={type:"stylesheet",instance:null,count:0,state:{loading:0,preload:null}},p.set(t,g),(p=u.querySelector(ro(t)))&&!p._p&&(g.instance=p,g.state.loading=5),mn.has(t)||(s={rel:"preload",as:"style",href:s.href,crossOrigin:s.crossOrigin,integrity:s.integrity,media:s.media,hrefLang:s.hrefLang,referrerPolicy:s.referrerPolicy},mn.set(t,s),p||RC(u,t,s,g.state))),r&&l===null)throw Error(a(528,""));return g}if(r&&l!==null)throw Error(a(529,""));return null;case"script":return r=s.async,s=s.src,typeof s=="string"&&r&&typeof r!="function"&&typeof r!="symbol"?(r=La(s),s=ra(u).hoistableScripts,l=s.get(r),l||(l={type:"script",instance:null,count:0,state:null},s.set(r,l)),l):{type:"void",instance:null,count:0,state:null};default:throw Error(a(444,t))}}function Pa(t){return'href="'+an(t)+'"'}function ro(t){return'link[rel="stylesheet"]['+t+"]"}function Xy(t){return v({},t,{"data-precedence":t.precedence,precedence:null})}function RC(t,r,s,l){t.querySelector('link[rel="preload"][as="style"]['+r+"]")?l.loading=1:(r=t.createElement("link"),l.preload=r,r.addEventListener("load",function(){return l.loading|=1}),r.addEventListener("error",function(){return l.loading|=2}),Ot(r,"link",s),ft(r),t.head.appendChild(r))}function La(t){return'[src="'+an(t)+'"]'}function ao(t){return"script[async]"+t}function $y(t,r,s){if(r.count++,r.instance===null)switch(r.type){case"style":var l=t.querySelector('style[data-href~="'+an(s.href)+'"]');if(l)return r.instance=l,ft(l),l;var u=v({},s,{"data-href":s.href,"data-precedence":s.precedence,href:null,precedence:null});return l=(t.ownerDocument||t).createElement("style"),ft(l),Ot(l,"style",u),mc(l,s.precedence,t),r.instance=l;case"stylesheet":u=Pa(s.href);var p=t.querySelector(ro(u));if(p)return r.state.loading|=4,r.instance=p,ft(p),p;l=Xy(s),(u=mn.get(u))&&Hp(l,u),p=(t.ownerDocument||t).createElement("link"),ft(p);var g=p;return g._p=new Promise(function(w,C){g.onload=w,g.onerror=C}),Ot(p,"link",l),r.state.loading|=4,mc(p,s.precedence,t),r.instance=p;case"script":return p=La(s.src),(u=t.querySelector(ao(p)))?(r.instance=u,ft(u),u):(l=s,(u=mn.get(p))&&(l=v({},s),Yp(l,u)),t=t.ownerDocument||t,u=t.createElement("script"),ft(u),Ot(u,"link",l),t.head.appendChild(u),r.instance=u);case"void":return null;default:throw Error(a(443,r.type))}else r.type==="stylesheet"&&(r.state.loading&4)===0&&(l=r.instance,r.state.loading|=4,mc(l,s.precedence,t));return r.instance}function mc(t,r,s){for(var l=s.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'),u=l.length?l[l.length-1]:null,p=u,g=0;g<l.length;g++){var w=l[g];if(w.dataset.precedence===r)p=w;else if(p!==u)break}p?p.parentNode.insertBefore(t,p.nextSibling):(r=s.nodeType===9?s.head:s,r.insertBefore(t,r.firstChild))}function Hp(t,r){t.crossOrigin==null&&(t.crossOrigin=r.crossOrigin),t.referrerPolicy==null&&(t.referrerPolicy=r.referrerPolicy),t.title==null&&(t.title=r.title)}function Yp(t,r){t.crossOrigin==null&&(t.crossOrigin=r.crossOrigin),t.referrerPolicy==null&&(t.referrerPolicy=r.referrerPolicy),t.integrity==null&&(t.integrity=r.integrity)}var fc=null;function Zy(t,r,s){if(fc===null){var l=new Map,u=fc=new Map;u.set(s,l)}else u=fc,l=u.get(s),l||(l=new Map,u.set(s,l));if(l.has(t))return l;for(l.set(t,null),s=s.getElementsByTagName(t),u=0;u<s.length;u++){var p=s[u];if(!(p[ws]||p[bt]||t==="link"&&p.getAttribute("rel")==="stylesheet")&&p.namespaceURI!=="http://www.w3.org/2000/svg"){var g=p.getAttribute(r)||"";g=t+g;var w=l.get(g);w?w.push(p):l.set(g,[p])}}return l}function Jy(t,r,s){t=t.ownerDocument||t,t.head.insertBefore(s,r==="title"?t.querySelector("head > title"):null)}function DC(t,r,s){if(s===1||r.itemProp!=null)return!1;switch(t){case"meta":case"title":return!0;case"style":if(typeof r.precedence!="string"||typeof r.href!="string"||r.href==="")break;return!0;case"link":if(typeof r.rel!="string"||typeof r.href!="string"||r.href===""||r.onLoad||r.onError)break;return r.rel==="stylesheet"?(t=r.disabled,typeof r.precedence=="string"&&t==null):!0;case"script":if(r.async&&typeof r.async!="function"&&typeof r.async!="symbol"&&!r.onLoad&&!r.onError&&r.src&&typeof r.src=="string")return!0}return!1}function e1(t){return!(t.type==="stylesheet"&&(t.state.loading&3)===0)}function IC(t,r,s,l){if(s.type==="stylesheet"&&(typeof l.media!="string"||matchMedia(l.media).matches!==!1)&&(s.state.loading&4)===0){if(s.instance===null){var u=Pa(l.href),p=r.querySelector(ro(u));if(p){r=p._p,r!==null&&typeof r=="object"&&typeof r.then=="function"&&(t.count++,t=hc.bind(t),r.then(t,t)),s.state.loading|=4,s.instance=p,ft(p);return}p=r.ownerDocument||r,l=Xy(l),(u=mn.get(u))&&Hp(l,u),p=p.createElement("link"),ft(p);var g=p;g._p=new Promise(function(w,C){g.onload=w,g.onerror=C}),Ot(p,"link",l),s.instance=p}t.stylesheets===null&&(t.stylesheets=new Map),t.stylesheets.set(s,r),(r=s.state.preload)&&(s.state.loading&3)===0&&(t.count++,s=hc.bind(t),r.addEventListener("load",s),r.addEventListener("error",s))}}var Gp=0;function PC(t,r){return t.stylesheets&&t.count===0&&yc(t,t.stylesheets),0<t.count||0<t.imgCount?function(s){var l=setTimeout(function(){if(t.stylesheets&&yc(t,t.stylesheets),t.unsuspend){var p=t.unsuspend;t.unsuspend=null,p()}},6e4+r);0<t.imgBytes&&Gp===0&&(Gp=62500*gC());var u=setTimeout(function(){if(t.waitingForImages=!1,t.count===0&&(t.stylesheets&&yc(t,t.stylesheets),t.unsuspend)){var p=t.unsuspend;t.unsuspend=null,p()}},(t.imgBytes>Gp?50:800)+r);return t.unsuspend=s,function(){t.unsuspend=null,clearTimeout(l),clearTimeout(u)}}:null}function hc(){if(this.count--,this.count===0&&(this.imgCount===0||!this.waitingForImages)){if(this.stylesheets)yc(this,this.stylesheets);else if(this.unsuspend){var t=this.unsuspend;this.unsuspend=null,t()}}}var gc=null;function yc(t,r){t.stylesheets=null,t.unsuspend!==null&&(t.count++,gc=new Map,r.forEach(LC,t),gc=null,hc.call(t))}function LC(t,r){if(!(r.state.loading&4)){var s=gc.get(t);if(s)var l=s.get(null);else{s=new Map,gc.set(t,s);for(var u=t.querySelectorAll("link[data-precedence],style[data-precedence]"),p=0;p<u.length;p++){var g=u[p];(g.nodeName==="LINK"||g.getAttribute("media")!=="not all")&&(s.set(g.dataset.precedence,g),l=g)}l&&s.set(null,l)}u=r.instance,g=u.getAttribute("data-precedence"),p=s.get(g)||l,p===l&&s.set(null,u),s.set(g,u),this.count++,l=hc.bind(this),u.addEventListener("load",l),u.addEventListener("error",l),p?p.parentNode.insertBefore(u,p.nextSibling):(t=t.nodeType===9?t.head:t,t.insertBefore(u,t.firstChild)),r.state.loading|=4}}var so={$$typeof:H,Provider:null,Consumer:null,_currentValue:J,_currentValue2:J,_threadCount:0};function UC(t,r,s,l,u,p,g,w,C){this.tag=1,this.containerInfo=t,this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.next=this.pendingContext=this.context=this.cancelPendingCommit=null,this.callbackPriority=0,this.expirationTimes=zu(-1),this.entangledLanes=this.shellSuspendCounter=this.errorRecoveryDisabledLanes=this.expiredLanes=this.warmLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=zu(0),this.hiddenUpdates=zu(null),this.identifierPrefix=l,this.onUncaughtError=u,this.onCaughtError=p,this.onRecoverableError=g,this.pooledCache=null,this.pooledCacheLanes=0,this.formState=C,this.incompleteTransitions=new Map}function t1(t,r,s,l,u,p,g,w,C,j,P,B){return t=new UC(t,r,s,g,C,j,P,B,w),r=1,p===!0&&(r|=24),p=Kt(3,null,null,r),t.current=p,p.stateNode=t,r=Od(),r.refCount++,t.pooledCache=r,r.refCount++,p.memoizedState={element:l,isDehydrated:s,cache:r},Nd(p),t}function n1(t){return t?(t=fa,t):fa}function i1(t,r,s,l,u,p){u=n1(u),l.context===null?l.context=u:l.pendingContext=u,l=Ei(r),l.payload={element:s},p=p===void 0?null:p,p!==null&&(l.callback=p),s=ji(t,l,r),s!==null&&(qt(s,t,r),Us(s,t,r))}function r1(t,r){if(t=t.memoizedState,t!==null&&t.dehydrated!==null){var s=t.retryLane;t.retryLane=s!==0&&s<r?s:r}}function Vp(t,r){r1(t,r),(t=t.alternate)&&r1(t,r)}function a1(t){if(t.tag===13||t.tag===31){var r=vr(t,67108864);r!==null&&qt(r,t,67108864),Vp(t,67108864)}}function s1(t){if(t.tag===13||t.tag===31){var r=Jt();r=Fu(r);var s=vr(t,r);s!==null&&qt(s,t,r),Vp(t,r)}}var vc=!0;function BC(t,r,s,l){var u=M.T;M.T=null;var p=V.p;try{V.p=2,Wp(t,r,s,l)}finally{V.p=p,M.T=u}}function zC(t,r,s,l){var u=M.T;M.T=null;var p=V.p;try{V.p=8,Wp(t,r,s,l)}finally{V.p=p,M.T=u}}function Wp(t,r,s,l){if(vc){var u=Kp(l);if(u===null)Rp(t,r,l,xc,s),l1(t,l);else if(qC(u,t,r,s,l))l.stopPropagation();else if(l1(t,l),r&4&&-1<FC.indexOf(t)){for(;u!==null;){var p=ia(u);if(p!==null)switch(p.tag){case 3:if(p=p.stateNode,p.current.memoizedState.isDehydrated){var g=mr(p.pendingLanes);if(g!==0){var w=p;for(w.pendingLanes|=2,w.entangledLanes|=2;g;){var C=1<<31-Vt(g);w.entanglements[1]|=C,g&=~C}jn(p),(Ae&6)===0&&(tc=kt()+500,eo(0))}}break;case 31:case 13:w=vr(p,2),w!==null&&qt(w,p,2),ic(),Vp(p,2)}if(p=Kp(l),p===null&&Rp(t,r,l,xc,s),p===u)break;u=p}u!==null&&l.stopPropagation()}else Rp(t,r,l,null,s)}}function Kp(t){return t=Xu(t),Qp(t)}var xc=null;function Qp(t){if(xc=null,t=na(t),t!==null){var r=c(t);if(r===null)t=null;else{var s=r.tag;if(s===13){if(t=d(r),t!==null)return t;t=null}else if(s===31){if(t=m(r),t!==null)return t;t=null}else if(s===3){if(r.stateNode.current.memoizedState.isDehydrated)return r.tag===3?r.stateNode.containerInfo:null;t=null}else r!==t&&(t=null)}}return xc=t,null}function o1(t){switch(t){case"beforetoggle":case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"toggle":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 2;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 8;case"message":switch(bi()){case ll:return 2;case gs:return 8;case ea:case Bu:return 32;case ys:return 268435456;default:return 32}default:return 32}}var Xp=!1,Fi=null,qi=null,Hi=null,oo=new Map,lo=new Map,Yi=[],FC="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" ");function l1(t,r){switch(t){case"focusin":case"focusout":Fi=null;break;case"dragenter":case"dragleave":qi=null;break;case"mouseover":case"mouseout":Hi=null;break;case"pointerover":case"pointerout":oo.delete(r.pointerId);break;case"gotpointercapture":case"lostpointercapture":lo.delete(r.pointerId)}}function co(t,r,s,l,u,p){return t===null||t.nativeEvent!==p?(t={blockedOn:r,domEventName:s,eventSystemFlags:l,nativeEvent:p,targetContainers:[u]},r!==null&&(r=ia(r),r!==null&&a1(r)),t):(t.eventSystemFlags|=l,r=t.targetContainers,u!==null&&r.indexOf(u)===-1&&r.push(u),t)}function qC(t,r,s,l,u){switch(r){case"focusin":return Fi=co(Fi,t,r,s,l,u),!0;case"dragenter":return qi=co(qi,t,r,s,l,u),!0;case"mouseover":return Hi=co(Hi,t,r,s,l,u),!0;case"pointerover":var p=u.pointerId;return oo.set(p,co(oo.get(p)||null,t,r,s,l,u)),!0;case"gotpointercapture":return p=u.pointerId,lo.set(p,co(lo.get(p)||null,t,r,s,l,u)),!0}return!1}function c1(t){var r=na(t.target);if(r!==null){var s=c(r);if(s!==null){if(r=s.tag,r===13){if(r=d(s),r!==null){t.blockedOn=r,Ch(t.priority,function(){s1(s)});return}}else if(r===31){if(r=m(s),r!==null){t.blockedOn=r,Ch(t.priority,function(){s1(s)});return}}else if(r===3&&s.stateNode.current.memoizedState.isDehydrated){t.blockedOn=s.tag===3?s.stateNode.containerInfo:null;return}}}t.blockedOn=null}function bc(t){if(t.blockedOn!==null)return!1;for(var r=t.targetContainers;0<r.length;){var s=Kp(t.nativeEvent);if(s===null){s=t.nativeEvent;var l=new s.constructor(s.type,s);Qu=l,s.target.dispatchEvent(l),Qu=null}else return r=ia(s),r!==null&&a1(r),t.blockedOn=s,!1;r.shift()}return!0}function u1(t,r,s){bc(t)&&s.delete(r)}function HC(){Xp=!1,Fi!==null&&bc(Fi)&&(Fi=null),qi!==null&&bc(qi)&&(qi=null),Hi!==null&&bc(Hi)&&(Hi=null),oo.forEach(u1),lo.forEach(u1)}function wc(t,r){t.blockedOn===r&&(t.blockedOn=null,Xp||(Xp=!0,n.unstable_scheduleCallback(n.unstable_NormalPriority,HC)))}var Sc=null;function d1(t){Sc!==t&&(Sc=t,n.unstable_scheduleCallback(n.unstable_NormalPriority,function(){Sc===t&&(Sc=null);for(var r=0;r<t.length;r+=3){var s=t[r],l=t[r+1],u=t[r+2];if(typeof l!="function"){if(Qp(l||s)===null)continue;break}var p=ia(s);p!==null&&(t.splice(r,3),r-=3,Kd(p,{pending:!0,data:u,method:s.method,action:l},l,u))}}))}function Ua(t){function r(C){return wc(C,t)}Fi!==null&&wc(Fi,t),qi!==null&&wc(qi,t),Hi!==null&&wc(Hi,t),oo.forEach(r),lo.forEach(r);for(var s=0;s<Yi.length;s++){var l=Yi[s];l.blockedOn===t&&(l.blockedOn=null)}for(;0<Yi.length&&(s=Yi[0],s.blockedOn===null);)c1(s),s.blockedOn===null&&Yi.shift();if(s=(t.ownerDocument||t).$$reactFormReplay,s!=null)for(l=0;l<s.length;l+=3){var u=s[l],p=s[l+1],g=u[Pt]||null;if(typeof p=="function")g||d1(s);else if(g){var w=null;if(p&&p.hasAttribute("formAction")){if(u=p,g=p[Pt]||null)w=g.formAction;else if(Qp(u)!==null)continue}else w=g.action;typeof w=="function"?s[l+1]=w:(s.splice(l,3),l-=3),d1(s)}}}function p1(){function t(p){p.canIntercept&&p.info==="react-transition"&&p.intercept({handler:function(){return new Promise(function(g){return u=g})},focusReset:"manual",scroll:"manual"})}function r(){u!==null&&(u(),u=null),l||setTimeout(s,20)}function s(){if(!l&&!navigation.transition){var p=navigation.currentEntry;p&&p.url!=null&&navigation.navigate(p.url,{state:p.getState(),info:"react-transition",history:"replace"})}}if(typeof navigation=="object"){var l=!1,u=null;return navigation.addEventListener("navigate",t),navigation.addEventListener("navigatesuccess",r),navigation.addEventListener("navigateerror",r),setTimeout(s,100),function(){l=!0,navigation.removeEventListener("navigate",t),navigation.removeEventListener("navigatesuccess",r),navigation.removeEventListener("navigateerror",r),u!==null&&(u(),u=null)}}}function $p(t){this._internalRoot=t}Cc.prototype.render=$p.prototype.render=function(t){var r=this._internalRoot;if(r===null)throw Error(a(409));var s=r.current,l=Jt();i1(s,l,t,r,null,null)},Cc.prototype.unmount=$p.prototype.unmount=function(){var t=this._internalRoot;if(t!==null){this._internalRoot=null;var r=t.containerInfo;i1(t.current,2,null,t,null,null),ic(),r[ta]=null}};function Cc(t){this._internalRoot=t}Cc.prototype.unstable_scheduleHydration=function(t){if(t){var r=Sh();t={blockedOn:null,target:t,priority:r};for(var s=0;s<Yi.length&&r!==0&&r<Yi[s].priority;s++);Yi.splice(s,0,t),s===0&&c1(t)}};var m1=e.version;if(m1!=="19.2.3")throw Error(a(527,m1,"19.2.3"));V.findDOMNode=function(t){var r=t._reactInternals;if(r===void 0)throw typeof t.render=="function"?Error(a(188)):(t=Object.keys(t).join(","),Error(a(268,t)));return t=h(r),t=t!==null?x(t):null,t=t===null?null:t.stateNode,t};var YC={bundleType:0,version:"19.2.3",rendererPackageName:"react-dom",currentDispatcherRef:M,reconcilerVersion:"19.2.3"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var Oc=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!Oc.isDisabled&&Oc.supportsFiber)try{vs=Oc.inject(YC),Gt=Oc}catch{}}return po.createRoot=function(t,r){if(!o(t))throw Error(a(299));var s=!1,l="",u=b0,p=w0,g=S0;return r!=null&&(r.unstable_strictMode===!0&&(s=!0),r.identifierPrefix!==void 0&&(l=r.identifierPrefix),r.onUncaughtError!==void 0&&(u=r.onUncaughtError),r.onCaughtError!==void 0&&(p=r.onCaughtError),r.onRecoverableError!==void 0&&(g=r.onRecoverableError)),r=t1(t,1,!1,null,null,s,l,null,u,p,g,p1),t[ta]=r.current,Mp(t),new $p(r)},po.hydrateRoot=function(t,r,s){if(!o(t))throw Error(a(299));var l=!1,u="",p=b0,g=w0,w=S0,C=null;return s!=null&&(s.unstable_strictMode===!0&&(l=!0),s.identifierPrefix!==void 0&&(u=s.identifierPrefix),s.onUncaughtError!==void 0&&(p=s.onUncaughtError),s.onCaughtError!==void 0&&(g=s.onCaughtError),s.onRecoverableError!==void 0&&(w=s.onRecoverableError),s.formState!==void 0&&(C=s.formState)),r=t1(t,1,!0,r,s??null,l,u,C,p,g,w,p1),r.context=n1(null),s=r.current,l=Jt(),l=Fu(l),u=Ei(l),u.callback=null,ji(s,u,l),s=l,r.current.lanes=s,bs(r,s),jn(r),t[ta]=r.current,Mp(t),new Cc(r)},po.version="19.2.3",po}var C1;function tO(){if(C1)return em.exports;C1=1;function n(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n)}catch(e){console.error(e)}}return n(),em.exports=eO(),em.exports}var nO=tO();var O1="popstate";function iO(n={}){function e(a,o){let{pathname:c,search:d,hash:m}=a.location;return Tm("",{pathname:c,search:d,hash:m},o.state&&o.state.usr||null,o.state&&o.state.key||"default")}function i(a,o){return typeof o=="string"?o:Mo(o)}return aO(e,i,null,n)}function Qe(n,e){if(n===!1||n===null||typeof n>"u")throw new Error(e)}function hn(n,e){if(!n){typeof console<"u"&&console.warn(e);try{throw new Error(e)}catch{}}}function rO(){return Math.random().toString(36).substring(2,10)}function _1(n,e){return{usr:n.state,key:n.key,idx:e}}function Tm(n,e,i=null,a){return{pathname:typeof n=="string"?n:n.pathname,search:"",hash:"",...typeof e=="string"?ns(e):e,state:i,key:e&&e.key||a||rO()}}function Mo({pathname:n="/",search:e="",hash:i=""}){return e&&e!=="?"&&(n+=e.charAt(0)==="?"?e:"?"+e),i&&i!=="#"&&(n+=i.charAt(0)==="#"?i:"#"+i),n}function ns(n){let e={};if(n){let i=n.indexOf("#");i>=0&&(e.hash=n.substring(i),n=n.substring(0,i));let a=n.indexOf("?");a>=0&&(e.search=n.substring(a),n=n.substring(0,a)),n&&(e.pathname=n)}return e}function aO(n,e,i,a={}){let{window:o=document.defaultView,v5Compat:c=!1}=a,d=o.history,m="POP",f=null,h=x();h==null&&(h=0,d.replaceState({...d.state,idx:h},""));function x(){return(d.state||{idx:null}).idx}function v(){m="POP";let q=x(),F=q==null?null:q-h;h=q,f&&f({action:m,location:D.location,delta:F})}function b(q,F){m="PUSH";let I=Tm(D.location,q,F);h=x()+1;let H=_1(I,h),z=D.createHref(I);try{d.pushState(H,"",z)}catch(X){if(X instanceof DOMException&&X.name==="DataCloneError")throw X;o.location.assign(z)}c&&f&&f({action:m,location:D.location,delta:1})}function _(q,F){m="REPLACE";let I=Tm(D.location,q,F);h=x();let H=_1(I,h),z=D.createHref(I);d.replaceState(H,"",z),c&&f&&f({action:m,location:D.location,delta:0})}function N(q){return sO(q)}let D={get action(){return m},get location(){return n(o,d)},listen(q){if(f)throw new Error("A history only accepts one active listener");return o.addEventListener(O1,v),f=q,()=>{o.removeEventListener(O1,v),f=null}},createHref(q){return e(o,q)},createURL:N,encodeLocation(q){let F=N(q);return{pathname:F.pathname,search:F.search,hash:F.hash}},push:b,replace:_,go(q){return d.go(q)}};return D}function sO(n,e=!1){let i="http://localhost";typeof window<"u"&&(i=window.location.origin!=="null"?window.location.origin:window.location.href),Qe(i,"No window.location.(origin|href) available to create URL");let a=typeof n=="string"?n:Mo(n);return a=a.replace(/ $/,"%20"),!e&&a.startsWith("//")&&(a=i+a),new URL(a,i)}function ix(n,e,i="/"){return oO(n,e,i,!1)}function oO(n,e,i,a){let o=typeof e=="string"?ns(e):e,c=di(o.pathname||"/",i);if(c==null)return null;let d=rx(n);lO(d);let m=null;for(let f=0;m==null&&f<d.length;++f){let h=xO(c);m=yO(d[f],h,a)}return m}function rx(n,e=[],i=[],a="",o=!1){let c=(d,m,f=o,h)=>{let x={relativePath:h===void 0?d.path||"":h,caseSensitive:d.caseSensitive===!0,childrenIndex:m,route:d};if(x.relativePath.startsWith("/")){if(!x.relativePath.startsWith(a)&&f)return;Qe(x.relativePath.startsWith(a),`Absolute route path "${x.relativePath}" nested under path "${a}" is not valid. An absolute child route path must start with the combined path of all its parent routes.`),x.relativePath=x.relativePath.slice(a.length)}let v=li([a,x.relativePath]),b=i.concat(x);d.children&&d.children.length>0&&(Qe(d.index!==!0,`Index routes must not have child routes. Please remove all child routes from route path "${v}".`),rx(d.children,e,b,v,f)),!(d.path==null&&!d.index)&&e.push({path:v,score:hO(v,d.index),routesMeta:b})};return n.forEach((d,m)=>{if(d.path===""||!d.path?.includes("?"))c(d,m);else for(let f of ax(d.path))c(d,m,!0,f)}),e}function ax(n){let e=n.split("/");if(e.length===0)return[];let[i,...a]=e,o=i.endsWith("?"),c=i.replace(/\?$/,"");if(a.length===0)return o?[c,""]:[c];let d=ax(a.join("/")),m=[];return m.push(...d.map(f=>f===""?c:[c,f].join("/"))),o&&m.push(...d),m.map(f=>n.startsWith("/")&&f===""?"/":f)}function lO(n){n.sort((e,i)=>e.score!==i.score?i.score-e.score:gO(e.routesMeta.map(a=>a.childrenIndex),i.routesMeta.map(a=>a.childrenIndex)))}var cO=/^:[\w-]+$/,uO=3,dO=2,pO=1,mO=10,fO=-2,T1=n=>n==="*";function hO(n,e){let i=n.split("/"),a=i.length;return i.some(T1)&&(a+=fO),e&&(a+=dO),i.filter(o=>!T1(o)).reduce((o,c)=>o+(cO.test(c)?uO:c===""?pO:mO),a)}function gO(n,e){return n.length===e.length&&n.slice(0,-1).every((a,o)=>a===e[o])?n[n.length-1]-e[e.length-1]:0}function yO(n,e,i=!1){let{routesMeta:a}=n,o={},c="/",d=[];for(let m=0;m<a.length;++m){let f=a[m],h=m===a.length-1,x=c==="/"?e:e.slice(c.length)||"/",v=qc({path:f.relativePath,caseSensitive:f.caseSensitive,end:h},x),b=f.route;if(!v&&h&&i&&!a[a.length-1].route.index&&(v=qc({path:f.relativePath,caseSensitive:f.caseSensitive,end:!1},x)),!v)return null;Object.assign(o,v.params),d.push({params:o,pathname:li([c,v.pathname]),pathnameBase:CO(li([c,v.pathnameBase])),route:b}),v.pathnameBase!=="/"&&(c=li([c,v.pathnameBase]))}return d}function qc(n,e){typeof n=="string"&&(n={path:n,caseSensitive:!1,end:!0});let[i,a]=vO(n.path,n.caseSensitive,n.end),o=e.match(i);if(!o)return null;let c=o[0],d=c.replace(/(.)\/+$/,"$1"),m=o.slice(1);return{params:a.reduce((h,{paramName:x,isOptional:v},b)=>{if(x==="*"){let N=m[b]||"";d=c.slice(0,c.length-N.length).replace(/(.)\/+$/,"$1")}const _=m[b];return v&&!_?h[x]=void 0:h[x]=(_||"").replace(/%2F/g,"/"),h},{}),pathname:c,pathnameBase:d,pattern:n}}function vO(n,e=!1,i=!0){hn(n==="*"||!n.endsWith("*")||n.endsWith("/*"),`Route path "${n}" will be treated as if it were "${n.replace(/\*$/,"/*")}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${n.replace(/\*$/,"/*")}".`);let a=[],o="^"+n.replace(/\/*\*?$/,"").replace(/^\/*/,"/").replace(/[\\.*+^${}|()[\]]/g,"\\$&").replace(/\/:([\w-]+)(\?)?/g,(d,m,f)=>(a.push({paramName:m,isOptional:f!=null}),f?"/?([^\\/]+)?":"/([^\\/]+)")).replace(/\/([\w-]+)\?(\/|$)/g,"(/$1)?$2");return n.endsWith("*")?(a.push({paramName:"*"}),o+=n==="*"||n==="/*"?"(.*)$":"(?:\\/(.+)|\\/*)$"):i?o+="\\/*$":n!==""&&n!=="/"&&(o+="(?:(?=\\/|$))"),[new RegExp(o,e?void 0:"i"),a]}function xO(n){try{return n.split("/").map(e=>decodeURIComponent(e).replace(/\//g,"%2F")).join("/")}catch(e){return hn(!1,`The URL path "${n}" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (${e}).`),n}}function di(n,e){if(e==="/")return n;if(!n.toLowerCase().startsWith(e.toLowerCase()))return null;let i=e.endsWith("/")?e.length-1:e.length,a=n.charAt(i);return a&&a!=="/"?null:n.slice(i)||"/"}var sx=/^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,bO=n=>sx.test(n);function wO(n,e="/"){let{pathname:i,search:a="",hash:o=""}=typeof n=="string"?ns(n):n,c;if(i)if(bO(i))c=i;else{if(i.includes("//")){let d=i;i=i.replace(/\/\/+/g,"/"),hn(!1,`Pathnames cannot have embedded double slashes - normalizing ${d} -> ${i}`)}i.startsWith("/")?c=k1(i.substring(1),"/"):c=k1(i,e)}else c=e;return{pathname:c,search:OO(a),hash:_O(o)}}function k1(n,e){let i=e.replace(/\/+$/,"").split("/");return n.split("/").forEach(o=>{o===".."?i.length>1&&i.pop():o!=="."&&i.push(o)}),i.length>1?i.join("/"):"/"}function rm(n,e,i,a){return`Cannot include a '${n}' character in a manually specified \`to.${e}\` field [${JSON.stringify(a)}].  Please separate it out to the \`to.${i}\` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.`}function SO(n){return n.filter((e,i)=>i===0||e.route.path&&e.route.path.length>0)}function nf(n){let e=SO(n);return e.map((i,a)=>a===e.length-1?i.pathname:i.pathnameBase)}function rf(n,e,i,a=!1){let o;typeof n=="string"?o=ns(n):(o={...n},Qe(!o.pathname||!o.pathname.includes("?"),rm("?","pathname","search",o)),Qe(!o.pathname||!o.pathname.includes("#"),rm("#","pathname","hash",o)),Qe(!o.search||!o.search.includes("#"),rm("#","search","hash",o)));let c=n===""||o.pathname==="",d=c?"/":o.pathname,m;if(d==null)m=i;else{let v=e.length-1;if(!a&&d.startsWith("..")){let b=d.split("/");for(;b[0]==="..";)b.shift(),v-=1;o.pathname=b.join("/")}m=v>=0?e[v]:"/"}let f=wO(o,m),h=d&&d!=="/"&&d.endsWith("/"),x=(c||d===".")&&i.endsWith("/");return!f.pathname.endsWith("/")&&(h||x)&&(f.pathname+="/"),f}var li=n=>n.join("/").replace(/\/\/+/g,"/"),CO=n=>n.replace(/\/+$/,"").replace(/^\/*/,"/"),OO=n=>!n||n==="?"?"":n.startsWith("?")?n:"?"+n,_O=n=>!n||n==="#"?"":n.startsWith("#")?n:"#"+n,TO=class{constructor(n,e,i,a=!1){this.status=n,this.statusText=e||"",this.internal=a,i instanceof Error?(this.data=i.toString(),this.error=i):this.data=i}};function kO(n){return n!=null&&typeof n.status=="number"&&typeof n.statusText=="string"&&typeof n.internal=="boolean"&&"data"in n}function NO(n){return n.map(e=>e.route.path).filter(Boolean).join("/").replace(/\/\/*/g,"/")||"/"}var ox=typeof window<"u"&&typeof window.document<"u"&&typeof window.document.createElement<"u";function lx(n,e){let i=n;if(typeof i!="string"||!sx.test(i))return{absoluteURL:void 0,isExternal:!1,to:i};let a=i,o=!1;if(ox)try{let c=new URL(window.location.href),d=i.startsWith("//")?new URL(c.protocol+i):new URL(i),m=di(d.pathname,e);d.origin===c.origin&&m!=null?i=m+d.search+d.hash:o=!0}catch{hn(!1,`<Link to="${i}"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`)}return{absoluteURL:a,isExternal:o,to:i}}Object.getOwnPropertyNames(Object.prototype).sort().join("\0");var cx=["POST","PUT","PATCH","DELETE"];new Set(cx);var EO=["GET",...cx];new Set(EO);var is=S.createContext(null);is.displayName="DataRouter";var gu=S.createContext(null);gu.displayName="DataRouterState";var jO=S.createContext(!1),ux=S.createContext({isTransitioning:!1});ux.displayName="ViewTransition";var AO=S.createContext(new Map);AO.displayName="Fetchers";var MO=S.createContext(null);MO.displayName="Await";var nn=S.createContext(null);nn.displayName="Navigation";var Vo=S.createContext(null);Vo.displayName="Location";var Ln=S.createContext({outlet:null,matches:[],isDataRoute:!1});Ln.displayName="Route";var af=S.createContext(null);af.displayName="RouteError";var dx="REACT_ROUTER_ERROR",RO="REDIRECT",DO="ROUTE_ERROR_RESPONSE";function IO(n){if(n.startsWith(`${dx}:${RO}:{`))try{let e=JSON.parse(n.slice(28));if(typeof e=="object"&&e&&typeof e.status=="number"&&typeof e.statusText=="string"&&typeof e.location=="string"&&typeof e.reloadDocument=="boolean"&&typeof e.replace=="boolean")return e}catch{}}function PO(n){if(n.startsWith(`${dx}:${DO}:{`))try{let e=JSON.parse(n.slice(40));if(typeof e=="object"&&e&&typeof e.status=="number"&&typeof e.statusText=="string")return new TO(e.status,e.statusText,e.data)}catch{}}function LO(n,{relative:e}={}){Qe(rs(),"useHref() may be used only in the context of a <Router> component.");let{basename:i,navigator:a}=S.useContext(nn),{hash:o,pathname:c,search:d}=Wo(n,{relative:e}),m=c;return i!=="/"&&(m=c==="/"?i:li([i,c])),a.createHref({pathname:m,search:d,hash:o})}function rs(){return S.useContext(Vo)!=null}function hi(){return Qe(rs(),"useLocation() may be used only in the context of a <Router> component."),S.useContext(Vo).location}var px="You should call navigate() in a React.useEffect(), not when your component is first rendered.";function mx(n){S.useContext(nn).static||S.useLayoutEffect(n)}function yu(){let{isDataRoute:n}=S.useContext(Ln);return n?XO():UO()}function UO(){Qe(rs(),"useNavigate() may be used only in the context of a <Router> component.");let n=S.useContext(is),{basename:e,navigator:i}=S.useContext(nn),{matches:a}=S.useContext(Ln),{pathname:o}=hi(),c=JSON.stringify(nf(a)),d=S.useRef(!1);return mx(()=>{d.current=!0}),S.useCallback((f,h={})=>{if(hn(d.current,px),!d.current)return;if(typeof f=="number"){i.go(f);return}let x=rf(f,JSON.parse(c),o,h.relative==="path");n==null&&e!=="/"&&(x.pathname=x.pathname==="/"?e:li([e,x.pathname])),(h.replace?i.replace:i.push)(x,h.state,h)},[e,i,c,o,n])}S.createContext(null);function Wo(n,{relative:e}={}){let{matches:i}=S.useContext(Ln),{pathname:a}=hi(),o=JSON.stringify(nf(i));return S.useMemo(()=>rf(n,JSON.parse(o),a,e==="path"),[n,o,a,e])}function BO(n,e){return fx(n,e)}function fx(n,e,i,a,o){Qe(rs(),"useRoutes() may be used only in the context of a <Router> component.");let{navigator:c}=S.useContext(nn),{matches:d}=S.useContext(Ln),m=d[d.length-1],f=m?m.params:{},h=m?m.pathname:"/",x=m?m.pathnameBase:"/",v=m&&m.route;{let I=v&&v.path||"";gx(h,!v||I.endsWith("*")||I.endsWith("*?"),`You rendered descendant <Routes> (or called \`useRoutes()\`) at "${h}" (under <Route path="${I}">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

Please change the parent <Route path="${I}"> to <Route path="${I==="/"?"*":`${I}/*`}">.`)}let b=hi(),_;if(e){let I=typeof e=="string"?ns(e):e;Qe(x==="/"||I.pathname?.startsWith(x),`When overriding the location using \`<Routes location>\` or \`useRoutes(routes, location)\`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is "${x}" but pathname "${I.pathname}" was given in the \`location\` prop.`),_=I}else _=b;let N=_.pathname||"/",D=N;if(x!=="/"){let I=x.replace(/^\//,"").split("/");D="/"+N.replace(/^\//,"").split("/").slice(I.length).join("/")}let q=ix(n,{pathname:D});hn(v||q!=null,`No routes matched location "${_.pathname}${_.search}${_.hash}" `),hn(q==null||q[q.length-1].route.element!==void 0||q[q.length-1].route.Component!==void 0||q[q.length-1].route.lazy!==void 0,`Matched leaf route at location "${_.pathname}${_.search}${_.hash}" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.`);let F=YO(q&&q.map(I=>Object.assign({},I,{params:Object.assign({},f,I.params),pathname:li([x,c.encodeLocation?c.encodeLocation(I.pathname.replace(/\?/g,"%3F").replace(/#/g,"%23")).pathname:I.pathname]),pathnameBase:I.pathnameBase==="/"?x:li([x,c.encodeLocation?c.encodeLocation(I.pathnameBase.replace(/\?/g,"%3F").replace(/#/g,"%23")).pathname:I.pathnameBase])})),d,i,a,o);return e&&F?S.createElement(Vo.Provider,{value:{location:{pathname:"/",search:"",hash:"",state:null,key:"default",..._},navigationType:"POP"}},F):F}function zO(){let n=QO(),e=kO(n)?`${n.status} ${n.statusText}`:n instanceof Error?n.message:JSON.stringify(n),i=n instanceof Error?n.stack:null,a="rgba(200,200,200, 0.5)",o={padding:"0.5rem",backgroundColor:a},c={padding:"2px 4px",backgroundColor:a},d=null;return console.error("Error handled by React Router default ErrorBoundary:",n),d=S.createElement(S.Fragment,null,S.createElement("p",null," Hey developer "),S.createElement("p",null,"You can provide a way better UX than this when your app throws errors by providing your own ",S.createElement("code",{style:c},"ErrorBoundary")," or"," ",S.createElement("code",{style:c},"errorElement")," prop on your route.")),S.createElement(S.Fragment,null,S.createElement("h2",null,"Unexpected Application Error!"),S.createElement("h3",{style:{fontStyle:"italic"}},e),i?S.createElement("pre",{style:o},i):null,d)}var FO=S.createElement(zO,null),hx=class extends S.Component{constructor(n){super(n),this.state={location:n.location,revalidation:n.revalidation,error:n.error}}static getDerivedStateFromError(n){return{error:n}}static getDerivedStateFromProps(n,e){return e.location!==n.location||e.revalidation!=="idle"&&n.revalidation==="idle"?{error:n.error,location:n.location,revalidation:n.revalidation}:{error:n.error!==void 0?n.error:e.error,location:e.location,revalidation:n.revalidation||e.revalidation}}componentDidCatch(n,e){this.props.onError?this.props.onError(n,e):console.error("React Router caught the following error during render",n)}render(){let n=this.state.error;if(this.context&&typeof n=="object"&&n&&"digest"in n&&typeof n.digest=="string"){const i=PO(n.digest);i&&(n=i)}let e=n!==void 0?S.createElement(Ln.Provider,{value:this.props.routeContext},S.createElement(af.Provider,{value:n,children:this.props.component})):this.props.children;return this.context?S.createElement(qO,{error:n},e):e}};hx.contextType=jO;var am=new WeakMap;function qO({children:n,error:e}){let{basename:i}=S.useContext(nn);if(typeof e=="object"&&e&&"digest"in e&&typeof e.digest=="string"){let a=IO(e.digest);if(a){let o=am.get(e);if(o)throw o;let c=lx(a.location,i);if(ox&&!am.get(e))if(c.isExternal||a.reloadDocument)window.location.href=c.absoluteURL||c.to;else{const d=Promise.resolve().then(()=>window.__reactRouterDataRouter.navigate(c.to,{replace:a.replace}));throw am.set(e,d),d}return S.createElement("meta",{httpEquiv:"refresh",content:`0;url=${c.absoluteURL||c.to}`})}}return n}function HO({routeContext:n,match:e,children:i}){let a=S.useContext(is);return a&&a.static&&a.staticContext&&(e.route.errorElement||e.route.ErrorBoundary)&&(a.staticContext._deepestRenderedBoundaryId=e.route.id),S.createElement(Ln.Provider,{value:n},i)}function YO(n,e=[],i=null,a=null,o=null){if(n==null){if(!i)return null;if(i.errors)n=i.matches;else if(e.length===0&&!i.initialized&&i.matches.length>0)n=i.matches;else return null}let c=n,d=i?.errors;if(d!=null){let x=c.findIndex(v=>v.route.id&&d?.[v.route.id]!==void 0);Qe(x>=0,`Could not find a matching route for errors on route IDs: ${Object.keys(d).join(",")}`),c=c.slice(0,Math.min(c.length,x+1))}let m=!1,f=-1;if(i)for(let x=0;x<c.length;x++){let v=c[x];if((v.route.HydrateFallback||v.route.hydrateFallbackElement)&&(f=x),v.route.id){let{loaderData:b,errors:_}=i,N=v.route.loader&&!b.hasOwnProperty(v.route.id)&&(!_||_[v.route.id]===void 0);if(v.route.lazy||N){m=!0,f>=0?c=c.slice(0,f+1):c=[c[0]];break}}}let h=i&&a?(x,v)=>{a(x,{location:i.location,params:i.matches?.[0]?.params??{},unstable_pattern:NO(i.matches),errorInfo:v})}:void 0;return c.reduceRight((x,v,b)=>{let _,N=!1,D=null,q=null;i&&(_=d&&v.route.id?d[v.route.id]:void 0,D=v.route.errorElement||FO,m&&(f<0&&b===0?(gx("route-fallback",!1,"No `HydrateFallback` element provided to render during initial hydration"),N=!0,q=null):f===b&&(N=!0,q=v.route.hydrateFallbackElement||null)));let F=e.concat(c.slice(0,b+1)),I=()=>{let H;return _?H=D:N?H=q:v.route.Component?H=S.createElement(v.route.Component,null):v.route.element?H=v.route.element:H=x,S.createElement(HO,{match:v,routeContext:{outlet:x,matches:F,isDataRoute:i!=null},children:H})};return i&&(v.route.ErrorBoundary||v.route.errorElement||b===0)?S.createElement(hx,{location:i.location,revalidation:i.revalidation,component:D,error:_,children:I(),routeContext:{outlet:null,matches:F,isDataRoute:!0},onError:h}):I()},null)}function sf(n){return`${n} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`}function GO(n){let e=S.useContext(is);return Qe(e,sf(n)),e}function VO(n){let e=S.useContext(gu);return Qe(e,sf(n)),e}function WO(n){let e=S.useContext(Ln);return Qe(e,sf(n)),e}function of(n){let e=WO(n),i=e.matches[e.matches.length-1];return Qe(i.route.id,`${n} can only be used on routes that contain a unique "id"`),i.route.id}function KO(){return of("useRouteId")}function QO(){let n=S.useContext(af),e=VO("useRouteError"),i=of("useRouteError");return n!==void 0?n:e.errors?.[i]}function XO(){let{router:n}=GO("useNavigate"),e=of("useNavigate"),i=S.useRef(!1);return mx(()=>{i.current=!0}),S.useCallback(async(o,c={})=>{hn(i.current,px),i.current&&(typeof o=="number"?await n.navigate(o):await n.navigate(o,{fromRouteId:e,...c}))},[n,e])}var N1={};function gx(n,e,i){!e&&!N1[n]&&(N1[n]=!0,hn(!1,i))}S.memo($O);function $O({routes:n,future:e,state:i,onError:a}){return fx(n,void 0,i,a,e)}function yx({to:n,replace:e,state:i,relative:a}){Qe(rs(),"<Navigate> may be used only in the context of a <Router> component.");let{static:o}=S.useContext(nn);hn(!o,"<Navigate> must not be used on the initial render in a <StaticRouter>. This is a no-op, but you should modify your code so the <Navigate> is only ever rendered in response to some user interaction or state change.");let{matches:c}=S.useContext(Ln),{pathname:d}=hi(),m=yu(),f=rf(n,nf(c),d,a==="path"),h=JSON.stringify(f);return S.useEffect(()=>{m(JSON.parse(h),{replace:e,state:i,relative:a})},[m,h,a,e,i]),null}function An(n){Qe(!1,"A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.")}function ZO({basename:n="/",children:e=null,location:i,navigationType:a="POP",navigator:o,static:c=!1,unstable_useTransitions:d}){Qe(!rs(),"You cannot render a <Router> inside another <Router>. You should never have more than one in your app.");let m=n.replace(/^\/*/,"/"),f=S.useMemo(()=>({basename:m,navigator:o,static:c,unstable_useTransitions:d,future:{}}),[m,o,c,d]);typeof i=="string"&&(i=ns(i));let{pathname:h="/",search:x="",hash:v="",state:b=null,key:_="default"}=i,N=S.useMemo(()=>{let D=di(h,m);return D==null?null:{location:{pathname:D,search:x,hash:v,state:b,key:_},navigationType:a}},[m,h,x,v,b,_,a]);return hn(N!=null,`<Router basename="${m}"> is not able to match the URL "${h}${x}${v}" because it does not start with the basename, so the <Router> won't render anything.`),N==null?null:S.createElement(nn.Provider,{value:f},S.createElement(Vo.Provider,{children:e,value:N}))}function JO({children:n,location:e}){return BO(km(n),e)}function km(n,e=[]){let i=[];return S.Children.forEach(n,(a,o)=>{if(!S.isValidElement(a))return;let c=[...e,o];if(a.type===S.Fragment){i.push.apply(i,km(a.props.children,c));return}Qe(a.type===An,`[${typeof a.type=="string"?a.type:a.type.name}] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>`),Qe(!a.props.index||!a.props.children,"An index route cannot have child routes.");let d={id:a.props.id||c.join("-"),caseSensitive:a.props.caseSensitive,element:a.props.element,Component:a.props.Component,index:a.props.index,path:a.props.path,middleware:a.props.middleware,loader:a.props.loader,action:a.props.action,hydrateFallbackElement:a.props.hydrateFallbackElement,HydrateFallback:a.props.HydrateFallback,errorElement:a.props.errorElement,ErrorBoundary:a.props.ErrorBoundary,hasErrorBoundary:a.props.hasErrorBoundary===!0||a.props.ErrorBoundary!=null||a.props.errorElement!=null,shouldRevalidate:a.props.shouldRevalidate,handle:a.props.handle,lazy:a.props.lazy};a.props.children&&(d.children=km(a.props.children,c)),i.push(d)}),i}var Dc="get",Ic="application/x-www-form-urlencoded";function vu(n){return typeof HTMLElement<"u"&&n instanceof HTMLElement}function e_(n){return vu(n)&&n.tagName.toLowerCase()==="button"}function t_(n){return vu(n)&&n.tagName.toLowerCase()==="form"}function n_(n){return vu(n)&&n.tagName.toLowerCase()==="input"}function i_(n){return!!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey)}function r_(n,e){return n.button===0&&(!e||e==="_self")&&!i_(n)}var _c=null;function a_(){if(_c===null)try{new FormData(document.createElement("form"),0),_c=!1}catch{_c=!0}return _c}var s_=new Set(["application/x-www-form-urlencoded","multipart/form-data","text/plain"]);function sm(n){return n!=null&&!s_.has(n)?(hn(!1,`"${n}" is not a valid \`encType\` for \`<Form>\`/\`<fetcher.Form>\` and will default to "${Ic}"`),null):n}function o_(n,e){let i,a,o,c,d;if(t_(n)){let m=n.getAttribute("action");a=m?di(m,e):null,i=n.getAttribute("method")||Dc,o=sm(n.getAttribute("enctype"))||Ic,c=new FormData(n)}else if(e_(n)||n_(n)&&(n.type==="submit"||n.type==="image")){let m=n.form;if(m==null)throw new Error('Cannot submit a <button> or <input type="submit"> without a <form>');let f=n.getAttribute("formaction")||m.getAttribute("action");if(a=f?di(f,e):null,i=n.getAttribute("formmethod")||m.getAttribute("method")||Dc,o=sm(n.getAttribute("formenctype"))||sm(m.getAttribute("enctype"))||Ic,c=new FormData(m,n),!a_()){let{name:h,type:x,value:v}=n;if(x==="image"){let b=h?`${h}.`:"";c.append(`${b}x`,"0"),c.append(`${b}y`,"0")}else h&&c.append(h,v)}}else{if(vu(n))throw new Error('Cannot submit element that is not <form>, <button>, or <input type="submit|image">');i=Dc,a=null,o=Ic,d=n}return c&&o==="text/plain"&&(d=c,c=void 0),{action:a,method:i.toLowerCase(),encType:o,formData:c,body:d}}Object.getOwnPropertyNames(Object.prototype).sort().join("\0");function lf(n,e){if(n===!1||n===null||typeof n>"u")throw new Error(e)}function l_(n,e,i){let a=typeof n=="string"?new URL(n,typeof window>"u"?"server://singlefetch/":window.location.origin):n;return a.pathname==="/"?a.pathname=`_root.${i}`:e&&di(a.pathname,e)==="/"?a.pathname=`${e.replace(/\/$/,"")}/_root.${i}`:a.pathname=`${a.pathname.replace(/\/$/,"")}.${i}`,a}async function c_(n,e){if(n.id in e)return e[n.id];try{let i=await import(n.module);return e[n.id]=i,i}catch(i){return console.error(`Error loading route module \`${n.module}\`, reloading page...`),console.error(i),window.__reactRouterContext&&window.__reactRouterContext.isSpaMode,window.location.reload(),new Promise(()=>{})}}function u_(n){return n==null?!1:n.href==null?n.rel==="preload"&&typeof n.imageSrcSet=="string"&&typeof n.imageSizes=="string":typeof n.rel=="string"&&typeof n.href=="string"}async function d_(n,e,i){let a=await Promise.all(n.map(async o=>{let c=e.routes[o.route.id];if(c){let d=await c_(c,i);return d.links?d.links():[]}return[]}));return h_(a.flat(1).filter(u_).filter(o=>o.rel==="stylesheet"||o.rel==="preload").map(o=>o.rel==="stylesheet"?{...o,rel:"prefetch",as:"style"}:{...o,rel:"prefetch"}))}function E1(n,e,i,a,o,c){let d=(f,h)=>i[h]?f.route.id!==i[h].route.id:!0,m=(f,h)=>i[h].pathname!==f.pathname||i[h].route.path?.endsWith("*")&&i[h].params["*"]!==f.params["*"];return c==="assets"?e.filter((f,h)=>d(f,h)||m(f,h)):c==="data"?e.filter((f,h)=>{let x=a.routes[f.route.id];if(!x||!x.hasLoader)return!1;if(d(f,h)||m(f,h))return!0;if(f.route.shouldRevalidate){let v=f.route.shouldRevalidate({currentUrl:new URL(o.pathname+o.search+o.hash,window.origin),currentParams:i[0]?.params||{},nextUrl:new URL(n,window.origin),nextParams:f.params,defaultShouldRevalidate:!0});if(typeof v=="boolean")return v}return!0}):[]}function p_(n,e,{includeHydrateFallback:i}={}){return m_(n.map(a=>{let o=e.routes[a.route.id];if(!o)return[];let c=[o.module];return o.clientActionModule&&(c=c.concat(o.clientActionModule)),o.clientLoaderModule&&(c=c.concat(o.clientLoaderModule)),i&&o.hydrateFallbackModule&&(c=c.concat(o.hydrateFallbackModule)),o.imports&&(c=c.concat(o.imports)),c}).flat(1))}function m_(n){return[...new Set(n)]}function f_(n){let e={},i=Object.keys(n).sort();for(let a of i)e[a]=n[a];return e}function h_(n,e){let i=new Set;return new Set(e),n.reduce((a,o)=>{let c=JSON.stringify(f_(o));return i.has(c)||(i.add(c),a.push({key:c,link:o})),a},[])}function vx(){let n=S.useContext(is);return lf(n,"You must render this element inside a <DataRouterContext.Provider> element"),n}function g_(){let n=S.useContext(gu);return lf(n,"You must render this element inside a <DataRouterStateContext.Provider> element"),n}var cf=S.createContext(void 0);cf.displayName="FrameworkContext";function xx(){let n=S.useContext(cf);return lf(n,"You must render this element inside a <HydratedRouter> element"),n}function y_(n,e){let i=S.useContext(cf),[a,o]=S.useState(!1),[c,d]=S.useState(!1),{onFocus:m,onBlur:f,onMouseEnter:h,onMouseLeave:x,onTouchStart:v}=e,b=S.useRef(null);S.useEffect(()=>{if(n==="render"&&d(!0),n==="viewport"){let D=F=>{F.forEach(I=>{d(I.isIntersecting)})},q=new IntersectionObserver(D,{threshold:.5});return b.current&&q.observe(b.current),()=>{q.disconnect()}}},[n]),S.useEffect(()=>{if(a){let D=setTimeout(()=>{d(!0)},100);return()=>{clearTimeout(D)}}},[a]);let _=()=>{o(!0)},N=()=>{o(!1),d(!1)};return i?n!=="intent"?[c,b,{}]:[c,b,{onFocus:mo(m,_),onBlur:mo(f,N),onMouseEnter:mo(h,_),onMouseLeave:mo(x,N),onTouchStart:mo(v,_)}]:[!1,b,{}]}function mo(n,e){return i=>{n&&n(i),i.defaultPrevented||e(i)}}function v_({page:n,...e}){let{router:i}=vx(),a=S.useMemo(()=>ix(i.routes,n,i.basename),[i.routes,n,i.basename]);return a?S.createElement(b_,{page:n,matches:a,...e}):null}function x_(n){let{manifest:e,routeModules:i}=xx(),[a,o]=S.useState([]);return S.useEffect(()=>{let c=!1;return d_(n,e,i).then(d=>{c||o(d)}),()=>{c=!0}},[n,e,i]),a}function b_({page:n,matches:e,...i}){let a=hi(),{manifest:o,routeModules:c}=xx(),{basename:d}=vx(),{loaderData:m,matches:f}=g_(),h=S.useMemo(()=>E1(n,e,f,o,a,"data"),[n,e,f,o,a]),x=S.useMemo(()=>E1(n,e,f,o,a,"assets"),[n,e,f,o,a]),v=S.useMemo(()=>{if(n===a.pathname+a.search+a.hash)return[];let N=new Set,D=!1;if(e.forEach(F=>{let I=o.routes[F.route.id];!I||!I.hasLoader||(!h.some(H=>H.route.id===F.route.id)&&F.route.id in m&&c[F.route.id]?.shouldRevalidate||I.hasClientLoader?D=!0:N.add(F.route.id))}),N.size===0)return[];let q=l_(n,d,"data");return D&&N.size>0&&q.searchParams.set("_routes",e.filter(F=>N.has(F.route.id)).map(F=>F.route.id).join(",")),[q.pathname+q.search]},[d,m,a,o,h,e,n,c]),b=S.useMemo(()=>p_(x,o),[x,o]),_=x_(x);return S.createElement(S.Fragment,null,v.map(N=>S.createElement("link",{key:N,rel:"prefetch",as:"fetch",href:N,...i})),b.map(N=>S.createElement("link",{key:N,rel:"modulepreload",href:N,...i})),_.map(({key:N,link:D})=>S.createElement("link",{key:N,nonce:i.nonce,...D})))}function w_(...n){return e=>{n.forEach(i=>{typeof i=="function"?i(e):i!=null&&(i.current=e)})}}var S_=typeof window<"u"&&typeof window.document<"u"&&typeof window.document.createElement<"u";try{S_&&(window.__reactRouterVersion="7.11.0")}catch{}function C_({basename:n,children:e,unstable_useTransitions:i,window:a}){let o=S.useRef();o.current==null&&(o.current=iO({window:a,v5Compat:!0}));let c=o.current,[d,m]=S.useState({action:c.action,location:c.location}),f=S.useCallback(h=>{i===!1?m(h):S.startTransition(()=>m(h))},[i]);return S.useLayoutEffect(()=>c.listen(f),[c,f]),S.createElement(ZO,{basename:n,children:e,location:d.location,navigationType:d.action,navigator:c,unstable_useTransitions:i})}var bx=/^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,Tt=S.forwardRef(function({onClick:e,discover:i="render",prefetch:a="none",relative:o,reloadDocument:c,replace:d,state:m,target:f,to:h,preventScrollReset:x,viewTransition:v,unstable_defaultShouldRevalidate:b,..._},N){let{basename:D,unstable_useTransitions:q}=S.useContext(nn),F=typeof h=="string"&&bx.test(h),I=lx(h,D);h=I.to;let H=LO(h,{relative:o}),[z,X,Z]=y_(a,_),K=k_(h,{replace:d,state:m,target:f,preventScrollReset:x,relative:o,viewTransition:v,unstable_defaultShouldRevalidate:b,unstable_useTransitions:q});function fe(te){e&&e(te),te.defaultPrevented||K(te)}let se=S.createElement("a",{..._,...Z,href:I.absoluteURL||H,onClick:I.isExternal||c?e:fe,ref:w_(N,X),target:f,"data-discover":!F&&i==="render"?"true":void 0});return z&&!F?S.createElement(S.Fragment,null,se,S.createElement(v_,{page:H})):se});Tt.displayName="Link";var O_=S.forwardRef(function({"aria-current":e="page",caseSensitive:i=!1,className:a="",end:o=!1,style:c,to:d,viewTransition:m,children:f,...h},x){let v=Wo(d,{relative:h.relative}),b=hi(),_=S.useContext(gu),{navigator:N,basename:D}=S.useContext(nn),q=_!=null&&M_(v)&&m===!0,F=N.encodeLocation?N.encodeLocation(v).pathname:v.pathname,I=b.pathname,H=_&&_.navigation&&_.navigation.location?_.navigation.location.pathname:null;i||(I=I.toLowerCase(),H=H?H.toLowerCase():null,F=F.toLowerCase()),H&&D&&(H=di(H,D)||H);const z=F!=="/"&&F.endsWith("/")?F.length-1:F.length;let X=I===F||!o&&I.startsWith(F)&&I.charAt(z)==="/",Z=H!=null&&(H===F||!o&&H.startsWith(F)&&H.charAt(F.length)==="/"),K={isActive:X,isPending:Z,isTransitioning:q},fe=X?e:void 0,se;typeof a=="function"?se=a(K):se=[a,X?"active":null,Z?"pending":null,q?"transitioning":null].filter(Boolean).join(" ");let te=typeof c=="function"?c(K):c;return S.createElement(Tt,{...h,"aria-current":fe,className:se,ref:x,style:te,to:d,viewTransition:m},typeof f=="function"?f(K):f)});O_.displayName="NavLink";var __=S.forwardRef(({discover:n="render",fetcherKey:e,navigate:i,reloadDocument:a,replace:o,state:c,method:d=Dc,action:m,onSubmit:f,relative:h,preventScrollReset:x,viewTransition:v,unstable_defaultShouldRevalidate:b,..._},N)=>{let{unstable_useTransitions:D}=S.useContext(nn),q=j_(),F=A_(m,{relative:h}),I=d.toLowerCase()==="get"?"get":"post",H=typeof m=="string"&&bx.test(m),z=X=>{if(f&&f(X),X.defaultPrevented)return;X.preventDefault();let Z=X.nativeEvent.submitter,K=Z?.getAttribute("formmethod")||d,fe=()=>q(Z||X.currentTarget,{fetcherKey:e,method:K,navigate:i,replace:o,state:c,relative:h,preventScrollReset:x,viewTransition:v,unstable_defaultShouldRevalidate:b});D&&i!==!1?S.startTransition(()=>fe()):fe()};return S.createElement("form",{ref:N,method:I,action:F,onSubmit:a?f:z,..._,"data-discover":!H&&n==="render"?"true":void 0})});__.displayName="Form";function T_(n){return`${n} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`}function wx(n){let e=S.useContext(is);return Qe(e,T_(n)),e}function k_(n,{target:e,replace:i,state:a,preventScrollReset:o,relative:c,viewTransition:d,unstable_defaultShouldRevalidate:m,unstable_useTransitions:f}={}){let h=yu(),x=hi(),v=Wo(n,{relative:c});return S.useCallback(b=>{if(r_(b,e)){b.preventDefault();let _=i!==void 0?i:Mo(x)===Mo(v),N=()=>h(n,{replace:_,state:a,preventScrollReset:o,relative:c,viewTransition:d,unstable_defaultShouldRevalidate:m});f?S.startTransition(()=>N()):N()}},[x,h,v,i,a,e,n,o,c,d,m,f])}var N_=0,E_=()=>`__${String(++N_)}__`;function j_(){let{router:n}=wx("useSubmit"),{basename:e}=S.useContext(nn),i=KO(),a=n.fetch,o=n.navigate;return S.useCallback(async(c,d={})=>{let{action:m,method:f,encType:h,formData:x,body:v}=o_(c,e);if(d.navigate===!1){let b=d.fetcherKey||E_();await a(b,i,d.action||m,{unstable_defaultShouldRevalidate:d.unstable_defaultShouldRevalidate,preventScrollReset:d.preventScrollReset,formData:x,body:v,formMethod:d.method||f,formEncType:d.encType||h,flushSync:d.flushSync})}else await o(d.action||m,{unstable_defaultShouldRevalidate:d.unstable_defaultShouldRevalidate,preventScrollReset:d.preventScrollReset,formData:x,body:v,formMethod:d.method||f,formEncType:d.encType||h,replace:d.replace,state:d.state,fromRouteId:i,flushSync:d.flushSync,viewTransition:d.viewTransition})},[a,o,e,i])}function A_(n,{relative:e}={}){let{basename:i}=S.useContext(nn),a=S.useContext(Ln);Qe(a,"useFormAction must be used inside a RouteContext");let[o]=a.matches.slice(-1),c={...Wo(n||".",{relative:e})},d=hi();if(n==null){c.search=d.search;let m=new URLSearchParams(c.search),f=m.getAll("index");if(f.some(x=>x==="")){m.delete("index"),f.filter(v=>v).forEach(v=>m.append("index",v));let x=m.toString();c.search=x?`?${x}`:""}}return(!n||n===".")&&o.route.index&&(c.search=c.search?c.search.replace(/^\?/,"?index&"):"?index"),i!=="/"&&(c.pathname=c.pathname==="/"?i:li([i,c.pathname])),Mo(c)}function M_(n,{relative:e}={}){let i=S.useContext(ux);Qe(i!=null,"`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?");let{basename:a}=wx("useViewTransitionState"),o=Wo(n,{relative:e});if(!i.isTransitioning)return!1;let c=di(i.currentLocation.pathname,a)||i.currentLocation.pathname,d=di(i.nextLocation.pathname,a)||i.nextLocation.pathname;return qc(o.pathname,d)!=null||qc(o.pathname,c)!=null}const R_=()=>{};var j1={};const Sx={NODE_ADMIN:!1,SDK_VERSION:"${JSCORE_VERSION}"};const G=function(n,e){if(!n)throw as(e)},as=function(n){return new Error("Firebase Database ("+Sx.SDK_VERSION+") INTERNAL ASSERT FAILED: "+n)};const Cx=function(n){const e=[];let i=0;for(let a=0;a<n.length;a++){let o=n.charCodeAt(a);o<128?e[i++]=o:o<2048?(e[i++]=o>>6|192,e[i++]=o&63|128):(o&64512)===55296&&a+1<n.length&&(n.charCodeAt(a+1)&64512)===56320?(o=65536+((o&1023)<<10)+(n.charCodeAt(++a)&1023),e[i++]=o>>18|240,e[i++]=o>>12&63|128,e[i++]=o>>6&63|128,e[i++]=o&63|128):(e[i++]=o>>12|224,e[i++]=o>>6&63|128,e[i++]=o&63|128)}return e},D_=function(n){const e=[];let i=0,a=0;for(;i<n.length;){const o=n[i++];if(o<128)e[a++]=String.fromCharCode(o);else if(o>191&&o<224){const c=n[i++];e[a++]=String.fromCharCode((o&31)<<6|c&63)}else if(o>239&&o<365){const c=n[i++],d=n[i++],m=n[i++],f=((o&7)<<18|(c&63)<<12|(d&63)<<6|m&63)-65536;e[a++]=String.fromCharCode(55296+(f>>10)),e[a++]=String.fromCharCode(56320+(f&1023))}else{const c=n[i++],d=n[i++];e[a++]=String.fromCharCode((o&15)<<12|(c&63)<<6|d&63)}}return e.join("")},uf={byteToCharMap_:null,charToByteMap_:null,byteToCharMapWebSafe_:null,charToByteMapWebSafe_:null,ENCODED_VALS_BASE:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",get ENCODED_VALS(){return this.ENCODED_VALS_BASE+"+/="},get ENCODED_VALS_WEBSAFE(){return this.ENCODED_VALS_BASE+"-_."},HAS_NATIVE_SUPPORT:typeof atob=="function",encodeByteArray(n,e){if(!Array.isArray(n))throw Error("encodeByteArray takes an array as a parameter");this.init_();const i=e?this.byteToCharMapWebSafe_:this.byteToCharMap_,a=[];for(let o=0;o<n.length;o+=3){const c=n[o],d=o+1<n.length,m=d?n[o+1]:0,f=o+2<n.length,h=f?n[o+2]:0,x=c>>2,v=(c&3)<<4|m>>4;let b=(m&15)<<2|h>>6,_=h&63;f||(_=64,d||(b=64)),a.push(i[x],i[v],i[b],i[_])}return a.join("")},encodeString(n,e){return this.HAS_NATIVE_SUPPORT&&!e?btoa(n):this.encodeByteArray(Cx(n),e)},decodeString(n,e){return this.HAS_NATIVE_SUPPORT&&!e?atob(n):D_(this.decodeStringToByteArray(n,e))},decodeStringToByteArray(n,e){this.init_();const i=e?this.charToByteMapWebSafe_:this.charToByteMap_,a=[];for(let o=0;o<n.length;){const c=i[n.charAt(o++)],m=o<n.length?i[n.charAt(o)]:0;++o;const h=o<n.length?i[n.charAt(o)]:64;++o;const v=o<n.length?i[n.charAt(o)]:64;if(++o,c==null||m==null||h==null||v==null)throw new I_;const b=c<<2|m>>4;if(a.push(b),h!==64){const _=m<<4&240|h>>2;if(a.push(_),v!==64){const N=h<<6&192|v;a.push(N)}}}return a},init_(){if(!this.byteToCharMap_){this.byteToCharMap_={},this.charToByteMap_={},this.byteToCharMapWebSafe_={},this.charToByteMapWebSafe_={};for(let n=0;n<this.ENCODED_VALS.length;n++)this.byteToCharMap_[n]=this.ENCODED_VALS.charAt(n),this.charToByteMap_[this.byteToCharMap_[n]]=n,this.byteToCharMapWebSafe_[n]=this.ENCODED_VALS_WEBSAFE.charAt(n),this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[n]]=n,n>=this.ENCODED_VALS_BASE.length&&(this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(n)]=n,this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(n)]=n)}}};class I_ extends Error{constructor(){super(...arguments),this.name="DecodeBase64StringError"}}const Ox=function(n){const e=Cx(n);return uf.encodeByteArray(e,!0)},Hc=function(n){return Ox(n).replace(/\./g,"")},Yc=function(n){try{return uf.decodeString(n,!0)}catch(e){console.error("base64Decode failed: ",e)}return null};function P_(n){return _x(void 0,n)}function _x(n,e){if(!(e instanceof Object))return e;switch(e.constructor){case Date:const i=e;return new Date(i.getTime());case Object:n===void 0&&(n={});break;case Array:n=[];break;default:return e}for(const i in e)!e.hasOwnProperty(i)||!L_(i)||(n[i]=_x(n[i],e[i]));return n}function L_(n){return n!=="__proto__"}function U_(){if(typeof self<"u")return self;if(typeof window<"u")return window;if(typeof global<"u")return global;throw new Error("Unable to locate global object.")}const B_=()=>U_().__FIREBASE_DEFAULTS__,z_=()=>{if(typeof process>"u"||typeof j1>"u")return;const n=j1.__FIREBASE_DEFAULTS__;if(n)return JSON.parse(n)},F_=()=>{if(typeof document>"u")return;let n;try{n=document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/)}catch{return}const e=n&&Yc(n[1]);return e&&JSON.parse(e)},df=()=>{try{return R_()||B_()||z_()||F_()}catch(n){console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${n}`);return}},Tx=n=>df()?.emulatorHosts?.[n],kx=n=>{const e=Tx(n);if(!e)return;const i=e.lastIndexOf(":");if(i<=0||i+1===e.length)throw new Error(`Invalid host ${e} with no separate hostname and port!`);const a=parseInt(e.substring(i+1),10);return e[0]==="["?[e.substring(1,i-1),a]:[e.substring(0,i),a]},Nx=()=>df()?.config,Ex=n=>df()?.[`_${n}`];class Mn{constructor(){this.reject=()=>{},this.resolve=()=>{},this.promise=new Promise((e,i)=>{this.resolve=e,this.reject=i})}wrapCallback(e){return(i,a)=>{i?this.reject(i):this.resolve(a),typeof e=="function"&&(this.promise.catch(()=>{}),e.length===1?e(i):e(i,a))}}}function cr(n){try{return(n.startsWith("http://")||n.startsWith("https://")?new URL(n).hostname:n).endsWith(".cloudworkstations.dev")}catch{return!1}}async function pf(n){return(await fetch(n,{credentials:"include"})).ok}function jx(n,e){if(n.uid)throw new Error('The "uid" field is no longer supported by mockUserToken. Please use "sub" instead for Firebase Auth User ID.');const i={alg:"none",type:"JWT"},a=e||"demo-project",o=n.iat||0,c=n.sub||n.user_id;if(!c)throw new Error("mockUserToken must contain 'sub' or 'user_id' field!");const d={iss:`https://securetoken.google.com/${a}`,aud:a,iat:o,exp:o+3600,auth_time:o,sub:c,user_id:c,firebase:{sign_in_provider:"custom",identities:{}},...n};return[Hc(JSON.stringify(i)),Hc(JSON.stringify(d)),""].join(".")}const Co={};function q_(){const n={prod:[],emulator:[]};for(const e of Object.keys(Co))Co[e]?n.emulator.push(e):n.prod.push(e);return n}function H_(n){let e=document.getElementById(n),i=!1;return e||(e=document.createElement("div"),e.setAttribute("id",n),i=!0),{created:i,element:e}}let A1=!1;function mf(n,e){if(typeof window>"u"||typeof document>"u"||!cr(window.location.host)||Co[n]===e||Co[n]||A1)return;Co[n]=e;function i(b){return`__firebase__banner__${b}`}const a="__firebase__banner",c=q_().prod.length>0;function d(){const b=document.getElementById(a);b&&b.remove()}function m(b){b.style.display="flex",b.style.background="#7faaf0",b.style.position="fixed",b.style.bottom="5px",b.style.left="5px",b.style.padding=".5em",b.style.borderRadius="5px",b.style.alignItems="center"}function f(b,_){b.setAttribute("width","24"),b.setAttribute("id",_),b.setAttribute("height","24"),b.setAttribute("viewBox","0 0 24 24"),b.setAttribute("fill","none"),b.style.marginLeft="-6px"}function h(){const b=document.createElement("span");return b.style.cursor="pointer",b.style.marginLeft="16px",b.style.fontSize="24px",b.innerHTML=" &times;",b.onclick=()=>{A1=!0,d()},b}function x(b,_){b.setAttribute("id",_),b.innerText="Learn more",b.href="https://firebase.google.com/docs/studio/preview-apps#preview-backend",b.setAttribute("target","__blank"),b.style.paddingLeft="5px",b.style.textDecoration="underline"}function v(){const b=H_(a),_=i("text"),N=document.getElementById(_)||document.createElement("span"),D=i("learnmore"),q=document.getElementById(D)||document.createElement("a"),F=i("preprendIcon"),I=document.getElementById(F)||document.createElementNS("http://www.w3.org/2000/svg","svg");if(b.created){const H=b.element;m(H),x(q,D);const z=h();f(I,F),H.append(I,N,q,z),document.body.appendChild(H)}c?(N.innerText="Preview backend disconnected.",I.innerHTML=`<g clip-path="url(#clip0_6013_33858)">
<path d="M4.8 17.6L12 5.6L19.2 17.6H4.8ZM6.91667 16.4H17.0833L12 7.93333L6.91667 16.4ZM12 15.6C12.1667 15.6 12.3056 15.5444 12.4167 15.4333C12.5389 15.3111 12.6 15.1667 12.6 15C12.6 14.8333 12.5389 14.6944 12.4167 14.5833C12.3056 14.4611 12.1667 14.4 12 14.4C11.8333 14.4 11.6889 14.4611 11.5667 14.5833C11.4556 14.6944 11.4 14.8333 11.4 15C11.4 15.1667 11.4556 15.3111 11.5667 15.4333C11.6889 15.5444 11.8333 15.6 12 15.6ZM11.4 13.6H12.6V10.4H11.4V13.6Z" fill="#212121"/>
</g>
<defs>
<clipPath id="clip0_6013_33858">
<rect width="24" height="24" fill="white"/>
</clipPath>
</defs>`):(I.innerHTML=`<g clip-path="url(#clip0_6083_34804)">
<path d="M11.4 15.2H12.6V11.2H11.4V15.2ZM12 10C12.1667 10 12.3056 9.94444 12.4167 9.83333C12.5389 9.71111 12.6 9.56667 12.6 9.4C12.6 9.23333 12.5389 9.09444 12.4167 8.98333C12.3056 8.86111 12.1667 8.8 12 8.8C11.8333 8.8 11.6889 8.86111 11.5667 8.98333C11.4556 9.09444 11.4 9.23333 11.4 9.4C11.4 9.56667 11.4556 9.71111 11.5667 9.83333C11.6889 9.94444 11.8333 10 12 10ZM12 18.4C11.1222 18.4 10.2944 18.2333 9.51667 17.9C8.73889 17.5667 8.05556 17.1111 7.46667 16.5333C6.88889 15.9444 6.43333 15.2611 6.1 14.4833C5.76667 13.7056 5.6 12.8778 5.6 12C5.6 11.1111 5.76667 10.2833 6.1 9.51667C6.43333 8.73889 6.88889 8.06111 7.46667 7.48333C8.05556 6.89444 8.73889 6.43333 9.51667 6.1C10.2944 5.76667 11.1222 5.6 12 5.6C12.8889 5.6 13.7167 5.76667 14.4833 6.1C15.2611 6.43333 15.9389 6.89444 16.5167 7.48333C17.1056 8.06111 17.5667 8.73889 17.9 9.51667C18.2333 10.2833 18.4 11.1111 18.4 12C18.4 12.8778 18.2333 13.7056 17.9 14.4833C17.5667 15.2611 17.1056 15.9444 16.5167 16.5333C15.9389 17.1111 15.2611 17.5667 14.4833 17.9C13.7167 18.2333 12.8889 18.4 12 18.4ZM12 17.2C13.4444 17.2 14.6722 16.6944 15.6833 15.6833C16.6944 14.6722 17.2 13.4444 17.2 12C17.2 10.5556 16.6944 9.32778 15.6833 8.31667C14.6722 7.30555 13.4444 6.8 12 6.8C10.5556 6.8 9.32778 7.30555 8.31667 8.31667C7.30556 9.32778 6.8 10.5556 6.8 12C6.8 13.4444 7.30556 14.6722 8.31667 15.6833C9.32778 16.6944 10.5556 17.2 12 17.2Z" fill="#212121"/>
</g>
<defs>
<clipPath id="clip0_6083_34804">
<rect width="24" height="24" fill="white"/>
</clipPath>
</defs>`,N.innerText="Preview backend running in this workspace."),N.setAttribute("id",_)}document.readyState==="loading"?window.addEventListener("DOMContentLoaded",v):v()}function Mt(){return typeof navigator<"u"&&typeof navigator.userAgent=="string"?navigator.userAgent:""}function ff(){return typeof window<"u"&&!!(window.cordova||window.phonegap||window.PhoneGap)&&/ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(Mt())}function Y_(){return typeof navigator<"u"&&navigator.userAgent==="Cloudflare-Workers"}function G_(){const n=typeof chrome=="object"?chrome.runtime:typeof browser=="object"?browser.runtime:void 0;return typeof n=="object"&&n.id!==void 0}function Ax(){return typeof navigator=="object"&&navigator.product==="ReactNative"}function V_(){const n=Mt();return n.indexOf("MSIE ")>=0||n.indexOf("Trident/")>=0}function W_(){return Sx.NODE_ADMIN===!0}function K_(){try{return typeof indexedDB=="object"}catch{return!1}}function Q_(){return new Promise((n,e)=>{try{let i=!0;const a="validate-browser-context-for-indexeddb-analytics-module",o=self.indexedDB.open(a);o.onsuccess=()=>{o.result.close(),i||self.indexedDB.deleteDatabase(a),n(!0)},o.onupgradeneeded=()=>{i=!1},o.onerror=()=>{e(o.error?.message||"")}}catch(i){e(i)}})}const X_="FirebaseError";class gi extends Error{constructor(e,i,a){super(i),this.code=e,this.customData=a,this.name=X_,Object.setPrototypeOf(this,gi.prototype),Error.captureStackTrace&&Error.captureStackTrace(this,Ko.prototype.create)}}class Ko{constructor(e,i,a){this.service=e,this.serviceName=i,this.errors=a}create(e,...i){const a=i[0]||{},o=`${this.service}/${e}`,c=this.errors[e],d=c?$_(c,a):"Error",m=`${this.serviceName}: ${d} (${o}).`;return new gi(o,m,a)}}function $_(n,e){return n.replace(Z_,(i,a)=>{const o=e[a];return o!=null?String(o):`<${a}?>`})}const Z_=/\{\$([^}]+)}/g;function Ro(n){return JSON.parse(n)}function mt(n){return JSON.stringify(n)}const Mx=function(n){let e={},i={},a={},o="";try{const c=n.split(".");e=Ro(Yc(c[0])||""),i=Ro(Yc(c[1])||""),o=c[2],a=i.d||{},delete i.d}catch{}return{header:e,claims:i,data:a,signature:o}},J_=function(n){const e=Mx(n),i=e.claims;return!!i&&typeof i=="object"&&i.hasOwnProperty("iat")},eT=function(n){const e=Mx(n).claims;return typeof e=="object"&&e.admin===!0};function Un(n,e){return Object.prototype.hasOwnProperty.call(n,e)}function Ka(n,e){if(Object.prototype.hasOwnProperty.call(n,e))return n[e]}function Gc(n){for(const e in n)if(Object.prototype.hasOwnProperty.call(n,e))return!1;return!0}function Vc(n,e,i){const a={};for(const o in n)Object.prototype.hasOwnProperty.call(n,o)&&(a[o]=e.call(i,n[o],o,n));return a}function Ur(n,e){if(n===e)return!0;const i=Object.keys(n),a=Object.keys(e);for(const o of i){if(!a.includes(o))return!1;const c=n[o],d=e[o];if(M1(c)&&M1(d)){if(!Ur(c,d))return!1}else if(c!==d)return!1}for(const o of a)if(!i.includes(o))return!1;return!0}function M1(n){return n!==null&&typeof n=="object"}function ss(n){const e=[];for(const[i,a]of Object.entries(n))Array.isArray(a)?a.forEach(o=>{e.push(encodeURIComponent(i)+"="+encodeURIComponent(o))}):e.push(encodeURIComponent(i)+"="+encodeURIComponent(a));return e.length?"&"+e.join("&"):""}function bo(n){const e={};return n.replace(/^\?/,"").split("&").forEach(a=>{if(a){const[o,c]=a.split("=");e[decodeURIComponent(o)]=decodeURIComponent(c)}}),e}function wo(n){const e=n.indexOf("?");if(!e)return"";const i=n.indexOf("#",e);return n.substring(e,i>0?i:void 0)}class tT{constructor(){this.chain_=[],this.buf_=[],this.W_=[],this.pad_=[],this.inbuf_=0,this.total_=0,this.blockSize=512/8,this.pad_[0]=128;for(let e=1;e<this.blockSize;++e)this.pad_[e]=0;this.reset()}reset(){this.chain_[0]=1732584193,this.chain_[1]=4023233417,this.chain_[2]=2562383102,this.chain_[3]=271733878,this.chain_[4]=3285377520,this.inbuf_=0,this.total_=0}compress_(e,i){i||(i=0);const a=this.W_;if(typeof e=="string")for(let v=0;v<16;v++)a[v]=e.charCodeAt(i)<<24|e.charCodeAt(i+1)<<16|e.charCodeAt(i+2)<<8|e.charCodeAt(i+3),i+=4;else for(let v=0;v<16;v++)a[v]=e[i]<<24|e[i+1]<<16|e[i+2]<<8|e[i+3],i+=4;for(let v=16;v<80;v++){const b=a[v-3]^a[v-8]^a[v-14]^a[v-16];a[v]=(b<<1|b>>>31)&4294967295}let o=this.chain_[0],c=this.chain_[1],d=this.chain_[2],m=this.chain_[3],f=this.chain_[4],h,x;for(let v=0;v<80;v++){v<40?v<20?(h=m^c&(d^m),x=1518500249):(h=c^d^m,x=1859775393):v<60?(h=c&d|m&(c|d),x=2400959708):(h=c^d^m,x=3395469782);const b=(o<<5|o>>>27)+h+f+x+a[v]&4294967295;f=m,m=d,d=(c<<30|c>>>2)&4294967295,c=o,o=b}this.chain_[0]=this.chain_[0]+o&4294967295,this.chain_[1]=this.chain_[1]+c&4294967295,this.chain_[2]=this.chain_[2]+d&4294967295,this.chain_[3]=this.chain_[3]+m&4294967295,this.chain_[4]=this.chain_[4]+f&4294967295}update(e,i){if(e==null)return;i===void 0&&(i=e.length);const a=i-this.blockSize;let o=0;const c=this.buf_;let d=this.inbuf_;for(;o<i;){if(d===0)for(;o<=a;)this.compress_(e,o),o+=this.blockSize;if(typeof e=="string"){for(;o<i;)if(c[d]=e.charCodeAt(o),++d,++o,d===this.blockSize){this.compress_(c),d=0;break}}else for(;o<i;)if(c[d]=e[o],++d,++o,d===this.blockSize){this.compress_(c),d=0;break}}this.inbuf_=d,this.total_+=i}digest(){const e=[];let i=this.total_*8;this.inbuf_<56?this.update(this.pad_,56-this.inbuf_):this.update(this.pad_,this.blockSize-(this.inbuf_-56));for(let o=this.blockSize-1;o>=56;o--)this.buf_[o]=i&255,i/=256;this.compress_(this.buf_);let a=0;for(let o=0;o<5;o++)for(let c=24;c>=0;c-=8)e[a]=this.chain_[o]>>c&255,++a;return e}}function nT(n,e){const i=new iT(n,e);return i.subscribe.bind(i)}class iT{constructor(e,i){this.observers=[],this.unsubscribes=[],this.observerCount=0,this.task=Promise.resolve(),this.finalized=!1,this.onNoObservers=i,this.task.then(()=>{e(this)}).catch(a=>{this.error(a)})}next(e){this.forEachObserver(i=>{i.next(e)})}error(e){this.forEachObserver(i=>{i.error(e)}),this.close(e)}complete(){this.forEachObserver(e=>{e.complete()}),this.close()}subscribe(e,i,a){let o;if(e===void 0&&i===void 0&&a===void 0)throw new Error("Missing Observer.");rT(e,["next","error","complete"])?o=e:o={next:e,error:i,complete:a},o.next===void 0&&(o.next=om),o.error===void 0&&(o.error=om),o.complete===void 0&&(o.complete=om);const c=this.unsubscribeOne.bind(this,this.observers.length);return this.finalized&&this.task.then(()=>{try{this.finalError?o.error(this.finalError):o.complete()}catch{}}),this.observers.push(o),c}unsubscribeOne(e){this.observers===void 0||this.observers[e]===void 0||(delete this.observers[e],this.observerCount-=1,this.observerCount===0&&this.onNoObservers!==void 0&&this.onNoObservers(this))}forEachObserver(e){if(!this.finalized)for(let i=0;i<this.observers.length;i++)this.sendOne(i,e)}sendOne(e,i){this.task.then(()=>{if(this.observers!==void 0&&this.observers[e]!==void 0)try{i(this.observers[e])}catch(a){typeof console<"u"&&console.error&&console.error(a)}})}close(e){this.finalized||(this.finalized=!0,e!==void 0&&(this.finalError=e),this.task.then(()=>{this.observers=void 0,this.onNoObservers=void 0}))}}function rT(n,e){if(typeof n!="object"||n===null)return!1;for(const i of e)if(i in n&&typeof n[i]=="function")return!0;return!1}function om(){}function Qa(n,e){return`${n} failed: ${e} argument `}const aT=function(n){const e=[];let i=0;for(let a=0;a<n.length;a++){let o=n.charCodeAt(a);if(o>=55296&&o<=56319){const c=o-55296;a++,G(a<n.length,"Surrogate pair missing trail surrogate.");const d=n.charCodeAt(a)-56320;o=65536+(c<<10)+d}o<128?e[i++]=o:o<2048?(e[i++]=o>>6|192,e[i++]=o&63|128):o<65536?(e[i++]=o>>12|224,e[i++]=o>>6&63|128,e[i++]=o&63|128):(e[i++]=o>>18|240,e[i++]=o>>12&63|128,e[i++]=o>>6&63|128,e[i++]=o&63|128)}return e},xu=function(n){let e=0;for(let i=0;i<n.length;i++){const a=n.charCodeAt(i);a<128?e++:a<2048?e+=2:a>=55296&&a<=56319?(e+=4,i++):e+=3}return e};function nt(n){return n&&n._delegate?n._delegate:n}class ir{constructor(e,i,a){this.name=e,this.instanceFactory=i,this.type=a,this.multipleInstances=!1,this.serviceProps={},this.instantiationMode="LAZY",this.onInstanceCreated=null}setInstantiationMode(e){return this.instantiationMode=e,this}setMultipleInstances(e){return this.multipleInstances=e,this}setServiceProps(e){return this.serviceProps=e,this}setInstanceCreatedCallback(e){return this.onInstanceCreated=e,this}}const Ar="[DEFAULT]";class sT{constructor(e,i){this.name=e,this.container=i,this.component=null,this.instances=new Map,this.instancesDeferred=new Map,this.instancesOptions=new Map,this.onInitCallbacks=new Map}get(e){const i=this.normalizeInstanceIdentifier(e);if(!this.instancesDeferred.has(i)){const a=new Mn;if(this.instancesDeferred.set(i,a),this.isInitialized(i)||this.shouldAutoInitialize())try{const o=this.getOrInitializeService({instanceIdentifier:i});o&&a.resolve(o)}catch{}}return this.instancesDeferred.get(i).promise}getImmediate(e){const i=this.normalizeInstanceIdentifier(e?.identifier),a=e?.optional??!1;if(this.isInitialized(i)||this.shouldAutoInitialize())try{return this.getOrInitializeService({instanceIdentifier:i})}catch(o){if(a)return null;throw o}else{if(a)return null;throw Error(`Service ${this.name} is not available`)}}getComponent(){return this.component}setComponent(e){if(e.name!==this.name)throw Error(`Mismatching Component ${e.name} for Provider ${this.name}.`);if(this.component)throw Error(`Component for ${this.name} has already been provided`);if(this.component=e,!!this.shouldAutoInitialize()){if(lT(e))try{this.getOrInitializeService({instanceIdentifier:Ar})}catch{}for(const[i,a]of this.instancesDeferred.entries()){const o=this.normalizeInstanceIdentifier(i);try{const c=this.getOrInitializeService({instanceIdentifier:o});a.resolve(c)}catch{}}}}clearInstance(e=Ar){this.instancesDeferred.delete(e),this.instancesOptions.delete(e),this.instances.delete(e)}async delete(){const e=Array.from(this.instances.values());await Promise.all([...e.filter(i=>"INTERNAL"in i).map(i=>i.INTERNAL.delete()),...e.filter(i=>"_delete"in i).map(i=>i._delete())])}isComponentSet(){return this.component!=null}isInitialized(e=Ar){return this.instances.has(e)}getOptions(e=Ar){return this.instancesOptions.get(e)||{}}initialize(e={}){const{options:i={}}=e,a=this.normalizeInstanceIdentifier(e.instanceIdentifier);if(this.isInitialized(a))throw Error(`${this.name}(${a}) has already been initialized`);if(!this.isComponentSet())throw Error(`Component ${this.name} has not been registered yet`);const o=this.getOrInitializeService({instanceIdentifier:a,options:i});for(const[c,d]of this.instancesDeferred.entries()){const m=this.normalizeInstanceIdentifier(c);a===m&&d.resolve(o)}return o}onInit(e,i){const a=this.normalizeInstanceIdentifier(i),o=this.onInitCallbacks.get(a)??new Set;o.add(e),this.onInitCallbacks.set(a,o);const c=this.instances.get(a);return c&&e(c,a),()=>{o.delete(e)}}invokeOnInitCallbacks(e,i){const a=this.onInitCallbacks.get(i);if(a)for(const o of a)try{o(e,i)}catch{}}getOrInitializeService({instanceIdentifier:e,options:i={}}){let a=this.instances.get(e);if(!a&&this.component&&(a=this.component.instanceFactory(this.container,{instanceIdentifier:oT(e),options:i}),this.instances.set(e,a),this.instancesOptions.set(e,i),this.invokeOnInitCallbacks(a,e),this.component.onInstanceCreated))try{this.component.onInstanceCreated(this.container,e,a)}catch{}return a||null}normalizeInstanceIdentifier(e=Ar){return this.component?this.component.multipleInstances?e:Ar:e}shouldAutoInitialize(){return!!this.component&&this.component.instantiationMode!=="EXPLICIT"}}function oT(n){return n===Ar?void 0:n}function lT(n){return n.instantiationMode==="EAGER"}class cT{constructor(e){this.name=e,this.providers=new Map}addComponent(e){const i=this.getProvider(e.name);if(i.isComponentSet())throw new Error(`Component ${e.name} has already been registered with ${this.name}`);i.setComponent(e)}addOrOverwriteComponent(e){this.getProvider(e.name).isComponentSet()&&this.providers.delete(e.name),this.addComponent(e)}getProvider(e){if(this.providers.has(e))return this.providers.get(e);const i=new sT(e,this);return this.providers.set(e,i),i}getProviders(){return Array.from(this.providers.values())}}var Be;(function(n){n[n.DEBUG=0]="DEBUG",n[n.VERBOSE=1]="VERBOSE",n[n.INFO=2]="INFO",n[n.WARN=3]="WARN",n[n.ERROR=4]="ERROR",n[n.SILENT=5]="SILENT"})(Be||(Be={}));const uT={debug:Be.DEBUG,verbose:Be.VERBOSE,info:Be.INFO,warn:Be.WARN,error:Be.ERROR,silent:Be.SILENT},dT=Be.INFO,pT={[Be.DEBUG]:"log",[Be.VERBOSE]:"log",[Be.INFO]:"info",[Be.WARN]:"warn",[Be.ERROR]:"error"},mT=(n,e,...i)=>{if(e<n.logLevel)return;const a=new Date().toISOString(),o=pT[e];if(o)console[o](`[${a}]  ${n.name}:`,...i);else throw new Error(`Attempted to log a message with an invalid logType (value: ${e})`)};class hf{constructor(e){this.name=e,this._logLevel=dT,this._logHandler=mT,this._userLogHandler=null}get logLevel(){return this._logLevel}set logLevel(e){if(!(e in Be))throw new TypeError(`Invalid value "${e}" assigned to \`logLevel\``);this._logLevel=e}setLogLevel(e){this._logLevel=typeof e=="string"?uT[e]:e}get logHandler(){return this._logHandler}set logHandler(e){if(typeof e!="function")throw new TypeError("Value assigned to `logHandler` must be a function");this._logHandler=e}get userLogHandler(){return this._userLogHandler}set userLogHandler(e){this._userLogHandler=e}debug(...e){this._userLogHandler&&this._userLogHandler(this,Be.DEBUG,...e),this._logHandler(this,Be.DEBUG,...e)}log(...e){this._userLogHandler&&this._userLogHandler(this,Be.VERBOSE,...e),this._logHandler(this,Be.VERBOSE,...e)}info(...e){this._userLogHandler&&this._userLogHandler(this,Be.INFO,...e),this._logHandler(this,Be.INFO,...e)}warn(...e){this._userLogHandler&&this._userLogHandler(this,Be.WARN,...e),this._logHandler(this,Be.WARN,...e)}error(...e){this._userLogHandler&&this._userLogHandler(this,Be.ERROR,...e),this._logHandler(this,Be.ERROR,...e)}}const fT=(n,e)=>e.some(i=>n instanceof i);let R1,D1;function hT(){return R1||(R1=[IDBDatabase,IDBObjectStore,IDBIndex,IDBCursor,IDBTransaction])}function gT(){return D1||(D1=[IDBCursor.prototype.advance,IDBCursor.prototype.continue,IDBCursor.prototype.continuePrimaryKey])}const Rx=new WeakMap,Nm=new WeakMap,Dx=new WeakMap,lm=new WeakMap,gf=new WeakMap;function yT(n){const e=new Promise((i,a)=>{const o=()=>{n.removeEventListener("success",c),n.removeEventListener("error",d)},c=()=>{i(Zi(n.result)),o()},d=()=>{a(n.error),o()};n.addEventListener("success",c),n.addEventListener("error",d)});return e.then(i=>{i instanceof IDBCursor&&Rx.set(i,n)}).catch(()=>{}),gf.set(e,n),e}function vT(n){if(Nm.has(n))return;const e=new Promise((i,a)=>{const o=()=>{n.removeEventListener("complete",c),n.removeEventListener("error",d),n.removeEventListener("abort",d)},c=()=>{i(),o()},d=()=>{a(n.error||new DOMException("AbortError","AbortError")),o()};n.addEventListener("complete",c),n.addEventListener("error",d),n.addEventListener("abort",d)});Nm.set(n,e)}let Em={get(n,e,i){if(n instanceof IDBTransaction){if(e==="done")return Nm.get(n);if(e==="objectStoreNames")return n.objectStoreNames||Dx.get(n);if(e==="store")return i.objectStoreNames[1]?void 0:i.objectStore(i.objectStoreNames[0])}return Zi(n[e])},set(n,e,i){return n[e]=i,!0},has(n,e){return n instanceof IDBTransaction&&(e==="done"||e==="store")?!0:e in n}};function xT(n){Em=n(Em)}function bT(n){return n===IDBDatabase.prototype.transaction&&!("objectStoreNames"in IDBTransaction.prototype)?function(e,...i){const a=n.call(cm(this),e,...i);return Dx.set(a,e.sort?e.sort():[e]),Zi(a)}:gT().includes(n)?function(...e){return n.apply(cm(this),e),Zi(Rx.get(this))}:function(...e){return Zi(n.apply(cm(this),e))}}function wT(n){return typeof n=="function"?bT(n):(n instanceof IDBTransaction&&vT(n),fT(n,hT())?new Proxy(n,Em):n)}function Zi(n){if(n instanceof IDBRequest)return yT(n);if(lm.has(n))return lm.get(n);const e=wT(n);return e!==n&&(lm.set(n,e),gf.set(e,n)),e}const cm=n=>gf.get(n);function ST(n,e,{blocked:i,upgrade:a,blocking:o,terminated:c}={}){const d=indexedDB.open(n,e),m=Zi(d);return a&&d.addEventListener("upgradeneeded",f=>{a(Zi(d.result),f.oldVersion,f.newVersion,Zi(d.transaction),f)}),i&&d.addEventListener("blocked",f=>i(f.oldVersion,f.newVersion,f)),m.then(f=>{c&&f.addEventListener("close",()=>c()),o&&f.addEventListener("versionchange",h=>o(h.oldVersion,h.newVersion,h))}).catch(()=>{}),m}const CT=["get","getKey","getAll","getAllKeys","count"],OT=["put","add","delete","clear"],um=new Map;function I1(n,e){if(!(n instanceof IDBDatabase&&!(e in n)&&typeof e=="string"))return;if(um.get(e))return um.get(e);const i=e.replace(/FromIndex$/,""),a=e!==i,o=OT.includes(i);if(!(i in(a?IDBIndex:IDBObjectStore).prototype)||!(o||CT.includes(i)))return;const c=async function(d,...m){const f=this.transaction(d,o?"readwrite":"readonly");let h=f.store;return a&&(h=h.index(m.shift())),(await Promise.all([h[i](...m),o&&f.done]))[0]};return um.set(e,c),c}xT(n=>({...n,get:(e,i,a)=>I1(e,i)||n.get(e,i,a),has:(e,i)=>!!I1(e,i)||n.has(e,i)}));class _T{constructor(e){this.container=e}getPlatformInfoString(){return this.container.getProviders().map(i=>{if(TT(i)){const a=i.getImmediate();return`${a.library}/${a.version}`}else return null}).filter(i=>i).join(" ")}}function TT(n){return n.getComponent()?.type==="VERSION"}const jm="@firebase/app",P1="0.14.6";const pi=new hf("@firebase/app"),kT="@firebase/app-compat",NT="@firebase/analytics-compat",ET="@firebase/analytics",jT="@firebase/app-check-compat",AT="@firebase/app-check",MT="@firebase/auth",RT="@firebase/auth-compat",DT="@firebase/database",IT="@firebase/data-connect",PT="@firebase/database-compat",LT="@firebase/functions",UT="@firebase/functions-compat",BT="@firebase/installations",zT="@firebase/installations-compat",FT="@firebase/messaging",qT="@firebase/messaging-compat",HT="@firebase/performance",YT="@firebase/performance-compat",GT="@firebase/remote-config",VT="@firebase/remote-config-compat",WT="@firebase/storage",KT="@firebase/storage-compat",QT="@firebase/firestore",XT="@firebase/ai",$T="@firebase/firestore-compat",ZT="firebase",JT="12.6.0";const Am="[DEFAULT]",ek={[jm]:"fire-core",[kT]:"fire-core-compat",[ET]:"fire-analytics",[NT]:"fire-analytics-compat",[AT]:"fire-app-check",[jT]:"fire-app-check-compat",[MT]:"fire-auth",[RT]:"fire-auth-compat",[DT]:"fire-rtdb",[IT]:"fire-data-connect",[PT]:"fire-rtdb-compat",[LT]:"fire-fn",[UT]:"fire-fn-compat",[BT]:"fire-iid",[zT]:"fire-iid-compat",[FT]:"fire-fcm",[qT]:"fire-fcm-compat",[HT]:"fire-perf",[YT]:"fire-perf-compat",[GT]:"fire-rc",[VT]:"fire-rc-compat",[WT]:"fire-gcs",[KT]:"fire-gcs-compat",[QT]:"fire-fst",[$T]:"fire-fst-compat",[XT]:"fire-vertex","fire-js":"fire-js",[ZT]:"fire-js-all"};const Wc=new Map,tk=new Map,Mm=new Map;function L1(n,e){try{n.container.addComponent(e)}catch(i){pi.debug(`Component ${e.name} failed to register with FirebaseApp ${n.name}`,i)}}function Br(n){const e=n.name;if(Mm.has(e))return pi.debug(`There were multiple attempts to register component ${e}.`),!1;Mm.set(e,n);for(const i of Wc.values())L1(i,n);for(const i of tk.values())L1(i,n);return!0}function bu(n,e){const i=n.container.getProvider("heartbeat").getImmediate({optional:!0});return i&&i.triggerHeartbeat(),n.container.getProvider(e)}function Ht(n){return n==null?!1:n.settings!==void 0}const nk={"no-app":"No Firebase App '{$appName}' has been created - call initializeApp() first","bad-app-name":"Illegal App name: '{$appName}'","duplicate-app":"Firebase App named '{$appName}' already exists with different options or config","app-deleted":"Firebase App named '{$appName}' already deleted","server-app-deleted":"Firebase Server App has been deleted","no-options":"Need to provide options, when not being deployed to hosting via source.","invalid-app-argument":"firebase.{$appName}() takes either no argument or a Firebase App instance.","invalid-log-argument":"First argument to `onLog` must be null or a function.","idb-open":"Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.","idb-get":"Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.","idb-set":"Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.","idb-delete":"Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}.","finalization-registry-not-supported":"FirebaseServerApp deleteOnDeref field defined but the JS runtime does not support FinalizationRegistry.","invalid-server-app-environment":"FirebaseServerApp is not for use in browser environments."},Ji=new Ko("app","Firebase",nk);class ik{constructor(e,i,a){this._isDeleted=!1,this._options={...e},this._config={...i},this._name=i.name,this._automaticDataCollectionEnabled=i.automaticDataCollectionEnabled,this._container=a,this.container.addComponent(new ir("app",()=>this,"PUBLIC"))}get automaticDataCollectionEnabled(){return this.checkDestroyed(),this._automaticDataCollectionEnabled}set automaticDataCollectionEnabled(e){this.checkDestroyed(),this._automaticDataCollectionEnabled=e}get name(){return this.checkDestroyed(),this._name}get options(){return this.checkDestroyed(),this._options}get config(){return this.checkDestroyed(),this._config}get container(){return this._container}get isDeleted(){return this._isDeleted}set isDeleted(e){this._isDeleted=e}checkDestroyed(){if(this.isDeleted)throw Ji.create("app-deleted",{appName:this._name})}}const Wr=JT;function Ix(n,e={}){let i=n;typeof e!="object"&&(e={name:e});const a={name:Am,automaticDataCollectionEnabled:!0,...e},o=a.name;if(typeof o!="string"||!o)throw Ji.create("bad-app-name",{appName:String(o)});if(i||(i=Nx()),!i)throw Ji.create("no-options");const c=Wc.get(o);if(c){if(Ur(i,c.options)&&Ur(a,c.config))return c;throw Ji.create("duplicate-app",{appName:o})}const d=new cT(o);for(const f of Mm.values())d.addComponent(f);const m=new ik(i,a,d);return Wc.set(o,m),m}function yf(n=Am){const e=Wc.get(n);if(!e&&n===Am&&Nx())return Ix();if(!e)throw Ji.create("no-app",{appName:n});return e}function Dn(n,e,i){let a=ek[n]??n;i&&(a+=`-${i}`);const o=a.match(/\s|\//),c=e.match(/\s|\//);if(o||c){const d=[`Unable to register library "${a}" with version "${e}":`];o&&d.push(`library name "${a}" contains illegal characters (whitespace or "/")`),o&&c&&d.push("and"),c&&d.push(`version name "${e}" contains illegal characters (whitespace or "/")`),pi.warn(d.join(" "));return}Br(new ir(`${a}-version`,()=>({library:a,version:e}),"VERSION"))}const rk="firebase-heartbeat-database",ak=1,Do="firebase-heartbeat-store";let dm=null;function Px(){return dm||(dm=ST(rk,ak,{upgrade:(n,e)=>{switch(e){case 0:try{n.createObjectStore(Do)}catch(i){console.warn(i)}}}}).catch(n=>{throw Ji.create("idb-open",{originalErrorMessage:n.message})})),dm}async function sk(n){try{const i=(await Px()).transaction(Do),a=await i.objectStore(Do).get(Lx(n));return await i.done,a}catch(e){if(e instanceof gi)pi.warn(e.message);else{const i=Ji.create("idb-get",{originalErrorMessage:e?.message});pi.warn(i.message)}}}async function U1(n,e){try{const a=(await Px()).transaction(Do,"readwrite");await a.objectStore(Do).put(e,Lx(n)),await a.done}catch(i){if(i instanceof gi)pi.warn(i.message);else{const a=Ji.create("idb-set",{originalErrorMessage:i?.message});pi.warn(a.message)}}}function Lx(n){return`${n.name}!${n.options.appId}`}const ok=1024,lk=30;class ck{constructor(e){this.container=e,this._heartbeatsCache=null;const i=this.container.getProvider("app").getImmediate();this._storage=new dk(i),this._heartbeatsCachePromise=this._storage.read().then(a=>(this._heartbeatsCache=a,a))}async triggerHeartbeat(){try{const i=this.container.getProvider("platform-logger").getImmediate().getPlatformInfoString(),a=B1();if(this._heartbeatsCache?.heartbeats==null&&(this._heartbeatsCache=await this._heartbeatsCachePromise,this._heartbeatsCache?.heartbeats==null)||this._heartbeatsCache.lastSentHeartbeatDate===a||this._heartbeatsCache.heartbeats.some(o=>o.date===a))return;if(this._heartbeatsCache.heartbeats.push({date:a,agent:i}),this._heartbeatsCache.heartbeats.length>lk){const o=pk(this._heartbeatsCache.heartbeats);this._heartbeatsCache.heartbeats.splice(o,1)}return this._storage.overwrite(this._heartbeatsCache)}catch(e){pi.warn(e)}}async getHeartbeatsHeader(){try{if(this._heartbeatsCache===null&&await this._heartbeatsCachePromise,this._heartbeatsCache?.heartbeats==null||this._heartbeatsCache.heartbeats.length===0)return"";const e=B1(),{heartbeatsToSend:i,unsentEntries:a}=uk(this._heartbeatsCache.heartbeats),o=Hc(JSON.stringify({version:2,heartbeats:i}));return this._heartbeatsCache.lastSentHeartbeatDate=e,a.length>0?(this._heartbeatsCache.heartbeats=a,await this._storage.overwrite(this._heartbeatsCache)):(this._heartbeatsCache.heartbeats=[],this._storage.overwrite(this._heartbeatsCache)),o}catch(e){return pi.warn(e),""}}}function B1(){return new Date().toISOString().substring(0,10)}function uk(n,e=ok){const i=[];let a=n.slice();for(const o of n){const c=i.find(d=>d.agent===o.agent);if(c){if(c.dates.push(o.date),z1(i)>e){c.dates.pop();break}}else if(i.push({agent:o.agent,dates:[o.date]}),z1(i)>e){i.pop();break}a=a.slice(1)}return{heartbeatsToSend:i,unsentEntries:a}}class dk{constructor(e){this.app=e,this._canUseIndexedDBPromise=this.runIndexedDBEnvironmentCheck()}async runIndexedDBEnvironmentCheck(){return K_()?Q_().then(()=>!0).catch(()=>!1):!1}async read(){if(await this._canUseIndexedDBPromise){const i=await sk(this.app);return i?.heartbeats?i:{heartbeats:[]}}else return{heartbeats:[]}}async overwrite(e){if(await this._canUseIndexedDBPromise){const a=await this.read();return U1(this.app,{lastSentHeartbeatDate:e.lastSentHeartbeatDate??a.lastSentHeartbeatDate,heartbeats:e.heartbeats})}else return}async add(e){if(await this._canUseIndexedDBPromise){const a=await this.read();return U1(this.app,{lastSentHeartbeatDate:e.lastSentHeartbeatDate??a.lastSentHeartbeatDate,heartbeats:[...a.heartbeats,...e.heartbeats]})}else return}}function z1(n){return Hc(JSON.stringify({version:2,heartbeats:n})).length}function pk(n){if(n.length===0)return-1;let e=0,i=n[0].date;for(let a=1;a<n.length;a++)n[a].date<i&&(i=n[a].date,e=a);return e}function mk(n){Br(new ir("platform-logger",e=>new _T(e),"PRIVATE")),Br(new ir("heartbeat",e=>new ck(e),"PRIVATE")),Dn(jm,P1,n),Dn(jm,P1,"esm2020"),Dn("fire-js","")}mk("");var fk="firebase",hk="12.7.0";Dn(fk,hk,"app");function Ux(){return{"dependent-sdk-initialized-before-auth":"Another Firebase SDK was initialized and is trying to use Auth before Auth is initialized. Please be sure to call `initializeAuth` or `getAuth` before starting any other Firebase SDK."}}const gk=Ux,Bx=new Ko("auth","Firebase",Ux());const Kc=new hf("@firebase/auth");function yk(n,...e){Kc.logLevel<=Be.WARN&&Kc.warn(`Auth (${Wr}): ${n}`,...e)}function Pc(n,...e){Kc.logLevel<=Be.ERROR&&Kc.error(`Auth (${Wr}): ${n}`,...e)}function gn(n,...e){throw xf(n,...e)}function On(n,...e){return xf(n,...e)}function vf(n,e,i){const a={...gk(),[e]:i};return new Ko("auth","Firebase",a).create(e,{appName:n.name})}function ci(n){return vf(n,"operation-not-supported-in-this-environment","Operations that alter the current user are not supported in conjunction with FirebaseServerApp")}function vk(n,e,i){const a=i;if(!(e instanceof a))throw a.name!==e.constructor.name&&gn(n,"argument-error"),vf(n,"argument-error",`Type of ${e.constructor.name} does not match expected instance.Did you pass a reference from a different Auth SDK?`)}function xf(n,...e){if(typeof n!="string"){const i=e[0],a=[...e.slice(1)];return a[0]&&(a[0].appName=n.name),n._errorFactory.create(i,...a)}return Bx.create(n,...e)}function re(n,e,...i){if(!n)throw xf(e,...i)}function ai(n){const e="INTERNAL ASSERTION FAILED: "+n;throw Pc(e),new Error(e)}function mi(n,e){n||ai(e)}function Rm(){return typeof self<"u"&&self.location?.href||""}function xk(){return F1()==="http:"||F1()==="https:"}function F1(){return typeof self<"u"&&self.location?.protocol||null}function bk(){return typeof navigator<"u"&&navigator&&"onLine"in navigator&&typeof navigator.onLine=="boolean"&&(xk()||G_()||"connection"in navigator)?navigator.onLine:!0}function wk(){if(typeof navigator>"u")return null;const n=navigator;return n.languages&&n.languages[0]||n.language||null}class Qo{constructor(e,i){this.shortDelay=e,this.longDelay=i,mi(i>e,"Short delay should be less than long delay!"),this.isMobile=ff()||Ax()}get(){return bk()?this.isMobile?this.longDelay:this.shortDelay:Math.min(5e3,this.shortDelay)}}function bf(n,e){mi(n.emulator,"Emulator should always be set here");const{url:i}=n.emulator;return e?`${i}${e.startsWith("/")?e.slice(1):e}`:i}class zx{static initialize(e,i,a){this.fetchImpl=e,i&&(this.headersImpl=i),a&&(this.responseImpl=a)}static fetch(){if(this.fetchImpl)return this.fetchImpl;if(typeof self<"u"&&"fetch"in self)return self.fetch;if(typeof globalThis<"u"&&globalThis.fetch)return globalThis.fetch;if(typeof fetch<"u")return fetch;ai("Could not find fetch implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill")}static headers(){if(this.headersImpl)return this.headersImpl;if(typeof self<"u"&&"Headers"in self)return self.Headers;if(typeof globalThis<"u"&&globalThis.Headers)return globalThis.Headers;if(typeof Headers<"u")return Headers;ai("Could not find Headers implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill")}static response(){if(this.responseImpl)return this.responseImpl;if(typeof self<"u"&&"Response"in self)return self.Response;if(typeof globalThis<"u"&&globalThis.Response)return globalThis.Response;if(typeof Response<"u")return Response;ai("Could not find Response implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill")}}const Sk={CREDENTIAL_MISMATCH:"custom-token-mismatch",MISSING_CUSTOM_TOKEN:"internal-error",INVALID_IDENTIFIER:"invalid-email",MISSING_CONTINUE_URI:"internal-error",INVALID_PASSWORD:"wrong-password",MISSING_PASSWORD:"missing-password",INVALID_LOGIN_CREDENTIALS:"invalid-credential",EMAIL_EXISTS:"email-already-in-use",PASSWORD_LOGIN_DISABLED:"operation-not-allowed",INVALID_IDP_RESPONSE:"invalid-credential",INVALID_PENDING_TOKEN:"invalid-credential",FEDERATED_USER_ID_ALREADY_LINKED:"credential-already-in-use",MISSING_REQ_TYPE:"internal-error",EMAIL_NOT_FOUND:"user-not-found",RESET_PASSWORD_EXCEED_LIMIT:"too-many-requests",EXPIRED_OOB_CODE:"expired-action-code",INVALID_OOB_CODE:"invalid-action-code",MISSING_OOB_CODE:"internal-error",CREDENTIAL_TOO_OLD_LOGIN_AGAIN:"requires-recent-login",INVALID_ID_TOKEN:"invalid-user-token",TOKEN_EXPIRED:"user-token-expired",USER_NOT_FOUND:"user-token-expired",TOO_MANY_ATTEMPTS_TRY_LATER:"too-many-requests",PASSWORD_DOES_NOT_MEET_REQUIREMENTS:"password-does-not-meet-requirements",INVALID_CODE:"invalid-verification-code",INVALID_SESSION_INFO:"invalid-verification-id",INVALID_TEMPORARY_PROOF:"invalid-credential",MISSING_SESSION_INFO:"missing-verification-id",SESSION_EXPIRED:"code-expired",MISSING_ANDROID_PACKAGE_NAME:"missing-android-pkg-name",UNAUTHORIZED_DOMAIN:"unauthorized-continue-uri",INVALID_OAUTH_CLIENT_ID:"invalid-oauth-client-id",ADMIN_ONLY_OPERATION:"admin-restricted-operation",INVALID_MFA_PENDING_CREDENTIAL:"invalid-multi-factor-session",MFA_ENROLLMENT_NOT_FOUND:"multi-factor-info-not-found",MISSING_MFA_ENROLLMENT_ID:"missing-multi-factor-info",MISSING_MFA_PENDING_CREDENTIAL:"missing-multi-factor-session",SECOND_FACTOR_EXISTS:"second-factor-already-in-use",SECOND_FACTOR_LIMIT_EXCEEDED:"maximum-second-factor-count-exceeded",BLOCKING_FUNCTION_ERROR_RESPONSE:"internal-error",RECAPTCHA_NOT_ENABLED:"recaptcha-not-enabled",MISSING_RECAPTCHA_TOKEN:"missing-recaptcha-token",INVALID_RECAPTCHA_TOKEN:"invalid-recaptcha-token",INVALID_RECAPTCHA_ACTION:"invalid-recaptcha-action",MISSING_CLIENT_TYPE:"missing-client-type",MISSING_RECAPTCHA_VERSION:"missing-recaptcha-version",INVALID_RECAPTCHA_VERSION:"invalid-recaptcha-version",INVALID_REQ_TYPE:"invalid-req-type"};const Ck=["/v1/accounts:signInWithCustomToken","/v1/accounts:signInWithEmailLink","/v1/accounts:signInWithIdp","/v1/accounts:signInWithPassword","/v1/accounts:signInWithPhoneNumber","/v1/token"],Ok=new Qo(3e4,6e4);function ur(n,e){return n.tenantId&&!e.tenantId?{...e,tenantId:n.tenantId}:e}async function yi(n,e,i,a,o={}){return Fx(n,o,async()=>{let c={},d={};a&&(e==="GET"?d=a:c={body:JSON.stringify(a)});const m=ss({key:n.config.apiKey,...d}).slice(1),f=await n._getAdditionalHeaders();f["Content-Type"]="application/json",n.languageCode&&(f["X-Firebase-Locale"]=n.languageCode);const h={method:e,headers:f,...c};return Y_()||(h.referrerPolicy="no-referrer"),n.emulatorConfig&&cr(n.emulatorConfig.host)&&(h.credentials="include"),zx.fetch()(await qx(n,n.config.apiHost,i,m),h)})}async function Fx(n,e,i){n._canInitEmulator=!1;const a={...Sk,...e};try{const o=new Tk(n),c=await Promise.race([i(),o.promise]);o.clearNetworkTimeout();const d=await c.json();if("needConfirmation"in d)throw Tc(n,"account-exists-with-different-credential",d);if(c.ok&&!("errorMessage"in d))return d;{const m=c.ok?d.errorMessage:d.error.message,[f,h]=m.split(" : ");if(f==="FEDERATED_USER_ID_ALREADY_LINKED")throw Tc(n,"credential-already-in-use",d);if(f==="EMAIL_EXISTS")throw Tc(n,"email-already-in-use",d);if(f==="USER_DISABLED")throw Tc(n,"user-disabled",d);const x=a[f]||f.toLowerCase().replace(/[_\s]+/g,"-");if(h)throw vf(n,x,h);gn(n,x)}}catch(o){if(o instanceof gi)throw o;gn(n,"network-request-failed",{message:String(o)})}}async function Xo(n,e,i,a,o={}){const c=await yi(n,e,i,a,o);return"mfaPendingCredential"in c&&gn(n,"multi-factor-auth-required",{_serverResponse:c}),c}async function qx(n,e,i,a){const o=`${e}${i}?${a}`,c=n,d=c.config.emulator?bf(n.config,o):`${n.config.apiScheme}://${o}`;return Ck.includes(i)&&(await c._persistenceManagerAvailable,c._getPersistenceType()==="COOKIE")?c._getPersistence()._getFinalTarget(d).toString():d}function _k(n){switch(n){case"ENFORCE":return"ENFORCE";case"AUDIT":return"AUDIT";case"OFF":return"OFF";default:return"ENFORCEMENT_STATE_UNSPECIFIED"}}class Tk{clearNetworkTimeout(){clearTimeout(this.timer)}constructor(e){this.auth=e,this.timer=null,this.promise=new Promise((i,a)=>{this.timer=setTimeout(()=>a(On(this.auth,"network-request-failed")),Ok.get())})}}function Tc(n,e,i){const a={appName:n.name};i.email&&(a.email=i.email),i.phoneNumber&&(a.phoneNumber=i.phoneNumber);const o=On(n,e,a);return o.customData._tokenResponse=i,o}function q1(n){return n!==void 0&&n.enterprise!==void 0}class kk{constructor(e){if(this.siteKey="",this.recaptchaEnforcementState=[],e.recaptchaKey===void 0)throw new Error("recaptchaKey undefined");this.siteKey=e.recaptchaKey.split("/")[3],this.recaptchaEnforcementState=e.recaptchaEnforcementState}getProviderEnforcementState(e){if(!this.recaptchaEnforcementState||this.recaptchaEnforcementState.length===0)return null;for(const i of this.recaptchaEnforcementState)if(i.provider&&i.provider===e)return _k(i.enforcementState);return null}isProviderEnabled(e){return this.getProviderEnforcementState(e)==="ENFORCE"||this.getProviderEnforcementState(e)==="AUDIT"}isAnyProviderEnabled(){return this.isProviderEnabled("EMAIL_PASSWORD_PROVIDER")||this.isProviderEnabled("PHONE_PROVIDER")}}async function Nk(n,e){return yi(n,"GET","/v2/recaptchaConfig",ur(n,e))}async function Ek(n,e){return yi(n,"POST","/v1/accounts:delete",e)}async function Qc(n,e){return yi(n,"POST","/v1/accounts:lookup",e)}function Oo(n){if(n)try{const e=new Date(Number(n));if(!isNaN(e.getTime()))return e.toUTCString()}catch{}}async function jk(n,e=!1){const i=nt(n),a=await i.getIdToken(e),o=wf(a);re(o&&o.exp&&o.auth_time&&o.iat,i.auth,"internal-error");const c=typeof o.firebase=="object"?o.firebase:void 0,d=c?.sign_in_provider;return{claims:o,token:a,authTime:Oo(pm(o.auth_time)),issuedAtTime:Oo(pm(o.iat)),expirationTime:Oo(pm(o.exp)),signInProvider:d||null,signInSecondFactor:c?.sign_in_second_factor||null}}function pm(n){return Number(n)*1e3}function wf(n){const[e,i,a]=n.split(".");if(e===void 0||i===void 0||a===void 0)return Pc("JWT malformed, contained fewer than 3 sections"),null;try{const o=Yc(i);return o?JSON.parse(o):(Pc("Failed to decode base64 JWT payload"),null)}catch(o){return Pc("Caught error parsing JWT payload as JSON",o?.toString()),null}}function H1(n){const e=wf(n);return re(e,"internal-error"),re(typeof e.exp<"u","internal-error"),re(typeof e.iat<"u","internal-error"),Number(e.exp)-Number(e.iat)}async function Xa(n,e,i=!1){if(i)return e;try{return await e}catch(a){throw a instanceof gi&&Ak(a)&&n.auth.currentUser===n&&await n.auth.signOut(),a}}function Ak({code:n}){return n==="auth/user-disabled"||n==="auth/user-token-expired"}class Mk{constructor(e){this.user=e,this.isRunning=!1,this.timerId=null,this.errorBackoff=3e4}_start(){this.isRunning||(this.isRunning=!0,this.schedule())}_stop(){this.isRunning&&(this.isRunning=!1,this.timerId!==null&&clearTimeout(this.timerId))}getInterval(e){if(e){const i=this.errorBackoff;return this.errorBackoff=Math.min(this.errorBackoff*2,96e4),i}else{this.errorBackoff=3e4;const a=(this.user.stsTokenManager.expirationTime??0)-Date.now()-3e5;return Math.max(0,a)}}schedule(e=!1){if(!this.isRunning)return;const i=this.getInterval(e);this.timerId=setTimeout(async()=>{await this.iteration()},i)}async iteration(){try{await this.user.getIdToken(!0)}catch(e){e?.code==="auth/network-request-failed"&&this.schedule(!0);return}this.schedule()}}class Dm{constructor(e,i){this.createdAt=e,this.lastLoginAt=i,this._initializeTime()}_initializeTime(){this.lastSignInTime=Oo(this.lastLoginAt),this.creationTime=Oo(this.createdAt)}_copy(e){this.createdAt=e.createdAt,this.lastLoginAt=e.lastLoginAt,this._initializeTime()}toJSON(){return{createdAt:this.createdAt,lastLoginAt:this.lastLoginAt}}}async function Xc(n){const e=n.auth,i=await n.getIdToken(),a=await Xa(n,Qc(e,{idToken:i}));re(a?.users.length,e,"internal-error");const o=a.users[0];n._notifyReloadListener(o);const c=o.providerUserInfo?.length?Hx(o.providerUserInfo):[],d=Dk(n.providerData,c),m=n.isAnonymous,f=!(n.email&&o.passwordHash)&&!d?.length,h=m?f:!1,x={uid:o.localId,displayName:o.displayName||null,photoURL:o.photoUrl||null,email:o.email||null,emailVerified:o.emailVerified||!1,phoneNumber:o.phoneNumber||null,tenantId:o.tenantId||null,providerData:d,metadata:new Dm(o.createdAt,o.lastLoginAt),isAnonymous:h};Object.assign(n,x)}async function Rk(n){const e=nt(n);await Xc(e),await e.auth._persistUserIfCurrent(e),e.auth._notifyListenersIfCurrent(e)}function Dk(n,e){return[...n.filter(a=>!e.some(o=>o.providerId===a.providerId)),...e]}function Hx(n){return n.map(({providerId:e,...i})=>({providerId:e,uid:i.rawId||"",displayName:i.displayName||null,email:i.email||null,phoneNumber:i.phoneNumber||null,photoURL:i.photoUrl||null}))}async function Ik(n,e){const i=await Fx(n,{},async()=>{const a=ss({grant_type:"refresh_token",refresh_token:e}).slice(1),{tokenApiHost:o,apiKey:c}=n.config,d=await qx(n,o,"/v1/token",`key=${c}`),m=await n._getAdditionalHeaders();m["Content-Type"]="application/x-www-form-urlencoded";const f={method:"POST",headers:m,body:a};return n.emulatorConfig&&cr(n.emulatorConfig.host)&&(f.credentials="include"),zx.fetch()(d,f)});return{accessToken:i.access_token,expiresIn:i.expires_in,refreshToken:i.refresh_token}}async function Pk(n,e){return yi(n,"POST","/v2/accounts:revokeToken",ur(n,e))}class Ha{constructor(){this.refreshToken=null,this.accessToken=null,this.expirationTime=null}get isExpired(){return!this.expirationTime||Date.now()>this.expirationTime-3e4}updateFromServerResponse(e){re(e.idToken,"internal-error"),re(typeof e.idToken<"u","internal-error"),re(typeof e.refreshToken<"u","internal-error");const i="expiresIn"in e&&typeof e.expiresIn<"u"?Number(e.expiresIn):H1(e.idToken);this.updateTokensAndExpiration(e.idToken,e.refreshToken,i)}updateFromIdToken(e){re(e.length!==0,"internal-error");const i=H1(e);this.updateTokensAndExpiration(e,null,i)}async getToken(e,i=!1){return!i&&this.accessToken&&!this.isExpired?this.accessToken:(re(this.refreshToken,e,"user-token-expired"),this.refreshToken?(await this.refresh(e,this.refreshToken),this.accessToken):null)}clearRefreshToken(){this.refreshToken=null}async refresh(e,i){const{accessToken:a,refreshToken:o,expiresIn:c}=await Ik(e,i);this.updateTokensAndExpiration(a,o,Number(c))}updateTokensAndExpiration(e,i,a){this.refreshToken=i||null,this.accessToken=e||null,this.expirationTime=Date.now()+a*1e3}static fromJSON(e,i){const{refreshToken:a,accessToken:o,expirationTime:c}=i,d=new Ha;return a&&(re(typeof a=="string","internal-error",{appName:e}),d.refreshToken=a),o&&(re(typeof o=="string","internal-error",{appName:e}),d.accessToken=o),c&&(re(typeof c=="number","internal-error",{appName:e}),d.expirationTime=c),d}toJSON(){return{refreshToken:this.refreshToken,accessToken:this.accessToken,expirationTime:this.expirationTime}}_assign(e){this.accessToken=e.accessToken,this.refreshToken=e.refreshToken,this.expirationTime=e.expirationTime}_clone(){return Object.assign(new Ha,this.toJSON())}_performRefresh(){return ai("not implemented")}}function Vi(n,e){re(typeof n=="string"||typeof n>"u","internal-error",{appName:e})}class Sn{constructor({uid:e,auth:i,stsTokenManager:a,...o}){this.providerId="firebase",this.proactiveRefresh=new Mk(this),this.reloadUserInfo=null,this.reloadListener=null,this.uid=e,this.auth=i,this.stsTokenManager=a,this.accessToken=a.accessToken,this.displayName=o.displayName||null,this.email=o.email||null,this.emailVerified=o.emailVerified||!1,this.phoneNumber=o.phoneNumber||null,this.photoURL=o.photoURL||null,this.isAnonymous=o.isAnonymous||!1,this.tenantId=o.tenantId||null,this.providerData=o.providerData?[...o.providerData]:[],this.metadata=new Dm(o.createdAt||void 0,o.lastLoginAt||void 0)}async getIdToken(e){const i=await Xa(this,this.stsTokenManager.getToken(this.auth,e));return re(i,this.auth,"internal-error"),this.accessToken!==i&&(this.accessToken=i,await this.auth._persistUserIfCurrent(this),this.auth._notifyListenersIfCurrent(this)),i}getIdTokenResult(e){return jk(this,e)}reload(){return Rk(this)}_assign(e){this!==e&&(re(this.uid===e.uid,this.auth,"internal-error"),this.displayName=e.displayName,this.photoURL=e.photoURL,this.email=e.email,this.emailVerified=e.emailVerified,this.phoneNumber=e.phoneNumber,this.isAnonymous=e.isAnonymous,this.tenantId=e.tenantId,this.providerData=e.providerData.map(i=>({...i})),this.metadata._copy(e.metadata),this.stsTokenManager._assign(e.stsTokenManager))}_clone(e){const i=new Sn({...this,auth:e,stsTokenManager:this.stsTokenManager._clone()});return i.metadata._copy(this.metadata),i}_onReload(e){re(!this.reloadListener,this.auth,"internal-error"),this.reloadListener=e,this.reloadUserInfo&&(this._notifyReloadListener(this.reloadUserInfo),this.reloadUserInfo=null)}_notifyReloadListener(e){this.reloadListener?this.reloadListener(e):this.reloadUserInfo=e}_startProactiveRefresh(){this.proactiveRefresh._start()}_stopProactiveRefresh(){this.proactiveRefresh._stop()}async _updateTokensIfNecessary(e,i=!1){let a=!1;e.idToken&&e.idToken!==this.stsTokenManager.accessToken&&(this.stsTokenManager.updateFromServerResponse(e),a=!0),i&&await Xc(this),await this.auth._persistUserIfCurrent(this),a&&this.auth._notifyListenersIfCurrent(this)}async delete(){if(Ht(this.auth.app))return Promise.reject(ci(this.auth));const e=await this.getIdToken();return await Xa(this,Ek(this.auth,{idToken:e})),this.stsTokenManager.clearRefreshToken(),this.auth.signOut()}toJSON(){return{uid:this.uid,email:this.email||void 0,emailVerified:this.emailVerified,displayName:this.displayName||void 0,isAnonymous:this.isAnonymous,photoURL:this.photoURL||void 0,phoneNumber:this.phoneNumber||void 0,tenantId:this.tenantId||void 0,providerData:this.providerData.map(e=>({...e})),stsTokenManager:this.stsTokenManager.toJSON(),_redirectEventId:this._redirectEventId,...this.metadata.toJSON(),apiKey:this.auth.config.apiKey,appName:this.auth.name}}get refreshToken(){return this.stsTokenManager.refreshToken||""}static _fromJSON(e,i){const a=i.displayName??void 0,o=i.email??void 0,c=i.phoneNumber??void 0,d=i.photoURL??void 0,m=i.tenantId??void 0,f=i._redirectEventId??void 0,h=i.createdAt??void 0,x=i.lastLoginAt??void 0,{uid:v,emailVerified:b,isAnonymous:_,providerData:N,stsTokenManager:D}=i;re(v&&D,e,"internal-error");const q=Ha.fromJSON(this.name,D);re(typeof v=="string",e,"internal-error"),Vi(a,e.name),Vi(o,e.name),re(typeof b=="boolean",e,"internal-error"),re(typeof _=="boolean",e,"internal-error"),Vi(c,e.name),Vi(d,e.name),Vi(m,e.name),Vi(f,e.name),Vi(h,e.name),Vi(x,e.name);const F=new Sn({uid:v,auth:e,email:o,emailVerified:b,displayName:a,isAnonymous:_,photoURL:d,phoneNumber:c,tenantId:m,stsTokenManager:q,createdAt:h,lastLoginAt:x});return N&&Array.isArray(N)&&(F.providerData=N.map(I=>({...I}))),f&&(F._redirectEventId=f),F}static async _fromIdTokenResponse(e,i,a=!1){const o=new Ha;o.updateFromServerResponse(i);const c=new Sn({uid:i.localId,auth:e,stsTokenManager:o,isAnonymous:a});return await Xc(c),c}static async _fromGetAccountInfoResponse(e,i,a){const o=i.users[0];re(o.localId!==void 0,"internal-error");const c=o.providerUserInfo!==void 0?Hx(o.providerUserInfo):[],d=!(o.email&&o.passwordHash)&&!c?.length,m=new Ha;m.updateFromIdToken(a);const f=new Sn({uid:o.localId,auth:e,stsTokenManager:m,isAnonymous:d}),h={uid:o.localId,displayName:o.displayName||null,photoURL:o.photoUrl||null,email:o.email||null,emailVerified:o.emailVerified||!1,phoneNumber:o.phoneNumber||null,tenantId:o.tenantId||null,providerData:c,metadata:new Dm(o.createdAt,o.lastLoginAt),isAnonymous:!(o.email&&o.passwordHash)&&!c?.length};return Object.assign(f,h),f}}const Y1=new Map;function si(n){mi(n instanceof Function,"Expected a class definition");let e=Y1.get(n);return e?(mi(e instanceof n,"Instance stored in cache mismatched with class"),e):(e=new n,Y1.set(n,e),e)}class Yx{constructor(){this.type="NONE",this.storage={}}async _isAvailable(){return!0}async _set(e,i){this.storage[e]=i}async _get(e){const i=this.storage[e];return i===void 0?null:i}async _remove(e){delete this.storage[e]}_addListener(e,i){}_removeListener(e,i){}}Yx.type="NONE";const G1=Yx;function Lc(n,e,i){return`firebase:${n}:${e}:${i}`}class Ya{constructor(e,i,a){this.persistence=e,this.auth=i,this.userKey=a;const{config:o,name:c}=this.auth;this.fullUserKey=Lc(this.userKey,o.apiKey,c),this.fullPersistenceKey=Lc("persistence",o.apiKey,c),this.boundEventHandler=i._onStorageEvent.bind(i),this.persistence._addListener(this.fullUserKey,this.boundEventHandler)}setCurrentUser(e){return this.persistence._set(this.fullUserKey,e.toJSON())}async getCurrentUser(){const e=await this.persistence._get(this.fullUserKey);if(!e)return null;if(typeof e=="string"){const i=await Qc(this.auth,{idToken:e}).catch(()=>{});return i?Sn._fromGetAccountInfoResponse(this.auth,i,e):null}return Sn._fromJSON(this.auth,e)}removeCurrentUser(){return this.persistence._remove(this.fullUserKey)}savePersistenceForRedirect(){return this.persistence._set(this.fullPersistenceKey,this.persistence.type)}async setPersistence(e){if(this.persistence===e)return;const i=await this.getCurrentUser();if(await this.removeCurrentUser(),this.persistence=e,i)return this.setCurrentUser(i)}delete(){this.persistence._removeListener(this.fullUserKey,this.boundEventHandler)}static async create(e,i,a="authUser"){if(!i.length)return new Ya(si(G1),e,a);const o=(await Promise.all(i.map(async h=>{if(await h._isAvailable())return h}))).filter(h=>h);let c=o[0]||si(G1);const d=Lc(a,e.config.apiKey,e.name);let m=null;for(const h of i)try{const x=await h._get(d);if(x){let v;if(typeof x=="string"){const b=await Qc(e,{idToken:x}).catch(()=>{});if(!b)break;v=await Sn._fromGetAccountInfoResponse(e,b,x)}else v=Sn._fromJSON(e,x);h!==c&&(m=v),c=h;break}}catch{}const f=o.filter(h=>h._shouldAllowMigration);return!c._shouldAllowMigration||!f.length?new Ya(c,e,a):(c=f[0],m&&await c._set(d,m.toJSON()),await Promise.all(i.map(async h=>{if(h!==c)try{await h._remove(d)}catch{}})),new Ya(c,e,a))}}function V1(n){const e=n.toLowerCase();if(e.includes("opera/")||e.includes("opr/")||e.includes("opios/"))return"Opera";if(Kx(e))return"IEMobile";if(e.includes("msie")||e.includes("trident/"))return"IE";if(e.includes("edge/"))return"Edge";if(Gx(e))return"Firefox";if(e.includes("silk/"))return"Silk";if(Xx(e))return"Blackberry";if($x(e))return"Webos";if(Vx(e))return"Safari";if((e.includes("chrome/")||Wx(e))&&!e.includes("edge/"))return"Chrome";if(Qx(e))return"Android";{const i=/([a-zA-Z\d\.]+)\/[a-zA-Z\d\.]*$/,a=n.match(i);if(a?.length===2)return a[1]}return"Other"}function Gx(n=Mt()){return/firefox\//i.test(n)}function Vx(n=Mt()){const e=n.toLowerCase();return e.includes("safari/")&&!e.includes("chrome/")&&!e.includes("crios/")&&!e.includes("android")}function Wx(n=Mt()){return/crios\//i.test(n)}function Kx(n=Mt()){return/iemobile/i.test(n)}function Qx(n=Mt()){return/android/i.test(n)}function Xx(n=Mt()){return/blackberry/i.test(n)}function $x(n=Mt()){return/webos/i.test(n)}function Sf(n=Mt()){return/iphone|ipad|ipod/i.test(n)||/macintosh/i.test(n)&&/mobile/i.test(n)}function Lk(n=Mt()){return Sf(n)&&!!window.navigator?.standalone}function Uk(){return V_()&&document.documentMode===10}function Zx(n=Mt()){return Sf(n)||Qx(n)||$x(n)||Xx(n)||/windows phone/i.test(n)||Kx(n)}function Jx(n,e=[]){let i;switch(n){case"Browser":i=V1(Mt());break;case"Worker":i=`${V1(Mt())}-${n}`;break;default:i=n}const a=e.length?e.join(","):"FirebaseCore-web";return`${i}/JsCore/${Wr}/${a}`}class Bk{constructor(e){this.auth=e,this.queue=[]}pushCallback(e,i){const a=c=>new Promise((d,m)=>{try{const f=e(c);d(f)}catch(f){m(f)}});a.onAbort=i,this.queue.push(a);const o=this.queue.length-1;return()=>{this.queue[o]=()=>Promise.resolve()}}async runMiddleware(e){if(this.auth.currentUser===e)return;const i=[];try{for(const a of this.queue)await a(e),a.onAbort&&i.push(a.onAbort)}catch(a){i.reverse();for(const o of i)try{o()}catch{}throw this.auth._errorFactory.create("login-blocked",{originalMessage:a?.message})}}}async function zk(n,e={}){return yi(n,"GET","/v2/passwordPolicy",ur(n,e))}const Fk=6;class qk{constructor(e){const i=e.customStrengthOptions;this.customStrengthOptions={},this.customStrengthOptions.minPasswordLength=i.minPasswordLength??Fk,i.maxPasswordLength&&(this.customStrengthOptions.maxPasswordLength=i.maxPasswordLength),i.containsLowercaseCharacter!==void 0&&(this.customStrengthOptions.containsLowercaseLetter=i.containsLowercaseCharacter),i.containsUppercaseCharacter!==void 0&&(this.customStrengthOptions.containsUppercaseLetter=i.containsUppercaseCharacter),i.containsNumericCharacter!==void 0&&(this.customStrengthOptions.containsNumericCharacter=i.containsNumericCharacter),i.containsNonAlphanumericCharacter!==void 0&&(this.customStrengthOptions.containsNonAlphanumericCharacter=i.containsNonAlphanumericCharacter),this.enforcementState=e.enforcementState,this.enforcementState==="ENFORCEMENT_STATE_UNSPECIFIED"&&(this.enforcementState="OFF"),this.allowedNonAlphanumericCharacters=e.allowedNonAlphanumericCharacters?.join("")??"",this.forceUpgradeOnSignin=e.forceUpgradeOnSignin??!1,this.schemaVersion=e.schemaVersion}validatePassword(e){const i={isValid:!0,passwordPolicy:this};return this.validatePasswordLengthOptions(e,i),this.validatePasswordCharacterOptions(e,i),i.isValid&&(i.isValid=i.meetsMinPasswordLength??!0),i.isValid&&(i.isValid=i.meetsMaxPasswordLength??!0),i.isValid&&(i.isValid=i.containsLowercaseLetter??!0),i.isValid&&(i.isValid=i.containsUppercaseLetter??!0),i.isValid&&(i.isValid=i.containsNumericCharacter??!0),i.isValid&&(i.isValid=i.containsNonAlphanumericCharacter??!0),i}validatePasswordLengthOptions(e,i){const a=this.customStrengthOptions.minPasswordLength,o=this.customStrengthOptions.maxPasswordLength;a&&(i.meetsMinPasswordLength=e.length>=a),o&&(i.meetsMaxPasswordLength=e.length<=o)}validatePasswordCharacterOptions(e,i){this.updatePasswordCharacterOptionsStatuses(i,!1,!1,!1,!1);let a;for(let o=0;o<e.length;o++)a=e.charAt(o),this.updatePasswordCharacterOptionsStatuses(i,a>="a"&&a<="z",a>="A"&&a<="Z",a>="0"&&a<="9",this.allowedNonAlphanumericCharacters.includes(a))}updatePasswordCharacterOptionsStatuses(e,i,a,o,c){this.customStrengthOptions.containsLowercaseLetter&&(e.containsLowercaseLetter||(e.containsLowercaseLetter=i)),this.customStrengthOptions.containsUppercaseLetter&&(e.containsUppercaseLetter||(e.containsUppercaseLetter=a)),this.customStrengthOptions.containsNumericCharacter&&(e.containsNumericCharacter||(e.containsNumericCharacter=o)),this.customStrengthOptions.containsNonAlphanumericCharacter&&(e.containsNonAlphanumericCharacter||(e.containsNonAlphanumericCharacter=c))}}class Hk{constructor(e,i,a,o){this.app=e,this.heartbeatServiceProvider=i,this.appCheckServiceProvider=a,this.config=o,this.currentUser=null,this.emulatorConfig=null,this.operations=Promise.resolve(),this.authStateSubscription=new W1(this),this.idTokenSubscription=new W1(this),this.beforeStateQueue=new Bk(this),this.redirectUser=null,this.isProactiveRefreshEnabled=!1,this.EXPECTED_PASSWORD_POLICY_SCHEMA_VERSION=1,this._canInitEmulator=!0,this._isInitialized=!1,this._deleted=!1,this._initializationPromise=null,this._popupRedirectResolver=null,this._errorFactory=Bx,this._agentRecaptchaConfig=null,this._tenantRecaptchaConfigs={},this._projectPasswordPolicy=null,this._tenantPasswordPolicies={},this._resolvePersistenceManagerAvailable=void 0,this.lastNotifiedUid=void 0,this.languageCode=null,this.tenantId=null,this.settings={appVerificationDisabledForTesting:!1},this.frameworks=[],this.name=e.name,this.clientVersion=o.sdkClientVersion,this._persistenceManagerAvailable=new Promise(c=>this._resolvePersistenceManagerAvailable=c)}_initializeWithPersistence(e,i){return i&&(this._popupRedirectResolver=si(i)),this._initializationPromise=this.queue(async()=>{if(!this._deleted&&(this.persistenceManager=await Ya.create(this,e),this._resolvePersistenceManagerAvailable?.(),!this._deleted)){if(this._popupRedirectResolver?._shouldInitProactively)try{await this._popupRedirectResolver._initialize(this)}catch{}await this.initializeCurrentUser(i),this.lastNotifiedUid=this.currentUser?.uid||null,!this._deleted&&(this._isInitialized=!0)}}),this._initializationPromise}async _onStorageEvent(){if(this._deleted)return;const e=await this.assertedPersistence.getCurrentUser();if(!(!this.currentUser&&!e)){if(this.currentUser&&e&&this.currentUser.uid===e.uid){this._currentUser._assign(e),await this.currentUser.getIdToken();return}await this._updateCurrentUser(e,!0)}}async initializeCurrentUserFromIdToken(e){try{const i=await Qc(this,{idToken:e}),a=await Sn._fromGetAccountInfoResponse(this,i,e);await this.directlySetCurrentUser(a)}catch(i){console.warn("FirebaseServerApp could not login user with provided authIdToken: ",i),await this.directlySetCurrentUser(null)}}async initializeCurrentUser(e){if(Ht(this.app)){const c=this.app.settings.authIdToken;return c?new Promise(d=>{setTimeout(()=>this.initializeCurrentUserFromIdToken(c).then(d,d))}):this.directlySetCurrentUser(null)}const i=await this.assertedPersistence.getCurrentUser();let a=i,o=!1;if(e&&this.config.authDomain){await this.getOrInitRedirectPersistenceManager();const c=this.redirectUser?._redirectEventId,d=a?._redirectEventId,m=await this.tryRedirectSignIn(e);(!c||c===d)&&m?.user&&(a=m.user,o=!0)}if(!a)return this.directlySetCurrentUser(null);if(!a._redirectEventId){if(o)try{await this.beforeStateQueue.runMiddleware(a)}catch(c){a=i,this._popupRedirectResolver._overrideRedirectResult(this,()=>Promise.reject(c))}return a?this.reloadAndSetCurrentUserOrClear(a):this.directlySetCurrentUser(null)}return re(this._popupRedirectResolver,this,"argument-error"),await this.getOrInitRedirectPersistenceManager(),this.redirectUser&&this.redirectUser._redirectEventId===a._redirectEventId?this.directlySetCurrentUser(a):this.reloadAndSetCurrentUserOrClear(a)}async tryRedirectSignIn(e){let i=null;try{i=await this._popupRedirectResolver._completeRedirectFn(this,e,!0)}catch{await this._setRedirectUser(null)}return i}async reloadAndSetCurrentUserOrClear(e){try{await Xc(e)}catch(i){if(i?.code!=="auth/network-request-failed")return this.directlySetCurrentUser(null)}return this.directlySetCurrentUser(e)}useDeviceLanguage(){this.languageCode=wk()}async _delete(){this._deleted=!0}async updateCurrentUser(e){if(Ht(this.app))return Promise.reject(ci(this));const i=e?nt(e):null;return i&&re(i.auth.config.apiKey===this.config.apiKey,this,"invalid-user-token"),this._updateCurrentUser(i&&i._clone(this))}async _updateCurrentUser(e,i=!1){if(!this._deleted)return e&&re(this.tenantId===e.tenantId,this,"tenant-id-mismatch"),i||await this.beforeStateQueue.runMiddleware(e),this.queue(async()=>{await this.directlySetCurrentUser(e),this.notifyAuthListeners()})}async signOut(){return Ht(this.app)?Promise.reject(ci(this)):(await this.beforeStateQueue.runMiddleware(null),(this.redirectPersistenceManager||this._popupRedirectResolver)&&await this._setRedirectUser(null),this._updateCurrentUser(null,!0))}setPersistence(e){return Ht(this.app)?Promise.reject(ci(this)):this.queue(async()=>{await this.assertedPersistence.setPersistence(si(e))})}_getRecaptchaConfig(){return this.tenantId==null?this._agentRecaptchaConfig:this._tenantRecaptchaConfigs[this.tenantId]}async validatePassword(e){this._getPasswordPolicyInternal()||await this._updatePasswordPolicy();const i=this._getPasswordPolicyInternal();return i.schemaVersion!==this.EXPECTED_PASSWORD_POLICY_SCHEMA_VERSION?Promise.reject(this._errorFactory.create("unsupported-password-policy-schema-version",{})):i.validatePassword(e)}_getPasswordPolicyInternal(){return this.tenantId===null?this._projectPasswordPolicy:this._tenantPasswordPolicies[this.tenantId]}async _updatePasswordPolicy(){const e=await zk(this),i=new qk(e);this.tenantId===null?this._projectPasswordPolicy=i:this._tenantPasswordPolicies[this.tenantId]=i}_getPersistenceType(){return this.assertedPersistence.persistence.type}_getPersistence(){return this.assertedPersistence.persistence}_updateErrorMap(e){this._errorFactory=new Ko("auth","Firebase",e())}onAuthStateChanged(e,i,a){return this.registerStateListener(this.authStateSubscription,e,i,a)}beforeAuthStateChanged(e,i){return this.beforeStateQueue.pushCallback(e,i)}onIdTokenChanged(e,i,a){return this.registerStateListener(this.idTokenSubscription,e,i,a)}authStateReady(){return new Promise((e,i)=>{if(this.currentUser)e();else{const a=this.onAuthStateChanged(()=>{a(),e()},i)}})}async revokeAccessToken(e){if(this.currentUser){const i=await this.currentUser.getIdToken(),a={providerId:"apple.com",tokenType:"ACCESS_TOKEN",token:e,idToken:i};this.tenantId!=null&&(a.tenantId=this.tenantId),await Pk(this,a)}}toJSON(){return{apiKey:this.config.apiKey,authDomain:this.config.authDomain,appName:this.name,currentUser:this._currentUser?.toJSON()}}async _setRedirectUser(e,i){const a=await this.getOrInitRedirectPersistenceManager(i);return e===null?a.removeCurrentUser():a.setCurrentUser(e)}async getOrInitRedirectPersistenceManager(e){if(!this.redirectPersistenceManager){const i=e&&si(e)||this._popupRedirectResolver;re(i,this,"argument-error"),this.redirectPersistenceManager=await Ya.create(this,[si(i._redirectPersistence)],"redirectUser"),this.redirectUser=await this.redirectPersistenceManager.getCurrentUser()}return this.redirectPersistenceManager}async _redirectUserForId(e){return this._isInitialized&&await this.queue(async()=>{}),this._currentUser?._redirectEventId===e?this._currentUser:this.redirectUser?._redirectEventId===e?this.redirectUser:null}async _persistUserIfCurrent(e){if(e===this.currentUser)return this.queue(async()=>this.directlySetCurrentUser(e))}_notifyListenersIfCurrent(e){e===this.currentUser&&this.notifyAuthListeners()}_key(){return`${this.config.authDomain}:${this.config.apiKey}:${this.name}`}_startProactiveRefresh(){this.isProactiveRefreshEnabled=!0,this.currentUser&&this._currentUser._startProactiveRefresh()}_stopProactiveRefresh(){this.isProactiveRefreshEnabled=!1,this.currentUser&&this._currentUser._stopProactiveRefresh()}get _currentUser(){return this.currentUser}notifyAuthListeners(){if(!this._isInitialized)return;this.idTokenSubscription.next(this.currentUser);const e=this.currentUser?.uid??null;this.lastNotifiedUid!==e&&(this.lastNotifiedUid=e,this.authStateSubscription.next(this.currentUser))}registerStateListener(e,i,a,o){if(this._deleted)return()=>{};const c=typeof i=="function"?i:i.next.bind(i);let d=!1;const m=this._isInitialized?Promise.resolve():this._initializationPromise;if(re(m,this,"internal-error"),m.then(()=>{d||c(this.currentUser)}),typeof i=="function"){const f=e.addObserver(i,a,o);return()=>{d=!0,f()}}else{const f=e.addObserver(i);return()=>{d=!0,f()}}}async directlySetCurrentUser(e){this.currentUser&&this.currentUser!==e&&this._currentUser._stopProactiveRefresh(),e&&this.isProactiveRefreshEnabled&&e._startProactiveRefresh(),this.currentUser=e,e?await this.assertedPersistence.setCurrentUser(e):await this.assertedPersistence.removeCurrentUser()}queue(e){return this.operations=this.operations.then(e,e),this.operations}get assertedPersistence(){return re(this.persistenceManager,this,"internal-error"),this.persistenceManager}_logFramework(e){!e||this.frameworks.includes(e)||(this.frameworks.push(e),this.frameworks.sort(),this.clientVersion=Jx(this.config.clientPlatform,this._getFrameworks()))}_getFrameworks(){return this.frameworks}async _getAdditionalHeaders(){const e={"X-Client-Version":this.clientVersion};this.app.options.appId&&(e["X-Firebase-gmpid"]=this.app.options.appId);const i=await this.heartbeatServiceProvider.getImmediate({optional:!0})?.getHeartbeatsHeader();i&&(e["X-Firebase-Client"]=i);const a=await this._getAppCheckToken();return a&&(e["X-Firebase-AppCheck"]=a),e}async _getAppCheckToken(){if(Ht(this.app)&&this.app.settings.appCheckToken)return this.app.settings.appCheckToken;const e=await this.appCheckServiceProvider.getImmediate({optional:!0})?.getToken();return e?.error&&yk(`Error while retrieving App Check token: ${e.error}`),e?.token}}function dr(n){return nt(n)}class W1{constructor(e){this.auth=e,this.observer=null,this.addObserver=nT(i=>this.observer=i)}get next(){return re(this.observer,this.auth,"internal-error"),this.observer.next.bind(this.observer)}}let wu={async loadJS(){throw new Error("Unable to load external scripts")},recaptchaV2Script:"",recaptchaEnterpriseScript:"",gapiScript:""};function Yk(n){wu=n}function eb(n){return wu.loadJS(n)}function Gk(){return wu.recaptchaEnterpriseScript}function Vk(){return wu.gapiScript}function Wk(n){return`__${n}${Math.floor(Math.random()*1e6)}`}class Kk{constructor(){this.enterprise=new Qk}ready(e){e()}execute(e,i){return Promise.resolve("token")}render(e,i){return""}}class Qk{ready(e){e()}execute(e,i){return Promise.resolve("token")}render(e,i){return""}}const Xk="recaptcha-enterprise",tb="NO_RECAPTCHA";class $k{constructor(e){this.type=Xk,this.auth=dr(e)}async verify(e="verify",i=!1){async function a(c){if(!i){if(c.tenantId==null&&c._agentRecaptchaConfig!=null)return c._agentRecaptchaConfig.siteKey;if(c.tenantId!=null&&c._tenantRecaptchaConfigs[c.tenantId]!==void 0)return c._tenantRecaptchaConfigs[c.tenantId].siteKey}return new Promise(async(d,m)=>{Nk(c,{clientType:"CLIENT_TYPE_WEB",version:"RECAPTCHA_ENTERPRISE"}).then(f=>{if(f.recaptchaKey===void 0)m(new Error("recaptcha Enterprise site key undefined"));else{const h=new kk(f);return c.tenantId==null?c._agentRecaptchaConfig=h:c._tenantRecaptchaConfigs[c.tenantId]=h,d(h.siteKey)}}).catch(f=>{m(f)})})}function o(c,d,m){const f=window.grecaptcha;q1(f)?f.enterprise.ready(()=>{f.enterprise.execute(c,{action:e}).then(h=>{d(h)}).catch(()=>{d(tb)})}):m(Error("No reCAPTCHA enterprise script loaded."))}return this.auth.settings.appVerificationDisabledForTesting?new Kk().execute("siteKey",{action:"verify"}):new Promise((c,d)=>{a(this.auth).then(m=>{if(!i&&q1(window.grecaptcha))o(m,c,d);else{if(typeof window>"u"){d(new Error("RecaptchaVerifier is only supported in browser"));return}let f=Gk();f.length!==0&&(f+=m),eb(f).then(()=>{o(m,c,d)}).catch(h=>{d(h)})}}).catch(m=>{d(m)})})}}async function K1(n,e,i,a=!1,o=!1){const c=new $k(n);let d;if(o)d=tb;else try{d=await c.verify(i)}catch{d=await c.verify(i,!0)}const m={...e};if(i==="mfaSmsEnrollment"||i==="mfaSmsSignIn"){if("phoneEnrollmentInfo"in m){const f=m.phoneEnrollmentInfo.phoneNumber,h=m.phoneEnrollmentInfo.recaptchaToken;Object.assign(m,{phoneEnrollmentInfo:{phoneNumber:f,recaptchaToken:h,captchaResponse:d,clientType:"CLIENT_TYPE_WEB",recaptchaVersion:"RECAPTCHA_ENTERPRISE"}})}else if("phoneSignInInfo"in m){const f=m.phoneSignInInfo.recaptchaToken;Object.assign(m,{phoneSignInInfo:{recaptchaToken:f,captchaResponse:d,clientType:"CLIENT_TYPE_WEB",recaptchaVersion:"RECAPTCHA_ENTERPRISE"}})}return m}return a?Object.assign(m,{captchaResp:d}):Object.assign(m,{captchaResponse:d}),Object.assign(m,{clientType:"CLIENT_TYPE_WEB"}),Object.assign(m,{recaptchaVersion:"RECAPTCHA_ENTERPRISE"}),m}async function Im(n,e,i,a,o){if(n._getRecaptchaConfig()?.isProviderEnabled("EMAIL_PASSWORD_PROVIDER")){const c=await K1(n,e,i,i==="getOobCode");return a(n,c)}else return a(n,e).catch(async c=>{if(c.code==="auth/missing-recaptcha-token"){console.log(`${i} is protected by reCAPTCHA Enterprise for this project. Automatically triggering the reCAPTCHA flow and restarting the flow.`);const d=await K1(n,e,i,i==="getOobCode");return a(n,d)}else return Promise.reject(c)})}function Zk(n,e){const i=bu(n,"auth");if(i.isInitialized()){const o=i.getImmediate(),c=i.getOptions();if(Ur(c,e??{}))return o;gn(o,"already-initialized")}return i.initialize({options:e})}function Jk(n,e){const i=e?.persistence||[],a=(Array.isArray(i)?i:[i]).map(si);e?.errorMap&&n._updateErrorMap(e.errorMap),n._initializeWithPersistence(a,e?.popupRedirectResolver)}function eN(n,e,i){const a=dr(n);re(/^https?:\/\//.test(e),a,"invalid-emulator-scheme");const o=!1,c=nb(e),{host:d,port:m}=tN(e),f=m===null?"":`:${m}`,h={url:`${c}//${d}${f}/`},x=Object.freeze({host:d,port:m,protocol:c.replace(":",""),options:Object.freeze({disableWarnings:o})});if(!a._canInitEmulator){re(a.config.emulator&&a.emulatorConfig,a,"emulator-config-failed"),re(Ur(h,a.config.emulator)&&Ur(x,a.emulatorConfig),a,"emulator-config-failed");return}a.config.emulator=h,a.emulatorConfig=x,a.settings.appVerificationDisabledForTesting=!0,cr(d)?(pf(`${c}//${d}${f}`),mf("Auth",!0)):nN()}function nb(n){const e=n.indexOf(":");return e<0?"":n.substr(0,e+1)}function tN(n){const e=nb(n),i=/(\/\/)?([^?#/]+)/.exec(n.substr(e.length));if(!i)return{host:"",port:null};const a=i[2].split("@").pop()||"",o=/^(\[[^\]]+\])(:|$)/.exec(a);if(o){const c=o[1];return{host:c,port:Q1(a.substr(c.length+1))}}else{const[c,d]=a.split(":");return{host:c,port:Q1(d)}}}function Q1(n){if(!n)return null;const e=Number(n);return isNaN(e)?null:e}function nN(){function n(){const e=document.createElement("p"),i=e.style;e.innerText="Running in emulator mode. Do not use with production credentials.",i.position="fixed",i.width="100%",i.backgroundColor="#ffffff",i.border=".1em solid #000000",i.color="#b50000",i.bottom="0px",i.left="0px",i.margin="0px",i.zIndex="10000",i.textAlign="center",e.classList.add("firebase-emulator-warning"),document.body.appendChild(e)}typeof console<"u"&&typeof console.info=="function"&&console.info("WARNING: You are using the Auth Emulator, which is intended for local testing only.  Do not use with production credentials."),typeof window<"u"&&typeof document<"u"&&(document.readyState==="loading"?window.addEventListener("DOMContentLoaded",n):n())}class Cf{constructor(e,i){this.providerId=e,this.signInMethod=i}toJSON(){return ai("not implemented")}_getIdTokenResponse(e){return ai("not implemented")}_linkToIdToken(e,i){return ai("not implemented")}_getReauthenticationResolver(e){return ai("not implemented")}}async function iN(n,e){return yi(n,"POST","/v1/accounts:signUp",e)}async function rN(n,e){return Xo(n,"POST","/v1/accounts:signInWithPassword",ur(n,e))}async function aN(n,e){return Xo(n,"POST","/v1/accounts:signInWithEmailLink",ur(n,e))}async function sN(n,e){return Xo(n,"POST","/v1/accounts:signInWithEmailLink",ur(n,e))}class Io extends Cf{constructor(e,i,a,o=null){super("password",a),this._email=e,this._password=i,this._tenantId=o}static _fromEmailAndPassword(e,i){return new Io(e,i,"password")}static _fromEmailAndCode(e,i,a=null){return new Io(e,i,"emailLink",a)}toJSON(){return{email:this._email,password:this._password,signInMethod:this.signInMethod,tenantId:this._tenantId}}static fromJSON(e){const i=typeof e=="string"?JSON.parse(e):e;if(i?.email&&i?.password){if(i.signInMethod==="password")return this._fromEmailAndPassword(i.email,i.password);if(i.signInMethod==="emailLink")return this._fromEmailAndCode(i.email,i.password,i.tenantId)}return null}async _getIdTokenResponse(e){switch(this.signInMethod){case"password":const i={returnSecureToken:!0,email:this._email,password:this._password,clientType:"CLIENT_TYPE_WEB"};return Im(e,i,"signInWithPassword",rN);case"emailLink":return aN(e,{email:this._email,oobCode:this._password});default:gn(e,"internal-error")}}async _linkToIdToken(e,i){switch(this.signInMethod){case"password":const a={idToken:i,returnSecureToken:!0,email:this._email,password:this._password,clientType:"CLIENT_TYPE_WEB"};return Im(e,a,"signUpPassword",iN);case"emailLink":return sN(e,{idToken:i,email:this._email,oobCode:this._password});default:gn(e,"internal-error")}}_getReauthenticationResolver(e){return this._getIdTokenResponse(e)}}async function Ga(n,e){return Xo(n,"POST","/v1/accounts:signInWithIdp",ur(n,e))}const oN="http://localhost";class zr extends Cf{constructor(){super(...arguments),this.pendingToken=null}static _fromParams(e){const i=new zr(e.providerId,e.signInMethod);return e.idToken||e.accessToken?(e.idToken&&(i.idToken=e.idToken),e.accessToken&&(i.accessToken=e.accessToken),e.nonce&&!e.pendingToken&&(i.nonce=e.nonce),e.pendingToken&&(i.pendingToken=e.pendingToken)):e.oauthToken&&e.oauthTokenSecret?(i.accessToken=e.oauthToken,i.secret=e.oauthTokenSecret):gn("argument-error"),i}toJSON(){return{idToken:this.idToken,accessToken:this.accessToken,secret:this.secret,nonce:this.nonce,pendingToken:this.pendingToken,providerId:this.providerId,signInMethod:this.signInMethod}}static fromJSON(e){const i=typeof e=="string"?JSON.parse(e):e,{providerId:a,signInMethod:o,...c}=i;if(!a||!o)return null;const d=new zr(a,o);return d.idToken=c.idToken||void 0,d.accessToken=c.accessToken||void 0,d.secret=c.secret,d.nonce=c.nonce,d.pendingToken=c.pendingToken||null,d}_getIdTokenResponse(e){const i=this.buildRequest();return Ga(e,i)}_linkToIdToken(e,i){const a=this.buildRequest();return a.idToken=i,Ga(e,a)}_getReauthenticationResolver(e){const i=this.buildRequest();return i.autoCreate=!1,Ga(e,i)}buildRequest(){const e={requestUri:oN,returnSecureToken:!0};if(this.pendingToken)e.pendingToken=this.pendingToken;else{const i={};this.idToken&&(i.id_token=this.idToken),this.accessToken&&(i.access_token=this.accessToken),this.secret&&(i.oauth_token_secret=this.secret),i.providerId=this.providerId,this.nonce&&!this.pendingToken&&(i.nonce=this.nonce),e.postBody=ss(i)}return e}}function lN(n){switch(n){case"recoverEmail":return"RECOVER_EMAIL";case"resetPassword":return"PASSWORD_RESET";case"signIn":return"EMAIL_SIGNIN";case"verifyEmail":return"VERIFY_EMAIL";case"verifyAndChangeEmail":return"VERIFY_AND_CHANGE_EMAIL";case"revertSecondFactorAddition":return"REVERT_SECOND_FACTOR_ADDITION";default:return null}}function cN(n){const e=bo(wo(n)).link,i=e?bo(wo(e)).deep_link_id:null,a=bo(wo(n)).deep_link_id;return(a?bo(wo(a)).link:null)||a||i||e||n}class Of{constructor(e){const i=bo(wo(e)),a=i.apiKey??null,o=i.oobCode??null,c=lN(i.mode??null);re(a&&o&&c,"argument-error"),this.apiKey=a,this.operation=c,this.code=o,this.continueUrl=i.continueUrl??null,this.languageCode=i.lang??null,this.tenantId=i.tenantId??null}static parseLink(e){const i=cN(e);try{return new Of(i)}catch{return null}}}class os{constructor(){this.providerId=os.PROVIDER_ID}static credential(e,i){return Io._fromEmailAndPassword(e,i)}static credentialWithLink(e,i){const a=Of.parseLink(i);return re(a,"argument-error"),Io._fromEmailAndCode(e,a.code,a.tenantId)}}os.PROVIDER_ID="password";os.EMAIL_PASSWORD_SIGN_IN_METHOD="password";os.EMAIL_LINK_SIGN_IN_METHOD="emailLink";class _f{constructor(e){this.providerId=e,this.defaultLanguageCode=null,this.customParameters={}}setDefaultLanguage(e){this.defaultLanguageCode=e}setCustomParameters(e){return this.customParameters=e,this}getCustomParameters(){return this.customParameters}}class $o extends _f{constructor(){super(...arguments),this.scopes=[]}addScope(e){return this.scopes.includes(e)||this.scopes.push(e),this}getScopes(){return[...this.scopes]}}class Wi extends $o{constructor(){super("facebook.com")}static credential(e){return zr._fromParams({providerId:Wi.PROVIDER_ID,signInMethod:Wi.FACEBOOK_SIGN_IN_METHOD,accessToken:e})}static credentialFromResult(e){return Wi.credentialFromTaggedObject(e)}static credentialFromError(e){return Wi.credentialFromTaggedObject(e.customData||{})}static credentialFromTaggedObject({_tokenResponse:e}){if(!e||!("oauthAccessToken"in e)||!e.oauthAccessToken)return null;try{return Wi.credential(e.oauthAccessToken)}catch{return null}}}Wi.FACEBOOK_SIGN_IN_METHOD="facebook.com";Wi.PROVIDER_ID="facebook.com";class ri extends $o{constructor(){super("google.com"),this.addScope("profile")}static credential(e,i){return zr._fromParams({providerId:ri.PROVIDER_ID,signInMethod:ri.GOOGLE_SIGN_IN_METHOD,idToken:e,accessToken:i})}static credentialFromResult(e){return ri.credentialFromTaggedObject(e)}static credentialFromError(e){return ri.credentialFromTaggedObject(e.customData||{})}static credentialFromTaggedObject({_tokenResponse:e}){if(!e)return null;const{oauthIdToken:i,oauthAccessToken:a}=e;if(!i&&!a)return null;try{return ri.credential(i,a)}catch{return null}}}ri.GOOGLE_SIGN_IN_METHOD="google.com";ri.PROVIDER_ID="google.com";class Ki extends $o{constructor(){super("github.com")}static credential(e){return zr._fromParams({providerId:Ki.PROVIDER_ID,signInMethod:Ki.GITHUB_SIGN_IN_METHOD,accessToken:e})}static credentialFromResult(e){return Ki.credentialFromTaggedObject(e)}static credentialFromError(e){return Ki.credentialFromTaggedObject(e.customData||{})}static credentialFromTaggedObject({_tokenResponse:e}){if(!e||!("oauthAccessToken"in e)||!e.oauthAccessToken)return null;try{return Ki.credential(e.oauthAccessToken)}catch{return null}}}Ki.GITHUB_SIGN_IN_METHOD="github.com";Ki.PROVIDER_ID="github.com";class Qi extends $o{constructor(){super("twitter.com")}static credential(e,i){return zr._fromParams({providerId:Qi.PROVIDER_ID,signInMethod:Qi.TWITTER_SIGN_IN_METHOD,oauthToken:e,oauthTokenSecret:i})}static credentialFromResult(e){return Qi.credentialFromTaggedObject(e)}static credentialFromError(e){return Qi.credentialFromTaggedObject(e.customData||{})}static credentialFromTaggedObject({_tokenResponse:e}){if(!e)return null;const{oauthAccessToken:i,oauthTokenSecret:a}=e;if(!i||!a)return null;try{return Qi.credential(i,a)}catch{return null}}}Qi.TWITTER_SIGN_IN_METHOD="twitter.com";Qi.PROVIDER_ID="twitter.com";async function uN(n,e){return Xo(n,"POST","/v1/accounts:signUp",ur(n,e))}class Fr{constructor(e){this.user=e.user,this.providerId=e.providerId,this._tokenResponse=e._tokenResponse,this.operationType=e.operationType}static async _fromIdTokenResponse(e,i,a,o=!1){const c=await Sn._fromIdTokenResponse(e,a,o),d=X1(a);return new Fr({user:c,providerId:d,_tokenResponse:a,operationType:i})}static async _forOperation(e,i,a){await e._updateTokensIfNecessary(a,!0);const o=X1(a);return new Fr({user:e,providerId:o,_tokenResponse:a,operationType:i})}}function X1(n){return n.providerId?n.providerId:"phoneNumber"in n?"phone":null}class $c extends gi{constructor(e,i,a,o){super(i.code,i.message),this.operationType=a,this.user=o,Object.setPrototypeOf(this,$c.prototype),this.customData={appName:e.name,tenantId:e.tenantId??void 0,_serverResponse:i.customData._serverResponse,operationType:a}}static _fromErrorAndOperation(e,i,a,o){return new $c(e,i,a,o)}}function ib(n,e,i,a){return(e==="reauthenticate"?i._getReauthenticationResolver(n):i._getIdTokenResponse(n)).catch(c=>{throw c.code==="auth/multi-factor-auth-required"?$c._fromErrorAndOperation(n,c,e,a):c})}async function dN(n,e,i=!1){const a=await Xa(n,e._linkToIdToken(n.auth,await n.getIdToken()),i);return Fr._forOperation(n,"link",a)}async function pN(n,e,i=!1){const{auth:a}=n;if(Ht(a.app))return Promise.reject(ci(a));const o="reauthenticate";try{const c=await Xa(n,ib(a,o,e,n),i);re(c.idToken,a,"internal-error");const d=wf(c.idToken);re(d,a,"internal-error");const{sub:m}=d;return re(n.uid===m,a,"user-mismatch"),Fr._forOperation(n,o,c)}catch(c){throw c?.code==="auth/user-not-found"&&gn(a,"user-mismatch"),c}}async function rb(n,e,i=!1){if(Ht(n.app))return Promise.reject(ci(n));const a="signIn",o=await ib(n,a,e),c=await Fr._fromIdTokenResponse(n,a,o);return i||await n._updateCurrentUser(c.user),c}async function mN(n,e){return rb(dr(n),e)}async function ab(n){const e=dr(n);e._getPasswordPolicyInternal()&&await e._updatePasswordPolicy()}async function fN(n,e,i){if(Ht(n.app))return Promise.reject(ci(n));const a=dr(n),d=await Im(a,{returnSecureToken:!0,email:e,password:i,clientType:"CLIENT_TYPE_WEB"},"signUpPassword",uN).catch(f=>{throw f.code==="auth/password-does-not-meet-requirements"&&ab(n),f}),m=await Fr._fromIdTokenResponse(a,"signIn",d);return await a._updateCurrentUser(m.user),m}function hN(n,e,i){return Ht(n.app)?Promise.reject(ci(n)):mN(nt(n),os.credential(e,i)).catch(async a=>{throw a.code==="auth/password-does-not-meet-requirements"&&ab(n),a})}async function gN(n,e){return yi(n,"POST","/v1/accounts:update",e)}async function sb(n,{displayName:e,photoURL:i}){if(e===void 0&&i===void 0)return;const a=nt(n),c={idToken:await a.getIdToken(),displayName:e,photoUrl:i,returnSecureToken:!0},d=await Xa(a,gN(a.auth,c));a.displayName=d.displayName||null,a.photoURL=d.photoUrl||null;const m=a.providerData.find(({providerId:f})=>f==="password");m&&(m.displayName=a.displayName,m.photoURL=a.photoURL),await a._updateTokensIfNecessary(d)}function yN(n,e,i,a){return nt(n).onIdTokenChanged(e,i,a)}function vN(n,e,i){return nt(n).beforeAuthStateChanged(e,i)}function xN(n,e,i,a){return nt(n).onAuthStateChanged(e,i,a)}function bN(n){return nt(n).signOut()}const Zc="__sak";class ob{constructor(e,i){this.storageRetriever=e,this.type=i}_isAvailable(){try{return this.storage?(this.storage.setItem(Zc,"1"),this.storage.removeItem(Zc),Promise.resolve(!0)):Promise.resolve(!1)}catch{return Promise.resolve(!1)}}_set(e,i){return this.storage.setItem(e,JSON.stringify(i)),Promise.resolve()}_get(e){const i=this.storage.getItem(e);return Promise.resolve(i?JSON.parse(i):null)}_remove(e){return this.storage.removeItem(e),Promise.resolve()}get storage(){return this.storageRetriever()}}const wN=1e3,SN=10;class lb extends ob{constructor(){super(()=>window.localStorage,"LOCAL"),this.boundEventHandler=(e,i)=>this.onStorageEvent(e,i),this.listeners={},this.localCache={},this.pollTimer=null,this.fallbackToPolling=Zx(),this._shouldAllowMigration=!0}forAllChangedKeys(e){for(const i of Object.keys(this.listeners)){const a=this.storage.getItem(i),o=this.localCache[i];a!==o&&e(i,o,a)}}onStorageEvent(e,i=!1){if(!e.key){this.forAllChangedKeys((d,m,f)=>{this.notifyListeners(d,f)});return}const a=e.key;i?this.detachListener():this.stopPolling();const o=()=>{const d=this.storage.getItem(a);!i&&this.localCache[a]===d||this.notifyListeners(a,d)},c=this.storage.getItem(a);Uk()&&c!==e.newValue&&e.newValue!==e.oldValue?setTimeout(o,SN):o()}notifyListeners(e,i){this.localCache[e]=i;const a=this.listeners[e];if(a)for(const o of Array.from(a))o(i&&JSON.parse(i))}startPolling(){this.stopPolling(),this.pollTimer=setInterval(()=>{this.forAllChangedKeys((e,i,a)=>{this.onStorageEvent(new StorageEvent("storage",{key:e,oldValue:i,newValue:a}),!0)})},wN)}stopPolling(){this.pollTimer&&(clearInterval(this.pollTimer),this.pollTimer=null)}attachListener(){window.addEventListener("storage",this.boundEventHandler)}detachListener(){window.removeEventListener("storage",this.boundEventHandler)}_addListener(e,i){Object.keys(this.listeners).length===0&&(this.fallbackToPolling?this.startPolling():this.attachListener()),this.listeners[e]||(this.listeners[e]=new Set,this.localCache[e]=this.storage.getItem(e)),this.listeners[e].add(i)}_removeListener(e,i){this.listeners[e]&&(this.listeners[e].delete(i),this.listeners[e].size===0&&delete this.listeners[e]),Object.keys(this.listeners).length===0&&(this.detachListener(),this.stopPolling())}async _set(e,i){await super._set(e,i),this.localCache[e]=JSON.stringify(i)}async _get(e){const i=await super._get(e);return this.localCache[e]=JSON.stringify(i),i}async _remove(e){await super._remove(e),delete this.localCache[e]}}lb.type="LOCAL";const CN=lb;class cb extends ob{constructor(){super(()=>window.sessionStorage,"SESSION")}_addListener(e,i){}_removeListener(e,i){}}cb.type="SESSION";const ub=cb;function ON(n){return Promise.all(n.map(async e=>{try{return{fulfilled:!0,value:await e}}catch(i){return{fulfilled:!1,reason:i}}}))}class Su{constructor(e){this.eventTarget=e,this.handlersMap={},this.boundEventHandler=this.handleEvent.bind(this)}static _getInstance(e){const i=this.receivers.find(o=>o.isListeningto(e));if(i)return i;const a=new Su(e);return this.receivers.push(a),a}isListeningto(e){return this.eventTarget===e}async handleEvent(e){const i=e,{eventId:a,eventType:o,data:c}=i.data,d=this.handlersMap[o];if(!d?.size)return;i.ports[0].postMessage({status:"ack",eventId:a,eventType:o});const m=Array.from(d).map(async h=>h(i.origin,c)),f=await ON(m);i.ports[0].postMessage({status:"done",eventId:a,eventType:o,response:f})}_subscribe(e,i){Object.keys(this.handlersMap).length===0&&this.eventTarget.addEventListener("message",this.boundEventHandler),this.handlersMap[e]||(this.handlersMap[e]=new Set),this.handlersMap[e].add(i)}_unsubscribe(e,i){this.handlersMap[e]&&i&&this.handlersMap[e].delete(i),(!i||this.handlersMap[e].size===0)&&delete this.handlersMap[e],Object.keys(this.handlersMap).length===0&&this.eventTarget.removeEventListener("message",this.boundEventHandler)}}Su.receivers=[];function Tf(n="",e=10){let i="";for(let a=0;a<e;a++)i+=Math.floor(Math.random()*10);return n+i}class _N{constructor(e){this.target=e,this.handlers=new Set}removeMessageHandler(e){e.messageChannel&&(e.messageChannel.port1.removeEventListener("message",e.onMessage),e.messageChannel.port1.close()),this.handlers.delete(e)}async _send(e,i,a=50){const o=typeof MessageChannel<"u"?new MessageChannel:null;if(!o)throw new Error("connection_unavailable");let c,d;return new Promise((m,f)=>{const h=Tf("",20);o.port1.start();const x=setTimeout(()=>{f(new Error("unsupported_event"))},a);d={messageChannel:o,onMessage(v){const b=v;if(b.data.eventId===h)switch(b.data.status){case"ack":clearTimeout(x),c=setTimeout(()=>{f(new Error("timeout"))},3e3);break;case"done":clearTimeout(c),m(b.data.response);break;default:clearTimeout(x),clearTimeout(c),f(new Error("invalid_response"));break}}},this.handlers.add(d),o.port1.addEventListener("message",d.onMessage),this.target.postMessage({eventType:e,eventId:h,data:i},[o.port2])}).finally(()=>{d&&this.removeMessageHandler(d)})}}function In(){return window}function TN(n){In().location.href=n}function db(){return typeof In().WorkerGlobalScope<"u"&&typeof In().importScripts=="function"}async function kN(){if(!navigator?.serviceWorker)return null;try{return(await navigator.serviceWorker.ready).active}catch{return null}}function NN(){return navigator?.serviceWorker?.controller||null}function EN(){return db()?self:null}const pb="firebaseLocalStorageDb",jN=1,Jc="firebaseLocalStorage",mb="fbase_key";class Zo{constructor(e){this.request=e}toPromise(){return new Promise((e,i)=>{this.request.addEventListener("success",()=>{e(this.request.result)}),this.request.addEventListener("error",()=>{i(this.request.error)})})}}function Cu(n,e){return n.transaction([Jc],e?"readwrite":"readonly").objectStore(Jc)}function AN(){const n=indexedDB.deleteDatabase(pb);return new Zo(n).toPromise()}function Pm(){const n=indexedDB.open(pb,jN);return new Promise((e,i)=>{n.addEventListener("error",()=>{i(n.error)}),n.addEventListener("upgradeneeded",()=>{const a=n.result;try{a.createObjectStore(Jc,{keyPath:mb})}catch(o){i(o)}}),n.addEventListener("success",async()=>{const a=n.result;a.objectStoreNames.contains(Jc)?e(a):(a.close(),await AN(),e(await Pm()))})})}async function $1(n,e,i){const a=Cu(n,!0).put({[mb]:e,value:i});return new Zo(a).toPromise()}async function MN(n,e){const i=Cu(n,!1).get(e),a=await new Zo(i).toPromise();return a===void 0?null:a.value}function Z1(n,e){const i=Cu(n,!0).delete(e);return new Zo(i).toPromise()}const RN=800,DN=3;class fb{constructor(){this.type="LOCAL",this._shouldAllowMigration=!0,this.listeners={},this.localCache={},this.pollTimer=null,this.pendingWrites=0,this.receiver=null,this.sender=null,this.serviceWorkerReceiverAvailable=!1,this.activeServiceWorker=null,this._workerInitializationPromise=this.initializeServiceWorkerMessaging().then(()=>{},()=>{})}async _openDb(){return this.db?this.db:(this.db=await Pm(),this.db)}async _withRetries(e){let i=0;for(;;)try{const a=await this._openDb();return await e(a)}catch(a){if(i++>DN)throw a;this.db&&(this.db.close(),this.db=void 0)}}async initializeServiceWorkerMessaging(){return db()?this.initializeReceiver():this.initializeSender()}async initializeReceiver(){this.receiver=Su._getInstance(EN()),this.receiver._subscribe("keyChanged",async(e,i)=>({keyProcessed:(await this._poll()).includes(i.key)})),this.receiver._subscribe("ping",async(e,i)=>["keyChanged"])}async initializeSender(){if(this.activeServiceWorker=await kN(),!this.activeServiceWorker)return;this.sender=new _N(this.activeServiceWorker);const e=await this.sender._send("ping",{},800);e&&e[0]?.fulfilled&&e[0]?.value.includes("keyChanged")&&(this.serviceWorkerReceiverAvailable=!0)}async notifyServiceWorker(e){if(!(!this.sender||!this.activeServiceWorker||NN()!==this.activeServiceWorker))try{await this.sender._send("keyChanged",{key:e},this.serviceWorkerReceiverAvailable?800:50)}catch{}}async _isAvailable(){try{if(!indexedDB)return!1;const e=await Pm();return await $1(e,Zc,"1"),await Z1(e,Zc),!0}catch{}return!1}async _withPendingWrite(e){this.pendingWrites++;try{await e()}finally{this.pendingWrites--}}async _set(e,i){return this._withPendingWrite(async()=>(await this._withRetries(a=>$1(a,e,i)),this.localCache[e]=i,this.notifyServiceWorker(e)))}async _get(e){const i=await this._withRetries(a=>MN(a,e));return this.localCache[e]=i,i}async _remove(e){return this._withPendingWrite(async()=>(await this._withRetries(i=>Z1(i,e)),delete this.localCache[e],this.notifyServiceWorker(e)))}async _poll(){const e=await this._withRetries(o=>{const c=Cu(o,!1).getAll();return new Zo(c).toPromise()});if(!e)return[];if(this.pendingWrites!==0)return[];const i=[],a=new Set;if(e.length!==0)for(const{fbase_key:o,value:c}of e)a.add(o),JSON.stringify(this.localCache[o])!==JSON.stringify(c)&&(this.notifyListeners(o,c),i.push(o));for(const o of Object.keys(this.localCache))this.localCache[o]&&!a.has(o)&&(this.notifyListeners(o,null),i.push(o));return i}notifyListeners(e,i){this.localCache[e]=i;const a=this.listeners[e];if(a)for(const o of Array.from(a))o(i)}startPolling(){this.stopPolling(),this.pollTimer=setInterval(async()=>this._poll(),RN)}stopPolling(){this.pollTimer&&(clearInterval(this.pollTimer),this.pollTimer=null)}_addListener(e,i){Object.keys(this.listeners).length===0&&this.startPolling(),this.listeners[e]||(this.listeners[e]=new Set,this._get(e)),this.listeners[e].add(i)}_removeListener(e,i){this.listeners[e]&&(this.listeners[e].delete(i),this.listeners[e].size===0&&delete this.listeners[e]),Object.keys(this.listeners).length===0&&this.stopPolling()}}fb.type="LOCAL";const IN=fb;new Qo(3e4,6e4);function hb(n,e){return e?si(e):(re(n._popupRedirectResolver,n,"argument-error"),n._popupRedirectResolver)}class kf extends Cf{constructor(e){super("custom","custom"),this.params=e}_getIdTokenResponse(e){return Ga(e,this._buildIdpRequest())}_linkToIdToken(e,i){return Ga(e,this._buildIdpRequest(i))}_getReauthenticationResolver(e){return Ga(e,this._buildIdpRequest())}_buildIdpRequest(e){const i={requestUri:this.params.requestUri,sessionId:this.params.sessionId,postBody:this.params.postBody,tenantId:this.params.tenantId,pendingToken:this.params.pendingToken,returnSecureToken:!0,returnIdpCredential:!0};return e&&(i.idToken=e),i}}function PN(n){return rb(n.auth,new kf(n),n.bypassAuthState)}function LN(n){const{auth:e,user:i}=n;return re(i,e,"internal-error"),pN(i,new kf(n),n.bypassAuthState)}async function UN(n){const{auth:e,user:i}=n;return re(i,e,"internal-error"),dN(i,new kf(n),n.bypassAuthState)}class gb{constructor(e,i,a,o,c=!1){this.auth=e,this.resolver=a,this.user=o,this.bypassAuthState=c,this.pendingPromise=null,this.eventManager=null,this.filter=Array.isArray(i)?i:[i]}execute(){return new Promise(async(e,i)=>{this.pendingPromise={resolve:e,reject:i};try{this.eventManager=await this.resolver._initialize(this.auth),await this.onExecution(),this.eventManager.registerConsumer(this)}catch(a){this.reject(a)}})}async onAuthEvent(e){const{urlResponse:i,sessionId:a,postBody:o,tenantId:c,error:d,type:m}=e;if(d){this.reject(d);return}const f={auth:this.auth,requestUri:i,sessionId:a,tenantId:c||void 0,postBody:o||void 0,user:this.user,bypassAuthState:this.bypassAuthState};try{this.resolve(await this.getIdpTask(m)(f))}catch(h){this.reject(h)}}onError(e){this.reject(e)}getIdpTask(e){switch(e){case"signInViaPopup":case"signInViaRedirect":return PN;case"linkViaPopup":case"linkViaRedirect":return UN;case"reauthViaPopup":case"reauthViaRedirect":return LN;default:gn(this.auth,"internal-error")}}resolve(e){mi(this.pendingPromise,"Pending promise was never set"),this.pendingPromise.resolve(e),this.unregisterAndCleanUp()}reject(e){mi(this.pendingPromise,"Pending promise was never set"),this.pendingPromise.reject(e),this.unregisterAndCleanUp()}unregisterAndCleanUp(){this.eventManager&&this.eventManager.unregisterConsumer(this),this.pendingPromise=null,this.cleanUp()}}const BN=new Qo(2e3,1e4);async function zN(n,e,i){if(Ht(n.app))return Promise.reject(On(n,"operation-not-supported-in-this-environment"));const a=dr(n);vk(n,e,_f);const o=hb(a,i);return new Rr(a,"signInViaPopup",e,o).executeNotNull()}class Rr extends gb{constructor(e,i,a,o,c){super(e,i,o,c),this.provider=a,this.authWindow=null,this.pollId=null,Rr.currentPopupAction&&Rr.currentPopupAction.cancel(),Rr.currentPopupAction=this}async executeNotNull(){const e=await this.execute();return re(e,this.auth,"internal-error"),e}async onExecution(){mi(this.filter.length===1,"Popup operations only handle one event");const e=Tf();this.authWindow=await this.resolver._openPopup(this.auth,this.provider,this.filter[0],e),this.authWindow.associatedEvent=e,this.resolver._originValidation(this.auth).catch(i=>{this.reject(i)}),this.resolver._isIframeWebStorageSupported(this.auth,i=>{i||this.reject(On(this.auth,"web-storage-unsupported"))}),this.pollUserCancellation()}get eventId(){return this.authWindow?.associatedEvent||null}cancel(){this.reject(On(this.auth,"cancelled-popup-request"))}cleanUp(){this.authWindow&&this.authWindow.close(),this.pollId&&window.clearTimeout(this.pollId),this.authWindow=null,this.pollId=null,Rr.currentPopupAction=null}pollUserCancellation(){const e=()=>{if(this.authWindow?.window?.closed){this.pollId=window.setTimeout(()=>{this.pollId=null,this.reject(On(this.auth,"popup-closed-by-user"))},8e3);return}this.pollId=window.setTimeout(e,BN.get())};e()}}Rr.currentPopupAction=null;const FN="pendingRedirect",Uc=new Map;class qN extends gb{constructor(e,i,a=!1){super(e,["signInViaRedirect","linkViaRedirect","reauthViaRedirect","unknown"],i,void 0,a),this.eventId=null}async execute(){let e=Uc.get(this.auth._key());if(!e){try{const a=await HN(this.resolver,this.auth)?await super.execute():null;e=()=>Promise.resolve(a)}catch(i){e=()=>Promise.reject(i)}Uc.set(this.auth._key(),e)}return this.bypassAuthState||Uc.set(this.auth._key(),()=>Promise.resolve(null)),e()}async onAuthEvent(e){if(e.type==="signInViaRedirect")return super.onAuthEvent(e);if(e.type==="unknown"){this.resolve(null);return}if(e.eventId){const i=await this.auth._redirectUserForId(e.eventId);if(i)return this.user=i,super.onAuthEvent(e);this.resolve(null)}}async onExecution(){}cleanUp(){}}async function HN(n,e){const i=VN(e),a=GN(n);if(!await a._isAvailable())return!1;const o=await a._get(i)==="true";return await a._remove(i),o}function YN(n,e){Uc.set(n._key(),e)}function GN(n){return si(n._redirectPersistence)}function VN(n){return Lc(FN,n.config.apiKey,n.name)}async function WN(n,e,i=!1){if(Ht(n.app))return Promise.reject(ci(n));const a=dr(n),o=hb(a,e),d=await new qN(a,o,i).execute();return d&&!i&&(delete d.user._redirectEventId,await a._persistUserIfCurrent(d.user),await a._setRedirectUser(null,e)),d}const KN=600*1e3;class QN{constructor(e){this.auth=e,this.cachedEventUids=new Set,this.consumers=new Set,this.queuedRedirectEvent=null,this.hasHandledPotentialRedirect=!1,this.lastProcessedEventTime=Date.now()}registerConsumer(e){this.consumers.add(e),this.queuedRedirectEvent&&this.isEventForConsumer(this.queuedRedirectEvent,e)&&(this.sendToConsumer(this.queuedRedirectEvent,e),this.saveEventToCache(this.queuedRedirectEvent),this.queuedRedirectEvent=null)}unregisterConsumer(e){this.consumers.delete(e)}onEvent(e){if(this.hasEventBeenHandled(e))return!1;let i=!1;return this.consumers.forEach(a=>{this.isEventForConsumer(e,a)&&(i=!0,this.sendToConsumer(e,a),this.saveEventToCache(e))}),this.hasHandledPotentialRedirect||!XN(e)||(this.hasHandledPotentialRedirect=!0,i||(this.queuedRedirectEvent=e,i=!0)),i}sendToConsumer(e,i){if(e.error&&!yb(e)){const a=e.error.code?.split("auth/")[1]||"internal-error";i.onError(On(this.auth,a))}else i.onAuthEvent(e)}isEventForConsumer(e,i){const a=i.eventId===null||!!e.eventId&&e.eventId===i.eventId;return i.filter.includes(e.type)&&a}hasEventBeenHandled(e){return Date.now()-this.lastProcessedEventTime>=KN&&this.cachedEventUids.clear(),this.cachedEventUids.has(J1(e))}saveEventToCache(e){this.cachedEventUids.add(J1(e)),this.lastProcessedEventTime=Date.now()}}function J1(n){return[n.type,n.eventId,n.sessionId,n.tenantId].filter(e=>e).join("-")}function yb({type:n,error:e}){return n==="unknown"&&e?.code==="auth/no-auth-event"}function XN(n){switch(n.type){case"signInViaRedirect":case"linkViaRedirect":case"reauthViaRedirect":return!0;case"unknown":return yb(n);default:return!1}}async function $N(n,e={}){return yi(n,"GET","/v1/projects",e)}const ZN=/^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/,JN=/^https?/;async function eE(n){if(n.config.emulator)return;const{authorizedDomains:e}=await $N(n);for(const i of e)try{if(tE(i))return}catch{}gn(n,"unauthorized-domain")}function tE(n){const e=Rm(),{protocol:i,hostname:a}=new URL(e);if(n.startsWith("chrome-extension://")){const d=new URL(n);return d.hostname===""&&a===""?i==="chrome-extension:"&&n.replace("chrome-extension://","")===e.replace("chrome-extension://",""):i==="chrome-extension:"&&d.hostname===a}if(!JN.test(i))return!1;if(ZN.test(n))return a===n;const o=n.replace(/\./g,"\\.");return new RegExp("^(.+\\."+o+"|"+o+")$","i").test(a)}const nE=new Qo(3e4,6e4);function ev(){const n=In().___jsl;if(n?.H){for(const e of Object.keys(n.H))if(n.H[e].r=n.H[e].r||[],n.H[e].L=n.H[e].L||[],n.H[e].r=[...n.H[e].L],n.CP)for(let i=0;i<n.CP.length;i++)n.CP[i]=null}}function iE(n){return new Promise((e,i)=>{function a(){ev(),gapi.load("gapi.iframes",{callback:()=>{e(gapi.iframes.getContext())},ontimeout:()=>{ev(),i(On(n,"network-request-failed"))},timeout:nE.get()})}if(In().gapi?.iframes?.Iframe)e(gapi.iframes.getContext());else if(In().gapi?.load)a();else{const o=Wk("iframefcb");return In()[o]=()=>{gapi.load?a():i(On(n,"network-request-failed"))},eb(`${Vk()}?onload=${o}`).catch(c=>i(c))}}).catch(e=>{throw Bc=null,e})}let Bc=null;function rE(n){return Bc=Bc||iE(n),Bc}const aE=new Qo(5e3,15e3),sE="__/auth/iframe",oE="emulator/auth/iframe",lE={style:{position:"absolute",top:"-100px",width:"1px",height:"1px"},"aria-hidden":"true",tabindex:"-1"},cE=new Map([["identitytoolkit.googleapis.com","p"],["staging-identitytoolkit.sandbox.googleapis.com","s"],["test-identitytoolkit.sandbox.googleapis.com","t"]]);function uE(n){const e=n.config;re(e.authDomain,n,"auth-domain-config-required");const i=e.emulator?bf(e,oE):`https://${n.config.authDomain}/${sE}`,a={apiKey:e.apiKey,appName:n.name,v:Wr},o=cE.get(n.config.apiHost);o&&(a.eid=o);const c=n._getFrameworks();return c.length&&(a.fw=c.join(",")),`${i}?${ss(a).slice(1)}`}async function dE(n){const e=await rE(n),i=In().gapi;return re(i,n,"internal-error"),e.open({where:document.body,url:uE(n),messageHandlersFilter:i.iframes.CROSS_ORIGIN_IFRAMES_FILTER,attributes:lE,dontclear:!0},a=>new Promise(async(o,c)=>{await a.restyle({setHideOnLeave:!1});const d=On(n,"network-request-failed"),m=In().setTimeout(()=>{c(d)},aE.get());function f(){In().clearTimeout(m),o(a)}a.ping(f).then(f,()=>{c(d)})}))}const pE={location:"yes",resizable:"yes",statusbar:"yes",toolbar:"no"},mE=500,fE=600,hE="_blank",gE="http://localhost";class tv{constructor(e){this.window=e,this.associatedEvent=null}close(){if(this.window)try{this.window.close()}catch{}}}function yE(n,e,i,a=mE,o=fE){const c=Math.max((window.screen.availHeight-o)/2,0).toString(),d=Math.max((window.screen.availWidth-a)/2,0).toString();let m="";const f={...pE,width:a.toString(),height:o.toString(),top:c,left:d},h=Mt().toLowerCase();i&&(m=Wx(h)?hE:i),Gx(h)&&(e=e||gE,f.scrollbars="yes");const x=Object.entries(f).reduce((b,[_,N])=>`${b}${_}=${N},`,"");if(Lk(h)&&m!=="_self")return vE(e||"",m),new tv(null);const v=window.open(e||"",m,x);re(v,n,"popup-blocked");try{v.focus()}catch{}return new tv(v)}function vE(n,e){const i=document.createElement("a");i.href=n,i.target=e;const a=document.createEvent("MouseEvent");a.initMouseEvent("click",!0,!0,window,1,0,0,0,0,!1,!1,!1,!1,1,null),i.dispatchEvent(a)}const xE="__/auth/handler",bE="emulator/auth/handler",wE=encodeURIComponent("fac");async function nv(n,e,i,a,o,c){re(n.config.authDomain,n,"auth-domain-config-required"),re(n.config.apiKey,n,"invalid-api-key");const d={apiKey:n.config.apiKey,appName:n.name,authType:i,redirectUrl:a,v:Wr,eventId:o};if(e instanceof _f){e.setDefaultLanguage(n.languageCode),d.providerId=e.providerId||"",Gc(e.getCustomParameters())||(d.customParameters=JSON.stringify(e.getCustomParameters()));for(const[x,v]of Object.entries({}))d[x]=v}if(e instanceof $o){const x=e.getScopes().filter(v=>v!=="");x.length>0&&(d.scopes=x.join(","))}n.tenantId&&(d.tid=n.tenantId);const m=d;for(const x of Object.keys(m))m[x]===void 0&&delete m[x];const f=await n._getAppCheckToken(),h=f?`#${wE}=${encodeURIComponent(f)}`:"";return`${SE(n)}?${ss(m).slice(1)}${h}`}function SE({config:n}){return n.emulator?bf(n,bE):`https://${n.authDomain}/${xE}`}const mm="webStorageSupport";class CE{constructor(){this.eventManagers={},this.iframes={},this.originValidationPromises={},this._redirectPersistence=ub,this._completeRedirectFn=WN,this._overrideRedirectResult=YN}async _openPopup(e,i,a,o){mi(this.eventManagers[e._key()]?.manager,"_initialize() not called before _openPopup()");const c=await nv(e,i,a,Rm(),o);return yE(e,c,Tf())}async _openRedirect(e,i,a,o){await this._originValidation(e);const c=await nv(e,i,a,Rm(),o);return TN(c),new Promise(()=>{})}_initialize(e){const i=e._key();if(this.eventManagers[i]){const{manager:o,promise:c}=this.eventManagers[i];return o?Promise.resolve(o):(mi(c,"If manager is not set, promise should be"),c)}const a=this.initAndGetManager(e);return this.eventManagers[i]={promise:a},a.catch(()=>{delete this.eventManagers[i]}),a}async initAndGetManager(e){const i=await dE(e),a=new QN(e);return i.register("authEvent",o=>(re(o?.authEvent,e,"invalid-auth-event"),{status:a.onEvent(o.authEvent)?"ACK":"ERROR"}),gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER),this.eventManagers[e._key()]={manager:a},this.iframes[e._key()]=i,a}_isIframeWebStorageSupported(e,i){this.iframes[e._key()].send(mm,{type:mm},o=>{const c=o?.[0]?.[mm];c!==void 0&&i(!!c),gn(e,"internal-error")},gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER)}_originValidation(e){const i=e._key();return this.originValidationPromises[i]||(this.originValidationPromises[i]=eE(e)),this.originValidationPromises[i]}get _shouldInitProactively(){return Zx()||Vx()||Sf()}}const OE=CE;var iv="@firebase/auth",rv="1.12.0";class _E{constructor(e){this.auth=e,this.internalListeners=new Map}getUid(){return this.assertAuthConfigured(),this.auth.currentUser?.uid||null}async getToken(e){return this.assertAuthConfigured(),await this.auth._initializationPromise,this.auth.currentUser?{accessToken:await this.auth.currentUser.getIdToken(e)}:null}addAuthTokenListener(e){if(this.assertAuthConfigured(),this.internalListeners.has(e))return;const i=this.auth.onIdTokenChanged(a=>{e(a?.stsTokenManager.accessToken||null)});this.internalListeners.set(e,i),this.updateProactiveRefresh()}removeAuthTokenListener(e){this.assertAuthConfigured();const i=this.internalListeners.get(e);i&&(this.internalListeners.delete(e),i(),this.updateProactiveRefresh())}assertAuthConfigured(){re(this.auth._initializationPromise,"dependent-sdk-initialized-before-auth")}updateProactiveRefresh(){this.internalListeners.size>0?this.auth._startProactiveRefresh():this.auth._stopProactiveRefresh()}}function TE(n){switch(n){case"Node":return"node";case"ReactNative":return"rn";case"Worker":return"webworker";case"Cordova":return"cordova";case"WebExtension":return"web-extension";default:return}}function kE(n){Br(new ir("auth",(e,{options:i})=>{const a=e.getProvider("app").getImmediate(),o=e.getProvider("heartbeat"),c=e.getProvider("app-check-internal"),{apiKey:d,authDomain:m}=a.options;re(d&&!d.includes(":"),"invalid-api-key",{appName:a.name});const f={apiKey:d,authDomain:m,clientPlatform:n,apiHost:"identitytoolkit.googleapis.com",tokenApiHost:"securetoken.googleapis.com",apiScheme:"https",sdkClientVersion:Jx(n)},h=new Hk(a,o,c,f);return Jk(h,i),h},"PUBLIC").setInstantiationMode("EXPLICIT").setInstanceCreatedCallback((e,i,a)=>{e.getProvider("auth-internal").initialize()})),Br(new ir("auth-internal",e=>{const i=dr(e.getProvider("auth").getImmediate());return(a=>new _E(a))(i)},"PRIVATE").setInstantiationMode("EXPLICIT")),Dn(iv,rv,TE(n)),Dn(iv,rv,"esm2020")}const NE=300,EE=Ex("authIdTokenMaxAge")||NE;let av=null;const jE=n=>async e=>{const i=e&&await e.getIdTokenResult(),a=i&&(new Date().getTime()-Date.parse(i.issuedAtTime))/1e3;if(a&&a>EE)return;const o=i?.token;av!==o&&(av=o,await fetch(n,{method:o?"POST":"DELETE",headers:o?{Authorization:`Bearer ${o}`}:{}}))};function AE(n=yf()){const e=bu(n,"auth");if(e.isInitialized())return e.getImmediate();const i=Zk(n,{popupRedirectResolver:OE,persistence:[IN,CN,ub]}),a=Ex("authTokenSyncURL");if(a&&typeof isSecureContext=="boolean"&&isSecureContext){const c=new URL(a,location.origin);if(location.origin===c.origin){const d=jE(c.toString());vN(i,d,()=>d(i.currentUser)),yN(i,m=>d(m))}}const o=Tx("auth");return o&&eN(i,`http://${o}`),i}function ME(){return document.getElementsByTagName("head")?.[0]??document}Yk({loadJS(n){return new Promise((e,i)=>{const a=document.createElement("script");a.setAttribute("src",n),a.onload=e,a.onerror=o=>{const c=On("internal-error");c.customData=o,i(c)},a.type="text/javascript",a.charset="UTF-8",ME().appendChild(a)})},gapiScript:"https://apis.google.com/js/api.js",recaptchaV2Script:"https://www.google.com/recaptcha/api.js",recaptchaEnterpriseScript:"https://www.google.com/recaptcha/enterprise.js?render="});kE("Browser");var sv={};const ov="@firebase/database",lv="1.1.0";let vb="";function RE(n){vb=n}class DE{constructor(e){this.domStorage_=e,this.prefix_="firebase:"}set(e,i){i==null?this.domStorage_.removeItem(this.prefixedName_(e)):this.domStorage_.setItem(this.prefixedName_(e),mt(i))}get(e){const i=this.domStorage_.getItem(this.prefixedName_(e));return i==null?null:Ro(i)}remove(e){this.domStorage_.removeItem(this.prefixedName_(e))}prefixedName_(e){return this.prefix_+e}toString(){return this.domStorage_.toString()}}class IE{constructor(){this.cache_={},this.isInMemoryStorage=!0}set(e,i){i==null?delete this.cache_[e]:this.cache_[e]=i}get(e){return Un(this.cache_,e)?this.cache_[e]:null}remove(e){delete this.cache_[e]}}const xb=function(n){try{if(typeof window<"u"&&typeof window[n]<"u"){const e=window[n];return e.setItem("firebase:sentinel","cache"),e.removeItem("firebase:sentinel"),new DE(e)}}catch{}return new IE},Dr=xb("localStorage"),PE=xb("sessionStorage");const Va=new hf("@firebase/database"),LE=(function(){let n=1;return function(){return n++}})(),bb=function(n){const e=aT(n),i=new tT;i.update(e);const a=i.digest();return uf.encodeByteArray(a)},Jo=function(...n){let e="";for(let i=0;i<n.length;i++){const a=n[i];Array.isArray(a)||a&&typeof a=="object"&&typeof a.length=="number"?e+=Jo.apply(null,a):typeof a=="object"?e+=mt(a):e+=a,e+=" "}return e};let _o=null,cv=!0;const UE=function(n,e){G(!0,"Can't turn on custom loggers persistently."),Va.logLevel=Be.VERBOSE,_o=Va.log.bind(Va)},vt=function(...n){if(cv===!0&&(cv=!1,_o===null&&PE.get("logging_enabled")===!0&&UE()),_o){const e=Jo.apply(null,n);_o(e)}},el=function(n){return function(...e){vt(n,...e)}},Lm=function(...n){const e="FIREBASE INTERNAL ERROR: "+Jo(...n);Va.error(e)},fi=function(...n){const e=`FIREBASE FATAL ERROR: ${Jo(...n)}`;throw Va.error(e),new Error(e)},At=function(...n){const e="FIREBASE WARNING: "+Jo(...n);Va.warn(e)},BE=function(){typeof window<"u"&&window.location&&window.location.protocol&&window.location.protocol.indexOf("https:")!==-1&&At("Insecure Firebase access from a secure page. Please use https in calls to new Firebase().")},Ou=function(n){return typeof n=="number"&&(n!==n||n===Number.POSITIVE_INFINITY||n===Number.NEGATIVE_INFINITY)},zE=function(n){if(document.readyState==="complete")n();else{let e=!1;const i=function(){if(!document.body){setTimeout(i,Math.floor(10));return}e||(e=!0,n())};document.addEventListener?(document.addEventListener("DOMContentLoaded",i,!1),window.addEventListener("load",i,!1)):document.attachEvent&&(document.attachEvent("onreadystatechange",()=>{document.readyState==="complete"&&i()}),window.attachEvent("onload",i))}},$a="[MIN_NAME]",qr="[MAX_NAME]",Kr=function(n,e){if(n===e)return 0;if(n===$a||e===qr)return-1;if(e===$a||n===qr)return 1;{const i=uv(n),a=uv(e);return i!==null?a!==null?i-a===0?n.length-e.length:i-a:-1:a!==null?1:n<e?-1:1}},FE=function(n,e){return n===e?0:n<e?-1:1},fo=function(n,e){if(e&&n in e)return e[n];throw new Error("Missing required key ("+n+") in object: "+mt(e))},Nf=function(n){if(typeof n!="object"||n===null)return mt(n);const e=[];for(const a in n)e.push(a);e.sort();let i="{";for(let a=0;a<e.length;a++)a!==0&&(i+=","),i+=mt(e[a]),i+=":",i+=Nf(n[e[a]]);return i+="}",i},wb=function(n,e){const i=n.length;if(i<=e)return[n];const a=[];for(let o=0;o<i;o+=e)o+e>i?a.push(n.substring(o,i)):a.push(n.substring(o,o+e));return a};function xt(n,e){for(const i in n)n.hasOwnProperty(i)&&e(i,n[i])}const Sb=function(n){G(!Ou(n),"Invalid JSON number");const e=11,i=52,a=(1<<e-1)-1;let o,c,d,m,f;n===0?(c=0,d=0,o=1/n===-1/0?1:0):(o=n<0,n=Math.abs(n),n>=Math.pow(2,1-a)?(m=Math.min(Math.floor(Math.log(n)/Math.LN2),a),c=m+a,d=Math.round(n*Math.pow(2,i-m)-Math.pow(2,i))):(c=0,d=Math.round(n/Math.pow(2,1-a-i))));const h=[];for(f=i;f;f-=1)h.push(d%2?1:0),d=Math.floor(d/2);for(f=e;f;f-=1)h.push(c%2?1:0),c=Math.floor(c/2);h.push(o?1:0),h.reverse();const x=h.join("");let v="";for(f=0;f<64;f+=8){let b=parseInt(x.substr(f,8),2).toString(16);b.length===1&&(b="0"+b),v=v+b}return v.toLowerCase()},qE=function(){return!!(typeof window=="object"&&window.chrome&&window.chrome.extension&&!/^chrome/.test(window.location.href))},HE=function(){return typeof Windows=="object"&&typeof Windows.UI=="object"};function YE(n,e){let i="Unknown Error";n==="too_big"?i="The data requested exceeds the maximum size that can be accessed with a single request.":n==="permission_denied"?i="Client doesn't have permission to access the desired data.":n==="unavailable"&&(i="The service is unavailable");const a=new Error(n+" at "+e._path.toString()+": "+i);return a.code=n.toUpperCase(),a}const GE=new RegExp("^-?(0*)\\d{1,10}$"),VE=-2147483648,WE=2147483647,uv=function(n){if(GE.test(n)){const e=Number(n);if(e>=VE&&e<=WE)return e}return null},ls=function(n){try{n()}catch(e){setTimeout(()=>{const i=e.stack||"";throw At("Exception was thrown by user callback.",i),e},Math.floor(0))}},KE=function(){return(typeof window=="object"&&window.navigator&&window.navigator.userAgent||"").search(/googlebot|google webmaster tools|bingbot|yahoo! slurp|baiduspider|yandexbot|duckduckbot/i)>=0},To=function(n,e){const i=setTimeout(n,e);return typeof i=="number"&&typeof Deno<"u"&&Deno.unrefTimer?Deno.unrefTimer(i):typeof i=="object"&&i.unref&&i.unref(),i};class QE{constructor(e,i){this.appCheckProvider=i,this.appName=e.name,Ht(e)&&e.settings.appCheckToken&&(this.serverAppAppCheckToken=e.settings.appCheckToken),this.appCheck=i?.getImmediate({optional:!0}),this.appCheck||i?.get().then(a=>this.appCheck=a)}getToken(e){if(this.serverAppAppCheckToken){if(e)throw new Error("Attempted reuse of `FirebaseServerApp.appCheckToken` after previous usage failed.");return Promise.resolve({token:this.serverAppAppCheckToken})}return this.appCheck?this.appCheck.getToken(e):new Promise((i,a)=>{setTimeout(()=>{this.appCheck?this.getToken(e).then(i,a):i(null)},0)})}addTokenChangeListener(e){this.appCheckProvider?.get().then(i=>i.addTokenListener(e))}notifyForInvalidToken(){At(`Provided AppCheck credentials for the app named "${this.appName}" are invalid. This usually indicates your app was not initialized correctly.`)}}class XE{constructor(e,i,a){this.appName_=e,this.firebaseOptions_=i,this.authProvider_=a,this.auth_=null,this.auth_=a.getImmediate({optional:!0}),this.auth_||a.onInit(o=>this.auth_=o)}getToken(e){return this.auth_?this.auth_.getToken(e).catch(i=>i&&i.code==="auth/token-not-initialized"?(vt("Got auth/token-not-initialized error.  Treating as null token."),null):Promise.reject(i)):new Promise((i,a)=>{setTimeout(()=>{this.auth_?this.getToken(e).then(i,a):i(null)},0)})}addTokenChangeListener(e){this.auth_?this.auth_.addAuthTokenListener(e):this.authProvider_.get().then(i=>i.addAuthTokenListener(e))}removeTokenChangeListener(e){this.authProvider_.get().then(i=>i.removeAuthTokenListener(e))}notifyForInvalidToken(){let e='Provided authentication credentials for the app named "'+this.appName_+'" are invalid. This usually indicates your app was not initialized correctly. ';"credential"in this.firebaseOptions_?e+='Make sure the "credential" property provided to initializeApp() is authorized to access the specified "databaseURL" and is from the correct project.':"serviceAccount"in this.firebaseOptions_?e+='Make sure the "serviceAccount" property provided to initializeApp() is authorized to access the specified "databaseURL" and is from the correct project.':e+='Make sure the "apiKey" and "databaseURL" properties provided to initializeApp() match the values provided for your app at https://console.firebase.google.com/.',At(e)}}class zc{constructor(e){this.accessToken=e}getToken(e){return Promise.resolve({accessToken:this.accessToken})}addTokenChangeListener(e){e(this.accessToken)}removeTokenChangeListener(e){}notifyForInvalidToken(){}}zc.OWNER="owner";const Ef="5",Cb="v",Ob="s",_b="r",Tb="f",kb=/(console\.firebase|firebase-console-\w+\.corp|firebase\.corp)\.google\.com/,Nb="ls",Eb="p",Um="ac",jb="websocket",Ab="long_polling";class Mb{constructor(e,i,a,o,c=!1,d="",m=!1,f=!1,h=null){this.secure=i,this.namespace=a,this.webSocketOnly=o,this.nodeAdmin=c,this.persistenceKey=d,this.includeNamespaceInQueryParams=m,this.isUsingEmulator=f,this.emulatorOptions=h,this._host=e.toLowerCase(),this._domain=this._host.substr(this._host.indexOf(".")+1),this.internalHost=Dr.get("host:"+e)||this._host}isCacheableHost(){return this.internalHost.substr(0,2)==="s-"}isCustomHost(){return this._domain!=="firebaseio.com"&&this._domain!=="firebaseio-demo.com"}get host(){return this._host}set host(e){e!==this.internalHost&&(this.internalHost=e,this.isCacheableHost()&&Dr.set("host:"+this._host,this.internalHost))}toString(){let e=this.toURLString();return this.persistenceKey&&(e+="<"+this.persistenceKey+">"),e}toURLString(){const e=this.secure?"https://":"http://",i=this.includeNamespaceInQueryParams?`?ns=${this.namespace}`:"";return`${e}${this.host}/${i}`}}function $E(n){return n.host!==n.internalHost||n.isCustomHost()||n.includeNamespaceInQueryParams}function Rb(n,e,i){G(typeof e=="string","typeof type must == string"),G(typeof i=="object","typeof params must == object");let a;if(e===jb)a=(n.secure?"wss://":"ws://")+n.internalHost+"/.ws?";else if(e===Ab)a=(n.secure?"https://":"http://")+n.internalHost+"/.lp?";else throw new Error("Unknown connection type: "+e);$E(n)&&(i.ns=n.namespace);const o=[];return xt(i,(c,d)=>{o.push(c+"="+d)}),a+o.join("&")}class ZE{constructor(){this.counters_={}}incrementCounter(e,i=1){Un(this.counters_,e)||(this.counters_[e]=0),this.counters_[e]+=i}get(){return P_(this.counters_)}}const fm={},hm={};function jf(n){const e=n.toString();return fm[e]||(fm[e]=new ZE),fm[e]}function JE(n,e){const i=n.toString();return hm[i]||(hm[i]=e()),hm[i]}class ej{constructor(e){this.onMessage_=e,this.pendingResponses=[],this.currentResponseNum=0,this.closeAfterResponse=-1,this.onClose=null}closeAfter(e,i){this.closeAfterResponse=e,this.onClose=i,this.closeAfterResponse<this.currentResponseNum&&(this.onClose(),this.onClose=null)}handleResponse(e,i){for(this.pendingResponses[e]=i;this.pendingResponses[this.currentResponseNum];){const a=this.pendingResponses[this.currentResponseNum];delete this.pendingResponses[this.currentResponseNum];for(let o=0;o<a.length;++o)a[o]&&ls(()=>{this.onMessage_(a[o])});if(this.currentResponseNum===this.closeAfterResponse){this.onClose&&(this.onClose(),this.onClose=null);break}this.currentResponseNum++}}}const dv="start",tj="close",nj="pLPCommand",ij="pRTLPCB",Db="id",Ib="pw",Pb="ser",rj="cb",aj="seg",sj="ts",oj="d",lj="dframe",Lb=1870,Ub=30,cj=Lb-Ub,uj=25e3,dj=3e4;class Fa{constructor(e,i,a,o,c,d,m){this.connId=e,this.repoInfo=i,this.applicationId=a,this.appCheckToken=o,this.authToken=c,this.transportSessionId=d,this.lastSessionId=m,this.bytesSent=0,this.bytesReceived=0,this.everConnected_=!1,this.log_=el(e),this.stats_=jf(i),this.urlFn=f=>(this.appCheckToken&&(f[Um]=this.appCheckToken),Rb(i,Ab,f))}open(e,i){this.curSegmentNum=0,this.onDisconnect_=i,this.myPacketOrderer=new ej(e),this.isClosed_=!1,this.connectTimeoutTimer_=setTimeout(()=>{this.log_("Timed out trying to connect."),this.onClosed_(),this.connectTimeoutTimer_=null},Math.floor(dj)),zE(()=>{if(this.isClosed_)return;this.scriptTagHolder=new Af((...c)=>{const[d,m,f,h,x]=c;if(this.incrementIncomingBytes_(c),!!this.scriptTagHolder)if(this.connectTimeoutTimer_&&(clearTimeout(this.connectTimeoutTimer_),this.connectTimeoutTimer_=null),this.everConnected_=!0,d===dv)this.id=m,this.password=f;else if(d===tj)m?(this.scriptTagHolder.sendNewPolls=!1,this.myPacketOrderer.closeAfter(m,()=>{this.onClosed_()})):this.onClosed_();else throw new Error("Unrecognized command received: "+d)},(...c)=>{const[d,m]=c;this.incrementIncomingBytes_(c),this.myPacketOrderer.handleResponse(d,m)},()=>{this.onClosed_()},this.urlFn);const a={};a[dv]="t",a[Pb]=Math.floor(Math.random()*1e8),this.scriptTagHolder.uniqueCallbackIdentifier&&(a[rj]=this.scriptTagHolder.uniqueCallbackIdentifier),a[Cb]=Ef,this.transportSessionId&&(a[Ob]=this.transportSessionId),this.lastSessionId&&(a[Nb]=this.lastSessionId),this.applicationId&&(a[Eb]=this.applicationId),this.appCheckToken&&(a[Um]=this.appCheckToken),typeof location<"u"&&location.hostname&&kb.test(location.hostname)&&(a[_b]=Tb);const o=this.urlFn(a);this.log_("Connecting via long-poll to "+o),this.scriptTagHolder.addTag(o,()=>{})})}start(){this.scriptTagHolder.startLongPoll(this.id,this.password),this.addDisconnectPingFrame(this.id,this.password)}static forceAllow(){Fa.forceAllow_=!0}static forceDisallow(){Fa.forceDisallow_=!0}static isAvailable(){return Fa.forceAllow_?!0:!Fa.forceDisallow_&&typeof document<"u"&&document.createElement!=null&&!qE()&&!HE()}markConnectionHealthy(){}shutdown_(){this.isClosed_=!0,this.scriptTagHolder&&(this.scriptTagHolder.close(),this.scriptTagHolder=null),this.myDisconnFrame&&(document.body.removeChild(this.myDisconnFrame),this.myDisconnFrame=null),this.connectTimeoutTimer_&&(clearTimeout(this.connectTimeoutTimer_),this.connectTimeoutTimer_=null)}onClosed_(){this.isClosed_||(this.log_("Longpoll is closing itself"),this.shutdown_(),this.onDisconnect_&&(this.onDisconnect_(this.everConnected_),this.onDisconnect_=null))}close(){this.isClosed_||(this.log_("Longpoll is being closed."),this.shutdown_())}send(e){const i=mt(e);this.bytesSent+=i.length,this.stats_.incrementCounter("bytes_sent",i.length);const a=Ox(i),o=wb(a,cj);for(let c=0;c<o.length;c++)this.scriptTagHolder.enqueueSegment(this.curSegmentNum,o.length,o[c]),this.curSegmentNum++}addDisconnectPingFrame(e,i){this.myDisconnFrame=document.createElement("iframe");const a={};a[lj]="t",a[Db]=e,a[Ib]=i,this.myDisconnFrame.src=this.urlFn(a),this.myDisconnFrame.style.display="none",document.body.appendChild(this.myDisconnFrame)}incrementIncomingBytes_(e){const i=mt(e).length;this.bytesReceived+=i,this.stats_.incrementCounter("bytes_received",i)}}class Af{constructor(e,i,a,o){this.onDisconnect=a,this.urlFn=o,this.outstandingRequests=new Set,this.pendingSegs=[],this.currentSerial=Math.floor(Math.random()*1e8),this.sendNewPolls=!0;{this.uniqueCallbackIdentifier=LE(),window[nj+this.uniqueCallbackIdentifier]=e,window[ij+this.uniqueCallbackIdentifier]=i,this.myIFrame=Af.createIFrame_();let c="";this.myIFrame.src&&this.myIFrame.src.substr(0,11)==="javascript:"&&(c='<script>document.domain="'+document.domain+'";<\/script>');const d="<html><body>"+c+"</body></html>";try{this.myIFrame.doc.open(),this.myIFrame.doc.write(d),this.myIFrame.doc.close()}catch(m){vt("frame writing exception"),m.stack&&vt(m.stack),vt(m)}}}static createIFrame_(){const e=document.createElement("iframe");if(e.style.display="none",document.body){document.body.appendChild(e);try{e.contentWindow.document||vt("No IE domain setting required")}catch{const a=document.domain;e.src="javascript:void((function(){document.open();document.domain='"+a+"';document.close();})())"}}else throw"Document body has not initialized. Wait to initialize Firebase until after the document is ready.";return e.contentDocument?e.doc=e.contentDocument:e.contentWindow?e.doc=e.contentWindow.document:e.document&&(e.doc=e.document),e}close(){this.alive=!1,this.myIFrame&&(this.myIFrame.doc.body.textContent="",setTimeout(()=>{this.myIFrame!==null&&(document.body.removeChild(this.myIFrame),this.myIFrame=null)},Math.floor(0)));const e=this.onDisconnect;e&&(this.onDisconnect=null,e())}startLongPoll(e,i){for(this.myID=e,this.myPW=i,this.alive=!0;this.newRequest_(););}newRequest_(){if(this.alive&&this.sendNewPolls&&this.outstandingRequests.size<(this.pendingSegs.length>0?2:1)){this.currentSerial++;const e={};e[Db]=this.myID,e[Ib]=this.myPW,e[Pb]=this.currentSerial;let i=this.urlFn(e),a="",o=0;for(;this.pendingSegs.length>0&&this.pendingSegs[0].d.length+Ub+a.length<=Lb;){const d=this.pendingSegs.shift();a=a+"&"+aj+o+"="+d.seg+"&"+sj+o+"="+d.ts+"&"+oj+o+"="+d.d,o++}return i=i+a,this.addLongPollTag_(i,this.currentSerial),!0}else return!1}enqueueSegment(e,i,a){this.pendingSegs.push({seg:e,ts:i,d:a}),this.alive&&this.newRequest_()}addLongPollTag_(e,i){this.outstandingRequests.add(i);const a=()=>{this.outstandingRequests.delete(i),this.newRequest_()},o=setTimeout(a,Math.floor(uj)),c=()=>{clearTimeout(o),a()};this.addTag(e,c)}addTag(e,i){setTimeout(()=>{try{if(!this.sendNewPolls)return;const a=this.myIFrame.doc.createElement("script");a.type="text/javascript",a.async=!0,a.src=e,a.onload=a.onreadystatechange=function(){const o=a.readyState;(!o||o==="loaded"||o==="complete")&&(a.onload=a.onreadystatechange=null,a.parentNode&&a.parentNode.removeChild(a),i())},a.onerror=()=>{vt("Long-poll script failed to load: "+e),this.sendNewPolls=!1,this.close()},this.myIFrame.doc.body.appendChild(a)}catch{}},Math.floor(1))}}const pj=16384,mj=45e3;let eu=null;typeof MozWebSocket<"u"?eu=MozWebSocket:typeof WebSocket<"u"&&(eu=WebSocket);class wn{constructor(e,i,a,o,c,d,m){this.connId=e,this.applicationId=a,this.appCheckToken=o,this.authToken=c,this.keepaliveTimer=null,this.frames=null,this.totalFrames=0,this.bytesSent=0,this.bytesReceived=0,this.log_=el(this.connId),this.stats_=jf(i),this.connURL=wn.connectionURL_(i,d,m,o,a),this.nodeAdmin=i.nodeAdmin}static connectionURL_(e,i,a,o,c){const d={};return d[Cb]=Ef,typeof location<"u"&&location.hostname&&kb.test(location.hostname)&&(d[_b]=Tb),i&&(d[Ob]=i),a&&(d[Nb]=a),o&&(d[Um]=o),c&&(d[Eb]=c),Rb(e,jb,d)}open(e,i){this.onDisconnect=i,this.onMessage=e,this.log_("Websocket connecting to "+this.connURL),this.everConnected_=!1,Dr.set("previous_websocket_failure",!0);try{let a;W_(),this.mySock=new eu(this.connURL,[],a)}catch(a){this.log_("Error instantiating WebSocket.");const o=a.message||a.data;o&&this.log_(o),this.onClosed_();return}this.mySock.onopen=()=>{this.log_("Websocket connected."),this.everConnected_=!0},this.mySock.onclose=()=>{this.log_("Websocket connection was disconnected."),this.mySock=null,this.onClosed_()},this.mySock.onmessage=a=>{this.handleIncomingFrame(a)},this.mySock.onerror=a=>{this.log_("WebSocket error.  Closing connection.");const o=a.message||a.data;o&&this.log_(o),this.onClosed_()}}start(){}static forceDisallow(){wn.forceDisallow_=!0}static isAvailable(){let e=!1;if(typeof navigator<"u"&&navigator.userAgent){const i=/Android ([0-9]{0,}\.[0-9]{0,})/,a=navigator.userAgent.match(i);a&&a.length>1&&parseFloat(a[1])<4.4&&(e=!0)}return!e&&eu!==null&&!wn.forceDisallow_}static previouslyFailed(){return Dr.isInMemoryStorage||Dr.get("previous_websocket_failure")===!0}markConnectionHealthy(){Dr.remove("previous_websocket_failure")}appendFrame_(e){if(this.frames.push(e),this.frames.length===this.totalFrames){const i=this.frames.join("");this.frames=null;const a=Ro(i);this.onMessage(a)}}handleNewFrameCount_(e){this.totalFrames=e,this.frames=[]}extractFrameCount_(e){if(G(this.frames===null,"We already have a frame buffer"),e.length<=6){const i=Number(e);if(!isNaN(i))return this.handleNewFrameCount_(i),null}return this.handleNewFrameCount_(1),e}handleIncomingFrame(e){if(this.mySock===null)return;const i=e.data;if(this.bytesReceived+=i.length,this.stats_.incrementCounter("bytes_received",i.length),this.resetKeepAlive(),this.frames!==null)this.appendFrame_(i);else{const a=this.extractFrameCount_(i);a!==null&&this.appendFrame_(a)}}send(e){this.resetKeepAlive();const i=mt(e);this.bytesSent+=i.length,this.stats_.incrementCounter("bytes_sent",i.length);const a=wb(i,pj);a.length>1&&this.sendString_(String(a.length));for(let o=0;o<a.length;o++)this.sendString_(a[o])}shutdown_(){this.isClosed_=!0,this.keepaliveTimer&&(clearInterval(this.keepaliveTimer),this.keepaliveTimer=null),this.mySock&&(this.mySock.close(),this.mySock=null)}onClosed_(){this.isClosed_||(this.log_("WebSocket is closing itself"),this.shutdown_(),this.onDisconnect&&(this.onDisconnect(this.everConnected_),this.onDisconnect=null))}close(){this.isClosed_||(this.log_("WebSocket is being closed"),this.shutdown_())}resetKeepAlive(){clearInterval(this.keepaliveTimer),this.keepaliveTimer=setInterval(()=>{this.mySock&&this.sendString_("0"),this.resetKeepAlive()},Math.floor(mj))}sendString_(e){try{this.mySock.send(e)}catch(i){this.log_("Exception thrown from WebSocket.send():",i.message||i.data,"Closing connection."),setTimeout(this.onClosed_.bind(this),0)}}}wn.responsesRequiredToBeHealthy=2;wn.healthyTimeout=3e4;class Po{static get ALL_TRANSPORTS(){return[Fa,wn]}static get IS_TRANSPORT_INITIALIZED(){return this.globalTransportInitialized_}constructor(e){this.initTransports_(e)}initTransports_(e){const i=wn&&wn.isAvailable();let a=i&&!wn.previouslyFailed();if(e.webSocketOnly&&(i||At("wss:// URL used, but browser isn't known to support websockets.  Trying anyway."),a=!0),a)this.transports_=[wn];else{const o=this.transports_=[];for(const c of Po.ALL_TRANSPORTS)c&&c.isAvailable()&&o.push(c);Po.globalTransportInitialized_=!0}}initialTransport(){if(this.transports_.length>0)return this.transports_[0];throw new Error("No transports available")}upgradeTransport(){return this.transports_.length>1?this.transports_[1]:null}}Po.globalTransportInitialized_=!1;const fj=6e4,hj=5e3,gj=10*1024,yj=100*1024,gm="t",pv="d",vj="s",mv="r",xj="e",fv="o",hv="a",gv="n",yv="p",bj="h";class wj{constructor(e,i,a,o,c,d,m,f,h,x){this.id=e,this.repoInfo_=i,this.applicationId_=a,this.appCheckToken_=o,this.authToken_=c,this.onMessage_=d,this.onReady_=m,this.onDisconnect_=f,this.onKill_=h,this.lastSessionId=x,this.connectionCount=0,this.pendingDataMessages=[],this.state_=0,this.log_=el("c:"+this.id+":"),this.transportManager_=new Po(i),this.log_("Connection created"),this.start_()}start_(){const e=this.transportManager_.initialTransport();this.conn_=new e(this.nextTransportId_(),this.repoInfo_,this.applicationId_,this.appCheckToken_,this.authToken_,null,this.lastSessionId),this.primaryResponsesRequired_=e.responsesRequiredToBeHealthy||0;const i=this.connReceiver_(this.conn_),a=this.disconnReceiver_(this.conn_);this.tx_=this.conn_,this.rx_=this.conn_,this.secondaryConn_=null,this.isHealthy_=!1,setTimeout(()=>{this.conn_&&this.conn_.open(i,a)},Math.floor(0));const o=e.healthyTimeout||0;o>0&&(this.healthyTimeout_=To(()=>{this.healthyTimeout_=null,this.isHealthy_||(this.conn_&&this.conn_.bytesReceived>yj?(this.log_("Connection exceeded healthy timeout but has received "+this.conn_.bytesReceived+" bytes.  Marking connection healthy."),this.isHealthy_=!0,this.conn_.markConnectionHealthy()):this.conn_&&this.conn_.bytesSent>gj?this.log_("Connection exceeded healthy timeout but has sent "+this.conn_.bytesSent+" bytes.  Leaving connection alive."):(this.log_("Closing unhealthy connection after timeout."),this.close()))},Math.floor(o)))}nextTransportId_(){return"c:"+this.id+":"+this.connectionCount++}disconnReceiver_(e){return i=>{e===this.conn_?this.onConnectionLost_(i):e===this.secondaryConn_?(this.log_("Secondary connection lost."),this.onSecondaryConnectionLost_()):this.log_("closing an old connection")}}connReceiver_(e){return i=>{this.state_!==2&&(e===this.rx_?this.onPrimaryMessageReceived_(i):e===this.secondaryConn_?this.onSecondaryMessageReceived_(i):this.log_("message on old connection"))}}sendRequest(e){const i={t:"d",d:e};this.sendData_(i)}tryCleanupConnection(){this.tx_===this.secondaryConn_&&this.rx_===this.secondaryConn_&&(this.log_("cleaning up and promoting a connection: "+this.secondaryConn_.connId),this.conn_=this.secondaryConn_,this.secondaryConn_=null)}onSecondaryControl_(e){if(gm in e){const i=e[gm];i===hv?this.upgradeIfSecondaryHealthy_():i===mv?(this.log_("Got a reset on secondary, closing it"),this.secondaryConn_.close(),(this.tx_===this.secondaryConn_||this.rx_===this.secondaryConn_)&&this.close()):i===fv&&(this.log_("got pong on secondary."),this.secondaryResponsesRequired_--,this.upgradeIfSecondaryHealthy_())}}onSecondaryMessageReceived_(e){const i=fo("t",e),a=fo("d",e);if(i==="c")this.onSecondaryControl_(a);else if(i==="d")this.pendingDataMessages.push(a);else throw new Error("Unknown protocol layer: "+i)}upgradeIfSecondaryHealthy_(){this.secondaryResponsesRequired_<=0?(this.log_("Secondary connection is healthy."),this.isHealthy_=!0,this.secondaryConn_.markConnectionHealthy(),this.proceedWithUpgrade_()):(this.log_("sending ping on secondary."),this.secondaryConn_.send({t:"c",d:{t:yv,d:{}}}))}proceedWithUpgrade_(){this.secondaryConn_.start(),this.log_("sending client ack on secondary"),this.secondaryConn_.send({t:"c",d:{t:hv,d:{}}}),this.log_("Ending transmission on primary"),this.conn_.send({t:"c",d:{t:gv,d:{}}}),this.tx_=this.secondaryConn_,this.tryCleanupConnection()}onPrimaryMessageReceived_(e){const i=fo("t",e),a=fo("d",e);i==="c"?this.onControl_(a):i==="d"&&this.onDataMessage_(a)}onDataMessage_(e){this.onPrimaryResponse_(),this.onMessage_(e)}onPrimaryResponse_(){this.isHealthy_||(this.primaryResponsesRequired_--,this.primaryResponsesRequired_<=0&&(this.log_("Primary connection is healthy."),this.isHealthy_=!0,this.conn_.markConnectionHealthy()))}onControl_(e){const i=fo(gm,e);if(pv in e){const a=e[pv];if(i===bj){const o={...a};this.repoInfo_.isUsingEmulator&&(o.h=this.repoInfo_.host),this.onHandshake_(o)}else if(i===gv){this.log_("recvd end transmission on primary"),this.rx_=this.secondaryConn_;for(let o=0;o<this.pendingDataMessages.length;++o)this.onDataMessage_(this.pendingDataMessages[o]);this.pendingDataMessages=[],this.tryCleanupConnection()}else i===vj?this.onConnectionShutdown_(a):i===mv?this.onReset_(a):i===xj?Lm("Server Error: "+a):i===fv?(this.log_("got pong on primary."),this.onPrimaryResponse_(),this.sendPingOnPrimaryIfNecessary_()):Lm("Unknown control packet command: "+i)}}onHandshake_(e){const i=e.ts,a=e.v,o=e.h;this.sessionId=e.s,this.repoInfo_.host=o,this.state_===0&&(this.conn_.start(),this.onConnectionEstablished_(this.conn_,i),Ef!==a&&At("Protocol version mismatch detected"),this.tryStartUpgrade_())}tryStartUpgrade_(){const e=this.transportManager_.upgradeTransport();e&&this.startUpgrade_(e)}startUpgrade_(e){this.secondaryConn_=new e(this.nextTransportId_(),this.repoInfo_,this.applicationId_,this.appCheckToken_,this.authToken_,this.sessionId),this.secondaryResponsesRequired_=e.responsesRequiredToBeHealthy||0;const i=this.connReceiver_(this.secondaryConn_),a=this.disconnReceiver_(this.secondaryConn_);this.secondaryConn_.open(i,a),To(()=>{this.secondaryConn_&&(this.log_("Timed out trying to upgrade."),this.secondaryConn_.close())},Math.floor(fj))}onReset_(e){this.log_("Reset packet received.  New host: "+e),this.repoInfo_.host=e,this.state_===1?this.close():(this.closeConnections_(),this.start_())}onConnectionEstablished_(e,i){this.log_("Realtime connection established."),this.conn_=e,this.state_=1,this.onReady_&&(this.onReady_(i,this.sessionId),this.onReady_=null),this.primaryResponsesRequired_===0?(this.log_("Primary connection is healthy."),this.isHealthy_=!0):To(()=>{this.sendPingOnPrimaryIfNecessary_()},Math.floor(hj))}sendPingOnPrimaryIfNecessary_(){!this.isHealthy_&&this.state_===1&&(this.log_("sending ping on primary."),this.sendData_({t:"c",d:{t:yv,d:{}}}))}onSecondaryConnectionLost_(){const e=this.secondaryConn_;this.secondaryConn_=null,(this.tx_===e||this.rx_===e)&&this.close()}onConnectionLost_(e){this.conn_=null,!e&&this.state_===0?(this.log_("Realtime connection failed."),this.repoInfo_.isCacheableHost()&&(Dr.remove("host:"+this.repoInfo_.host),this.repoInfo_.internalHost=this.repoInfo_.host)):this.state_===1&&this.log_("Realtime connection lost."),this.close()}onConnectionShutdown_(e){this.log_("Connection shutdown command received. Shutting down..."),this.onKill_&&(this.onKill_(e),this.onKill_=null),this.onDisconnect_=null,this.close()}sendData_(e){if(this.state_!==1)throw"Connection is not connected";this.tx_.send(e)}close(){this.state_!==2&&(this.log_("Closing realtime connection."),this.state_=2,this.closeConnections_(),this.onDisconnect_&&(this.onDisconnect_(),this.onDisconnect_=null))}closeConnections_(){this.log_("Shutting down all connections"),this.conn_&&(this.conn_.close(),this.conn_=null),this.secondaryConn_&&(this.secondaryConn_.close(),this.secondaryConn_=null),this.healthyTimeout_&&(clearTimeout(this.healthyTimeout_),this.healthyTimeout_=null)}}class Bb{put(e,i,a,o){}merge(e,i,a,o){}refreshAuthToken(e){}refreshAppCheckToken(e){}onDisconnectPut(e,i,a){}onDisconnectMerge(e,i,a){}onDisconnectCancel(e,i){}reportStats(e){}}class zb{constructor(e){this.allowedEvents_=e,this.listeners_={},G(Array.isArray(e)&&e.length>0,"Requires a non-empty array")}trigger(e,...i){if(Array.isArray(this.listeners_[e])){const a=[...this.listeners_[e]];for(let o=0;o<a.length;o++)a[o].callback.apply(a[o].context,i)}}on(e,i,a){this.validateEventType_(e),this.listeners_[e]=this.listeners_[e]||[],this.listeners_[e].push({callback:i,context:a});const o=this.getInitialEvent(e);o&&i.apply(a,o)}off(e,i,a){this.validateEventType_(e);const o=this.listeners_[e]||[];for(let c=0;c<o.length;c++)if(o[c].callback===i&&(!a||a===o[c].context)){o.splice(c,1);return}}validateEventType_(e){G(this.allowedEvents_.find(i=>i===e),"Unknown event: "+e)}}class tu extends zb{static getInstance(){return new tu}constructor(){super(["online"]),this.online_=!0,typeof window<"u"&&typeof window.addEventListener<"u"&&!ff()&&(window.addEventListener("online",()=>{this.online_||(this.online_=!0,this.trigger("online",!0))},!1),window.addEventListener("offline",()=>{this.online_&&(this.online_=!1,this.trigger("online",!1))},!1))}getInitialEvent(e){return G(e==="online","Unknown event type: "+e),[this.online_]}currentlyOnline(){return this.online_}}const vv=32,xv=768;class Ie{constructor(e,i){if(i===void 0){this.pieces_=e.split("/");let a=0;for(let o=0;o<this.pieces_.length;o++)this.pieces_[o].length>0&&(this.pieces_[a]=this.pieces_[o],a++);this.pieces_.length=a,this.pieceNum_=0}else this.pieces_=e,this.pieceNum_=i}toString(){let e="";for(let i=this.pieceNum_;i<this.pieces_.length;i++)this.pieces_[i]!==""&&(e+="/"+this.pieces_[i]);return e||"/"}}function je(){return new Ie("")}function pe(n){return n.pieceNum_>=n.pieces_.length?null:n.pieces_[n.pieceNum_]}function rr(n){return n.pieces_.length-n.pieceNum_}function Fe(n){let e=n.pieceNum_;return e<n.pieces_.length&&e++,new Ie(n.pieces_,e)}function Mf(n){return n.pieceNum_<n.pieces_.length?n.pieces_[n.pieces_.length-1]:null}function Sj(n){let e="";for(let i=n.pieceNum_;i<n.pieces_.length;i++)n.pieces_[i]!==""&&(e+="/"+encodeURIComponent(String(n.pieces_[i])));return e||"/"}function Lo(n,e=0){return n.pieces_.slice(n.pieceNum_+e)}function Fb(n){if(n.pieceNum_>=n.pieces_.length)return null;const e=[];for(let i=n.pieceNum_;i<n.pieces_.length-1;i++)e.push(n.pieces_[i]);return new Ie(e,0)}function Xe(n,e){const i=[];for(let a=n.pieceNum_;a<n.pieces_.length;a++)i.push(n.pieces_[a]);if(e instanceof Ie)for(let a=e.pieceNum_;a<e.pieces_.length;a++)i.push(e.pieces_[a]);else{const a=e.split("/");for(let o=0;o<a.length;o++)a[o].length>0&&i.push(a[o])}return new Ie(i,0)}function ge(n){return n.pieceNum_>=n.pieces_.length}function jt(n,e){const i=pe(n),a=pe(e);if(i===null)return e;if(i===a)return jt(Fe(n),Fe(e));throw new Error("INTERNAL ERROR: innerPath ("+e+") is not within outerPath ("+n+")")}function Cj(n,e){const i=Lo(n,0),a=Lo(e,0);for(let o=0;o<i.length&&o<a.length;o++){const c=Kr(i[o],a[o]);if(c!==0)return c}return i.length===a.length?0:i.length<a.length?-1:1}function Rf(n,e){if(rr(n)!==rr(e))return!1;for(let i=n.pieceNum_,a=e.pieceNum_;i<=n.pieces_.length;i++,a++)if(n.pieces_[i]!==e.pieces_[a])return!1;return!0}function fn(n,e){let i=n.pieceNum_,a=e.pieceNum_;if(rr(n)>rr(e))return!1;for(;i<n.pieces_.length;){if(n.pieces_[i]!==e.pieces_[a])return!1;++i,++a}return!0}class Oj{constructor(e,i){this.errorPrefix_=i,this.parts_=Lo(e,0),this.byteLength_=Math.max(1,this.parts_.length);for(let a=0;a<this.parts_.length;a++)this.byteLength_+=xu(this.parts_[a]);qb(this)}}function _j(n,e){n.parts_.length>0&&(n.byteLength_+=1),n.parts_.push(e),n.byteLength_+=xu(e),qb(n)}function Tj(n){const e=n.parts_.pop();n.byteLength_-=xu(e),n.parts_.length>0&&(n.byteLength_-=1)}function qb(n){if(n.byteLength_>xv)throw new Error(n.errorPrefix_+"has a key path longer than "+xv+" bytes ("+n.byteLength_+").");if(n.parts_.length>vv)throw new Error(n.errorPrefix_+"path specified exceeds the maximum depth that can be written ("+vv+") or object contains a cycle "+Mr(n))}function Mr(n){return n.parts_.length===0?"":"in property '"+n.parts_.join(".")+"'"}class Df extends zb{static getInstance(){return new Df}constructor(){super(["visible"]);let e,i;typeof document<"u"&&typeof document.addEventListener<"u"&&(typeof document.hidden<"u"?(i="visibilitychange",e="hidden"):typeof document.mozHidden<"u"?(i="mozvisibilitychange",e="mozHidden"):typeof document.msHidden<"u"?(i="msvisibilitychange",e="msHidden"):typeof document.webkitHidden<"u"&&(i="webkitvisibilitychange",e="webkitHidden")),this.visible_=!0,i&&document.addEventListener(i,()=>{const a=!document[e];a!==this.visible_&&(this.visible_=a,this.trigger("visible",a))},!1)}getInitialEvent(e){return G(e==="visible","Unknown event type: "+e),[this.visible_]}}const ho=1e3,kj=300*1e3,bv=30*1e3,Nj=1.3,Ej=3e4,jj="server_kill",wv=3;class ui extends Bb{constructor(e,i,a,o,c,d,m,f){if(super(),this.repoInfo_=e,this.applicationId_=i,this.onDataUpdate_=a,this.onConnectStatus_=o,this.onServerInfoUpdate_=c,this.authTokenProvider_=d,this.appCheckTokenProvider_=m,this.authOverride_=f,this.id=ui.nextPersistentConnectionId_++,this.log_=el("p:"+this.id+":"),this.interruptReasons_={},this.listens=new Map,this.outstandingPuts_=[],this.outstandingGets_=[],this.outstandingPutCount_=0,this.outstandingGetCount_=0,this.onDisconnectRequestQueue_=[],this.connected_=!1,this.reconnectDelay_=ho,this.maxReconnectDelay_=kj,this.securityDebugCallback_=null,this.lastSessionId=null,this.establishConnectionTimer_=null,this.visible_=!1,this.requestCBHash_={},this.requestNumber_=0,this.realtime_=null,this.authToken_=null,this.appCheckToken_=null,this.forceTokenRefresh_=!1,this.invalidAuthTokenCount_=0,this.invalidAppCheckTokenCount_=0,this.firstConnection_=!0,this.lastConnectionAttemptTime_=null,this.lastConnectionEstablishedTime_=null,f)throw new Error("Auth override specified in options, but not supported on non Node.js platforms");Df.getInstance().on("visible",this.onVisible_,this),e.host.indexOf("fblocal")===-1&&tu.getInstance().on("online",this.onOnline_,this)}sendRequest(e,i,a){const o=++this.requestNumber_,c={r:o,a:e,b:i};this.log_(mt(c)),G(this.connected_,"sendRequest call when we're not connected not allowed."),this.realtime_.sendRequest(c),a&&(this.requestCBHash_[o]=a)}get(e){this.initConnection_();const i=new Mn,o={action:"g",request:{p:e._path.toString(),q:e._queryObject},onComplete:d=>{const m=d.d;d.s==="ok"?i.resolve(m):i.reject(m)}};this.outstandingGets_.push(o),this.outstandingGetCount_++;const c=this.outstandingGets_.length-1;return this.connected_&&this.sendGet_(c),i.promise}listen(e,i,a,o){this.initConnection_();const c=e._queryIdentifier,d=e._path.toString();this.log_("Listen called for "+d+" "+c),this.listens.has(d)||this.listens.set(d,new Map),G(e._queryParams.isDefault()||!e._queryParams.loadsAllData(),"listen() called for non-default but complete query"),G(!this.listens.get(d).has(c),"listen() called twice for same path/queryId.");const m={onComplete:o,hashFn:i,query:e,tag:a};this.listens.get(d).set(c,m),this.connected_&&this.sendListen_(m)}sendGet_(e){const i=this.outstandingGets_[e];this.sendRequest("g",i.request,a=>{delete this.outstandingGets_[e],this.outstandingGetCount_--,this.outstandingGetCount_===0&&(this.outstandingGets_=[]),i.onComplete&&i.onComplete(a)})}sendListen_(e){const i=e.query,a=i._path.toString(),o=i._queryIdentifier;this.log_("Listen on "+a+" for "+o);const c={p:a},d="q";e.tag&&(c.q=i._queryObject,c.t=e.tag),c.h=e.hashFn(),this.sendRequest(d,c,m=>{const f=m.d,h=m.s;ui.warnOnListenWarnings_(f,i),(this.listens.get(a)&&this.listens.get(a).get(o))===e&&(this.log_("listen response",m),h!=="ok"&&this.removeListen_(a,o),e.onComplete&&e.onComplete(h,f))})}static warnOnListenWarnings_(e,i){if(e&&typeof e=="object"&&Un(e,"w")){const a=Ka(e,"w");if(Array.isArray(a)&&~a.indexOf("no_index")){const o='".indexOn": "'+i._queryParams.getIndex().toString()+'"',c=i._path.toString();At(`Using an unspecified index. Your data will be downloaded and filtered on the client. Consider adding ${o} at ${c} to your security rules for better performance.`)}}}refreshAuthToken(e){this.authToken_=e,this.log_("Auth token refreshed"),this.authToken_?this.tryAuth():this.connected_&&this.sendRequest("unauth",{},()=>{}),this.reduceReconnectDelayIfAdminCredential_(e)}reduceReconnectDelayIfAdminCredential_(e){(e&&e.length===40||eT(e))&&(this.log_("Admin auth credential detected.  Reducing max reconnect time."),this.maxReconnectDelay_=bv)}refreshAppCheckToken(e){this.appCheckToken_=e,this.log_("App check token refreshed"),this.appCheckToken_?this.tryAppCheck():this.connected_&&this.sendRequest("unappeck",{},()=>{})}tryAuth(){if(this.connected_&&this.authToken_){const e=this.authToken_,i=J_(e)?"auth":"gauth",a={cred:e};this.authOverride_===null?a.noauth=!0:typeof this.authOverride_=="object"&&(a.authvar=this.authOverride_),this.sendRequest(i,a,o=>{const c=o.s,d=o.d||"error";this.authToken_===e&&(c==="ok"?this.invalidAuthTokenCount_=0:this.onAuthRevoked_(c,d))})}}tryAppCheck(){this.connected_&&this.appCheckToken_&&this.sendRequest("appcheck",{token:this.appCheckToken_},e=>{const i=e.s,a=e.d||"error";i==="ok"?this.invalidAppCheckTokenCount_=0:this.onAppCheckRevoked_(i,a)})}unlisten(e,i){const a=e._path.toString(),o=e._queryIdentifier;this.log_("Unlisten called for "+a+" "+o),G(e._queryParams.isDefault()||!e._queryParams.loadsAllData(),"unlisten() called for non-default but complete query"),this.removeListen_(a,o)&&this.connected_&&this.sendUnlisten_(a,o,e._queryObject,i)}sendUnlisten_(e,i,a,o){this.log_("Unlisten on "+e+" for "+i);const c={p:e},d="n";o&&(c.q=a,c.t=o),this.sendRequest(d,c)}onDisconnectPut(e,i,a){this.initConnection_(),this.connected_?this.sendOnDisconnect_("o",e,i,a):this.onDisconnectRequestQueue_.push({pathString:e,action:"o",data:i,onComplete:a})}onDisconnectMerge(e,i,a){this.initConnection_(),this.connected_?this.sendOnDisconnect_("om",e,i,a):this.onDisconnectRequestQueue_.push({pathString:e,action:"om",data:i,onComplete:a})}onDisconnectCancel(e,i){this.initConnection_(),this.connected_?this.sendOnDisconnect_("oc",e,null,i):this.onDisconnectRequestQueue_.push({pathString:e,action:"oc",data:null,onComplete:i})}sendOnDisconnect_(e,i,a,o){const c={p:i,d:a};this.log_("onDisconnect "+e,c),this.sendRequest(e,c,d=>{o&&setTimeout(()=>{o(d.s,d.d)},Math.floor(0))})}put(e,i,a,o){this.putInternal("p",e,i,a,o)}merge(e,i,a,o){this.putInternal("m",e,i,a,o)}putInternal(e,i,a,o,c){this.initConnection_();const d={p:i,d:a};c!==void 0&&(d.h=c),this.outstandingPuts_.push({action:e,request:d,onComplete:o}),this.outstandingPutCount_++;const m=this.outstandingPuts_.length-1;this.connected_?this.sendPut_(m):this.log_("Buffering put: "+i)}sendPut_(e){const i=this.outstandingPuts_[e].action,a=this.outstandingPuts_[e].request,o=this.outstandingPuts_[e].onComplete;this.outstandingPuts_[e].queued=this.connected_,this.sendRequest(i,a,c=>{this.log_(i+" response",c),delete this.outstandingPuts_[e],this.outstandingPutCount_--,this.outstandingPutCount_===0&&(this.outstandingPuts_=[]),o&&o(c.s,c.d)})}reportStats(e){if(this.connected_){const i={c:e};this.log_("reportStats",i),this.sendRequest("s",i,a=>{if(a.s!=="ok"){const c=a.d;this.log_("reportStats","Error sending stats: "+c)}})}}onDataMessage_(e){if("r"in e){this.log_("from server: "+mt(e));const i=e.r,a=this.requestCBHash_[i];a&&(delete this.requestCBHash_[i],a(e.b))}else{if("error"in e)throw"A server-side error has occurred: "+e.error;"a"in e&&this.onDataPush_(e.a,e.b)}}onDataPush_(e,i){this.log_("handleServerMessage",e,i),e==="d"?this.onDataUpdate_(i.p,i.d,!1,i.t):e==="m"?this.onDataUpdate_(i.p,i.d,!0,i.t):e==="c"?this.onListenRevoked_(i.p,i.q):e==="ac"?this.onAuthRevoked_(i.s,i.d):e==="apc"?this.onAppCheckRevoked_(i.s,i.d):e==="sd"?this.onSecurityDebugPacket_(i):Lm("Unrecognized action received from server: "+mt(e)+`
Are you using the latest client?`)}onReady_(e,i){this.log_("connection ready"),this.connected_=!0,this.lastConnectionEstablishedTime_=new Date().getTime(),this.handleTimestamp_(e),this.lastSessionId=i,this.firstConnection_&&this.sendConnectStats_(),this.restoreState_(),this.firstConnection_=!1,this.onConnectStatus_(!0)}scheduleConnect_(e){G(!this.realtime_,"Scheduling a connect when we're already connected/ing?"),this.establishConnectionTimer_&&clearTimeout(this.establishConnectionTimer_),this.establishConnectionTimer_=setTimeout(()=>{this.establishConnectionTimer_=null,this.establishConnection_()},Math.floor(e))}initConnection_(){!this.realtime_&&this.firstConnection_&&this.scheduleConnect_(0)}onVisible_(e){e&&!this.visible_&&this.reconnectDelay_===this.maxReconnectDelay_&&(this.log_("Window became visible.  Reducing delay."),this.reconnectDelay_=ho,this.realtime_||this.scheduleConnect_(0)),this.visible_=e}onOnline_(e){e?(this.log_("Browser went online."),this.reconnectDelay_=ho,this.realtime_||this.scheduleConnect_(0)):(this.log_("Browser went offline.  Killing connection."),this.realtime_&&this.realtime_.close())}onRealtimeDisconnect_(){if(this.log_("data client disconnected"),this.connected_=!1,this.realtime_=null,this.cancelSentTransactions_(),this.requestCBHash_={},this.shouldReconnect_()){this.visible_?this.lastConnectionEstablishedTime_&&(new Date().getTime()-this.lastConnectionEstablishedTime_>Ej&&(this.reconnectDelay_=ho),this.lastConnectionEstablishedTime_=null):(this.log_("Window isn't visible.  Delaying reconnect."),this.reconnectDelay_=this.maxReconnectDelay_,this.lastConnectionAttemptTime_=new Date().getTime());const e=Math.max(0,new Date().getTime()-this.lastConnectionAttemptTime_);let i=Math.max(0,this.reconnectDelay_-e);i=Math.random()*i,this.log_("Trying to reconnect in "+i+"ms"),this.scheduleConnect_(i),this.reconnectDelay_=Math.min(this.maxReconnectDelay_,this.reconnectDelay_*Nj)}this.onConnectStatus_(!1)}async establishConnection_(){if(this.shouldReconnect_()){this.log_("Making a connection attempt"),this.lastConnectionAttemptTime_=new Date().getTime(),this.lastConnectionEstablishedTime_=null;const e=this.onDataMessage_.bind(this),i=this.onReady_.bind(this),a=this.onRealtimeDisconnect_.bind(this),o=this.id+":"+ui.nextConnectionId_++,c=this.lastSessionId;let d=!1,m=null;const f=function(){m?m.close():(d=!0,a())},h=function(v){G(m,"sendRequest call when we're not connected not allowed."),m.sendRequest(v)};this.realtime_={close:f,sendRequest:h};const x=this.forceTokenRefresh_;this.forceTokenRefresh_=!1;try{const[v,b]=await Promise.all([this.authTokenProvider_.getToken(x),this.appCheckTokenProvider_.getToken(x)]);d?vt("getToken() completed but was canceled"):(vt("getToken() completed. Creating connection."),this.authToken_=v&&v.accessToken,this.appCheckToken_=b&&b.token,m=new wj(o,this.repoInfo_,this.applicationId_,this.appCheckToken_,this.authToken_,e,i,a,_=>{At(_+" ("+this.repoInfo_.toString()+")"),this.interrupt(jj)},c))}catch(v){this.log_("Failed to get token: "+v),d||(this.repoInfo_.nodeAdmin&&At(v),f())}}}interrupt(e){vt("Interrupting connection for reason: "+e),this.interruptReasons_[e]=!0,this.realtime_?this.realtime_.close():(this.establishConnectionTimer_&&(clearTimeout(this.establishConnectionTimer_),this.establishConnectionTimer_=null),this.connected_&&this.onRealtimeDisconnect_())}resume(e){vt("Resuming connection for reason: "+e),delete this.interruptReasons_[e],Gc(this.interruptReasons_)&&(this.reconnectDelay_=ho,this.realtime_||this.scheduleConnect_(0))}handleTimestamp_(e){const i=e-new Date().getTime();this.onServerInfoUpdate_({serverTimeOffset:i})}cancelSentTransactions_(){for(let e=0;e<this.outstandingPuts_.length;e++){const i=this.outstandingPuts_[e];i&&"h"in i.request&&i.queued&&(i.onComplete&&i.onComplete("disconnect"),delete this.outstandingPuts_[e],this.outstandingPutCount_--)}this.outstandingPutCount_===0&&(this.outstandingPuts_=[])}onListenRevoked_(e,i){let a;i?a=i.map(c=>Nf(c)).join("$"):a="default";const o=this.removeListen_(e,a);o&&o.onComplete&&o.onComplete("permission_denied")}removeListen_(e,i){const a=new Ie(e).toString();let o;if(this.listens.has(a)){const c=this.listens.get(a);o=c.get(i),c.delete(i),c.size===0&&this.listens.delete(a)}else o=void 0;return o}onAuthRevoked_(e,i){vt("Auth token revoked: "+e+"/"+i),this.authToken_=null,this.forceTokenRefresh_=!0,this.realtime_.close(),(e==="invalid_token"||e==="permission_denied")&&(this.invalidAuthTokenCount_++,this.invalidAuthTokenCount_>=wv&&(this.reconnectDelay_=bv,this.authTokenProvider_.notifyForInvalidToken()))}onAppCheckRevoked_(e,i){vt("App check token revoked: "+e+"/"+i),this.appCheckToken_=null,this.forceTokenRefresh_=!0,(e==="invalid_token"||e==="permission_denied")&&(this.invalidAppCheckTokenCount_++,this.invalidAppCheckTokenCount_>=wv&&this.appCheckTokenProvider_.notifyForInvalidToken())}onSecurityDebugPacket_(e){this.securityDebugCallback_?this.securityDebugCallback_(e):"msg"in e&&console.log("FIREBASE: "+e.msg.replace(`
`,`
FIREBASE: `))}restoreState_(){this.tryAuth(),this.tryAppCheck();for(const e of this.listens.values())for(const i of e.values())this.sendListen_(i);for(let e=0;e<this.outstandingPuts_.length;e++)this.outstandingPuts_[e]&&this.sendPut_(e);for(;this.onDisconnectRequestQueue_.length;){const e=this.onDisconnectRequestQueue_.shift();this.sendOnDisconnect_(e.action,e.pathString,e.data,e.onComplete)}for(let e=0;e<this.outstandingGets_.length;e++)this.outstandingGets_[e]&&this.sendGet_(e)}sendConnectStats_(){const e={};let i="js";e["sdk."+i+"."+vb.replace(/\./g,"-")]=1,ff()?e["framework.cordova"]=1:Ax()&&(e["framework.reactnative"]=1),this.reportStats(e)}shouldReconnect_(){const e=tu.getInstance().currentlyOnline();return Gc(this.interruptReasons_)&&e}}ui.nextPersistentConnectionId_=0;ui.nextConnectionId_=0;class ye{constructor(e,i){this.name=e,this.node=i}static Wrap(e,i){return new ye(e,i)}}class _u{getCompare(){return this.compare.bind(this)}indexedValueChanged(e,i){const a=new ye($a,e),o=new ye($a,i);return this.compare(a,o)!==0}minPost(){return ye.MIN}}let kc;class Hb extends _u{static get __EMPTY_NODE(){return kc}static set __EMPTY_NODE(e){kc=e}compare(e,i){return Kr(e.name,i.name)}isDefinedOn(e){throw as("KeyIndex.isDefinedOn not expected to be called.")}indexedValueChanged(e,i){return!1}minPost(){return ye.MIN}maxPost(){return new ye(qr,kc)}makePost(e,i){return G(typeof e=="string","KeyIndex indexValue must always be a string."),new ye(e,kc)}toString(){return".key"}}const Wa=new Hb;class Nc{constructor(e,i,a,o,c=null){this.isReverse_=o,this.resultGenerator_=c,this.nodeStack_=[];let d=1;for(;!e.isEmpty();)if(e=e,d=i?a(e.key,i):1,o&&(d*=-1),d<0)this.isReverse_?e=e.left:e=e.right;else if(d===0){this.nodeStack_.push(e);break}else this.nodeStack_.push(e),this.isReverse_?e=e.right:e=e.left}getNext(){if(this.nodeStack_.length===0)return null;let e=this.nodeStack_.pop(),i;if(this.resultGenerator_?i=this.resultGenerator_(e.key,e.value):i={key:e.key,value:e.value},this.isReverse_)for(e=e.left;!e.isEmpty();)this.nodeStack_.push(e),e=e.right;else for(e=e.right;!e.isEmpty();)this.nodeStack_.push(e),e=e.left;return i}hasNext(){return this.nodeStack_.length>0}peek(){if(this.nodeStack_.length===0)return null;const e=this.nodeStack_[this.nodeStack_.length-1];return this.resultGenerator_?this.resultGenerator_(e.key,e.value):{key:e.key,value:e.value}}}class yt{constructor(e,i,a,o,c){this.key=e,this.value=i,this.color=a??yt.RED,this.left=o??Yt.EMPTY_NODE,this.right=c??Yt.EMPTY_NODE}copy(e,i,a,o,c){return new yt(e??this.key,i??this.value,a??this.color,o??this.left,c??this.right)}count(){return this.left.count()+1+this.right.count()}isEmpty(){return!1}inorderTraversal(e){return this.left.inorderTraversal(e)||!!e(this.key,this.value)||this.right.inorderTraversal(e)}reverseTraversal(e){return this.right.reverseTraversal(e)||e(this.key,this.value)||this.left.reverseTraversal(e)}min_(){return this.left.isEmpty()?this:this.left.min_()}minKey(){return this.min_().key}maxKey(){return this.right.isEmpty()?this.key:this.right.maxKey()}insert(e,i,a){let o=this;const c=a(e,o.key);return c<0?o=o.copy(null,null,null,o.left.insert(e,i,a),null):c===0?o=o.copy(null,i,null,null,null):o=o.copy(null,null,null,null,o.right.insert(e,i,a)),o.fixUp_()}removeMin_(){if(this.left.isEmpty())return Yt.EMPTY_NODE;let e=this;return!e.left.isRed_()&&!e.left.left.isRed_()&&(e=e.moveRedLeft_()),e=e.copy(null,null,null,e.left.removeMin_(),null),e.fixUp_()}remove(e,i){let a,o;if(a=this,i(e,a.key)<0)!a.left.isEmpty()&&!a.left.isRed_()&&!a.left.left.isRed_()&&(a=a.moveRedLeft_()),a=a.copy(null,null,null,a.left.remove(e,i),null);else{if(a.left.isRed_()&&(a=a.rotateRight_()),!a.right.isEmpty()&&!a.right.isRed_()&&!a.right.left.isRed_()&&(a=a.moveRedRight_()),i(e,a.key)===0){if(a.right.isEmpty())return Yt.EMPTY_NODE;o=a.right.min_(),a=a.copy(o.key,o.value,null,null,a.right.removeMin_())}a=a.copy(null,null,null,null,a.right.remove(e,i))}return a.fixUp_()}isRed_(){return this.color}fixUp_(){let e=this;return e.right.isRed_()&&!e.left.isRed_()&&(e=e.rotateLeft_()),e.left.isRed_()&&e.left.left.isRed_()&&(e=e.rotateRight_()),e.left.isRed_()&&e.right.isRed_()&&(e=e.colorFlip_()),e}moveRedLeft_(){let e=this.colorFlip_();return e.right.left.isRed_()&&(e=e.copy(null,null,null,null,e.right.rotateRight_()),e=e.rotateLeft_(),e=e.colorFlip_()),e}moveRedRight_(){let e=this.colorFlip_();return e.left.left.isRed_()&&(e=e.rotateRight_(),e=e.colorFlip_()),e}rotateLeft_(){const e=this.copy(null,null,yt.RED,null,this.right.left);return this.right.copy(null,null,this.color,e,null)}rotateRight_(){const e=this.copy(null,null,yt.RED,this.left.right,null);return this.left.copy(null,null,this.color,null,e)}colorFlip_(){const e=this.left.copy(null,null,!this.left.color,null,null),i=this.right.copy(null,null,!this.right.color,null,null);return this.copy(null,null,!this.color,e,i)}checkMaxDepth_(){const e=this.check_();return Math.pow(2,e)<=this.count()+1}check_(){if(this.isRed_()&&this.left.isRed_())throw new Error("Red node has red child("+this.key+","+this.value+")");if(this.right.isRed_())throw new Error("Right child of ("+this.key+","+this.value+") is red");const e=this.left.check_();if(e!==this.right.check_())throw new Error("Black depths differ");return e+(this.isRed_()?0:1)}}yt.RED=!0;yt.BLACK=!1;class Aj{copy(e,i,a,o,c){return this}insert(e,i,a){return new yt(e,i,null)}remove(e,i){return this}count(){return 0}isEmpty(){return!0}inorderTraversal(e){return!1}reverseTraversal(e){return!1}minKey(){return null}maxKey(){return null}check_(){return 0}isRed_(){return!1}}class Yt{constructor(e,i=Yt.EMPTY_NODE){this.comparator_=e,this.root_=i}insert(e,i){return new Yt(this.comparator_,this.root_.insert(e,i,this.comparator_).copy(null,null,yt.BLACK,null,null))}remove(e){return new Yt(this.comparator_,this.root_.remove(e,this.comparator_).copy(null,null,yt.BLACK,null,null))}get(e){let i,a=this.root_;for(;!a.isEmpty();){if(i=this.comparator_(e,a.key),i===0)return a.value;i<0?a=a.left:i>0&&(a=a.right)}return null}getPredecessorKey(e){let i,a=this.root_,o=null;for(;!a.isEmpty();)if(i=this.comparator_(e,a.key),i===0){if(a.left.isEmpty())return o?o.key:null;for(a=a.left;!a.right.isEmpty();)a=a.right;return a.key}else i<0?a=a.left:i>0&&(o=a,a=a.right);throw new Error("Attempted to find predecessor key for a nonexistent key.  What gives?")}isEmpty(){return this.root_.isEmpty()}count(){return this.root_.count()}minKey(){return this.root_.minKey()}maxKey(){return this.root_.maxKey()}inorderTraversal(e){return this.root_.inorderTraversal(e)}reverseTraversal(e){return this.root_.reverseTraversal(e)}getIterator(e){return new Nc(this.root_,null,this.comparator_,!1,e)}getIteratorFrom(e,i){return new Nc(this.root_,e,this.comparator_,!1,i)}getReverseIteratorFrom(e,i){return new Nc(this.root_,e,this.comparator_,!0,i)}getReverseIterator(e){return new Nc(this.root_,null,this.comparator_,!0,e)}}Yt.EMPTY_NODE=new Aj;function Mj(n,e){return Kr(n.name,e.name)}function If(n,e){return Kr(n,e)}let Bm;function Rj(n){Bm=n}const Yb=function(n){return typeof n=="number"?"number:"+Sb(n):"string:"+n},Gb=function(n){if(n.isLeafNode()){const e=n.val();G(typeof e=="string"||typeof e=="number"||typeof e=="object"&&Un(e,".sv"),"Priority must be a string or number.")}else G(n===Bm||n.isEmpty(),"priority of unexpected type.");G(n===Bm||n.getPriority().isEmpty(),"Priority nodes can't have a priority of their own.")};let Sv;class gt{static set __childrenNodeConstructor(e){Sv=e}static get __childrenNodeConstructor(){return Sv}constructor(e,i=gt.__childrenNodeConstructor.EMPTY_NODE){this.value_=e,this.priorityNode_=i,this.lazyHash_=null,G(this.value_!==void 0&&this.value_!==null,"LeafNode shouldn't be created with null/undefined value."),Gb(this.priorityNode_)}isLeafNode(){return!0}getPriority(){return this.priorityNode_}updatePriority(e){return new gt(this.value_,e)}getImmediateChild(e){return e===".priority"?this.priorityNode_:gt.__childrenNodeConstructor.EMPTY_NODE}getChild(e){return ge(e)?this:pe(e)===".priority"?this.priorityNode_:gt.__childrenNodeConstructor.EMPTY_NODE}hasChild(){return!1}getPredecessorChildName(e,i){return null}updateImmediateChild(e,i){return e===".priority"?this.updatePriority(i):i.isEmpty()&&e!==".priority"?this:gt.__childrenNodeConstructor.EMPTY_NODE.updateImmediateChild(e,i).updatePriority(this.priorityNode_)}updateChild(e,i){const a=pe(e);return a===null?i:i.isEmpty()&&a!==".priority"?this:(G(a!==".priority"||rr(e)===1,".priority must be the last token in a path"),this.updateImmediateChild(a,gt.__childrenNodeConstructor.EMPTY_NODE.updateChild(Fe(e),i)))}isEmpty(){return!1}numChildren(){return 0}forEachChild(e,i){return!1}val(e){return e&&!this.getPriority().isEmpty()?{".value":this.getValue(),".priority":this.getPriority().val()}:this.getValue()}hash(){if(this.lazyHash_===null){let e="";this.priorityNode_.isEmpty()||(e+="priority:"+Yb(this.priorityNode_.val())+":");const i=typeof this.value_;e+=i+":",i==="number"?e+=Sb(this.value_):e+=this.value_,this.lazyHash_=bb(e)}return this.lazyHash_}getValue(){return this.value_}compareTo(e){return e===gt.__childrenNodeConstructor.EMPTY_NODE?1:e instanceof gt.__childrenNodeConstructor?-1:(G(e.isLeafNode(),"Unknown node type"),this.compareToLeafNode_(e))}compareToLeafNode_(e){const i=typeof e.value_,a=typeof this.value_,o=gt.VALUE_TYPE_ORDER.indexOf(i),c=gt.VALUE_TYPE_ORDER.indexOf(a);return G(o>=0,"Unknown leaf type: "+i),G(c>=0,"Unknown leaf type: "+a),o===c?a==="object"?0:this.value_<e.value_?-1:this.value_===e.value_?0:1:c-o}withIndex(){return this}isIndexed(){return!0}equals(e){if(e===this)return!0;if(e.isLeafNode()){const i=e;return this.value_===i.value_&&this.priorityNode_.equals(i.priorityNode_)}else return!1}}gt.VALUE_TYPE_ORDER=["object","boolean","number","string"];let Vb,Wb;function Dj(n){Vb=n}function Ij(n){Wb=n}class Pj extends _u{compare(e,i){const a=e.node.getPriority(),o=i.node.getPriority(),c=a.compareTo(o);return c===0?Kr(e.name,i.name):c}isDefinedOn(e){return!e.getPriority().isEmpty()}indexedValueChanged(e,i){return!e.getPriority().equals(i.getPriority())}minPost(){return ye.MIN}maxPost(){return new ye(qr,new gt("[PRIORITY-POST]",Wb))}makePost(e,i){const a=Vb(e);return new ye(i,new gt("[PRIORITY-POST]",a))}toString(){return".priority"}}const $e=new Pj;const Lj=Math.log(2);class Uj{constructor(e){const i=c=>parseInt(Math.log(c)/Lj,10),a=c=>parseInt(Array(c+1).join("1"),2);this.count=i(e+1),this.current_=this.count-1;const o=a(this.count);this.bits_=e+1&o}nextBitIsOne(){const e=!(this.bits_&1<<this.current_);return this.current_--,e}}const nu=function(n,e,i,a){n.sort(e);const o=function(f,h){const x=h-f;let v,b;if(x===0)return null;if(x===1)return v=n[f],b=i?i(v):v,new yt(b,v.node,yt.BLACK,null,null);{const _=parseInt(x/2,10)+f,N=o(f,_),D=o(_+1,h);return v=n[_],b=i?i(v):v,new yt(b,v.node,yt.BLACK,N,D)}},c=function(f){let h=null,x=null,v=n.length;const b=function(N,D){const q=v-N,F=v;v-=N;const I=o(q+1,F),H=n[q],z=i?i(H):H;_(new yt(z,H.node,D,null,I))},_=function(N){h?(h.left=N,h=N):(x=N,h=N)};for(let N=0;N<f.count;++N){const D=f.nextBitIsOne(),q=Math.pow(2,f.count-(N+1));D?b(q,yt.BLACK):(b(q,yt.BLACK),b(q,yt.RED))}return x},d=new Uj(n.length),m=c(d);return new Yt(a||e,m)};let ym;const Ba={};class oi{static get Default(){return G(Ba&&$e,"ChildrenNode.ts has not been loaded"),ym=ym||new oi({".priority":Ba},{".priority":$e}),ym}constructor(e,i){this.indexes_=e,this.indexSet_=i}get(e){const i=Ka(this.indexes_,e);if(!i)throw new Error("No index defined for "+e);return i instanceof Yt?i:null}hasIndex(e){return Un(this.indexSet_,e.toString())}addIndex(e,i){G(e!==Wa,"KeyIndex always exists and isn't meant to be added to the IndexMap.");const a=[];let o=!1;const c=i.getIterator(ye.Wrap);let d=c.getNext();for(;d;)o=o||e.isDefinedOn(d.node),a.push(d),d=c.getNext();let m;o?m=nu(a,e.getCompare()):m=Ba;const f=e.toString(),h={...this.indexSet_};h[f]=e;const x={...this.indexes_};return x[f]=m,new oi(x,h)}addToIndexes(e,i){const a=Vc(this.indexes_,(o,c)=>{const d=Ka(this.indexSet_,c);if(G(d,"Missing index implementation for "+c),o===Ba)if(d.isDefinedOn(e.node)){const m=[],f=i.getIterator(ye.Wrap);let h=f.getNext();for(;h;)h.name!==e.name&&m.push(h),h=f.getNext();return m.push(e),nu(m,d.getCompare())}else return Ba;else{const m=i.get(e.name);let f=o;return m&&(f=f.remove(new ye(e.name,m))),f.insert(e,e.node)}});return new oi(a,this.indexSet_)}removeFromIndexes(e,i){const a=Vc(this.indexes_,o=>{if(o===Ba)return o;{const c=i.get(e.name);return c?o.remove(new ye(e.name,c)):o}});return new oi(a,this.indexSet_)}}let go;class ae{static get EMPTY_NODE(){return go||(go=new ae(new Yt(If),null,oi.Default))}constructor(e,i,a){this.children_=e,this.priorityNode_=i,this.indexMap_=a,this.lazyHash_=null,this.priorityNode_&&Gb(this.priorityNode_),this.children_.isEmpty()&&G(!this.priorityNode_||this.priorityNode_.isEmpty(),"An empty node cannot have a priority")}isLeafNode(){return!1}getPriority(){return this.priorityNode_||go}updatePriority(e){return this.children_.isEmpty()?this:new ae(this.children_,e,this.indexMap_)}getImmediateChild(e){if(e===".priority")return this.getPriority();{const i=this.children_.get(e);return i===null?go:i}}getChild(e){const i=pe(e);return i===null?this:this.getImmediateChild(i).getChild(Fe(e))}hasChild(e){return this.children_.get(e)!==null}updateImmediateChild(e,i){if(G(i,"We should always be passing snapshot nodes"),e===".priority")return this.updatePriority(i);{const a=new ye(e,i);let o,c;i.isEmpty()?(o=this.children_.remove(e),c=this.indexMap_.removeFromIndexes(a,this.children_)):(o=this.children_.insert(e,i),c=this.indexMap_.addToIndexes(a,this.children_));const d=o.isEmpty()?go:this.priorityNode_;return new ae(o,d,c)}}updateChild(e,i){const a=pe(e);if(a===null)return i;{G(pe(e)!==".priority"||rr(e)===1,".priority must be the last token in a path");const o=this.getImmediateChild(a).updateChild(Fe(e),i);return this.updateImmediateChild(a,o)}}isEmpty(){return this.children_.isEmpty()}numChildren(){return this.children_.count()}val(e){if(this.isEmpty())return null;const i={};let a=0,o=0,c=!0;if(this.forEachChild($e,(d,m)=>{i[d]=m.val(e),a++,c&&ae.INTEGER_REGEXP_.test(d)?o=Math.max(o,Number(d)):c=!1}),!e&&c&&o<2*a){const d=[];for(const m in i)d[m]=i[m];return d}else return e&&!this.getPriority().isEmpty()&&(i[".priority"]=this.getPriority().val()),i}hash(){if(this.lazyHash_===null){let e="";this.getPriority().isEmpty()||(e+="priority:"+Yb(this.getPriority().val())+":"),this.forEachChild($e,(i,a)=>{const o=a.hash();o!==""&&(e+=":"+i+":"+o)}),this.lazyHash_=e===""?"":bb(e)}return this.lazyHash_}getPredecessorChildName(e,i,a){const o=this.resolveIndex_(a);if(o){const c=o.getPredecessorKey(new ye(e,i));return c?c.name:null}else return this.children_.getPredecessorKey(e)}getFirstChildName(e){const i=this.resolveIndex_(e);if(i){const a=i.minKey();return a&&a.name}else return this.children_.minKey()}getFirstChild(e){const i=this.getFirstChildName(e);return i?new ye(i,this.children_.get(i)):null}getLastChildName(e){const i=this.resolveIndex_(e);if(i){const a=i.maxKey();return a&&a.name}else return this.children_.maxKey()}getLastChild(e){const i=this.getLastChildName(e);return i?new ye(i,this.children_.get(i)):null}forEachChild(e,i){const a=this.resolveIndex_(e);return a?a.inorderTraversal(o=>i(o.name,o.node)):this.children_.inorderTraversal(i)}getIterator(e){return this.getIteratorFrom(e.minPost(),e)}getIteratorFrom(e,i){const a=this.resolveIndex_(i);if(a)return a.getIteratorFrom(e,o=>o);{const o=this.children_.getIteratorFrom(e.name,ye.Wrap);let c=o.peek();for(;c!=null&&i.compare(c,e)<0;)o.getNext(),c=o.peek();return o}}getReverseIterator(e){return this.getReverseIteratorFrom(e.maxPost(),e)}getReverseIteratorFrom(e,i){const a=this.resolveIndex_(i);if(a)return a.getReverseIteratorFrom(e,o=>o);{const o=this.children_.getReverseIteratorFrom(e.name,ye.Wrap);let c=o.peek();for(;c!=null&&i.compare(c,e)>0;)o.getNext(),c=o.peek();return o}}compareTo(e){return this.isEmpty()?e.isEmpty()?0:-1:e.isLeafNode()||e.isEmpty()?1:e===tl?-1:0}withIndex(e){if(e===Wa||this.indexMap_.hasIndex(e))return this;{const i=this.indexMap_.addIndex(e,this.children_);return new ae(this.children_,this.priorityNode_,i)}}isIndexed(e){return e===Wa||this.indexMap_.hasIndex(e)}equals(e){if(e===this)return!0;if(e.isLeafNode())return!1;{const i=e;if(this.getPriority().equals(i.getPriority()))if(this.children_.count()===i.children_.count()){const a=this.getIterator($e),o=i.getIterator($e);let c=a.getNext(),d=o.getNext();for(;c&&d;){if(c.name!==d.name||!c.node.equals(d.node))return!1;c=a.getNext(),d=o.getNext()}return c===null&&d===null}else return!1;else return!1}}resolveIndex_(e){return e===Wa?null:this.indexMap_.get(e.toString())}}ae.INTEGER_REGEXP_=/^(0|[1-9]\d*)$/;class Bj extends ae{constructor(){super(new Yt(If),ae.EMPTY_NODE,oi.Default)}compareTo(e){return e===this?0:1}equals(e){return e===this}getPriority(){return this}getImmediateChild(e){return ae.EMPTY_NODE}isEmpty(){return!1}}const tl=new Bj;Object.defineProperties(ye,{MIN:{value:new ye($a,ae.EMPTY_NODE)},MAX:{value:new ye(qr,tl)}});Hb.__EMPTY_NODE=ae.EMPTY_NODE;gt.__childrenNodeConstructor=ae;Rj(tl);Ij(tl);const zj=!0;function et(n,e=null){if(n===null)return ae.EMPTY_NODE;if(typeof n=="object"&&".priority"in n&&(e=n[".priority"]),G(e===null||typeof e=="string"||typeof e=="number"||typeof e=="object"&&".sv"in e,"Invalid priority type found: "+typeof e),typeof n=="object"&&".value"in n&&n[".value"]!==null&&(n=n[".value"]),typeof n!="object"||".sv"in n){const i=n;return new gt(i,et(e))}if(!(n instanceof Array)&&zj){const i=[];let a=!1;if(xt(n,(d,m)=>{if(d.substring(0,1)!=="."){const f=et(m);f.isEmpty()||(a=a||!f.getPriority().isEmpty(),i.push(new ye(d,f)))}}),i.length===0)return ae.EMPTY_NODE;const c=nu(i,Mj,d=>d.name,If);if(a){const d=nu(i,$e.getCompare());return new ae(c,et(e),new oi({".priority":d},{".priority":$e}))}else return new ae(c,et(e),oi.Default)}else{let i=ae.EMPTY_NODE;return xt(n,(a,o)=>{if(Un(n,a)&&a.substring(0,1)!=="."){const c=et(o);(c.isLeafNode()||!c.isEmpty())&&(i=i.updateImmediateChild(a,c))}}),i.updatePriority(et(e))}}Dj(et);class Fj extends _u{constructor(e){super(),this.indexPath_=e,G(!ge(e)&&pe(e)!==".priority","Can't create PathIndex with empty path or .priority key")}extractChild(e){return e.getChild(this.indexPath_)}isDefinedOn(e){return!e.getChild(this.indexPath_).isEmpty()}compare(e,i){const a=this.extractChild(e.node),o=this.extractChild(i.node),c=a.compareTo(o);return c===0?Kr(e.name,i.name):c}makePost(e,i){const a=et(e),o=ae.EMPTY_NODE.updateChild(this.indexPath_,a);return new ye(i,o)}maxPost(){const e=ae.EMPTY_NODE.updateChild(this.indexPath_,tl);return new ye(qr,e)}toString(){return Lo(this.indexPath_,0).join("/")}}class qj extends _u{compare(e,i){const a=e.node.compareTo(i.node);return a===0?Kr(e.name,i.name):a}isDefinedOn(e){return!0}indexedValueChanged(e,i){return!e.equals(i)}minPost(){return ye.MIN}maxPost(){return ye.MAX}makePost(e,i){const a=et(e);return new ye(i,a)}toString(){return".value"}}const Hj=new qj;function Kb(n){return{type:"value",snapshotNode:n}}function Za(n,e){return{type:"child_added",snapshotNode:e,childName:n}}function Uo(n,e){return{type:"child_removed",snapshotNode:e,childName:n}}function Bo(n,e,i){return{type:"child_changed",snapshotNode:e,childName:n,oldSnap:i}}function Yj(n,e){return{type:"child_moved",snapshotNode:e,childName:n}}class Pf{constructor(e){this.index_=e}updateChild(e,i,a,o,c,d){G(e.isIndexed(this.index_),"A node must be indexed if only a child is updated");const m=e.getImmediateChild(i);return m.getChild(o).equals(a.getChild(o))&&m.isEmpty()===a.isEmpty()||(d!=null&&(a.isEmpty()?e.hasChild(i)?d.trackChildChange(Uo(i,m)):G(e.isLeafNode(),"A child remove without an old child only makes sense on a leaf node"):m.isEmpty()?d.trackChildChange(Za(i,a)):d.trackChildChange(Bo(i,a,m))),e.isLeafNode()&&a.isEmpty())?e:e.updateImmediateChild(i,a).withIndex(this.index_)}updateFullNode(e,i,a){return a!=null&&(e.isLeafNode()||e.forEachChild($e,(o,c)=>{i.hasChild(o)||a.trackChildChange(Uo(o,c))}),i.isLeafNode()||i.forEachChild($e,(o,c)=>{if(e.hasChild(o)){const d=e.getImmediateChild(o);d.equals(c)||a.trackChildChange(Bo(o,c,d))}else a.trackChildChange(Za(o,c))})),i.withIndex(this.index_)}updatePriority(e,i){return e.isEmpty()?ae.EMPTY_NODE:e.updatePriority(i)}filtersNodes(){return!1}getIndexedFilter(){return this}getIndex(){return this.index_}}class zo{constructor(e){this.indexedFilter_=new Pf(e.getIndex()),this.index_=e.getIndex(),this.startPost_=zo.getStartPost_(e),this.endPost_=zo.getEndPost_(e),this.startIsInclusive_=!e.startAfterSet_,this.endIsInclusive_=!e.endBeforeSet_}getStartPost(){return this.startPost_}getEndPost(){return this.endPost_}matches(e){const i=this.startIsInclusive_?this.index_.compare(this.getStartPost(),e)<=0:this.index_.compare(this.getStartPost(),e)<0,a=this.endIsInclusive_?this.index_.compare(e,this.getEndPost())<=0:this.index_.compare(e,this.getEndPost())<0;return i&&a}updateChild(e,i,a,o,c,d){return this.matches(new ye(i,a))||(a=ae.EMPTY_NODE),this.indexedFilter_.updateChild(e,i,a,o,c,d)}updateFullNode(e,i,a){i.isLeafNode()&&(i=ae.EMPTY_NODE);let o=i.withIndex(this.index_);o=o.updatePriority(ae.EMPTY_NODE);const c=this;return i.forEachChild($e,(d,m)=>{c.matches(new ye(d,m))||(o=o.updateImmediateChild(d,ae.EMPTY_NODE))}),this.indexedFilter_.updateFullNode(e,o,a)}updatePriority(e,i){return e}filtersNodes(){return!0}getIndexedFilter(){return this.indexedFilter_}getIndex(){return this.index_}static getStartPost_(e){if(e.hasStart()){const i=e.getIndexStartName();return e.getIndex().makePost(e.getIndexStartValue(),i)}else return e.getIndex().minPost()}static getEndPost_(e){if(e.hasEnd()){const i=e.getIndexEndName();return e.getIndex().makePost(e.getIndexEndValue(),i)}else return e.getIndex().maxPost()}}class Gj{constructor(e){this.withinDirectionalStart=i=>this.reverse_?this.withinEndPost(i):this.withinStartPost(i),this.withinDirectionalEnd=i=>this.reverse_?this.withinStartPost(i):this.withinEndPost(i),this.withinStartPost=i=>{const a=this.index_.compare(this.rangedFilter_.getStartPost(),i);return this.startIsInclusive_?a<=0:a<0},this.withinEndPost=i=>{const a=this.index_.compare(i,this.rangedFilter_.getEndPost());return this.endIsInclusive_?a<=0:a<0},this.rangedFilter_=new zo(e),this.index_=e.getIndex(),this.limit_=e.getLimit(),this.reverse_=!e.isViewFromLeft(),this.startIsInclusive_=!e.startAfterSet_,this.endIsInclusive_=!e.endBeforeSet_}updateChild(e,i,a,o,c,d){return this.rangedFilter_.matches(new ye(i,a))||(a=ae.EMPTY_NODE),e.getImmediateChild(i).equals(a)?e:e.numChildren()<this.limit_?this.rangedFilter_.getIndexedFilter().updateChild(e,i,a,o,c,d):this.fullLimitUpdateChild_(e,i,a,c,d)}updateFullNode(e,i,a){let o;if(i.isLeafNode()||i.isEmpty())o=ae.EMPTY_NODE.withIndex(this.index_);else if(this.limit_*2<i.numChildren()&&i.isIndexed(this.index_)){o=ae.EMPTY_NODE.withIndex(this.index_);let c;this.reverse_?c=i.getReverseIteratorFrom(this.rangedFilter_.getEndPost(),this.index_):c=i.getIteratorFrom(this.rangedFilter_.getStartPost(),this.index_);let d=0;for(;c.hasNext()&&d<this.limit_;){const m=c.getNext();if(this.withinDirectionalStart(m))if(this.withinDirectionalEnd(m))o=o.updateImmediateChild(m.name,m.node),d++;else break;else continue}}else{o=i.withIndex(this.index_),o=o.updatePriority(ae.EMPTY_NODE);let c;this.reverse_?c=o.getReverseIterator(this.index_):c=o.getIterator(this.index_);let d=0;for(;c.hasNext();){const m=c.getNext();d<this.limit_&&this.withinDirectionalStart(m)&&this.withinDirectionalEnd(m)?d++:o=o.updateImmediateChild(m.name,ae.EMPTY_NODE)}}return this.rangedFilter_.getIndexedFilter().updateFullNode(e,o,a)}updatePriority(e,i){return e}filtersNodes(){return!0}getIndexedFilter(){return this.rangedFilter_.getIndexedFilter()}getIndex(){return this.index_}fullLimitUpdateChild_(e,i,a,o,c){let d;if(this.reverse_){const v=this.index_.getCompare();d=(b,_)=>v(_,b)}else d=this.index_.getCompare();const m=e;G(m.numChildren()===this.limit_,"");const f=new ye(i,a),h=this.reverse_?m.getFirstChild(this.index_):m.getLastChild(this.index_),x=this.rangedFilter_.matches(f);if(m.hasChild(i)){const v=m.getImmediateChild(i);let b=o.getChildAfterChild(this.index_,h,this.reverse_);for(;b!=null&&(b.name===i||m.hasChild(b.name));)b=o.getChildAfterChild(this.index_,b,this.reverse_);const _=b==null?1:d(b,f);if(x&&!a.isEmpty()&&_>=0)return c?.trackChildChange(Bo(i,a,v)),m.updateImmediateChild(i,a);{c?.trackChildChange(Uo(i,v));const D=m.updateImmediateChild(i,ae.EMPTY_NODE);return b!=null&&this.rangedFilter_.matches(b)?(c?.trackChildChange(Za(b.name,b.node)),D.updateImmediateChild(b.name,b.node)):D}}else return a.isEmpty()?e:x&&d(h,f)>=0?(c!=null&&(c.trackChildChange(Uo(h.name,h.node)),c.trackChildChange(Za(i,a))),m.updateImmediateChild(i,a).updateImmediateChild(h.name,ae.EMPTY_NODE)):e}}class Lf{constructor(){this.limitSet_=!1,this.startSet_=!1,this.startNameSet_=!1,this.startAfterSet_=!1,this.endSet_=!1,this.endNameSet_=!1,this.endBeforeSet_=!1,this.limit_=0,this.viewFrom_="",this.indexStartValue_=null,this.indexStartName_="",this.indexEndValue_=null,this.indexEndName_="",this.index_=$e}hasStart(){return this.startSet_}isViewFromLeft(){return this.viewFrom_===""?this.startSet_:this.viewFrom_==="l"}getIndexStartValue(){return G(this.startSet_,"Only valid if start has been set"),this.indexStartValue_}getIndexStartName(){return G(this.startSet_,"Only valid if start has been set"),this.startNameSet_?this.indexStartName_:$a}hasEnd(){return this.endSet_}getIndexEndValue(){return G(this.endSet_,"Only valid if end has been set"),this.indexEndValue_}getIndexEndName(){return G(this.endSet_,"Only valid if end has been set"),this.endNameSet_?this.indexEndName_:qr}hasLimit(){return this.limitSet_}hasAnchoredLimit(){return this.limitSet_&&this.viewFrom_!==""}getLimit(){return G(this.limitSet_,"Only valid if limit has been set"),this.limit_}getIndex(){return this.index_}loadsAllData(){return!(this.startSet_||this.endSet_||this.limitSet_)}isDefault(){return this.loadsAllData()&&this.index_===$e}copy(){const e=new Lf;return e.limitSet_=this.limitSet_,e.limit_=this.limit_,e.startSet_=this.startSet_,e.startAfterSet_=this.startAfterSet_,e.indexStartValue_=this.indexStartValue_,e.startNameSet_=this.startNameSet_,e.indexStartName_=this.indexStartName_,e.endSet_=this.endSet_,e.endBeforeSet_=this.endBeforeSet_,e.indexEndValue_=this.indexEndValue_,e.endNameSet_=this.endNameSet_,e.indexEndName_=this.indexEndName_,e.index_=this.index_,e.viewFrom_=this.viewFrom_,e}}function Vj(n){return n.loadsAllData()?new Pf(n.getIndex()):n.hasLimit()?new Gj(n):new zo(n)}function Cv(n){const e={};if(n.isDefault())return e;let i;if(n.index_===$e?i="$priority":n.index_===Hj?i="$value":n.index_===Wa?i="$key":(G(n.index_ instanceof Fj,"Unrecognized index type!"),i=n.index_.toString()),e.orderBy=mt(i),n.startSet_){const a=n.startAfterSet_?"startAfter":"startAt";e[a]=mt(n.indexStartValue_),n.startNameSet_&&(e[a]+=","+mt(n.indexStartName_))}if(n.endSet_){const a=n.endBeforeSet_?"endBefore":"endAt";e[a]=mt(n.indexEndValue_),n.endNameSet_&&(e[a]+=","+mt(n.indexEndName_))}return n.limitSet_&&(n.isViewFromLeft()?e.limitToFirst=n.limit_:e.limitToLast=n.limit_),e}function Ov(n){const e={};if(n.startSet_&&(e.sp=n.indexStartValue_,n.startNameSet_&&(e.sn=n.indexStartName_),e.sin=!n.startAfterSet_),n.endSet_&&(e.ep=n.indexEndValue_,n.endNameSet_&&(e.en=n.indexEndName_),e.ein=!n.endBeforeSet_),n.limitSet_){e.l=n.limit_;let i=n.viewFrom_;i===""&&(n.isViewFromLeft()?i="l":i="r"),e.vf=i}return n.index_!==$e&&(e.i=n.index_.toString()),e}class iu extends Bb{reportStats(e){throw new Error("Method not implemented.")}static getListenId_(e,i){return i!==void 0?"tag$"+i:(G(e._queryParams.isDefault(),"should have a tag if it's not a default query."),e._path.toString())}constructor(e,i,a,o){super(),this.repoInfo_=e,this.onDataUpdate_=i,this.authTokenProvider_=a,this.appCheckTokenProvider_=o,this.log_=el("p:rest:"),this.listens_={}}listen(e,i,a,o){const c=e._path.toString();this.log_("Listen called for "+c+" "+e._queryIdentifier);const d=iu.getListenId_(e,a),m={};this.listens_[d]=m;const f=Cv(e._queryParams);this.restRequest_(c+".json",f,(h,x)=>{let v=x;if(h===404&&(v=null,h=null),h===null&&this.onDataUpdate_(c,v,!1,a),Ka(this.listens_,d)===m){let b;h?h===401?b="permission_denied":b="rest_error:"+h:b="ok",o(b,null)}})}unlisten(e,i){const a=iu.getListenId_(e,i);delete this.listens_[a]}get(e){const i=Cv(e._queryParams),a=e._path.toString(),o=new Mn;return this.restRequest_(a+".json",i,(c,d)=>{let m=d;c===404&&(m=null,c=null),c===null?(this.onDataUpdate_(a,m,!1,null),o.resolve(m)):o.reject(new Error(m))}),o.promise}refreshAuthToken(e){}restRequest_(e,i={},a){return i.format="export",Promise.all([this.authTokenProvider_.getToken(!1),this.appCheckTokenProvider_.getToken(!1)]).then(([o,c])=>{o&&o.accessToken&&(i.auth=o.accessToken),c&&c.token&&(i.ac=c.token);const d=(this.repoInfo_.secure?"https://":"http://")+this.repoInfo_.host+e+"?ns="+this.repoInfo_.namespace+ss(i);this.log_("Sending REST request for "+d);const m=new XMLHttpRequest;m.onreadystatechange=()=>{if(a&&m.readyState===4){this.log_("REST Response for "+d+" received. status:",m.status,"response:",m.responseText);let f=null;if(m.status>=200&&m.status<300){try{f=Ro(m.responseText)}catch{At("Failed to parse JSON response for "+d+": "+m.responseText)}a(null,f)}else m.status!==401&&m.status!==404&&At("Got unsuccessful REST response for "+d+" Status: "+m.status),a(m.status);a=null}},m.open("GET",d,!0),m.send()})}}class Wj{constructor(){this.rootNode_=ae.EMPTY_NODE}getNode(e){return this.rootNode_.getChild(e)}updateSnapshot(e,i){this.rootNode_=this.rootNode_.updateChild(e,i)}}function ru(){return{value:null,children:new Map}}function cs(n,e,i){if(ge(e))n.value=i,n.children.clear();else if(n.value!==null)n.value=n.value.updateChild(e,i);else{const a=pe(e);n.children.has(a)||n.children.set(a,ru());const o=n.children.get(a);e=Fe(e),cs(o,e,i)}}function zm(n,e){if(ge(e))return n.value=null,n.children.clear(),!0;if(n.value!==null){if(n.value.isLeafNode())return!1;{const i=n.value;return n.value=null,i.forEachChild($e,(a,o)=>{cs(n,new Ie(a),o)}),zm(n,e)}}else if(n.children.size>0){const i=pe(e);return e=Fe(e),n.children.has(i)&&zm(n.children.get(i),e)&&n.children.delete(i),n.children.size===0}else return!0}function Fm(n,e,i){n.value!==null?i(e,n.value):Kj(n,(a,o)=>{const c=new Ie(e.toString()+"/"+a);Fm(o,c,i)})}function Kj(n,e){n.children.forEach((i,a)=>{e(a,i)})}class Qj{constructor(e){this.collection_=e,this.last_=null}get(){const e=this.collection_.get(),i={...e};return this.last_&&xt(this.last_,(a,o)=>{i[a]=i[a]-o}),this.last_=e,i}}const _v=10*1e3,Xj=30*1e3,$j=300*1e3;class Zj{constructor(e,i){this.server_=i,this.statsToReport_={},this.statsListener_=new Qj(e);const a=_v+(Xj-_v)*Math.random();To(this.reportStats_.bind(this),Math.floor(a))}reportStats_(){const e=this.statsListener_.get(),i={};let a=!1;xt(e,(o,c)=>{c>0&&Un(this.statsToReport_,o)&&(i[o]=c,a=!0)}),a&&this.server_.reportStats(i),To(this.reportStats_.bind(this),Math.floor(Math.random()*2*$j))}}var Cn;(function(n){n[n.OVERWRITE=0]="OVERWRITE",n[n.MERGE=1]="MERGE",n[n.ACK_USER_WRITE=2]="ACK_USER_WRITE",n[n.LISTEN_COMPLETE=3]="LISTEN_COMPLETE"})(Cn||(Cn={}));function Uf(){return{fromUser:!0,fromServer:!1,queryId:null,tagged:!1}}function Bf(){return{fromUser:!1,fromServer:!0,queryId:null,tagged:!1}}function zf(n){return{fromUser:!1,fromServer:!0,queryId:n,tagged:!0}}class au{constructor(e,i,a){this.path=e,this.affectedTree=i,this.revert=a,this.type=Cn.ACK_USER_WRITE,this.source=Uf()}operationForChild(e){if(ge(this.path)){if(this.affectedTree.value!=null)return G(this.affectedTree.children.isEmpty(),"affectedTree should not have overlapping affected paths."),this;{const i=this.affectedTree.subtree(new Ie(e));return new au(je(),i,this.revert)}}else return G(pe(this.path)===e,"operationForChild called for unrelated child."),new au(Fe(this.path),this.affectedTree,this.revert)}}class Fo{constructor(e,i){this.source=e,this.path=i,this.type=Cn.LISTEN_COMPLETE}operationForChild(e){return ge(this.path)?new Fo(this.source,je()):new Fo(this.source,Fe(this.path))}}class Hr{constructor(e,i,a){this.source=e,this.path=i,this.snap=a,this.type=Cn.OVERWRITE}operationForChild(e){return ge(this.path)?new Hr(this.source,je(),this.snap.getImmediateChild(e)):new Hr(this.source,Fe(this.path),this.snap)}}class Ja{constructor(e,i,a){this.source=e,this.path=i,this.children=a,this.type=Cn.MERGE}operationForChild(e){if(ge(this.path)){const i=this.children.subtree(new Ie(e));return i.isEmpty()?null:i.value?new Hr(this.source,je(),i.value):new Ja(this.source,je(),i)}else return G(pe(this.path)===e,"Can't get a merge for a child not on the path of the operation"),new Ja(this.source,Fe(this.path),this.children)}toString(){return"Operation("+this.path+": "+this.source.toString()+" merge: "+this.children.toString()+")"}}class ar{constructor(e,i,a){this.node_=e,this.fullyInitialized_=i,this.filtered_=a}isFullyInitialized(){return this.fullyInitialized_}isFiltered(){return this.filtered_}isCompleteForPath(e){if(ge(e))return this.isFullyInitialized()&&!this.filtered_;const i=pe(e);return this.isCompleteForChild(i)}isCompleteForChild(e){return this.isFullyInitialized()&&!this.filtered_||this.node_.hasChild(e)}getNode(){return this.node_}}class Jj{constructor(e){this.query_=e,this.index_=this.query_._queryParams.getIndex()}}function e3(n,e,i,a){const o=[],c=[];return e.forEach(d=>{d.type==="child_changed"&&n.index_.indexedValueChanged(d.oldSnap,d.snapshotNode)&&c.push(Yj(d.childName,d.snapshotNode))}),yo(n,o,"child_removed",e,a,i),yo(n,o,"child_added",e,a,i),yo(n,o,"child_moved",c,a,i),yo(n,o,"child_changed",e,a,i),yo(n,o,"value",e,a,i),o}function yo(n,e,i,a,o,c){const d=a.filter(m=>m.type===i);d.sort((m,f)=>n3(n,m,f)),d.forEach(m=>{const f=t3(n,m,c);o.forEach(h=>{h.respondsTo(m.type)&&e.push(h.createEvent(f,n.query_))})})}function t3(n,e,i){return e.type==="value"||e.type==="child_removed"||(e.prevName=i.getPredecessorChildName(e.childName,e.snapshotNode,n.index_)),e}function n3(n,e,i){if(e.childName==null||i.childName==null)throw as("Should only compare child_ events.");const a=new ye(e.childName,e.snapshotNode),o=new ye(i.childName,i.snapshotNode);return n.index_.compare(a,o)}function Tu(n,e){return{eventCache:n,serverCache:e}}function ko(n,e,i,a){return Tu(new ar(e,i,a),n.serverCache)}function Qb(n,e,i,a){return Tu(n.eventCache,new ar(e,i,a))}function su(n){return n.eventCache.isFullyInitialized()?n.eventCache.getNode():null}function Yr(n){return n.serverCache.isFullyInitialized()?n.serverCache.getNode():null}let vm;const i3=()=>(vm||(vm=new Yt(FE)),vm);class Ye{static fromObject(e){let i=new Ye(null);return xt(e,(a,o)=>{i=i.set(new Ie(a),o)}),i}constructor(e,i=i3()){this.value=e,this.children=i}isEmpty(){return this.value===null&&this.children.isEmpty()}findRootMostMatchingPathAndValue(e,i){if(this.value!=null&&i(this.value))return{path:je(),value:this.value};if(ge(e))return null;{const a=pe(e),o=this.children.get(a);if(o!==null){const c=o.findRootMostMatchingPathAndValue(Fe(e),i);return c!=null?{path:Xe(new Ie(a),c.path),value:c.value}:null}else return null}}findRootMostValueAndPath(e){return this.findRootMostMatchingPathAndValue(e,()=>!0)}subtree(e){if(ge(e))return this;{const i=pe(e),a=this.children.get(i);return a!==null?a.subtree(Fe(e)):new Ye(null)}}set(e,i){if(ge(e))return new Ye(i,this.children);{const a=pe(e),c=(this.children.get(a)||new Ye(null)).set(Fe(e),i),d=this.children.insert(a,c);return new Ye(this.value,d)}}remove(e){if(ge(e))return this.children.isEmpty()?new Ye(null):new Ye(null,this.children);{const i=pe(e),a=this.children.get(i);if(a){const o=a.remove(Fe(e));let c;return o.isEmpty()?c=this.children.remove(i):c=this.children.insert(i,o),this.value===null&&c.isEmpty()?new Ye(null):new Ye(this.value,c)}else return this}}get(e){if(ge(e))return this.value;{const i=pe(e),a=this.children.get(i);return a?a.get(Fe(e)):null}}setTree(e,i){if(ge(e))return i;{const a=pe(e),c=(this.children.get(a)||new Ye(null)).setTree(Fe(e),i);let d;return c.isEmpty()?d=this.children.remove(a):d=this.children.insert(a,c),new Ye(this.value,d)}}fold(e){return this.fold_(je(),e)}fold_(e,i){const a={};return this.children.inorderTraversal((o,c)=>{a[o]=c.fold_(Xe(e,o),i)}),i(e,this.value,a)}findOnPath(e,i){return this.findOnPath_(e,je(),i)}findOnPath_(e,i,a){const o=this.value?a(i,this.value):!1;if(o)return o;if(ge(e))return null;{const c=pe(e),d=this.children.get(c);return d?d.findOnPath_(Fe(e),Xe(i,c),a):null}}foreachOnPath(e,i){return this.foreachOnPath_(e,je(),i)}foreachOnPath_(e,i,a){if(ge(e))return this;{this.value&&a(i,this.value);const o=pe(e),c=this.children.get(o);return c?c.foreachOnPath_(Fe(e),Xe(i,o),a):new Ye(null)}}foreach(e){this.foreach_(je(),e)}foreach_(e,i){this.children.inorderTraversal((a,o)=>{o.foreach_(Xe(e,a),i)}),this.value&&i(e,this.value)}foreachChild(e){this.children.inorderTraversal((i,a)=>{a.value&&e(i,a.value)})}}class _n{constructor(e){this.writeTree_=e}static empty(){return new _n(new Ye(null))}}function No(n,e,i){if(ge(e))return new _n(new Ye(i));{const a=n.writeTree_.findRootMostValueAndPath(e);if(a!=null){const o=a.path;let c=a.value;const d=jt(o,e);return c=c.updateChild(d,i),new _n(n.writeTree_.set(o,c))}else{const o=new Ye(i),c=n.writeTree_.setTree(e,o);return new _n(c)}}}function qm(n,e,i){let a=n;return xt(i,(o,c)=>{a=No(a,Xe(e,o),c)}),a}function Tv(n,e){if(ge(e))return _n.empty();{const i=n.writeTree_.setTree(e,new Ye(null));return new _n(i)}}function Hm(n,e){return Qr(n,e)!=null}function Qr(n,e){const i=n.writeTree_.findRootMostValueAndPath(e);return i!=null?n.writeTree_.get(i.path).getChild(jt(i.path,e)):null}function kv(n){const e=[],i=n.writeTree_.value;return i!=null?i.isLeafNode()||i.forEachChild($e,(a,o)=>{e.push(new ye(a,o))}):n.writeTree_.children.inorderTraversal((a,o)=>{o.value!=null&&e.push(new ye(a,o.value))}),e}function er(n,e){if(ge(e))return n;{const i=Qr(n,e);return i!=null?new _n(new Ye(i)):new _n(n.writeTree_.subtree(e))}}function Ym(n){return n.writeTree_.isEmpty()}function es(n,e){return Xb(je(),n.writeTree_,e)}function Xb(n,e,i){if(e.value!=null)return i.updateChild(n,e.value);{let a=null;return e.children.inorderTraversal((o,c)=>{o===".priority"?(G(c.value!==null,"Priority writes must always be leaf nodes"),a=c.value):i=Xb(Xe(n,o),c,i)}),!i.getChild(n).isEmpty()&&a!==null&&(i=i.updateChild(Xe(n,".priority"),a)),i}}function ku(n,e){return ew(e,n)}function r3(n,e,i,a,o){G(a>n.lastWriteId,"Stacking an older write on top of newer ones"),o===void 0&&(o=!0),n.allWrites.push({path:e,snap:i,writeId:a,visible:o}),o&&(n.visibleWrites=No(n.visibleWrites,e,i)),n.lastWriteId=a}function a3(n,e,i,a){G(a>n.lastWriteId,"Stacking an older merge on top of newer ones"),n.allWrites.push({path:e,children:i,writeId:a,visible:!0}),n.visibleWrites=qm(n.visibleWrites,e,i),n.lastWriteId=a}function s3(n,e){for(let i=0;i<n.allWrites.length;i++){const a=n.allWrites[i];if(a.writeId===e)return a}return null}function o3(n,e){const i=n.allWrites.findIndex(m=>m.writeId===e);G(i>=0,"removeWrite called with nonexistent writeId.");const a=n.allWrites[i];n.allWrites.splice(i,1);let o=a.visible,c=!1,d=n.allWrites.length-1;for(;o&&d>=0;){const m=n.allWrites[d];m.visible&&(d>=i&&l3(m,a.path)?o=!1:fn(a.path,m.path)&&(c=!0)),d--}if(o){if(c)return c3(n),!0;if(a.snap)n.visibleWrites=Tv(n.visibleWrites,a.path);else{const m=a.children;xt(m,f=>{n.visibleWrites=Tv(n.visibleWrites,Xe(a.path,f))})}return!0}else return!1}function l3(n,e){if(n.snap)return fn(n.path,e);for(const i in n.children)if(n.children.hasOwnProperty(i)&&fn(Xe(n.path,i),e))return!0;return!1}function c3(n){n.visibleWrites=$b(n.allWrites,u3,je()),n.allWrites.length>0?n.lastWriteId=n.allWrites[n.allWrites.length-1].writeId:n.lastWriteId=-1}function u3(n){return n.visible}function $b(n,e,i){let a=_n.empty();for(let o=0;o<n.length;++o){const c=n[o];if(e(c)){const d=c.path;let m;if(c.snap)fn(i,d)?(m=jt(i,d),a=No(a,m,c.snap)):fn(d,i)&&(m=jt(d,i),a=No(a,je(),c.snap.getChild(m)));else if(c.children){if(fn(i,d))m=jt(i,d),a=qm(a,m,c.children);else if(fn(d,i))if(m=jt(d,i),ge(m))a=qm(a,je(),c.children);else{const f=Ka(c.children,pe(m));if(f){const h=f.getChild(Fe(m));a=No(a,je(),h)}}}else throw as("WriteRecord should have .snap or .children")}}return a}function Zb(n,e,i,a,o){if(!a&&!o){const c=Qr(n.visibleWrites,e);if(c!=null)return c;{const d=er(n.visibleWrites,e);if(Ym(d))return i;if(i==null&&!Hm(d,je()))return null;{const m=i||ae.EMPTY_NODE;return es(d,m)}}}else{const c=er(n.visibleWrites,e);if(!o&&Ym(c))return i;if(!o&&i==null&&!Hm(c,je()))return null;{const d=function(h){return(h.visible||o)&&(!a||!~a.indexOf(h.writeId))&&(fn(h.path,e)||fn(e,h.path))},m=$b(n.allWrites,d,e),f=i||ae.EMPTY_NODE;return es(m,f)}}}function d3(n,e,i){let a=ae.EMPTY_NODE;const o=Qr(n.visibleWrites,e);if(o)return o.isLeafNode()||o.forEachChild($e,(c,d)=>{a=a.updateImmediateChild(c,d)}),a;if(i){const c=er(n.visibleWrites,e);return i.forEachChild($e,(d,m)=>{const f=es(er(c,new Ie(d)),m);a=a.updateImmediateChild(d,f)}),kv(c).forEach(d=>{a=a.updateImmediateChild(d.name,d.node)}),a}else{const c=er(n.visibleWrites,e);return kv(c).forEach(d=>{a=a.updateImmediateChild(d.name,d.node)}),a}}function p3(n,e,i,a,o){G(a||o,"Either existingEventSnap or existingServerSnap must exist");const c=Xe(e,i);if(Hm(n.visibleWrites,c))return null;{const d=er(n.visibleWrites,c);return Ym(d)?o.getChild(i):es(d,o.getChild(i))}}function m3(n,e,i,a){const o=Xe(e,i),c=Qr(n.visibleWrites,o);if(c!=null)return c;if(a.isCompleteForChild(i)){const d=er(n.visibleWrites,o);return es(d,a.getNode().getImmediateChild(i))}else return null}function f3(n,e){return Qr(n.visibleWrites,e)}function h3(n,e,i,a,o,c,d){let m;const f=er(n.visibleWrites,e),h=Qr(f,je());if(h!=null)m=h;else if(i!=null)m=es(f,i);else return[];if(m=m.withIndex(d),!m.isEmpty()&&!m.isLeafNode()){const x=[],v=d.getCompare(),b=c?m.getReverseIteratorFrom(a,d):m.getIteratorFrom(a,d);let _=b.getNext();for(;_&&x.length<o;)v(_,a)!==0&&x.push(_),_=b.getNext();return x}else return[]}function g3(){return{visibleWrites:_n.empty(),allWrites:[],lastWriteId:-1}}function ou(n,e,i,a){return Zb(n.writeTree,n.treePath,e,i,a)}function Ff(n,e){return d3(n.writeTree,n.treePath,e)}function Nv(n,e,i,a){return p3(n.writeTree,n.treePath,e,i,a)}function lu(n,e){return f3(n.writeTree,Xe(n.treePath,e))}function y3(n,e,i,a,o,c){return h3(n.writeTree,n.treePath,e,i,a,o,c)}function qf(n,e,i){return m3(n.writeTree,n.treePath,e,i)}function Jb(n,e){return ew(Xe(n.treePath,e),n.writeTree)}function ew(n,e){return{treePath:n,writeTree:e}}class v3{constructor(){this.changeMap=new Map}trackChildChange(e){const i=e.type,a=e.childName;G(i==="child_added"||i==="child_changed"||i==="child_removed","Only child changes supported for tracking"),G(a!==".priority","Only non-priority child changes can be tracked.");const o=this.changeMap.get(a);if(o){const c=o.type;if(i==="child_added"&&c==="child_removed")this.changeMap.set(a,Bo(a,e.snapshotNode,o.snapshotNode));else if(i==="child_removed"&&c==="child_added")this.changeMap.delete(a);else if(i==="child_removed"&&c==="child_changed")this.changeMap.set(a,Uo(a,o.oldSnap));else if(i==="child_changed"&&c==="child_added")this.changeMap.set(a,Za(a,e.snapshotNode));else if(i==="child_changed"&&c==="child_changed")this.changeMap.set(a,Bo(a,e.snapshotNode,o.oldSnap));else throw as("Illegal combination of changes: "+e+" occurred after "+o)}else this.changeMap.set(a,e)}getChanges(){return Array.from(this.changeMap.values())}}class x3{getCompleteChild(e){return null}getChildAfterChild(e,i,a){return null}}const tw=new x3;class Hf{constructor(e,i,a=null){this.writes_=e,this.viewCache_=i,this.optCompleteServerCache_=a}getCompleteChild(e){const i=this.viewCache_.eventCache;if(i.isCompleteForChild(e))return i.getNode().getImmediateChild(e);{const a=this.optCompleteServerCache_!=null?new ar(this.optCompleteServerCache_,!0,!1):this.viewCache_.serverCache;return qf(this.writes_,e,a)}}getChildAfterChild(e,i,a){const o=this.optCompleteServerCache_!=null?this.optCompleteServerCache_:Yr(this.viewCache_),c=y3(this.writes_,o,i,1,a,e);return c.length===0?null:c[0]}}function b3(n){return{filter:n}}function w3(n,e){G(e.eventCache.getNode().isIndexed(n.filter.getIndex()),"Event snap not indexed"),G(e.serverCache.getNode().isIndexed(n.filter.getIndex()),"Server snap not indexed")}function S3(n,e,i,a,o){const c=new v3;let d,m;if(i.type===Cn.OVERWRITE){const h=i;h.source.fromUser?d=Gm(n,e,h.path,h.snap,a,o,c):(G(h.source.fromServer,"Unknown source."),m=h.source.tagged||e.serverCache.isFiltered()&&!ge(h.path),d=cu(n,e,h.path,h.snap,a,o,m,c))}else if(i.type===Cn.MERGE){const h=i;h.source.fromUser?d=O3(n,e,h.path,h.children,a,o,c):(G(h.source.fromServer,"Unknown source."),m=h.source.tagged||e.serverCache.isFiltered(),d=Vm(n,e,h.path,h.children,a,o,m,c))}else if(i.type===Cn.ACK_USER_WRITE){const h=i;h.revert?d=k3(n,e,h.path,a,o,c):d=_3(n,e,h.path,h.affectedTree,a,o,c)}else if(i.type===Cn.LISTEN_COMPLETE)d=T3(n,e,i.path,a,c);else throw as("Unknown operation type: "+i.type);const f=c.getChanges();return C3(e,d,f),{viewCache:d,changes:f}}function C3(n,e,i){const a=e.eventCache;if(a.isFullyInitialized()){const o=a.getNode().isLeafNode()||a.getNode().isEmpty(),c=su(n);(i.length>0||!n.eventCache.isFullyInitialized()||o&&!a.getNode().equals(c)||!a.getNode().getPriority().equals(c.getPriority()))&&i.push(Kb(su(e)))}}function nw(n,e,i,a,o,c){const d=e.eventCache;if(lu(a,i)!=null)return e;{let m,f;if(ge(i))if(G(e.serverCache.isFullyInitialized(),"If change path is empty, we must have complete server data"),e.serverCache.isFiltered()){const h=Yr(e),x=h instanceof ae?h:ae.EMPTY_NODE,v=Ff(a,x);m=n.filter.updateFullNode(e.eventCache.getNode(),v,c)}else{const h=ou(a,Yr(e));m=n.filter.updateFullNode(e.eventCache.getNode(),h,c)}else{const h=pe(i);if(h===".priority"){G(rr(i)===1,"Can't have a priority with additional path components");const x=d.getNode();f=e.serverCache.getNode();const v=Nv(a,i,x,f);v!=null?m=n.filter.updatePriority(x,v):m=d.getNode()}else{const x=Fe(i);let v;if(d.isCompleteForChild(h)){f=e.serverCache.getNode();const b=Nv(a,i,d.getNode(),f);b!=null?v=d.getNode().getImmediateChild(h).updateChild(x,b):v=d.getNode().getImmediateChild(h)}else v=qf(a,h,e.serverCache);v!=null?m=n.filter.updateChild(d.getNode(),h,v,x,o,c):m=d.getNode()}}return ko(e,m,d.isFullyInitialized()||ge(i),n.filter.filtersNodes())}}function cu(n,e,i,a,o,c,d,m){const f=e.serverCache;let h;const x=d?n.filter:n.filter.getIndexedFilter();if(ge(i))h=x.updateFullNode(f.getNode(),a,null);else if(x.filtersNodes()&&!f.isFiltered()){const _=f.getNode().updateChild(i,a);h=x.updateFullNode(f.getNode(),_,null)}else{const _=pe(i);if(!f.isCompleteForPath(i)&&rr(i)>1)return e;const N=Fe(i),q=f.getNode().getImmediateChild(_).updateChild(N,a);_===".priority"?h=x.updatePriority(f.getNode(),q):h=x.updateChild(f.getNode(),_,q,N,tw,null)}const v=Qb(e,h,f.isFullyInitialized()||ge(i),x.filtersNodes()),b=new Hf(o,v,c);return nw(n,v,i,o,b,m)}function Gm(n,e,i,a,o,c,d){const m=e.eventCache;let f,h;const x=new Hf(o,e,c);if(ge(i))h=n.filter.updateFullNode(e.eventCache.getNode(),a,d),f=ko(e,h,!0,n.filter.filtersNodes());else{const v=pe(i);if(v===".priority")h=n.filter.updatePriority(e.eventCache.getNode(),a),f=ko(e,h,m.isFullyInitialized(),m.isFiltered());else{const b=Fe(i),_=m.getNode().getImmediateChild(v);let N;if(ge(b))N=a;else{const D=x.getCompleteChild(v);D!=null?Mf(b)===".priority"&&D.getChild(Fb(b)).isEmpty()?N=D:N=D.updateChild(b,a):N=ae.EMPTY_NODE}if(_.equals(N))f=e;else{const D=n.filter.updateChild(m.getNode(),v,N,b,x,d);f=ko(e,D,m.isFullyInitialized(),n.filter.filtersNodes())}}}return f}function Ev(n,e){return n.eventCache.isCompleteForChild(e)}function O3(n,e,i,a,o,c,d){let m=e;return a.foreach((f,h)=>{const x=Xe(i,f);Ev(e,pe(x))&&(m=Gm(n,m,x,h,o,c,d))}),a.foreach((f,h)=>{const x=Xe(i,f);Ev(e,pe(x))||(m=Gm(n,m,x,h,o,c,d))}),m}function jv(n,e,i){return i.foreach((a,o)=>{e=e.updateChild(a,o)}),e}function Vm(n,e,i,a,o,c,d,m){if(e.serverCache.getNode().isEmpty()&&!e.serverCache.isFullyInitialized())return e;let f=e,h;ge(i)?h=a:h=new Ye(null).setTree(i,a);const x=e.serverCache.getNode();return h.children.inorderTraversal((v,b)=>{if(x.hasChild(v)){const _=e.serverCache.getNode().getImmediateChild(v),N=jv(n,_,b);f=cu(n,f,new Ie(v),N,o,c,d,m)}}),h.children.inorderTraversal((v,b)=>{const _=!e.serverCache.isCompleteForChild(v)&&b.value===null;if(!x.hasChild(v)&&!_){const N=e.serverCache.getNode().getImmediateChild(v),D=jv(n,N,b);f=cu(n,f,new Ie(v),D,o,c,d,m)}}),f}function _3(n,e,i,a,o,c,d){if(lu(o,i)!=null)return e;const m=e.serverCache.isFiltered(),f=e.serverCache;if(a.value!=null){if(ge(i)&&f.isFullyInitialized()||f.isCompleteForPath(i))return cu(n,e,i,f.getNode().getChild(i),o,c,m,d);if(ge(i)){let h=new Ye(null);return f.getNode().forEachChild(Wa,(x,v)=>{h=h.set(new Ie(x),v)}),Vm(n,e,i,h,o,c,m,d)}else return e}else{let h=new Ye(null);return a.foreach((x,v)=>{const b=Xe(i,x);f.isCompleteForPath(b)&&(h=h.set(x,f.getNode().getChild(b)))}),Vm(n,e,i,h,o,c,m,d)}}function T3(n,e,i,a,o){const c=e.serverCache,d=Qb(e,c.getNode(),c.isFullyInitialized()||ge(i),c.isFiltered());return nw(n,d,i,a,tw,o)}function k3(n,e,i,a,o,c){let d;if(lu(a,i)!=null)return e;{const m=new Hf(a,e,o),f=e.eventCache.getNode();let h;if(ge(i)||pe(i)===".priority"){let x;if(e.serverCache.isFullyInitialized())x=ou(a,Yr(e));else{const v=e.serverCache.getNode();G(v instanceof ae,"serverChildren would be complete if leaf node"),x=Ff(a,v)}x=x,h=n.filter.updateFullNode(f,x,c)}else{const x=pe(i);let v=qf(a,x,e.serverCache);v==null&&e.serverCache.isCompleteForChild(x)&&(v=f.getImmediateChild(x)),v!=null?h=n.filter.updateChild(f,x,v,Fe(i),m,c):e.eventCache.getNode().hasChild(x)?h=n.filter.updateChild(f,x,ae.EMPTY_NODE,Fe(i),m,c):h=f,h.isEmpty()&&e.serverCache.isFullyInitialized()&&(d=ou(a,Yr(e)),d.isLeafNode()&&(h=n.filter.updateFullNode(h,d,c)))}return d=e.serverCache.isFullyInitialized()||lu(a,je())!=null,ko(e,h,d,n.filter.filtersNodes())}}class N3{constructor(e,i){this.query_=e,this.eventRegistrations_=[];const a=this.query_._queryParams,o=new Pf(a.getIndex()),c=Vj(a);this.processor_=b3(c);const d=i.serverCache,m=i.eventCache,f=o.updateFullNode(ae.EMPTY_NODE,d.getNode(),null),h=c.updateFullNode(ae.EMPTY_NODE,m.getNode(),null),x=new ar(f,d.isFullyInitialized(),o.filtersNodes()),v=new ar(h,m.isFullyInitialized(),c.filtersNodes());this.viewCache_=Tu(v,x),this.eventGenerator_=new Jj(this.query_)}get query(){return this.query_}}function E3(n){return n.viewCache_.serverCache.getNode()}function j3(n){return su(n.viewCache_)}function A3(n,e){const i=Yr(n.viewCache_);return i&&(n.query._queryParams.loadsAllData()||!ge(e)&&!i.getImmediateChild(pe(e)).isEmpty())?i.getChild(e):null}function Av(n){return n.eventRegistrations_.length===0}function M3(n,e){n.eventRegistrations_.push(e)}function Mv(n,e,i){const a=[];if(i){G(e==null,"A cancel should cancel all event registrations.");const o=n.query._path;n.eventRegistrations_.forEach(c=>{const d=c.createCancelEvent(i,o);d&&a.push(d)})}if(e){let o=[];for(let c=0;c<n.eventRegistrations_.length;++c){const d=n.eventRegistrations_[c];if(!d.matches(e))o.push(d);else if(e.hasAnyCallback()){o=o.concat(n.eventRegistrations_.slice(c+1));break}}n.eventRegistrations_=o}else n.eventRegistrations_=[];return a}function Rv(n,e,i,a){e.type===Cn.MERGE&&e.source.queryId!==null&&(G(Yr(n.viewCache_),"We should always have a full cache before handling merges"),G(su(n.viewCache_),"Missing event cache, even though we have a server cache"));const o=n.viewCache_,c=S3(n.processor_,o,e,i,a);return w3(n.processor_,c.viewCache),G(c.viewCache.serverCache.isFullyInitialized()||!o.serverCache.isFullyInitialized(),"Once a server snap is complete, it should never go back"),n.viewCache_=c.viewCache,iw(n,c.changes,c.viewCache.eventCache.getNode(),null)}function R3(n,e){const i=n.viewCache_.eventCache,a=[];return i.getNode().isLeafNode()||i.getNode().forEachChild($e,(c,d)=>{a.push(Za(c,d))}),i.isFullyInitialized()&&a.push(Kb(i.getNode())),iw(n,a,i.getNode(),e)}function iw(n,e,i,a){const o=a?[a]:n.eventRegistrations_;return e3(n.eventGenerator_,e,i,o)}let uu;class rw{constructor(){this.views=new Map}}function D3(n){G(!uu,"__referenceConstructor has already been defined"),uu=n}function I3(){return G(uu,"Reference.ts has not been loaded"),uu}function P3(n){return n.views.size===0}function Yf(n,e,i,a){const o=e.source.queryId;if(o!==null){const c=n.views.get(o);return G(c!=null,"SyncTree gave us an op for an invalid query."),Rv(c,e,i,a)}else{let c=[];for(const d of n.views.values())c=c.concat(Rv(d,e,i,a));return c}}function aw(n,e,i,a,o){const c=e._queryIdentifier,d=n.views.get(c);if(!d){let m=ou(i,o?a:null),f=!1;m?f=!0:a instanceof ae?(m=Ff(i,a),f=!1):(m=ae.EMPTY_NODE,f=!1);const h=Tu(new ar(m,f,!1),new ar(a,o,!1));return new N3(e,h)}return d}function L3(n,e,i,a,o,c){const d=aw(n,e,a,o,c);return n.views.has(e._queryIdentifier)||n.views.set(e._queryIdentifier,d),M3(d,i),R3(d,i)}function U3(n,e,i,a){const o=e._queryIdentifier,c=[];let d=[];const m=sr(n);if(o==="default")for(const[f,h]of n.views.entries())d=d.concat(Mv(h,i,a)),Av(h)&&(n.views.delete(f),h.query._queryParams.loadsAllData()||c.push(h.query));else{const f=n.views.get(o);f&&(d=d.concat(Mv(f,i,a)),Av(f)&&(n.views.delete(o),f.query._queryParams.loadsAllData()||c.push(f.query)))}return m&&!sr(n)&&c.push(new(I3())(e._repo,e._path)),{removed:c,events:d}}function sw(n){const e=[];for(const i of n.views.values())i.query._queryParams.loadsAllData()||e.push(i);return e}function tr(n,e){let i=null;for(const a of n.views.values())i=i||A3(a,e);return i}function ow(n,e){if(e._queryParams.loadsAllData())return Nu(n);{const a=e._queryIdentifier;return n.views.get(a)}}function lw(n,e){return ow(n,e)!=null}function sr(n){return Nu(n)!=null}function Nu(n){for(const e of n.views.values())if(e.query._queryParams.loadsAllData())return e;return null}let du;function B3(n){G(!du,"__referenceConstructor has already been defined"),du=n}function z3(){return G(du,"Reference.ts has not been loaded"),du}let F3=1;class Dv{constructor(e){this.listenProvider_=e,this.syncPointTree_=new Ye(null),this.pendingWriteTree_=g3(),this.tagToQueryMap=new Map,this.queryToTagMap=new Map}}function cw(n,e,i,a,o){return r3(n.pendingWriteTree_,e,i,a,o),o?us(n,new Hr(Uf(),e,i)):[]}function q3(n,e,i,a){a3(n.pendingWriteTree_,e,i,a);const o=Ye.fromObject(i);return us(n,new Ja(Uf(),e,o))}function $i(n,e,i=!1){const a=s3(n.pendingWriteTree_,e);if(o3(n.pendingWriteTree_,e)){let c=new Ye(null);return a.snap!=null?c=c.set(je(),!0):xt(a.children,d=>{c=c.set(new Ie(d),!0)}),us(n,new au(a.path,c,i))}else return[]}function nl(n,e,i){return us(n,new Hr(Bf(),e,i))}function H3(n,e,i){const a=Ye.fromObject(i);return us(n,new Ja(Bf(),e,a))}function Y3(n,e){return us(n,new Fo(Bf(),e))}function G3(n,e,i){const a=Vf(n,i);if(a){const o=Wf(a),c=o.path,d=o.queryId,m=jt(c,e),f=new Fo(zf(d),m);return Kf(n,c,f)}else return[]}function pu(n,e,i,a,o=!1){const c=e._path,d=n.syncPointTree_.get(c);let m=[];if(d&&(e._queryIdentifier==="default"||lw(d,e))){const f=U3(d,e,i,a);P3(d)&&(n.syncPointTree_=n.syncPointTree_.remove(c));const h=f.removed;if(m=f.events,!o){const x=h.findIndex(b=>b._queryParams.loadsAllData())!==-1,v=n.syncPointTree_.findOnPath(c,(b,_)=>sr(_));if(x&&!v){const b=n.syncPointTree_.subtree(c);if(!b.isEmpty()){const _=K3(b);for(let N=0;N<_.length;++N){const D=_[N],q=D.query,F=mw(n,D);n.listenProvider_.startListening(Eo(q),qo(n,q),F.hashFn,F.onComplete)}}}!v&&h.length>0&&!a&&(x?n.listenProvider_.stopListening(Eo(e),null):h.forEach(b=>{const _=n.queryToTagMap.get(Eu(b));n.listenProvider_.stopListening(Eo(b),_)}))}Q3(n,h)}return m}function uw(n,e,i,a){const o=Vf(n,a);if(o!=null){const c=Wf(o),d=c.path,m=c.queryId,f=jt(d,e),h=new Hr(zf(m),f,i);return Kf(n,d,h)}else return[]}function V3(n,e,i,a){const o=Vf(n,a);if(o){const c=Wf(o),d=c.path,m=c.queryId,f=jt(d,e),h=Ye.fromObject(i),x=new Ja(zf(m),f,h);return Kf(n,d,x)}else return[]}function Wm(n,e,i,a=!1){const o=e._path;let c=null,d=!1;n.syncPointTree_.foreachOnPath(o,(b,_)=>{const N=jt(b,o);c=c||tr(_,N),d=d||sr(_)});let m=n.syncPointTree_.get(o);m?(d=d||sr(m),c=c||tr(m,je())):(m=new rw,n.syncPointTree_=n.syncPointTree_.set(o,m));let f;c!=null?f=!0:(f=!1,c=ae.EMPTY_NODE,n.syncPointTree_.subtree(o).foreachChild((_,N)=>{const D=tr(N,je());D&&(c=c.updateImmediateChild(_,D))}));const h=lw(m,e);if(!h&&!e._queryParams.loadsAllData()){const b=Eu(e);G(!n.queryToTagMap.has(b),"View does not exist, but we have a tag");const _=X3();n.queryToTagMap.set(b,_),n.tagToQueryMap.set(_,b)}const x=ku(n.pendingWriteTree_,o);let v=L3(m,e,i,x,c,f);if(!h&&!d&&!a){const b=ow(m,e);v=v.concat($3(n,e,b))}return v}function Gf(n,e,i){const o=n.pendingWriteTree_,c=n.syncPointTree_.findOnPath(e,(d,m)=>{const f=jt(d,e),h=tr(m,f);if(h)return h});return Zb(o,e,c,i,!0)}function W3(n,e){const i=e._path;let a=null;n.syncPointTree_.foreachOnPath(i,(h,x)=>{const v=jt(h,i);a=a||tr(x,v)});let o=n.syncPointTree_.get(i);o?a=a||tr(o,je()):(o=new rw,n.syncPointTree_=n.syncPointTree_.set(i,o));const c=a!=null,d=c?new ar(a,!0,!1):null,m=ku(n.pendingWriteTree_,e._path),f=aw(o,e,m,c?d.getNode():ae.EMPTY_NODE,c);return j3(f)}function us(n,e){return dw(e,n.syncPointTree_,null,ku(n.pendingWriteTree_,je()))}function dw(n,e,i,a){if(ge(n.path))return pw(n,e,i,a);{const o=e.get(je());i==null&&o!=null&&(i=tr(o,je()));let c=[];const d=pe(n.path),m=n.operationForChild(d),f=e.children.get(d);if(f&&m){const h=i?i.getImmediateChild(d):null,x=Jb(a,d);c=c.concat(dw(m,f,h,x))}return o&&(c=c.concat(Yf(o,n,a,i))),c}}function pw(n,e,i,a){const o=e.get(je());i==null&&o!=null&&(i=tr(o,je()));let c=[];return e.children.inorderTraversal((d,m)=>{const f=i?i.getImmediateChild(d):null,h=Jb(a,d),x=n.operationForChild(d);x&&(c=c.concat(pw(x,m,f,h)))}),o&&(c=c.concat(Yf(o,n,a,i))),c}function mw(n,e){const i=e.query,a=qo(n,i);return{hashFn:()=>(E3(e)||ae.EMPTY_NODE).hash(),onComplete:o=>{if(o==="ok")return a?G3(n,i._path,a):Y3(n,i._path);{const c=YE(o,i);return pu(n,i,null,c)}}}}function qo(n,e){const i=Eu(e);return n.queryToTagMap.get(i)}function Eu(n){return n._path.toString()+"$"+n._queryIdentifier}function Vf(n,e){return n.tagToQueryMap.get(e)}function Wf(n){const e=n.indexOf("$");return G(e!==-1&&e<n.length-1,"Bad queryKey."),{queryId:n.substr(e+1),path:new Ie(n.substr(0,e))}}function Kf(n,e,i){const a=n.syncPointTree_.get(e);G(a,"Missing sync point for query tag that we're tracking");const o=ku(n.pendingWriteTree_,e);return Yf(a,i,o,null)}function K3(n){return n.fold((e,i,a)=>{if(i&&sr(i))return[Nu(i)];{let o=[];return i&&(o=sw(i)),xt(a,(c,d)=>{o=o.concat(d)}),o}})}function Eo(n){return n._queryParams.loadsAllData()&&!n._queryParams.isDefault()?new(z3())(n._repo,n._path):n}function Q3(n,e){for(let i=0;i<e.length;++i){const a=e[i];if(!a._queryParams.loadsAllData()){const o=Eu(a),c=n.queryToTagMap.get(o);n.queryToTagMap.delete(o),n.tagToQueryMap.delete(c)}}}function X3(){return F3++}function $3(n,e,i){const a=e._path,o=qo(n,e),c=mw(n,i),d=n.listenProvider_.startListening(Eo(e),o,c.hashFn,c.onComplete),m=n.syncPointTree_.subtree(a);if(o)G(!sr(m.value),"If we're adding a query, it shouldn't be shadowed");else{const f=m.fold((h,x,v)=>{if(!ge(h)&&x&&sr(x))return[Nu(x).query];{let b=[];return x&&(b=b.concat(sw(x).map(_=>_.query))),xt(v,(_,N)=>{b=b.concat(N)}),b}});for(let h=0;h<f.length;++h){const x=f[h];n.listenProvider_.stopListening(Eo(x),qo(n,x))}}return d}class Qf{constructor(e){this.node_=e}getImmediateChild(e){const i=this.node_.getImmediateChild(e);return new Qf(i)}node(){return this.node_}}class Xf{constructor(e,i){this.syncTree_=e,this.path_=i}getImmediateChild(e){const i=Xe(this.path_,e);return new Xf(this.syncTree_,i)}node(){return Gf(this.syncTree_,this.path_)}}const Z3=function(n){return n=n||{},n.timestamp=n.timestamp||new Date().getTime(),n},Iv=function(n,e,i){if(!n||typeof n!="object")return n;if(G(".sv"in n,"Unexpected leaf node or priority contents"),typeof n[".sv"]=="string")return J3(n[".sv"],e,i);if(typeof n[".sv"]=="object")return eA(n[".sv"],e);G(!1,"Unexpected server value: "+JSON.stringify(n,null,2))},J3=function(n,e,i){if(n==="timestamp")return i.timestamp;G(!1,"Unexpected server value: "+n)},eA=function(n,e,i){n.hasOwnProperty("increment")||G(!1,"Unexpected server value: "+JSON.stringify(n,null,2));const a=n.increment;typeof a!="number"&&G(!1,"Unexpected increment value: "+a);const o=e.node();if(G(o!==null&&typeof o<"u","Expected ChildrenNode.EMPTY_NODE for nulls"),!o.isLeafNode())return a;const d=o.getValue();return typeof d!="number"?a:d+a},fw=function(n,e,i,a){return $f(e,new Xf(i,n),a)},hw=function(n,e,i){return $f(n,new Qf(e),i)};function $f(n,e,i){const a=n.getPriority().val(),o=Iv(a,e.getImmediateChild(".priority"),i);let c;if(n.isLeafNode()){const d=n,m=Iv(d.getValue(),e,i);return m!==d.getValue()||o!==d.getPriority().val()?new gt(m,et(o)):n}else{const d=n;return c=d,o!==d.getPriority().val()&&(c=c.updatePriority(new gt(o))),d.forEachChild($e,(m,f)=>{const h=$f(f,e.getImmediateChild(m),i);h!==f&&(c=c.updateImmediateChild(m,h))}),c}}class Zf{constructor(e="",i=null,a={children:{},childCount:0}){this.name=e,this.parent=i,this.node=a}}function Jf(n,e){let i=e instanceof Ie?e:new Ie(e),a=n,o=pe(i);for(;o!==null;){const c=Ka(a.node.children,o)||{children:{},childCount:0};a=new Zf(o,a,c),i=Fe(i),o=pe(i)}return a}function ds(n){return n.node.value}function gw(n,e){n.node.value=e,Km(n)}function yw(n){return n.node.childCount>0}function tA(n){return ds(n)===void 0&&!yw(n)}function ju(n,e){xt(n.node.children,(i,a)=>{e(new Zf(i,n,a))})}function vw(n,e,i,a){i&&e(n),ju(n,o=>{vw(o,e,!0)})}function nA(n,e,i){let a=n.parent;for(;a!==null;){if(e(a))return!0;a=a.parent}return!1}function il(n){return new Ie(n.parent===null?n.name:il(n.parent)+"/"+n.name)}function Km(n){n.parent!==null&&iA(n.parent,n.name,n)}function iA(n,e,i){const a=tA(i),o=Un(n.node.children,e);a&&o?(delete n.node.children[e],n.node.childCount--,Km(n)):!a&&!o&&(n.node.children[e]=i.node,n.node.childCount++,Km(n))}const rA=/[\[\].#$\/\u0000-\u001F\u007F]/,aA=/[\[\].#$\u0000-\u001F\u007F]/,xm=10*1024*1024,eh=function(n){return typeof n=="string"&&n.length!==0&&!rA.test(n)},xw=function(n){return typeof n=="string"&&n.length!==0&&!aA.test(n)},sA=function(n){return n&&(n=n.replace(/^\/*\.info(\/|$)/,"/")),xw(n)},bw=function(n){return n===null||typeof n=="string"||typeof n=="number"&&!Ou(n)||n&&typeof n=="object"&&Un(n,".sv")},mu=function(n,e,i,a){a&&e===void 0||Au(Qa(n,"value"),e,i)},Au=function(n,e,i){const a=i instanceof Ie?new Oj(i,n):i;if(e===void 0)throw new Error(n+"contains undefined "+Mr(a));if(typeof e=="function")throw new Error(n+"contains a function "+Mr(a)+" with contents = "+e.toString());if(Ou(e))throw new Error(n+"contains "+e.toString()+" "+Mr(a));if(typeof e=="string"&&e.length>xm/3&&xu(e)>xm)throw new Error(n+"contains a string greater than "+xm+" utf8 bytes "+Mr(a)+" ('"+e.substring(0,50)+"...')");if(e&&typeof e=="object"){let o=!1,c=!1;if(xt(e,(d,m)=>{if(d===".value")o=!0;else if(d!==".priority"&&d!==".sv"&&(c=!0,!eh(d)))throw new Error(n+" contains an invalid key ("+d+") "+Mr(a)+`.  Keys must be non-empty strings and can't contain ".", "#", "$", "/", "[", or "]"`);_j(a,d),Au(n,m,a),Tj(a)}),o&&c)throw new Error(n+' contains ".value" child '+Mr(a)+" in addition to actual children.")}},oA=function(n,e){let i,a;for(i=0;i<e.length;i++){a=e[i];const c=Lo(a);for(let d=0;d<c.length;d++)if(!(c[d]===".priority"&&d===c.length-1)){if(!eh(c[d]))throw new Error(n+"contains an invalid key ("+c[d]+") in path "+a.toString()+`. Keys must be non-empty strings and can't contain ".", "#", "$", "/", "[", or "]"`)}}e.sort(Cj);let o=null;for(i=0;i<e.length;i++){if(a=e[i],o!==null&&fn(o,a))throw new Error(n+"contains a path "+o.toString()+" that is ancestor of another path "+a.toString());o=a}},ww=function(n,e,i,a){const o=Qa(n,"values");if(!(e&&typeof e=="object")||Array.isArray(e))throw new Error(o+" must be an object containing the children to replace.");const c=[];xt(e,(d,m)=>{const f=new Ie(d);if(Au(o,m,Xe(i,f)),Mf(f)===".priority"&&!bw(m))throw new Error(o+"contains an invalid value for '"+f.toString()+"', which must be a valid Firebase priority (a string, finite number, server value, or null).");c.push(f)}),oA(o,c)},lA=function(n,e,i){if(Ou(e))throw new Error(Qa(n,"priority")+"is "+e.toString()+", but must be a valid Firebase priority (a string, finite number, server value, or null).");if(!bw(e))throw new Error(Qa(n,"priority")+"must be a valid Firebase priority (a string, finite number, server value, or null).")},Sw=function(n,e,i,a){if(!xw(i))throw new Error(Qa(n,e)+'was an invalid path = "'+i+`". Paths must be non-empty strings and can't contain ".", "#", "$", "[", or "]"`)},cA=function(n,e,i,a){i&&(i=i.replace(/^\/*\.info(\/|$)/,"/")),Sw(n,e,i)},Ir=function(n,e){if(pe(e)===".info")throw new Error(n+" failed = Can't modify data under /.info/")},uA=function(n,e){const i=e.path.toString();if(typeof e.repoInfo.host!="string"||e.repoInfo.host.length===0||!eh(e.repoInfo.namespace)&&e.repoInfo.host.split(":")[0]!=="localhost"||i.length!==0&&!sA(i))throw new Error(Qa(n,"url")+`must be a valid firebase URL and the path can't contain ".", "#", "$", "[", or "]".`)};class dA{constructor(){this.eventLists_=[],this.recursionDepth_=0}}function Mu(n,e){let i=null;for(let a=0;a<e.length;a++){const o=e[a],c=o.getPath();i!==null&&!Rf(c,i.path)&&(n.eventLists_.push(i),i=null),i===null&&(i={events:[],path:c}),i.events.push(o)}i&&n.eventLists_.push(i)}function Cw(n,e,i){Mu(n,i),Ow(n,a=>Rf(a,e))}function yn(n,e,i){Mu(n,i),Ow(n,a=>fn(a,e)||fn(e,a))}function Ow(n,e){n.recursionDepth_++;let i=!0;for(let a=0;a<n.eventLists_.length;a++){const o=n.eventLists_[a];if(o){const c=o.path;e(c)?(pA(n.eventLists_[a]),n.eventLists_[a]=null):i=!1}}i&&(n.eventLists_=[]),n.recursionDepth_--}function pA(n){for(let e=0;e<n.events.length;e++){const i=n.events[e];if(i!==null){n.events[e]=null;const a=i.getEventRunner();_o&&vt("event: "+i.toString()),ls(a)}}}const mA="repo_interrupt",fA=25;class hA{constructor(e,i,a,o){this.repoInfo_=e,this.forceRestClient_=i,this.authTokenProvider_=a,this.appCheckProvider_=o,this.dataUpdateCount=0,this.statsListener_=null,this.eventQueue_=new dA,this.nextWriteId_=1,this.interceptServerDataCallback_=null,this.onDisconnect_=ru(),this.transactionQueueTree_=new Zf,this.persistentConnection_=null,this.key=this.repoInfo_.toURLString()}toString(){return(this.repoInfo_.secure?"https://":"http://")+this.repoInfo_.host}}function gA(n,e,i){if(n.stats_=jf(n.repoInfo_),n.forceRestClient_||KE())n.server_=new iu(n.repoInfo_,(a,o,c,d)=>{Pv(n,a,o,c,d)},n.authTokenProvider_,n.appCheckProvider_),setTimeout(()=>Lv(n,!0),0);else{if(typeof i<"u"&&i!==null){if(typeof i!="object")throw new Error("Only objects are supported for option databaseAuthVariableOverride");try{mt(i)}catch(a){throw new Error("Invalid authOverride provided: "+a)}}n.persistentConnection_=new ui(n.repoInfo_,e,(a,o,c,d)=>{Pv(n,a,o,c,d)},a=>{Lv(n,a)},a=>{yA(n,a)},n.authTokenProvider_,n.appCheckProvider_,i),n.server_=n.persistentConnection_}n.authTokenProvider_.addTokenChangeListener(a=>{n.server_.refreshAuthToken(a)}),n.appCheckProvider_.addTokenChangeListener(a=>{n.server_.refreshAppCheckToken(a.token)}),n.statsReporter_=JE(n.repoInfo_,()=>new Zj(n.stats_,n.server_)),n.infoData_=new Wj,n.infoSyncTree_=new Dv({startListening:(a,o,c,d)=>{let m=[];const f=n.infoData_.getNode(a._path);return f.isEmpty()||(m=nl(n.infoSyncTree_,a._path,f),setTimeout(()=>{d("ok")},0)),m},stopListening:()=>{}}),th(n,"connected",!1),n.serverSyncTree_=new Dv({startListening:(a,o,c,d)=>(n.server_.listen(a,c,o,(m,f)=>{const h=d(m,f);yn(n.eventQueue_,a._path,h)}),[]),stopListening:(a,o)=>{n.server_.unlisten(a,o)}})}function _w(n){const i=n.infoData_.getNode(new Ie(".info/serverTimeOffset")).val()||0;return new Date().getTime()+i}function Ru(n){return Z3({timestamp:_w(n)})}function Pv(n,e,i,a,o){n.dataUpdateCount++;const c=new Ie(e);i=n.interceptServerDataCallback_?n.interceptServerDataCallback_(e,i):i;let d=[];if(o)if(a){const f=Vc(i,h=>et(h));d=V3(n.serverSyncTree_,c,f,o)}else{const f=et(i);d=uw(n.serverSyncTree_,c,f,o)}else if(a){const f=Vc(i,h=>et(h));d=H3(n.serverSyncTree_,c,f)}else{const f=et(i);d=nl(n.serverSyncTree_,c,f)}let m=c;d.length>0&&(m=ts(n,c)),yn(n.eventQueue_,m,d)}function Lv(n,e){th(n,"connected",e),e===!1&&wA(n)}function yA(n,e){xt(e,(i,a)=>{th(n,i,a)})}function th(n,e,i){const a=new Ie("/.info/"+e),o=et(i);n.infoData_.updateSnapshot(a,o);const c=nl(n.infoSyncTree_,a,o);yn(n.eventQueue_,a,c)}function nh(n){return n.nextWriteId_++}function vA(n,e,i){const a=W3(n.serverSyncTree_,e);return a!=null?Promise.resolve(a):n.server_.get(e).then(o=>{const c=et(o).withIndex(e._queryParams.getIndex());Wm(n.serverSyncTree_,e,i,!0);let d;if(e._queryParams.loadsAllData())d=nl(n.serverSyncTree_,e._path,c);else{const m=qo(n.serverSyncTree_,e);d=uw(n.serverSyncTree_,e._path,c,m)}return yn(n.eventQueue_,e._path,d),pu(n.serverSyncTree_,e,i,null,!0),c},o=>(rl(n,"get for query "+mt(e)+" failed: "+o),Promise.reject(new Error(o))))}function xA(n,e,i,a,o){rl(n,"set",{path:e.toString(),value:i,priority:a});const c=Ru(n),d=et(i,a),m=Gf(n.serverSyncTree_,e),f=hw(d,m,c),h=nh(n),x=cw(n.serverSyncTree_,e,f,h,!0);Mu(n.eventQueue_,x),n.server_.put(e.toString(),d.val(!0),(b,_)=>{const N=b==="ok";N||At("set at "+e+" failed: "+b);const D=$i(n.serverSyncTree_,h,!N);yn(n.eventQueue_,e,D),or(n,o,b,_)});const v=rh(n,e);ts(n,v),yn(n.eventQueue_,v,[])}function bA(n,e,i,a){rl(n,"update",{path:e.toString(),value:i});let o=!0;const c=Ru(n),d={};if(xt(i,(m,f)=>{o=!1,d[m]=fw(Xe(e,m),et(f),n.serverSyncTree_,c)}),o)vt("update() called with empty data.  Don't do anything."),or(n,a,"ok",void 0);else{const m=nh(n),f=q3(n.serverSyncTree_,e,d,m);Mu(n.eventQueue_,f),n.server_.merge(e.toString(),i,(h,x)=>{const v=h==="ok";v||At("update at "+e+" failed: "+h);const b=$i(n.serverSyncTree_,m,!v),_=b.length>0?ts(n,e):e;yn(n.eventQueue_,_,b),or(n,a,h,x)}),xt(i,h=>{const x=rh(n,Xe(e,h));ts(n,x)}),yn(n.eventQueue_,e,[])}}function wA(n){rl(n,"onDisconnectEvents");const e=Ru(n),i=ru();Fm(n.onDisconnect_,je(),(o,c)=>{const d=fw(o,c,n.serverSyncTree_,e);cs(i,o,d)});let a=[];Fm(i,je(),(o,c)=>{a=a.concat(nl(n.serverSyncTree_,o,c));const d=rh(n,o);ts(n,d)}),n.onDisconnect_=ru(),yn(n.eventQueue_,je(),a)}function SA(n,e,i){n.server_.onDisconnectCancel(e.toString(),(a,o)=>{a==="ok"&&zm(n.onDisconnect_,e),or(n,i,a,o)})}function Uv(n,e,i,a){const o=et(i);n.server_.onDisconnectPut(e.toString(),o.val(!0),(c,d)=>{c==="ok"&&cs(n.onDisconnect_,e,o),or(n,a,c,d)})}function CA(n,e,i,a,o){const c=et(i,a);n.server_.onDisconnectPut(e.toString(),c.val(!0),(d,m)=>{d==="ok"&&cs(n.onDisconnect_,e,c),or(n,o,d,m)})}function OA(n,e,i,a){if(Gc(i)){vt("onDisconnect().update() called with empty data.  Don't do anything."),or(n,a,"ok",void 0);return}n.server_.onDisconnectMerge(e.toString(),i,(o,c)=>{o==="ok"&&xt(i,(d,m)=>{const f=et(m);cs(n.onDisconnect_,Xe(e,d),f)}),or(n,a,o,c)})}function _A(n,e,i){let a;pe(e._path)===".info"?a=Wm(n.infoSyncTree_,e,i):a=Wm(n.serverSyncTree_,e,i),Cw(n.eventQueue_,e._path,a)}function Tw(n,e,i){let a;pe(e._path)===".info"?a=pu(n.infoSyncTree_,e,i):a=pu(n.serverSyncTree_,e,i),Cw(n.eventQueue_,e._path,a)}function TA(n){n.persistentConnection_&&n.persistentConnection_.interrupt(mA)}function rl(n,...e){let i="";n.persistentConnection_&&(i=n.persistentConnection_.id+":"),vt(i,...e)}function or(n,e,i,a){e&&ls(()=>{if(i==="ok")e(null);else{const o=(i||"error").toUpperCase();let c=o;a&&(c+=": "+a);const d=new Error(c);d.code=o,e(d)}})}function kw(n,e,i){return Gf(n.serverSyncTree_,e,i)||ae.EMPTY_NODE}function ih(n,e=n.transactionQueueTree_){if(e||Du(n,e),ds(e)){const i=Ew(n,e);G(i.length>0,"Sending zero length transaction queue"),i.every(o=>o.status===0)&&kA(n,il(e),i)}else yw(e)&&ju(e,i=>{ih(n,i)})}function kA(n,e,i){const a=i.map(h=>h.currentWriteId),o=kw(n,e,a);let c=o;const d=o.hash();for(let h=0;h<i.length;h++){const x=i[h];G(x.status===0,"tryToSendTransactionQueue_: items in queue should all be run."),x.status=1,x.retryCount++;const v=jt(e,x.path);c=c.updateChild(v,x.currentOutputSnapshotRaw)}const m=c.val(!0),f=e;n.server_.put(f.toString(),m,h=>{rl(n,"transaction put response",{path:f.toString(),status:h});let x=[];if(h==="ok"){const v=[];for(let b=0;b<i.length;b++)i[b].status=2,x=x.concat($i(n.serverSyncTree_,i[b].currentWriteId)),i[b].onComplete&&v.push(()=>i[b].onComplete(null,!0,i[b].currentOutputSnapshotResolved)),i[b].unwatcher();Du(n,Jf(n.transactionQueueTree_,e)),ih(n,n.transactionQueueTree_),yn(n.eventQueue_,e,x);for(let b=0;b<v.length;b++)ls(v[b])}else{if(h==="datastale")for(let v=0;v<i.length;v++)i[v].status===3?i[v].status=4:i[v].status=0;else{At("transaction at "+f.toString()+" failed: "+h);for(let v=0;v<i.length;v++)i[v].status=4,i[v].abortReason=h}ts(n,e)}},d)}function ts(n,e){const i=Nw(n,e),a=il(i),o=Ew(n,i);return NA(n,o,a),a}function NA(n,e,i){if(e.length===0)return;const a=[];let o=[];const d=e.filter(m=>m.status===0).map(m=>m.currentWriteId);for(let m=0;m<e.length;m++){const f=e[m],h=jt(i,f.path);let x=!1,v;if(G(h!==null,"rerunTransactionsUnderNode_: relativePath should not be null."),f.status===4)x=!0,v=f.abortReason,o=o.concat($i(n.serverSyncTree_,f.currentWriteId,!0));else if(f.status===0)if(f.retryCount>=fA)x=!0,v="maxretry",o=o.concat($i(n.serverSyncTree_,f.currentWriteId,!0));else{const b=kw(n,f.path,d);f.currentInputSnapshot=b;const _=e[m].update(b.val());if(_!==void 0){Au("transaction failed: Data returned ",_,f.path);let N=et(_);typeof _=="object"&&_!=null&&Un(_,".priority")||(N=N.updatePriority(b.getPriority()));const q=f.currentWriteId,F=Ru(n),I=hw(N,b,F);f.currentOutputSnapshotRaw=N,f.currentOutputSnapshotResolved=I,f.currentWriteId=nh(n),d.splice(d.indexOf(q),1),o=o.concat(cw(n.serverSyncTree_,f.path,I,f.currentWriteId,f.applyLocally)),o=o.concat($i(n.serverSyncTree_,q,!0))}else x=!0,v="nodata",o=o.concat($i(n.serverSyncTree_,f.currentWriteId,!0))}yn(n.eventQueue_,i,o),o=[],x&&(e[m].status=2,(function(b){setTimeout(b,Math.floor(0))})(e[m].unwatcher),e[m].onComplete&&(v==="nodata"?a.push(()=>e[m].onComplete(null,!1,e[m].currentInputSnapshot)):a.push(()=>e[m].onComplete(new Error(v),!1,null))))}Du(n,n.transactionQueueTree_);for(let m=0;m<a.length;m++)ls(a[m]);ih(n,n.transactionQueueTree_)}function Nw(n,e){let i,a=n.transactionQueueTree_;for(i=pe(e);i!==null&&ds(a)===void 0;)a=Jf(a,i),e=Fe(e),i=pe(e);return a}function Ew(n,e){const i=[];return jw(n,e,i),i.sort((a,o)=>a.order-o.order),i}function jw(n,e,i){const a=ds(e);if(a)for(let o=0;o<a.length;o++)i.push(a[o]);ju(e,o=>{jw(n,o,i)})}function Du(n,e){const i=ds(e);if(i){let a=0;for(let o=0;o<i.length;o++)i[o].status!==2&&(i[a]=i[o],a++);i.length=a,gw(e,i.length>0?i:void 0)}ju(e,a=>{Du(n,a)})}function rh(n,e){const i=il(Nw(n,e)),a=Jf(n.transactionQueueTree_,e);return nA(a,o=>{bm(n,o)}),bm(n,a),vw(a,o=>{bm(n,o)}),i}function bm(n,e){const i=ds(e);if(i){const a=[];let o=[],c=-1;for(let d=0;d<i.length;d++)i[d].status===3||(i[d].status===1?(G(c===d-1,"All SENT items should be at beginning of queue."),c=d,i[d].status=3,i[d].abortReason="set"):(G(i[d].status===0,"Unexpected transaction status in abort"),i[d].unwatcher(),o=o.concat($i(n.serverSyncTree_,i[d].currentWriteId,!0)),i[d].onComplete&&a.push(i[d].onComplete.bind(null,new Error("set"),!1,null))));c===-1?gw(e,void 0):i.length=c+1,yn(n.eventQueue_,il(e),o);for(let d=0;d<a.length;d++)ls(a[d])}}function EA(n){let e="";const i=n.split("/");for(let a=0;a<i.length;a++)if(i[a].length>0){let o=i[a];try{o=decodeURIComponent(o.replace(/\+/g," "))}catch{}e+="/"+o}return e}function jA(n){const e={};n.charAt(0)==="?"&&(n=n.substring(1));for(const i of n.split("&")){if(i.length===0)continue;const a=i.split("=");a.length===2?e[decodeURIComponent(a[0])]=decodeURIComponent(a[1]):At(`Invalid query segment '${i}' in query '${n}'`)}return e}const Bv=function(n,e){const i=AA(n),a=i.namespace;i.domain==="firebase.com"&&fi(i.host+" is no longer supported. Please use <YOUR FIREBASE>.firebaseio.com instead"),(!a||a==="undefined")&&i.domain!=="localhost"&&fi("Cannot parse Firebase url. Please use https://<YOUR FIREBASE>.firebaseio.com"),i.secure||BE();const o=i.scheme==="ws"||i.scheme==="wss";return{repoInfo:new Mb(i.host,i.secure,a,o,e,"",a!==i.subdomain),path:new Ie(i.pathString)}},AA=function(n){let e="",i="",a="",o="",c="",d=!0,m="https",f=443;if(typeof n=="string"){let h=n.indexOf("//");h>=0&&(m=n.substring(0,h-1),n=n.substring(h+2));let x=n.indexOf("/");x===-1&&(x=n.length);let v=n.indexOf("?");v===-1&&(v=n.length),e=n.substring(0,Math.min(x,v)),x<v&&(o=EA(n.substring(x,v)));const b=jA(n.substring(Math.min(n.length,v)));h=e.indexOf(":"),h>=0?(d=m==="https"||m==="wss",f=parseInt(e.substring(h+1),10)):h=e.length;const _=e.slice(0,h);if(_.toLowerCase()==="localhost")i="localhost";else if(_.split(".").length<=2)i=_;else{const N=e.indexOf(".");a=e.substring(0,N).toLowerCase(),i=e.substring(N+1),c=a}"ns"in b&&(c=b.ns)}return{host:e,port:f,domain:i,subdomain:a,secure:d,scheme:m,pathString:o,namespace:c}};const zv="-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz",MA=(function(){let n=0;const e=[];return function(i){const a=i===n;n=i;let o;const c=new Array(8);for(o=7;o>=0;o--)c[o]=zv.charAt(i%64),i=Math.floor(i/64);G(i===0,"Cannot push at time == 0");let d=c.join("");if(a){for(o=11;o>=0&&e[o]===63;o--)e[o]=0;e[o]++}else for(o=0;o<12;o++)e[o]=Math.floor(Math.random()*64);for(o=0;o<12;o++)d+=zv.charAt(e[o]);return G(d.length===20,"nextPushId: Length should be 20."),d}})();class RA{constructor(e,i,a,o){this.eventType=e,this.eventRegistration=i,this.snapshot=a,this.prevName=o}getPath(){const e=this.snapshot.ref;return this.eventType==="value"?e._path:e.parent._path}getEventType(){return this.eventType}getEventRunner(){return this.eventRegistration.getEventRunner(this)}toString(){return this.getPath().toString()+":"+this.eventType+":"+mt(this.snapshot.exportVal())}}class DA{constructor(e,i,a){this.eventRegistration=e,this.error=i,this.path=a}getPath(){return this.path}getEventType(){return"cancel"}getEventRunner(){return this.eventRegistration.getEventRunner(this)}toString(){return this.path.toString()+":cancel"}}class Aw{constructor(e,i){this.snapshotCallback=e,this.cancelCallback=i}onValue(e,i){this.snapshotCallback.call(null,e,i)}onCancel(e){return G(this.hasCancelCallback,"Raising a cancel event on a listener with no cancel callback"),this.cancelCallback.call(null,e)}get hasCancelCallback(){return!!this.cancelCallback}matches(e){return this.snapshotCallback===e.snapshotCallback||this.snapshotCallback.userCallback!==void 0&&this.snapshotCallback.userCallback===e.snapshotCallback.userCallback&&this.snapshotCallback.context===e.snapshotCallback.context}}class IA{constructor(e,i){this._repo=e,this._path=i}cancel(){const e=new Mn;return SA(this._repo,this._path,e.wrapCallback(()=>{})),e.promise}remove(){Ir("OnDisconnect.remove",this._path);const e=new Mn;return Uv(this._repo,this._path,null,e.wrapCallback(()=>{})),e.promise}set(e){Ir("OnDisconnect.set",this._path),mu("OnDisconnect.set",e,this._path,!1);const i=new Mn;return Uv(this._repo,this._path,e,i.wrapCallback(()=>{})),i.promise}setWithPriority(e,i){Ir("OnDisconnect.setWithPriority",this._path),mu("OnDisconnect.setWithPriority",e,this._path,!1),lA("OnDisconnect.setWithPriority",i);const a=new Mn;return CA(this._repo,this._path,e,i,a.wrapCallback(()=>{})),a.promise}update(e){Ir("OnDisconnect.update",this._path),ww("OnDisconnect.update",e,this._path);const i=new Mn;return OA(this._repo,this._path,e,i.wrapCallback(()=>{})),i.promise}}class ah{constructor(e,i,a,o){this._repo=e,this._path=i,this._queryParams=a,this._orderByCalled=o}get key(){return ge(this._path)?null:Mf(this._path)}get ref(){return new vi(this._repo,this._path)}get _queryIdentifier(){const e=Ov(this._queryParams),i=Nf(e);return i==="{}"?"default":i}get _queryObject(){return Ov(this._queryParams)}isEqual(e){if(e=nt(e),!(e instanceof ah))return!1;const i=this._repo===e._repo,a=Rf(this._path,e._path),o=this._queryIdentifier===e._queryIdentifier;return i&&a&&o}toJSON(){return this.toString()}toString(){return this._repo.toString()+Sj(this._path)}}class vi extends ah{constructor(e,i){super(e,i,new Lf,!1)}get parent(){const e=Fb(this._path);return e===null?null:new vi(this._repo,e)}get root(){let e=this;for(;e.parent!==null;)e=e.parent;return e}}class Ho{constructor(e,i,a){this._node=e,this.ref=i,this._index=a}get priority(){return this._node.getPriority().val()}get key(){return this.ref.key}get size(){return this._node.numChildren()}child(e){const i=new Ie(e),a=Yo(this.ref,e);return new Ho(this._node.getChild(i),a,$e)}exists(){return!this._node.isEmpty()}exportVal(){return this._node.val(!0)}forEach(e){return this._node.isLeafNode()?!1:!!this._node.forEachChild(this._index,(a,o)=>e(new Ho(o,Yo(this.ref,a),$e)))}hasChild(e){const i=new Ie(e);return!this._node.getChild(i).isEmpty()}hasChildren(){return this._node.isLeafNode()?!1:!this._node.isEmpty()}toJSON(){return this.exportVal()}val(){return this._node.val()}}function _e(n,e){return n=nt(n),n._checkNotDeleted("ref"),e!==void 0?Yo(n._root,e):n._root}function Yo(n,e){return n=nt(n),pe(n._path)===null?cA("child","path",e):Sw("child","path",e),new vi(n._repo,Xe(n._path,e))}function PA(n){return n=nt(n),new IA(n._repo,n._path)}function Mw(n,e){n=nt(n),Ir("push",n._path),mu("push",e,n._path,!0);const i=_w(n._repo),a=MA(i),o=Yo(n,a),c=Yo(n,a);let d;return d=Promise.resolve(c),o.then=d.then.bind(d),o.catch=d.then.bind(d,void 0),o}function ps(n){return Ir("remove",n._path),Pn(n,null)}function Pn(n,e){n=nt(n),Ir("set",n._path),mu("set",e,n._path,!1);const i=new Mn;return xA(n._repo,n._path,e,null,i.wrapCallback(()=>{})),i.promise}function Rt(n,e){ww("update",e,n._path);const i=new Mn;return bA(n._repo,n._path,e,i.wrapCallback(()=>{})),i.promise}function Tn(n){n=nt(n);const e=new Aw(()=>{}),i=new Iu(e);return vA(n._repo,n,i).then(a=>new Ho(a,new vi(n._repo,n._path),n._queryParams.getIndex()))}class Iu{constructor(e){this.callbackContext=e}respondsTo(e){return e==="value"}createEvent(e,i){const a=i._queryParams.getIndex();return new RA("value",this,new Ho(e.snapshotNode,new vi(i._repo,i._path),a))}getEventRunner(e){return e.getEventType()==="cancel"?()=>this.callbackContext.onCancel(e.error):()=>this.callbackContext.onValue(e.snapshot,null)}createCancelEvent(e,i){return this.callbackContext.hasCancelCallback?new DA(this,e,i):null}matches(e){return e instanceof Iu?!e.callbackContext||!this.callbackContext?!0:e.callbackContext.matches(this.callbackContext):!1}hasAnyCallback(){return this.callbackContext!==null}}function LA(n,e,i,a,o){const c=new Aw(i,void 0),d=new Iu(c);return _A(n._repo,n,d),()=>Tw(n._repo,n,d)}function lr(n,e,i,a){return LA(n,"value",e)}function Xr(n,e,i){Tw(n._repo,n,null)}D3(vi);B3(vi);const UA="FIREBASE_DATABASE_EMULATOR_HOST",Qm={};let BA=!1;function zA(n,e,i,a){const o=e.lastIndexOf(":"),c=e.substring(0,o),d=cr(c);n.repoInfo_=new Mb(e,d,n.repoInfo_.namespace,n.repoInfo_.webSocketOnly,n.repoInfo_.nodeAdmin,n.repoInfo_.persistenceKey,n.repoInfo_.includeNamespaceInQueryParams,!0,i),a&&(n.authTokenProvider_=a)}function FA(n,e,i,a,o){let c=a||n.options.databaseURL;c===void 0&&(n.options.projectId||fi("Can't determine Firebase Database URL. Be sure to include  a Project ID when calling firebase.initializeApp()."),vt("Using default host for project ",n.options.projectId),c=`${n.options.projectId}-default-rtdb.firebaseio.com`);let d=Bv(c,o),m=d.repoInfo,f;typeof process<"u"&&sv&&(f=sv[UA]),f?(c=`http://${f}?ns=${m.namespace}`,d=Bv(c,o),m=d.repoInfo):d.repoInfo.secure;const h=new XE(n.name,n.options,e);uA("Invalid Firebase Database URL",d),ge(d.path)||fi("Database URL must point to the root of a Firebase Database (not including a child path).");const x=HA(m,n,h,new QE(n,i));return new YA(x,n)}function qA(n,e){const i=Qm[e];(!i||i[n.key]!==n)&&fi(`Database ${e}(${n.repoInfo_}) has already been deleted.`),TA(n),delete i[n.key]}function HA(n,e,i,a){let o=Qm[e.name];o||(o={},Qm[e.name]=o);let c=o[n.toURLString()];return c&&fi("Database initialized multiple times. Please make sure the format of the database URL matches with each database() call."),c=new hA(n,BA,i,a),o[n.toURLString()]=c,c}class YA{constructor(e,i){this._repoInternal=e,this.app=i,this.type="database",this._instanceStarted=!1}get _repo(){return this._instanceStarted||(gA(this._repoInternal,this.app.options.appId,this.app.options.databaseAuthVariableOverride),this._instanceStarted=!0),this._repoInternal}get _root(){return this._rootInternal||(this._rootInternal=new vi(this._repo,je())),this._rootInternal}_delete(){return this._rootInternal!==null&&(qA(this._repo,this.app.name),this._repoInternal=null,this._rootInternal=null),Promise.resolve()}_checkNotDeleted(e){this._rootInternal===null&&fi("Cannot call "+e+" on a deleted database.")}}function GA(n=yf(),e){const i=bu(n,"database").getImmediate({identifier:e});if(!i._instanceStarted){const a=kx("database");a&&VA(i,...a)}return i}function VA(n,e,i,a={}){n=nt(n),n._checkNotDeleted("useEmulator");const o=`${e}:${i}`,c=n._repoInternal;if(n._instanceStarted){if(o===n._repoInternal.repoInfo_.host&&Ur(a,c.repoInfo_.emulatorOptions))return;fi("connectDatabaseEmulator() cannot initialize or alter the emulator configuration after the database instance has started.")}let d;if(c.repoInfo_.nodeAdmin)a.mockUserToken&&fi('mockUserToken is not supported by the Admin SDK. For client access with mock users, please use the "firebase" package instead of "firebase-admin".'),d=new zc(zc.OWNER);else if(a.mockUserToken){const m=typeof a.mockUserToken=="string"?a.mockUserToken:jx(a.mockUserToken,n.app.options.projectId);d=new zc(m)}cr(e)&&(pf(e),mf("Database",!0)),zA(c,o,a,d)}function WA(n){RE(Wr),Br(new ir("database",(e,{instanceIdentifier:i})=>{const a=e.getProvider("app").getImmediate(),o=e.getProvider("auth-internal"),c=e.getProvider("app-check-internal");return FA(a,o,c,i)},"PUBLIC").setMultipleInstances(!0)),Dn(ov,lv,n),Dn(ov,lv,"esm2020")}const KA={".sv":"timestamp"};function QA(){return KA}ui.prototype.simpleListen=function(n,e){this.sendRequest("q",{p:n},e)};ui.prototype.echo=function(n,e){this.sendRequest("echo",{d:n},e)};WA();const XA={apiKey:"AIzaSyBEngkGj-us_Jyf-D_or0H9qbEnySGqss0",authDomain:"valkry-ed5c2.firebaseapp.com",projectId:"valkry-ed5c2",storageBucket:"valkry-ed5c2.firebasestorage.app",messagingSenderId:"395028222152",appId:"1:395028222152:web:2d9cb122484ba888aa55fd",measurementId:"G-DWXGY75PBF",databaseURL:"https://valkry-ed5c2-default-rtdb.asia-southeast1.firebasedatabase.app"},Rw=Ix(XA),za=AE(Rw),sh=new ri;sh.addScope("profile");sh.addScope("email");const Te=GA(Rw);async function Dw(n,e,i=null){const a=_e(Te,`users/${n}/stats`),o=await Tn(a);if(!o.exists()){const d={name:e,avatar:i,battles:0,wins:0,losses:0,draws:0,winRate:0,currentStreak:0,bestStreak:0,rating:1e3,rank:"Bronze",totalTimeSpent:0,fastestWin:null,createdAt:Date.now(),lastBattleAt:null};await Pn(a,d);const m=_e(Te,`leaderboard/${n}`);return await Pn(m,{name:e,avatar:i,rating:1e3,wins:0,streak:0,updatedAt:Date.now()}),await Iw("player"),d}const c=o.val();if(i||e){const d={};if(i&&c.avatar!==i&&(d.avatar=i),e&&c.name!==e&&(d.name=e),Object.keys(d).length>0){await Rt(a,d);const m=_e(Te,`leaderboard/${n}`);await Rt(m,d)}}return{...c,avatar:i||c.avatar,name:e||c.name}}async function $A(n,e){const i=_e(Te,`users/${n}/stats`);await Rt(i,{avatar:e});const a=_e(Te,`leaderboard/${n}`);await Rt(a,{avatar:e})}function ZA(n,e){const i=_e(Te,`users/${n}/stats`);return lr(i,a=>{a.exists()&&e(a.val())}),()=>Xr(i)}function JA(n){return n>=2500?"Legendary":n>=2e3?"Master":n>=1600?"Diamond":n>=1400?"Platinum":n>=1200?"Gold":n>=1e3?"Silver":"Bronze"}async function eM(n,e,i,a=1e3){const o=_e(Te,`users/${n}/stats`),c=await Tn(o);if(!c.exists())return;const d=c.val(),m=1/(1+Math.pow(10,(a-d.rating)/400)),f=e?1:0,h=d.battles<30?40:20,x=Math.round(h*(f-m)),v=Math.max(0,d.rating+x),b=e?d.currentStreak+1:0,_=Math.max(d.bestStreak,b),N=d.battles+1,D=d.wins+(e?1:0),q=d.losses+(e?0:1),F=Math.round(D/N*100);let I=d.fastestWin;e&&i&&(!I||i<I)&&(I=i);const H={battles:N,wins:D,losses:q,winRate:F,rating:v,rank:JA(v),currentStreak:b,bestStreak:_,totalTimeSpent:d.totalTimeSpent+(i||0),fastestWin:I,lastBattleAt:Date.now()};return await Rt(o,H),await tM(n,d.name,v,D,b,d.avatar),H}async function tM(n,e,i,a,o,c=null){const d=_e(Te,`leaderboard/${n}`);await Pn(d,{name:e,avatar:c,rating:i,wins:a,streak:o,updatedAt:Date.now()})}async function nM(n=50){const e=_e(Te,"leaderboard"),i=await Tn(e);if(!i.exists())return[];const a=i.val(),o=Object.entries(a).map(([c,d])=>({id:c,...d}));return o.sort((c,d)=>d.rating-c.rating),o.slice(0,n).map((c,d)=>({...c,rank:d+1}))}function iM(n,e=50){const i=_e(Te,"leaderboard");return lr(i,a=>{if(a.exists()){const o=a.val(),c=Object.entries(o).map(([d,m])=>({id:d,...m}));c.sort((d,m)=>m.rating-d.rating),n(c.slice(0,e).map((d,m)=>({...d,rank:m+1})))}else n([])}),()=>Xr(i)}async function oh(){const n=_e(Te,"globalStats"),e=await Tn(n);return e.exists()?e.val():{totalPlayers:0,battlesToday:0,totalBattles:0}}async function Iw(n){const e=_e(Te,"globalStats"),i=await Tn(e),a=i.exists()?i.val():{totalPlayers:0,battlesToday:0,totalBattles:0,lastResetDate:null},o=new Date().toDateString();return a.lastResetDate!==o&&(a.battlesToday=0,a.lastResetDate=o),n==="player"?a.totalPlayers=(a.totalPlayers||0)+1:n==="battle"&&(a.battlesToday=(a.battlesToday||0)+1,a.totalBattles=(a.totalBattles||0)+1),await Pn(e,a),a}async function rM(n){const e=_e(Te,`users/${n}/achievements`),i=await Tn(e);return i.exists()?i.val():{}}async function aM(n,e){const i=_e(Te,`users/${n}/achievements`),a=await Tn(i),o=a.exists()?a.val():{},c=[],d=[{id:"first_battle",name:"First Blood",desc:"Complete your first battle",check:()=>e.battles>=1},{id:"first_win",name:"Victory!",desc:"Win your first battle",check:()=>e.wins>=1},{id:"streak_3",name:"On Fire",desc:"Win 3 battles in a row",check:()=>e.bestStreak>=3},{id:"streak_5",name:"Unstoppable",desc:"Win 5 battles in a row",check:()=>e.bestStreak>=5},{id:"streak_10",name:"Legendary",desc:"Win 10 battles in a row",check:()=>e.bestStreak>=10},{id:"battles_10",name:"Veteran",desc:"Complete 10 battles",check:()=>e.battles>=10},{id:"battles_50",name:"Warrior",desc:"Complete 50 battles",check:()=>e.battles>=50},{id:"battles_100",name:"Champion",desc:"Complete 100 battles",check:()=>e.battles>=100},{id:"rating_1200",name:"Gold Rank",desc:"Reach 1200 rating",check:()=>e.rating>=1200},{id:"rating_1600",name:"Diamond Rank",desc:"Reach 1600 rating",check:()=>e.rating>=1600},{id:"rating_2000",name:"Master Rank",desc:"Reach 2000 rating",check:()=>e.rating>=2e3},{id:"speed_demon",name:"Speed Demon",desc:"Win a battle in under 60 seconds",check:()=>e.fastestWin&&e.fastestWin<60}];for(const m of d)!o[m.id]&&m.check()&&(o[m.id]={unlockedAt:Date.now(),name:m.name,desc:m.desc},c.push(m));return c.length>0&&await Pn(i,o),{all:o,new:c}}const Pw=S.createContext(),sM=({children:n})=>{const[e,i]=S.useState(null),[a,o]=S.useState(!0),c=x=>({id:x.uid,name:x.displayName||x.email?.split("@")[0]||"Commander",email:x.email,avatar:x.photoURL,handle:x.email?.split("@")[0]||"nomad"});S.useEffect(()=>{const x=xN(za,v=>{if(v){const b=c(v);i(b),localStorage.setItem("valkry_user",JSON.stringify(b)),Dw(b.id,b.name,b.avatar)}else localStorage.removeItem("valkry_user"),i(null);o(!1)});return()=>x()},[]);const d=async()=>{try{return await zN(za,sh),{success:!0}}catch(x){return console.error("Google Auth Error:",x),{success:!1,error:x.message}}},m=async(x,v,b)=>{try{const _=await fN(za,x,v);return b&&await sb(_.user,{displayName:b}),{success:!0}}catch(_){console.error("Sign Up Error:",_);let N="Failed to create account";return _.code==="auth/email-already-in-use"?N="Email already in use":_.code==="auth/weak-password"?N="Password must be at least 6 characters":_.code==="auth/invalid-email"&&(N="Invalid email address"),{success:!1,error:N}}},f=async(x,v)=>{try{return await hN(za,x,v),{success:!0}}catch(b){console.error("Login Error:",b);let _="Failed to sign in";return b.code==="auth/user-not-found"?_="No account found with this email":b.code==="auth/wrong-password"?_="Incorrect password":b.code==="auth/invalid-email"?_="Invalid email address":b.code==="auth/invalid-credential"&&(_="Invalid email or password"),{success:!1,error:_}}},h=async()=>{try{await bN(za),localStorage.removeItem("valkry_user"),i(null)}catch(x){console.error("Logout Error:",x),localStorage.removeItem("valkry_user"),i(null)}};return y.jsx(Pw.Provider,{value:{user:e,loading:a,loginGoogle:d,loginWithEmail:f,signUpWithEmail:m,logout:h},children:!a&&n})},$r=()=>S.useContext(Pw);const oM=n=>n.replace(/([a-z0-9])([A-Z])/g,"$1-$2").toLowerCase(),lM=n=>n.replace(/^([A-Z])|[\s-_]+(\w)/g,(e,i,a)=>a?a.toUpperCase():i.toLowerCase()),Fv=n=>{const e=lM(n);return e.charAt(0).toUpperCase()+e.slice(1)},Lw=(...n)=>n.filter((e,i,a)=>!!e&&e.trim()!==""&&a.indexOf(e)===i).join(" ").trim(),cM=n=>{for(const e in n)if(e.startsWith("aria-")||e==="role"||e==="title")return!0};var uM={xmlns:"http://www.w3.org/2000/svg",width:24,height:24,viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:2,strokeLinecap:"round",strokeLinejoin:"round"};const dM=S.forwardRef(({color:n="currentColor",size:e=24,strokeWidth:i=2,absoluteStrokeWidth:a,className:o="",children:c,iconNode:d,...m},f)=>S.createElement("svg",{ref:f,...uM,width:e,height:e,stroke:n,strokeWidth:a?Number(i)*24/Number(e):i,className:Lw("lucide",o),...!c&&!cM(m)&&{"aria-hidden":"true"},...m},[...d.map(([h,x])=>S.createElement(h,x)),...Array.isArray(c)?c:[c]]));const me=(n,e)=>{const i=S.forwardRef(({className:a,...o},c)=>S.createElement(dM,{ref:c,iconNode:e,className:Lw(`lucide-${oM(Fv(n))}`,`lucide-${n}`,a),...o}));return i.displayName=Fv(n),i};const pM=[["path",{d:"m12 19-7-7 7-7",key:"1l729n"}],["path",{d:"M19 12H5",key:"x3x0zl"}]],mM=me("arrow-left",pM);const fM=[["path",{d:"M5 12h14",key:"1ays0h"}],["path",{d:"m12 5 7 7-7 7",key:"xquz4c"}]],fu=me("arrow-right",fM);const hM=[["circle",{cx:"12",cy:"12",r:"4",key:"4exip2"}],["path",{d:"M16 8v5a3 3 0 0 0 6 0v-1a10 10 0 1 0-4 8",key:"7n84p3"}]],gM=me("at-sign",hM);const yM=[["path",{d:"m15.477 12.89 1.515 8.526a.5.5 0 0 1-.81.47l-3.58-2.687a1 1 0 0 0-1.197 0l-3.586 2.686a.5.5 0 0 1-.81-.469l1.514-8.526",key:"1yiouv"}],["circle",{cx:"12",cy:"8",r:"6",key:"1vp47v"}]],Uw=me("award",yM);const vM=[["path",{d:"M13.997 4a2 2 0 0 1 1.76 1.05l.486.9A2 2 0 0 0 18.003 7H20a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V9a2 2 0 0 1 2-2h1.997a2 2 0 0 0 1.759-1.048l.489-.904A2 2 0 0 1 10.004 4z",key:"18u6gg"}],["circle",{cx:"12",cy:"13",r:"3",key:"1vg3eu"}]],xM=me("camera",vM);const bM=[["path",{d:"m6 9 6 6 6-6",key:"qrunsl"}]],wM=me("chevron-down",bM);const SM=[["path",{d:"m15 18-6-6 6-6",key:"1wnfg3"}]],CM=me("chevron-left",SM);const OM=[["path",{d:"m9 18 6-6-6-6",key:"mthhwq"}]],qv=me("chevron-right",OM);const _M=[["path",{d:"m11 17-5-5 5-5",key:"13zhaf"}],["path",{d:"m18 17-5-5 5-5",key:"h8a8et"}]],TM=me("chevrons-left",_M);const kM=[["path",{d:"m6 17 5-5-5-5",key:"xnjwq"}],["path",{d:"m13 17 5-5-5-5",key:"17xmmf"}]],NM=me("chevrons-right",kM);const EM=[["circle",{cx:"12",cy:"12",r:"10",key:"1mglay"}],["line",{x1:"12",x2:"12",y1:"8",y2:"12",key:"1pkeuh"}],["line",{x1:"12",x2:"12.01",y1:"16",y2:"16",key:"4dfq90"}]],jM=me("circle-alert",EM);const AM=[["path",{d:"M21.801 10A10 10 0 1 1 17 3.335",key:"yps3ct"}],["path",{d:"m9 11 3 3L22 4",key:"1pflzl"}]],MM=me("circle-check-big",AM);const RM=[["circle",{cx:"12",cy:"12",r:"10",key:"1mglay"}],["path",{d:"m15 9-6 6",key:"1uzhvr"}],["path",{d:"m9 9 6 6",key:"z0biqf"}]],DM=me("circle-x",RM);const IM=[["path",{d:"m16 18 6-6-6-6",key:"eg8j8"}],["path",{d:"m8 6-6 6 6 6",key:"ppft3o"}]],PM=me("code",IM);const LM=[["path",{d:"M11.562 3.266a.5.5 0 0 1 .876 0L15.39 8.87a1 1 0 0 0 1.516.294L21.183 5.5a.5.5 0 0 1 .798.519l-2.834 10.246a1 1 0 0 1-.956.734H5.81a1 1 0 0 1-.957-.734L2.02 6.02a.5.5 0 0 1 .798-.519l4.276 3.664a1 1 0 0 0 1.516-.294z",key:"1vdc57"}],["path",{d:"M5 21h14",key:"11awu3"}]],UM=me("crown",LM);const BM=[["path",{d:"M10.733 5.076a10.744 10.744 0 0 1 11.205 6.575 1 1 0 0 1 0 .696 10.747 10.747 0 0 1-1.444 2.49",key:"ct8e1f"}],["path",{d:"M14.084 14.158a3 3 0 0 1-4.242-4.242",key:"151rxh"}],["path",{d:"M17.479 17.499a10.75 10.75 0 0 1-15.417-5.151 1 1 0 0 1 0-.696 10.75 10.75 0 0 1 4.446-5.143",key:"13bj9a"}],["path",{d:"m2 2 20 20",key:"1ooewy"}]],zM=me("eye-off",BM);const FM=[["path",{d:"M2.062 12.348a1 1 0 0 1 0-.696 10.75 10.75 0 0 1 19.876 0 1 1 0 0 1 0 .696 10.75 10.75 0 0 1-19.876 0",key:"1nclc0"}],["circle",{cx:"12",cy:"12",r:"3",key:"1v7zrd"}]],qM=me("eye",FM);const HM=[["path",{d:"M4 22V4a1 1 0 0 1 .4-.8A6 6 0 0 1 8 2c3 0 5 2 7.333 2q2 0 3.067-.8A1 1 0 0 1 20 4v10a1 1 0 0 1-.4.8A6 6 0 0 1 16 16c-3 0-5-2-8-2a6 6 0 0 0-4 1.528",key:"1jaruq"}]],YM=me("flag",HM);const GM=[["path",{d:"M12 3q1 4 4 6.5t3 5.5a1 1 0 0 1-14 0 5 5 0 0 1 1-3 1 1 0 0 0 5 0c0-2-1.5-3-1.5-5q0-2 2.5-4",key:"1slcih"}]],Bw=me("flame",GM);const VM=[["path",{d:"M15 22v-4a4.8 4.8 0 0 0-1-3.5c3 0 6-2 6-5.5.08-1.25-.27-2.48-1-3.5.28-1.15.28-2.35 0-3.5 0 0-1 0-3 1.5-2.64-.5-5.36-.5-8 0C6 2 5 2 5 2c-.3 1.15-.3 2.35 0 3.5A5.403 5.403 0 0 0 4 9c0 3.5 3 5.5 6 5.5-.39.49-.68 1.05-.85 1.65-.17.6-.22 1.23-.15 1.85v4",key:"tonef"}],["path",{d:"M9 18c-4.51 2-5-2-7-2",key:"9comsn"}]],WM=me("github",VM);const KM=[["path",{d:"M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z",key:"c2jq9f"}],["rect",{width:"4",height:"12",x:"2",y:"9",key:"mk3on5"}],["circle",{cx:"4",cy:"4",r:"2",key:"bt5ra8"}]],QM=me("linkedin",KM);const XM=[["rect",{width:"18",height:"11",x:"3",y:"11",rx:"2",ry:"2",key:"1w4ew1"}],["path",{d:"M7 11V7a5 5 0 0 1 10 0v4",key:"fwvmzm"}]],$M=me("lock",XM);const ZM=[["path",{d:"m10 17 5-5-5-5",key:"1bsop3"}],["path",{d:"M15 12H3",key:"6jk70r"}],["path",{d:"M15 3h4a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-4",key:"u53s6r"}]],JM=me("log-in",ZM);const eR=[["path",{d:"m16 17 5-5-5-5",key:"1bji2h"}],["path",{d:"M21 12H9",key:"dn1m92"}],["path",{d:"M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4",key:"1uf3rs"}]],tR=me("log-out",eR);const nR=[["path",{d:"m22 7-8.991 5.727a2 2 0 0 1-2.009 0L2 7",key:"132q7q"}],["rect",{x:"2",y:"4",width:"20",height:"16",rx:"2",key:"izxlao"}]],zw=me("mail",nR);const iR=[["path",{d:"M4 5h16",key:"1tepv9"}],["path",{d:"M4 12h16",key:"1lakjw"}],["path",{d:"M4 19h16",key:"1djgab"}]],rR=me("menu",iR);const aR=[["path",{d:"M5 5a2 2 0 0 1 3.008-1.728l11.997 6.998a2 2 0 0 1 .003 3.458l-12 7A2 2 0 0 1 5 19z",key:"10ikf1"}]],Fw=me("play",aR);const sR=[["path",{d:"M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8",key:"1357e3"}],["path",{d:"M3 3v5h5",key:"1xhq8a"}]],oR=me("rotate-ccw",sR);const lR=[["path",{d:"M15.2 3a2 2 0 0 1 1.4.6l3.8 3.8a2 2 0 0 1 .6 1.4V19a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2z",key:"1c8476"}],["path",{d:"M17 21v-7a1 1 0 0 0-1-1H8a1 1 0 0 0-1 1v7",key:"1ydtos"}],["path",{d:"M7 3v4a1 1 0 0 0 1 1h7",key:"t51u73"}]],cR=me("save",lR);const uR=[["path",{d:"m21 21-4.34-4.34",key:"14j7rj"}],["circle",{cx:"11",cy:"11",r:"8",key:"4ej97u"}]],qw=me("search",uR);const dR=[["polyline",{points:"14.5 17.5 3 6 3 3 6 3 17.5 14.5",key:"1hfsw2"}],["line",{x1:"13",x2:"19",y1:"19",y2:"13",key:"1vrmhu"}],["line",{x1:"16",x2:"20",y1:"16",y2:"20",key:"1bron3"}],["line",{x1:"19",x2:"21",y1:"21",y2:"19",key:"13pww6"}],["polyline",{points:"14.5 6.5 18 3 21 3 21 6 17.5 9.5",key:"hbey2j"}],["line",{x1:"5",x2:"9",y1:"14",y2:"18",key:"1hf58s"}],["line",{x1:"7",x2:"4",y1:"17",y2:"20",key:"pidxm4"}],["line",{x1:"3",x2:"5",y1:"19",y2:"21",key:"1pehsh"}]],Xm=me("swords",dR);const pR=[["circle",{cx:"12",cy:"12",r:"10",key:"1mglay"}],["circle",{cx:"12",cy:"12",r:"6",key:"1vlfrh"}],["circle",{cx:"12",cy:"12",r:"2",key:"1c9p78"}]],Hw=me("target",pR);const mR=[["path",{d:"M16 7h6v6",key:"box55l"}],["path",{d:"m22 7-8.5 8.5-5-5L2 17",key:"1t1m79"}]],Yw=me("trending-up",mR);const fR=[["path",{d:"M10 14.66v1.626a2 2 0 0 1-.976 1.696A5 5 0 0 0 7 21.978",key:"1n3hpd"}],["path",{d:"M14 14.66v1.626a2 2 0 0 0 .976 1.696A5 5 0 0 1 17 21.978",key:"rfe1zi"}],["path",{d:"M18 9h1.5a1 1 0 0 0 0-5H18",key:"7xy6bh"}],["path",{d:"M4 22h16",key:"57wxv0"}],["path",{d:"M6 9a6 6 0 0 0 12 0V3a1 1 0 0 0-1-1H7a1 1 0 0 0-1 1z",key:"1mhfuq"}],["path",{d:"M6 9H4.5a1 1 0 0 1 0-5H6",key:"tex48p"}]],Hv=me("trophy",fR);const hR=[["path",{d:"M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2",key:"1yyitq"}],["circle",{cx:"9",cy:"7",r:"4",key:"nufk8"}],["line",{x1:"19",x2:"19",y1:"8",y2:"14",key:"1bvyxn"}],["line",{x1:"22",x2:"16",y1:"11",y2:"11",key:"1shjgl"}]],gR=me("user-plus",hR);const yR=[["path",{d:"M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2",key:"975kel"}],["circle",{cx:"12",cy:"7",r:"4",key:"17ys0d"}]],Gw=me("user",yR);const vR=[["path",{d:"M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2",key:"1yyitq"}],["path",{d:"M16 3.128a4 4 0 0 1 0 7.744",key:"16gr8j"}],["path",{d:"M22 21v-2a4 4 0 0 0-3-3.87",key:"kshegd"}],["circle",{cx:"9",cy:"7",r:"4",key:"nufk8"}]],Vw=me("users",vR);const xR=[["path",{d:"M18 6 6 18",key:"1bl5f8"}],["path",{d:"m6 6 12 12",key:"d8bk6v"}]],$m=me("x",xR);const bR=[["path",{d:"M2.5 17a24.12 24.12 0 0 1 0-10 2 2 0 0 1 1.4-1.4 49.56 49.56 0 0 1 16.2 0A2 2 0 0 1 21.5 7a24.12 24.12 0 0 1 0 10 2 2 0 0 1-1.4 1.4 49.55 49.55 0 0 1-16.2 0A2 2 0 0 1 2.5 17",key:"1q2vi4"}],["path",{d:"m10 15 5-3-5-3z",key:"1jp15x"}]],wR=me("youtube",bR),Ww=({size:n="default"})=>{const e={small:16,default:20,large:28,hero:44},i=e[n]||e.default;return y.jsx(Tt,{to:"/",style:{textDecoration:"none",display:"inline-block"},children:y.jsx("span",{style:{fontSize:i,fontWeight:500,letterSpacing:"-0.02em",color:"#FAFAFA",fontFamily:'-apple-system, BlinkMacSystemFont, "SF Pro Display", "Segoe UI", Roboto, sans-serif'},children:"Valkry"})})},SR=()=>{const{user:n,logout:e}=$r(),i=hi(),[a,o]=S.useState(!1),c=[{to:"/",label:"Home"},{to:"/arena",label:"Arena"},{to:"/learn",label:"Learn"},{to:"/leaderboard",label:"Leaderboard"},{to:"/about",label:"About"}],d=m=>i.pathname===m;return y.jsxs("nav",{className:"navbar",children:[y.jsx(Ww,{}),y.jsxs("div",{className:"nav-links",style:{display:"flex",alignItems:"center",gap:"28px"},children:[c.map(m=>y.jsx(Tt,{to:m.to,className:`nav-link ${d(m.to)?"active":""}`,children:m.label},m.to)),n&&y.jsx(Tt,{to:"/dashboard",className:`nav-link ${d("/dashboard")?"active":""}`,children:"Dashboard"})]}),y.jsxs("div",{style:{display:"flex",alignItems:"center",gap:"16px"},children:[n?y.jsxs(y.Fragment,{children:[y.jsx(Tt,{to:"/profile",style:{textDecoration:"none"},children:y.jsxs("div",{style:{display:"flex",alignItems:"center",gap:"8px",padding:"6px 12px",background:"var(--bg-elevated)",borderRadius:"980px",border:"1px solid var(--border)",cursor:"pointer",transition:"border-color 0.2s"},children:[n.avatar?y.jsx("img",{src:n.avatar,alt:n.name,style:{width:"24px",height:"24px",borderRadius:"50%",objectFit:"cover"}}):y.jsx("div",{className:"avatar",style:{width:"24px",height:"24px",fontSize:"11px"},children:n.name?.charAt(0).toUpperCase()||"U"}),y.jsx("span",{style:{fontSize:"13px",color:"var(--text-secondary)"},children:n.name?.split(" ")[0]||"User"})]})}),y.jsx("button",{onClick:e,className:"btn btn-ghost",style:{padding:"8px"},title:"Sign out",children:y.jsx(tR,{size:16})})]}):y.jsx(Tt,{to:"/signin",children:y.jsx("button",{className:"btn btn-primary",style:{padding:"8px 18px",fontSize:"13px"},children:"Sign In"})}),y.jsx("button",{onClick:()=>o(!a),className:"btn btn-ghost",style:{display:"none",padding:"8px"},children:a?y.jsx($m,{size:20}):y.jsx(rR,{size:20})})]}),a&&y.jsxs("div",{style:{position:"absolute",top:"52px",left:0,right:0,background:"rgba(0, 0, 0, 0.95)",backdropFilter:"saturate(180%) blur(20px)",borderBottom:"1px solid var(--border)",padding:"16px 22px"},children:[c.map(m=>y.jsx(Tt,{to:m.to,onClick:()=>o(!1),style:{display:"block",padding:"12px 0",fontSize:"15px",color:d(m.to)?"var(--text)":"var(--text-secondary)",borderBottom:"1px solid var(--border)"},children:m.label},m.to)),n&&y.jsx(Tt,{to:"/dashboard",onClick:()=>o(!1),style:{display:"block",padding:"12px 0",fontSize:"15px",color:d("/dashboard")?"var(--text)":"var(--text-secondary)"},children:"Dashboard"})]})]})},CR=JSON.parse(`[{"id":"easy1","title":"Add Two Numbers","description":"Return sum of two integers.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nint add(int a, int b) { return 0; }\\nint main() { cout << add(5, 3); return 0; }","expectedOutput":"8","solution":"#include <iostream>\\nusing namespace std;\\nint add(int a, int b) { return a + b; }\\nint main() { cout << add(5, 3); return 0; }","explanation":{"approach":"Simply use the + operator to add two numbers.","analogy":"Like counting on fingers - combine both hands.","steps":["Return a + b"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"easy2","title":"Multiply Two Numbers","description":"Return product of two integers.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nint multiply(int a, int b) { return 0; }\\nint main() { cout << multiply(4, 7); return 0; }","expectedOutput":"28","solution":"#include <iostream>\\nusing namespace std;\\nint multiply(int a, int b) { return a * b; }\\nint main() { cout << multiply(4, 7); return 0; }","explanation":{"approach":"Use multiplication operator.","analogy":"4 groups of 7 items.","steps":["Return a * b"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"easy3","title":"Find Maximum of Two","description":"Return larger of two numbers.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nint maxOfTwo(int a, int b) { return 0; }\\nint main() { cout << maxOfTwo(10, 25); return 0; }","expectedOutput":"25","solution":"#include <iostream>\\nusing namespace std;\\nint maxOfTwo(int a, int b) { return a > b ? a : b; }\\nint main() { cout << maxOfTwo(10, 25); return 0; }","explanation":{"approach":"Compare and return larger.","analogy":"Which is taller?","steps":["If a > b return a, else return b"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"easy4","title":"Absolute Value","description":"Return absolute value.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nint absolute(int n) { return 0; }\\nint main() { cout << absolute(-15); return 0; }","expectedOutput":"15","solution":"#include <iostream>\\nusing namespace std;\\nint absolute(int n) { return n < 0 ? -n : n; }\\nint main() { cout << absolute(-15); return 0; }","explanation":{"approach":"If negative, negate it.","analogy":"Distance from zero is always positive.","steps":["If n < 0, return -n","Else return n"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"easy5","title":"Check Even or Odd","description":"Print 'Even' or 'Odd'.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid check(int n) {}\\nint main() { check(7); return 0; }","expectedOutput":"Odd","solution":"#include <iostream>\\nusing namespace std;\\nvoid check(int n) { cout << (n % 2 == 0 ? \\"Even\\" : \\"Odd\\"); }\\nint main() { check(7); return 0; }","explanation":{"approach":"If divisible by 2, it's even.","analogy":"Can you split evenly into two groups?","steps":["Check n % 2","If 0, even; else odd"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"easy6","title":"Print Hello World","description":"Print Hello World.","difficulty":"EASY","category":"Basics","starterCode":"#include <iostream>\\nusing namespace std;\\nint main() { return 0; }","expectedOutput":"Hello World","solution":"#include <iostream>\\nusing namespace std;\\nint main() { cout << \\"Hello World\\"; return 0; }","explanation":{"approach":"Use cout to print.","analogy":"Your first program!","steps":["Use cout << \\"Hello World\\""],"complexity":"Time: O(1), Space: O(1)"}},{"id":"easy7","title":"Sum of Array","description":"Find sum of array elements.","difficulty":"EASY","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nint sum(int arr[], int n) { return 0; }\\nint main() { int a[] = {1,2,3,4,5}; cout << sum(a, 5); return 0; }","expectedOutput":"15","solution":"#include <iostream>\\nusing namespace std;\\nint sum(int arr[], int n) { int s = 0; for(int i = 0; i < n; i++) s += arr[i]; return s; }\\nint main() { int a[] = {1,2,3,4,5}; cout << sum(a, 5); return 0; }","explanation":{"approach":"Loop through and add each element.","analogy":"Count all coins.","steps":["Init sum = 0","Add each element"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"easy8","title":"Find Array Maximum","description":"Find largest element.","difficulty":"EASY","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nint findMax(int arr[], int n) { return 0; }\\nint main() { int a[] = {3,1,4,1,5,9}; cout << findMax(a, 6); return 0; }","expectedOutput":"9","solution":"#include <iostream>\\nusing namespace std;\\nint findMax(int arr[], int n) { int m = arr[0]; for(int i = 1; i < n; i++) if(arr[i] > m) m = arr[i]; return m; }\\nint main() { int a[] = {3,1,4,1,5,9}; cout << findMax(a, 6); return 0; }","explanation":{"approach":"Track maximum while looping.","analogy":"King of the hill contest.","steps":["Assume first is max","Compare with each element"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"easy9","title":"Find Array Minimum","description":"Find smallest element.","difficulty":"EASY","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nint findMin(int arr[], int n) { return 0; }\\nint main() { int a[] = {3,1,4,1,5,9}; cout << findMin(a, 6); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nint findMin(int arr[], int n) { int m = arr[0]; for(int i = 1; i < n; i++) if(arr[i] < m) m = arr[i]; return m; }\\nint main() { int a[] = {3,1,4,1,5,9}; cout << findMin(a, 6); return 0; }","explanation":{"approach":"Track minimum while looping.","analogy":"Find shortest person.","steps":["Assume first is min","Compare with each"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"easy10","title":"Reverse Array","description":"Reverse array in-place.","difficulty":"EASY","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid reverse(int arr[], int n) {}\\nint main() { int a[] = {1,2,3,4,5}; reverse(a,5); for(int i=0;i<5;i++) cout<<a[i]<<(i<4?\\" \\":\\"\\"); return 0; }","expectedOutput":"5 4 3 2 1","solution":"#include <iostream>\\nusing namespace std;\\nvoid reverse(int arr[], int n) { int l=0, r=n-1; while(l<r) { int t=arr[l]; arr[l]=arr[r]; arr[r]=t; l++; r--; } }\\nint main() { int a[] = {1,2,3,4,5}; reverse(a,5); for(int i=0;i<5;i++) cout<<a[i]<<(i<4?\\" \\":\\"\\"); return 0; }","explanation":{"approach":"Two pointers swap from ends.","analogy":"Swap first-last, second-second-last, etc.","steps":["Put pointers at both ends","Swap and move inward"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"easy11","title":"Count Occurrences","description":"Count how many times x appears.","difficulty":"EASY","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nint count(int arr[], int n, int x) { return 0; }\\nint main() { int a[] = {1,2,2,3,2,4}; cout << count(a, 6, 2); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nint count(int arr[], int n, int x) { int c = 0; for(int i = 0; i < n; i++) if(arr[i] == x) c++; return c; }\\nint main() { int a[] = {1,2,2,3,2,4}; cout << count(a, 6, 2); return 0; }","explanation":{"approach":"Loop and count matches.","analogy":"Count all red balls.","steps":["For each element, check if equals x","Increment counter"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"easy12","title":"Linear Search","description":"Find index of element.","difficulty":"EASY","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nint search(int arr[], int n, int x) { return -1; }\\nint main() { int a[] = {5,3,7,1,9}; cout << search(a, 5, 7); return 0; }","expectedOutput":"2","solution":"#include <iostream>\\nusing namespace std;\\nint search(int arr[], int n, int x) { for(int i = 0; i < n; i++) if(arr[i] == x) return i; return -1; }\\nint main() { int a[] = {5,3,7,1,9}; cout << search(a, 5, 7); return 0; }","explanation":{"approach":"Check each element one by one.","analogy":"Looking for your keys - check each pocket.","steps":["Loop through array","Return index when found","Return -1 if not found"],"complexity":"Time: O(n), Space: O(1)"}}]`),OR=JSON.parse(`[{"id":"easy13","title":"Binary Search","description":"Search in sorted array.","difficulty":"EASY","category":"Binary Search","starterCode":"#include <iostream>\\nusing namespace std;\\nint binarySearch(int arr[], int n, int x) { return -1; }\\nint main() { int a[] = {1,3,5,7,9}; cout << binarySearch(a, 5, 5); return 0; }","expectedOutput":"2","solution":"#include <iostream>\\nusing namespace std;\\nint binarySearch(int arr[], int n, int x) { int l=0, r=n-1; while(l<=r) { int m=(l+r)/2; if(arr[m]==x) return m; if(arr[m]<x) l=m+1; else r=m-1; } return -1; }\\nint main() { int a[] = {1,3,5,7,9}; cout << binarySearch(a, 5, 5); return 0; }","explanation":{"approach":"Divide search space in half each time.","analogy":"Like dictionary lookup - open to middle, go left or right.","steps":["Check middle","If less, search right half","If more, search left half"],"complexity":"Time: O(log n), Space: O(1)"}},{"id":"easy14","title":"Bubble Sort","description":"Sort array ascending.","difficulty":"EASY","category":"Sorting","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid bubbleSort(int arr[], int n) {}\\nint main() { int a[] = {5,1,4,2,8}; bubbleSort(a,5); for(int i=0;i<5;i++) cout<<a[i]<<(i<4?\\" \\":\\"\\"); return 0; }","expectedOutput":"1 2 4 5 8","solution":"#include <iostream>\\nusing namespace std;\\nvoid bubbleSort(int arr[], int n) { for(int i=0;i<n-1;i++) for(int j=0;j<n-i-1;j++) if(arr[j]>arr[j+1]) { int t=arr[j]; arr[j]=arr[j+1]; arr[j+1]=t; } }\\nint main() { int a[] = {5,1,4,2,8}; bubbleSort(a,5); for(int i=0;i<5;i++) cout<<a[i]<<(i<4?\\" \\":\\"\\"); return 0; }","explanation":{"approach":"Bubble largest elements to end repeatedly.","analogy":"Bubbles rise to top - large elements float up.","steps":["Compare adjacent pairs","Swap if out of order","Repeat n times"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"easy15","title":"Selection Sort","description":"Sort by selecting minimum.","difficulty":"EASY","category":"Sorting","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid selectionSort(int arr[], int n) {}\\nint main() { int a[] = {64,25,12,22,11}; selectionSort(a,5); for(int i=0;i<5;i++) cout<<a[i]<<(i<4?\\" \\":\\"\\"); return 0; }","expectedOutput":"11 12 22 25 64","solution":"#include <iostream>\\nusing namespace std;\\nvoid selectionSort(int arr[], int n) { for(int i=0;i<n-1;i++) { int m=i; for(int j=i+1;j<n;j++) if(arr[j]<arr[m]) m=j; int t=arr[i]; arr[i]=arr[m]; arr[m]=t; } }\\nint main() { int a[] = {64,25,12,22,11}; selectionSort(a,5); for(int i=0;i<5;i++) cout<<a[i]<<(i<4?\\" \\":\\"\\"); return 0; }","explanation":{"approach":"Find minimum, put in position, repeat.","analogy":"Pick smallest card, then next smallest...","steps":["Find minimum in unsorted part","Swap to current position"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"easy16","title":"Insertion Sort","description":"Sort by inserting in place.","difficulty":"EASY","category":"Sorting","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid insertionSort(int arr[], int n) {}\\nint main() { int a[] = {12,11,13,5,6}; insertionSort(a,5); for(int i=0;i<5;i++) cout<<a[i]<<(i<4?\\" \\":\\"\\"); return 0; }","expectedOutput":"5 6 11 12 13","solution":"#include <iostream>\\nusing namespace std;\\nvoid insertionSort(int arr[], int n) { for(int i=1;i<n;i++) { int k=arr[i], j=i-1; while(j>=0 && arr[j]>k) { arr[j+1]=arr[j]; j--; } arr[j+1]=k; } }\\nint main() { int a[] = {12,11,13,5,6}; insertionSort(a,5); for(int i=0;i<5;i++) cout<<a[i]<<(i<4?\\" \\":\\"\\"); return 0; }","explanation":{"approach":"Insert each element into sorted portion.","analogy":"Like sorting cards in hand one by one.","steps":["Take each element","Insert in correct position in sorted part"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"easy17","title":"String Length","description":"Find length of string.","difficulty":"EASY","category":"Strings","starterCode":"#include <iostream>\\nusing namespace std;\\nint strLen(char s[]) { return 0; }\\nint main() { cout << strLen(\\"hello\\"); return 0; }","expectedOutput":"5","solution":"#include <iostream>\\nusing namespace std;\\nint strLen(char s[]) { int l=0; while(s[l]) l++; return l; }\\nint main() { cout << strLen(\\"hello\\"); return 0; }","explanation":{"approach":"Count until null character.","analogy":"Count steps until you hit the wall.","steps":["Loop until \\\\0","Count characters"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"easy18","title":"String Copy","description":"Copy string to another.","difficulty":"EASY","category":"Strings","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid strCopy(char dest[], char src[]) {}\\nint main() { char d[20]; strCopy(d, \\"hello\\"); cout << d; return 0; }","expectedOutput":"hello","solution":"#include <iostream>\\nusing namespace std;\\nvoid strCopy(char dest[], char src[]) { int i=0; while(src[i]) { dest[i]=src[i]; i++; } dest[i]='\\\\0'; }\\nint main() { char d[20]; strCopy(d, \\"hello\\"); cout << d; return 0; }","explanation":{"approach":"Copy character by character.","analogy":"Photocopy each letter.","steps":["Copy each char","Add null terminator"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"easy19","title":"String Compare","description":"Compare two strings.","difficulty":"EASY","category":"Strings","starterCode":"#include <iostream>\\nusing namespace std;\\nint strCmp(char a[], char b[]) { return 0; }\\nint main() { cout << strCmp(\\"abc\\", \\"abc\\"); return 0; }","expectedOutput":"0","solution":"#include <iostream>\\nusing namespace std;\\nint strCmp(char a[], char b[]) { int i=0; while(a[i] && a[i]==b[i]) i++; return a[i]-b[i]; }\\nint main() { cout << strCmp(\\"abc\\", \\"abc\\"); return 0; }","explanation":{"approach":"Compare char by char, return difference.","analogy":"Compare letters alphabetically.","steps":["Loop while matching","Return difference at first mismatch"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"easy20","title":"Reverse String","description":"Reverse a string.","difficulty":"EASY","category":"Strings","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid reverse(char s[]) {}\\nint main() { char s[] = \\"hello\\"; reverse(s); cout << s; return 0; }","expectedOutput":"olleh","solution":"#include <iostream>\\nusing namespace std;\\nvoid reverse(char s[]) { int l=0, r=0; while(s[r]) r++; r--; while(l<r) { char t=s[l]; s[l]=s[r]; s[r]=t; l++; r--; } }\\nint main() { char s[] = \\"hello\\"; reverse(s); cout << s; return 0; }","explanation":{"approach":"Swap characters from both ends.","analogy":"Mirror image of the string.","steps":["Find length","Swap first-last pairs"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"easy21","title":"Check Palindrome String","description":"Is string a palindrome.","difficulty":"EASY","category":"Strings","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isPalindrome(char s[]) { return false; }\\nint main() { cout << isPalindrome(\\"radar\\"); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isPalindrome(char s[]) { int l=0, r=0; while(s[r]) r++; r--; while(l<r) if(s[l++]!=s[r--]) return false; return true; }\\nint main() { cout << isPalindrome(\\"radar\\"); return 0; }","explanation":{"approach":"Compare characters from both ends.","analogy":"Reads same forwards and backwards.","steps":["Compare s[left] with s[right]","Move inward"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"easy22","title":"Count Vowels","description":"Count vowels in string.","difficulty":"EASY","category":"Strings","starterCode":"#include <iostream>\\nusing namespace std;\\nint countVowels(char s[]) { return 0; }\\nint main() { cout << countVowels(\\"hello world\\"); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nint countVowels(char s[]) { int c=0; for(int i=0; s[i]; i++) { char ch=tolower(s[i]); if(ch=='a'||ch=='e'||ch=='i'||ch=='o'||ch=='u') c++; } return c; }\\nint main() { cout << countVowels(\\"hello world\\"); return 0; }","explanation":{"approach":"Check each character for vowel.","analogy":"Count A, E, I, O, U.","steps":["Loop through string","Check if vowel","Count"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"easy23","title":"Count Words","description":"Count words in string.","difficulty":"EASY","category":"Strings","starterCode":"#include <iostream>\\nusing namespace std;\\nint countWords(char s[]) { return 0; }\\nint main() { cout << countWords(\\"hello world test\\"); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nint countWords(char s[]) { int c=0; bool inWord=false; for(int i=0; s[i]; i++) { if(s[i]!=' ' && !inWord) { c++; inWord=true; } else if(s[i]==' ') inWord=false; } return c; }\\nint main() { cout << countWords(\\"hello world test\\"); return 0; }","explanation":{"approach":"Count transitions from space to word.","analogy":"Words are separated by spaces.","steps":["Track if in word","Count when entering word"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"easy24","title":"Convert to Uppercase","description":"Convert string to uppercase.","difficulty":"EASY","category":"Strings","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid toUpper(char s[]) {}\\nint main() { char s[] = \\"hello\\"; toUpper(s); cout << s; return 0; }","expectedOutput":"HELLO","solution":"#include <iostream>\\nusing namespace std;\\nvoid toUpper(char s[]) { for(int i=0; s[i]; i++) if(s[i]>='a' && s[i]<='z') s[i] -= 32; }\\nint main() { char s[] = \\"hello\\"; toUpper(s); cout << s; return 0; }","explanation":{"approach":"Subtract 32 from lowercase letters.","analogy":"'a'(97) - 32 = 'A'(65)","steps":["Check if lowercase","Subtract 32"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"easy25","title":"Convert to Lowercase","description":"Convert string to lowercase.","difficulty":"EASY","category":"Strings","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid toLower(char s[]) {}\\nint main() { char s[] = \\"HELLO\\"; toLower(s); cout << s; return 0; }","expectedOutput":"hello","solution":"#include <iostream>\\nusing namespace std;\\nvoid toLower(char s[]) { for(int i=0; s[i]; i++) if(s[i]>='A' && s[i]<='Z') s[i] += 32; }\\nint main() { char s[] = \\"HELLO\\"; toLower(s); cout << s; return 0; }","explanation":{"approach":"Add 32 to uppercase letters.","analogy":"'A'(65) + 32 = 'a'(97)","steps":["Check if uppercase","Add 32"],"complexity":"Time: O(n), Space: O(1)"}}]`),_R=JSON.parse('[{"id":"easy26","title":"Matrix Sum","description":"Sum all matrix elements.","difficulty":"EASY","category":"Matrix","starterCode":"#include <iostream>\\nusing namespace std;\\nint matSum(int m[][3], int r, int c) { return 0; }\\nint main() { int m[][3] = {{1,2,3},{4,5,6},{7,8,9}}; cout << matSum(m,3,3); return 0; }","expectedOutput":"45","solution":"#include <iostream>\\nusing namespace std;\\nint matSum(int m[][3], int r, int c) { int s=0; for(int i=0;i<r;i++) for(int j=0;j<c;j++) s+=m[i][j]; return s; }\\nint main() { int m[][3] = {{1,2,3},{4,5,6},{7,8,9}}; cout << matSum(m,3,3); return 0; }","explanation":{"approach":"Loop through all elements and sum.","analogy":"Count all cells in a grid.","steps":["Loop rows and columns","Add each element"],"complexity":"Time: O(rc), Space: O(1)"}},{"id":"easy27","title":"Matrix Transpose","description":"Transpose a matrix.","difficulty":"EASY","category":"Matrix","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid transpose(int m[][3], int r, int c) {}\\nint main() { int m[][3]={{1,2,3},{4,5,6}}; transpose(m,2,3); return 0; }","expectedOutput":"1 4 2 5 3 6","solution":"#include <iostream>\\nusing namespace std;\\nvoid transpose(int m[][3], int r, int c) { for(int j=0;j<c;j++) { for(int i=0;i<r;i++) cout<<m[i][j]<<(i<r-1||j<c-1?\\" \\":\\"\\"); } }\\nint main() { int m[][3]={{1,2,3},{4,5,6}}; transpose(m,2,3); return 0; }","explanation":{"approach":"Swap rows and columns.","analogy":"Flip matrix diagonally.","steps":["Print m[j][i] instead of m[i][j]"],"complexity":"Time: O(rc), Space: O(1)"}},{"id":"easy28","title":"Diagonal Sum","description":"Sum of main diagonal.","difficulty":"EASY","category":"Matrix","starterCode":"#include <iostream>\\nusing namespace std;\\nint diagSum(int m[][3], int n) { return 0; }\\nint main() { int m[][3]={{1,2,3},{4,5,6},{7,8,9}}; cout<<diagSum(m,3); return 0; }","expectedOutput":"15","solution":"#include <iostream>\\nusing namespace std;\\nint diagSum(int m[][3], int n) { int s=0; for(int i=0;i<n;i++) s+=m[i][i]; return s; }\\nint main() { int m[][3]={{1,2,3},{4,5,6},{7,8,9}}; cout<<diagSum(m,3); return 0; }","explanation":{"approach":"Sum elements where row = column.","analogy":"Top-left to bottom-right diagonal.","steps":["Sum m[0][0], m[1][1], m[2][2]..."],"complexity":"Time: O(n), Space: O(1)"}},{"id":"easy29","title":"Row Sum","description":"Sum of each row.","difficulty":"EASY","category":"Matrix","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid rowSum(int m[][3], int r, int c) {}\\nint main() { int m[][3]={{1,2,3},{4,5,6}}; rowSum(m,2,3); return 0; }","expectedOutput":"6 15","solution":"#include <iostream>\\nusing namespace std;\\nvoid rowSum(int m[][3], int r, int c) { for(int i=0;i<r;i++) { int s=0; for(int j=0;j<c;j++) s+=m[i][j]; cout<<s<<(i<r-1?\\" \\":\\"\\"); } }\\nint main() { int m[][3]={{1,2,3},{4,5,6}}; rowSum(m,2,3); return 0; }","explanation":{"approach":"Sum each row separately.","analogy":"Total for each row of spreadsheet.","steps":["For each row, sum its columns"],"complexity":"Time: O(rc), Space: O(1)"}},{"id":"easy30","title":"Column Sum","description":"Sum of each column.","difficulty":"EASY","category":"Matrix","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid colSum(int m[][3], int r, int c) {}\\nint main() { int m[][3]={{1,2,3},{4,5,6}}; colSum(m,2,3); return 0; }","expectedOutput":"5 7 9","solution":"#include <iostream>\\nusing namespace std;\\nvoid colSum(int m[][3], int r, int c) { for(int j=0;j<c;j++) { int s=0; for(int i=0;i<r;i++) s+=m[i][j]; cout<<s<<(j<c-1?\\" \\":\\"\\"); } }\\nint main() { int m[][3]={{1,2,3},{4,5,6}}; colSum(m,2,3); return 0; }","explanation":{"approach":"Sum each column separately.","analogy":"Total for each column of spreadsheet.","steps":["For each column, sum its rows"],"complexity":"Time: O(rc), Space: O(1)"}},{"id":"easy31","title":"Second Largest","description":"Find second largest element.","difficulty":"EASY","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nint secondLargest(int a[], int n) { return 0; }\\nint main() { int a[]={12,35,1,10,34,1}; cout<<secondLargest(a,6); return 0; }","expectedOutput":"34","solution":"#include <iostream>\\nusing namespace std;\\nint secondLargest(int a[], int n) { int f=-1, s=-1; for(int i=0;i<n;i++) { if(a[i]>f) { s=f; f=a[i]; } else if(a[i]>s && a[i]!=f) s=a[i]; } return s; }\\nint main() { int a[]={12,35,1,10,34,1}; cout<<secondLargest(a,6); return 0; }","explanation":{"approach":"Track first and second largest.","analogy":"Silver medalist in competition.","steps":["Track largest","Track second if smaller than first"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"easy32","title":"Remove Duplicates","description":"Remove duplicates from sorted array.","difficulty":"EASY","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nint removeDups(int a[], int n) { return 0; }\\nint main() { int a[]={1,1,2,2,3,4,4,5}; int k=removeDups(a,8); for(int i=0;i<k;i++) cout<<a[i]<<(i<k-1?\\" \\":\\"\\"); return 0; }","expectedOutput":"1 2 3 4 5","solution":"#include <iostream>\\nusing namespace std;\\nint removeDups(int a[], int n) { if(n==0) return 0; int j=1; for(int i=1;i<n;i++) if(a[i]!=a[i-1]) a[j++]=a[i]; return j; }\\nint main() { int a[]={1,1,2,2,3,4,4,5}; int k=removeDups(a,8); for(int i=0;i<k;i++) cout<<a[i]<<(i<k-1?\\" \\":\\"\\"); return 0; }","explanation":{"approach":"Keep unique elements in-place.","analogy":"Skip repeats, keep first occurrence.","steps":["Compare consecutive","Keep if different"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"easy33","title":"Move Zeros to End","description":"Move all zeros to end.","difficulty":"EASY","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid moveZeros(int a[], int n) {}\\nint main() { int a[]={0,1,0,3,12}; moveZeros(a,5); for(int i=0;i<5;i++) cout<<a[i]<<(i<4?\\" \\":\\"\\"); return 0; }","expectedOutput":"1 3 12 0 0","solution":"#include <iostream>\\nusing namespace std;\\nvoid moveZeros(int a[], int n) { int j=0; for(int i=0;i<n;i++) if(a[i]!=0) a[j++]=a[i]; while(j<n) a[j++]=0; }\\nint main() { int a[]={0,1,0,3,12}; moveZeros(a,5); for(int i=0;i<5;i++) cout<<a[i]<<(i<4?\\" \\":\\"\\"); return 0; }","explanation":{"approach":"Copy non-zeros, fill rest with zeros.","analogy":"Slide non-zeros left, zeros fall to end.","steps":["Copy non-zero elements","Fill remaining with 0"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"easy34","title":"Rotate Array Left","description":"Rotate array left by k.","difficulty":"EASY","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid rotateLeft(int a[], int n, int k) {}\\nint main() { int a[]={1,2,3,4,5}; rotateLeft(a,5,2); for(int i=0;i<5;i++) cout<<a[i]<<(i<4?\\" \\":\\"\\"); return 0; }","expectedOutput":"3 4 5 1 2","solution":"#include <iostream>\\nusing namespace std;\\nvoid rev(int a[], int l, int r) { while(l<r) { int t=a[l]; a[l]=a[r]; a[r]=t; l++; r--; } }\\nvoid rotateLeft(int a[], int n, int k) { k%=n; rev(a,0,k-1); rev(a,k,n-1); rev(a,0,n-1); }\\nint main() { int a[]={1,2,3,4,5}; rotateLeft(a,5,2); for(int i=0;i<5;i++) cout<<a[i]<<(i<4?\\" \\":\\"\\"); return 0; }","explanation":{"approach":"Reverse first k, reverse rest, reverse all.","analogy":"Rotate words in sentence.","steps":["Reverse [0,k)","Reverse [k,n)","Reverse all"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"easy35","title":"Rotate Array Right","description":"Rotate array right by k.","difficulty":"EASY","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid rotateRight(int a[], int n, int k) {}\\nint main() { int a[]={1,2,3,4,5}; rotateRight(a,5,2); for(int i=0;i<5;i++) cout<<a[i]<<(i<4?\\" \\":\\"\\"); return 0; }","expectedOutput":"4 5 1 2 3","solution":"#include <iostream>\\nusing namespace std;\\nvoid rev(int a[], int l, int r) { while(l<r) { int t=a[l]; a[l]=a[r]; a[r]=t; l++; r--; } }\\nvoid rotateRight(int a[], int n, int k) { k%=n; rev(a,0,n-1); rev(a,0,k-1); rev(a,k,n-1); }\\nint main() { int a[]={1,2,3,4,5}; rotateRight(a,5,2); for(int i=0;i<5;i++) cout<<a[i]<<(i<4?\\" \\":\\"\\"); return 0; }","explanation":{"approach":"Reverse all, reverse first k, reverse rest.","analogy":"Opposite of left rotation.","steps":["Reverse entire array","Reverse [0,k)","Reverse [k,n)"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"easy36","title":"Check Sorted","description":"Is array sorted.","difficulty":"EASY","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isSorted(int a[], int n) { return false; }\\nint main() { int a[]={1,2,3,4,5}; cout<<isSorted(a,5); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isSorted(int a[], int n) { for(int i=1;i<n;i++) if(a[i]<a[i-1]) return false; return true; }\\nint main() { int a[]={1,2,3,4,5}; cout<<isSorted(a,5); return 0; }","explanation":{"approach":"Check if each element >= previous.","analogy":"Are stairs going only up?","steps":["Compare consecutive pairs","Return false if decreasing"],"complexity":"Time: O(n), Space: O(1)"}}]'),TR=JSON.parse('[{"id":"easy37","title":"Merge Two Arrays","description":"Merge sorted arrays.","difficulty":"EASY","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid merge(int a[], int m, int b[], int n, int c[]) {}\\nint main() { int a[]={1,3,5}, b[]={2,4,6}, c[6]; merge(a,3,b,3,c); for(int i=0;i<6;i++) cout<<c[i]<<\\" \\"; return 0; }","expectedOutput":"1 2 3 4 5 6","solution":"#include <iostream>\\nusing namespace std;\\nvoid merge(int a[], int m, int b[], int n, int c[]) { int i=0,j=0,k=0; while(i<m && j<n) c[k++]=a[i]<b[j]?a[i++]:b[j++]; while(i<m) c[k++]=a[i++]; while(j<n) c[k++]=b[j++]; }\\nint main() { int a[]={1,3,5}, b[]={2,4,6}, c[6]; merge(a,3,b,3,c); for(int i=0;i<6;i++) cout<<c[i]<<\\" \\"; return 0; }","explanation":{"approach":"Two pointers, pick smaller.","analogy":"Merge sorted decks of cards.","steps":["Compare fronts","Pick smaller","Handle remainder"],"complexity":"Time: O(m+n), Space: O(m+n)"}},{"id":"easy38","title":"Find Intersection","description":"Common elements.","difficulty":"EASY","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid intersection(int a[], int m, int b[], int n) {}\\nint main() { int a[]={1,2,3,4,5}, b[]={3,4,5,6,7}; intersection(a,5,b,5); return 0; }","expectedOutput":"3 4 5","solution":"#include <iostream>\\nusing namespace std;\\nvoid intersection(int a[], int m, int b[], int n) { for(int i=0;i<m;i++) for(int j=0;j<n;j++) if(a[i]==b[j]) { cout<<a[i]<<\\" \\"; break; } }\\nint main() { int a[]={1,2,3,4,5}, b[]={3,4,5,6,7}; intersection(a,5,b,5); return 0; }","explanation":{"approach":"Check each element in both.","analogy":"Find matching items.","steps":["For each in a, search in b","Print if found"],"complexity":"Time: O(mn), Space: O(1)"}},{"id":"easy39","title":"Find Union","description":"All unique elements.","difficulty":"EASY","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid unionArr(int a[], int m, int b[], int n) {}\\nint main() { int a[]={1,2,3}, b[]={3,4,5}; unionArr(a,3,b,3); return 0; }","expectedOutput":"1 2 3 4 5","solution":"#include <iostream>\\nusing namespace std;\\nvoid unionArr(int a[], int m, int b[], int n) { for(int i=0;i<m;i++) cout<<a[i]<<\\" \\"; for(int i=0;i<n;i++) { bool found=false; for(int j=0;j<m;j++) if(b[i]==a[j]) { found=true; break; } if(!found) cout<<b[i]<<\\" \\"; } }\\nint main() { int a[]={1,2,3}, b[]={3,4,5}; unionArr(a,3,b,3); return 0; }","explanation":{"approach":"Print a, then b elements not in a.","analogy":"Combine without duplicates.","steps":["Print all of a","Print b if not in a"],"complexity":"Time: O(mn), Space: O(1)"}},{"id":"easy40","title":"Frequency Count","description":"Count each element.","difficulty":"EASY","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid frequency(int a[], int n) {}\\nint main() { int a[]={1,2,2,3,3,3,4,4,4,4}; frequency(a,10); return 0; }","expectedOutput":"1:1 2:2 3:3 4:4","solution":"#include <iostream>\\nusing namespace std;\\nvoid frequency(int a[], int n) { int vis[n]={}; for(int i=0;i<n;i++) { if(vis[i]) continue; int c=1; for(int j=i+1;j<n;j++) if(a[i]==a[j]) { c++; vis[j]=1; } cout<<a[i]<<\\":\\"<<c<<\\" \\"; } }\\nint main() { int a[]={1,2,2,3,3,3,4,4,4,4}; frequency(a,10); return 0; }","explanation":{"approach":"Count occurrences of each.","analogy":"Tally each unique element.","steps":["Mark visited","Count matches","Print count"],"complexity":"Time: O(n), Space: O(n)"}},{"id":"easy41","title":"Left Rotate Once","description":"Rotate left by 1.","difficulty":"EASY","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid rotateLeft(int a[], int n) {}\\nint main() { int a[]={1,2,3,4,5}; rotateLeft(a,5); for(int i=0;i<5;i++) cout<<a[i]<<\\" \\"; return 0; }","expectedOutput":"2 3 4 5 1","solution":"#include <iostream>\\nusing namespace std;\\nvoid rotateLeft(int a[], int n) { int t=a[0]; for(int i=0;i<n-1;i++) a[i]=a[i+1]; a[n-1]=t; }\\nint main() { int a[]={1,2,3,4,5}; rotateLeft(a,5); for(int i=0;i<5;i++) cout<<a[i]<<\\" \\"; return 0; }","explanation":{"approach":"Save first, shift left, put at end.","analogy":"Move everyone one seat left.","steps":["Save first element","Shift all left","Put saved at end"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"easy42","title":"Right Rotate Once","description":"Rotate right by 1.","difficulty":"EASY","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid rotateRight(int a[], int n) {}\\nint main() { int a[]={1,2,3,4,5}; rotateRight(a,5); for(int i=0;i<5;i++) cout<<a[i]<<\\" \\"; return 0; }","expectedOutput":"5 1 2 3 4","solution":"#include <iostream>\\nusing namespace std;\\nvoid rotateRight(int a[], int n) { int t=a[n-1]; for(int i=n-1;i>0;i--) a[i]=a[i-1]; a[0]=t; }\\nint main() { int a[]={1,2,3,4,5}; rotateRight(a,5); for(int i=0;i<5;i++) cout<<a[i]<<\\" \\"; return 0; }","explanation":{"approach":"Save last, shift right, put at start.","analogy":"Move everyone one seat right.","steps":["Save last element","Shift all right","Put saved at start"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"easy43","title":"Peak Element","description":"Find local maximum.","difficulty":"EASY","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nint findPeak(int a[], int n) { return 0; }\\nint main() { int a[]={1,3,20,4,1,0}; cout<<findPeak(a,6); return 0; }","expectedOutput":"20","solution":"#include <iostream>\\nusing namespace std;\\nint findPeak(int a[], int n) { for(int i=0;i<n;i++) { bool left = i==0 || a[i]>=a[i-1]; bool right = i==n-1 || a[i]>=a[i+1]; if(left && right) return a[i]; } return -1; }\\nint main() { int a[]={1,3,20,4,1,0}; cout<<findPeak(a,6); return 0; }","explanation":{"approach":"Find element >= both neighbors.","analogy":"Mountain top.","steps":["Check if >= left and >= right","Return first peak"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"easy44","title":"Find Minimum","description":"Minimum element.","difficulty":"EASY","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nint findMin(int a[], int n) { return 0; }\\nint main() { int a[]={3,1,4,1,5,9,2}; cout<<findMin(a,7); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nint findMin(int a[], int n) { int mn=a[0]; for(int i=1;i<n;i++) if(a[i]<mn) mn=a[i]; return mn; }\\nint main() { int a[]={3,1,4,1,5,9,2}; cout<<findMin(a,7); return 0; }","explanation":{"approach":"Track minimum while scanning.","analogy":"Find smallest number.","steps":["Assume first is min","Update if smaller found"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"easy45","title":"Sum of Digits","description":"Sum all digits.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nint sumDigits(int n) { return 0; }\\nint main() { cout<<sumDigits(12345); return 0; }","expectedOutput":"15","solution":"#include <iostream>\\nusing namespace std;\\nint sumDigits(int n) { int s=0; while(n>0) { s+=n%10; n/=10; } return s; }\\nint main() { cout<<sumDigits(12345); return 0; }","explanation":{"approach":"Extract and sum each digit.","analogy":"Add up all digit values.","steps":["Get last digit with %10","Add to sum","Remove digit with /10"],"complexity":"Time: O(log n), Space: O(1)"}},{"id":"easy46","title":"Count Digits","description":"Number of digits.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nint countDigits(int n) { return 0; }\\nint main() { cout<<countDigits(12345); return 0; }","expectedOutput":"5","solution":"#include <iostream>\\nusing namespace std;\\nint countDigits(int n) { int c=0; while(n>0) { c++; n/=10; } return c; }\\nint main() { cout<<countDigits(12345); return 0; }","explanation":{"approach":"Count divisions by 10.","analogy":"How many times can we divide by 10?","steps":["Divide by 10","Count iterations"],"complexity":"Time: O(log n), Space: O(1)"}},{"id":"easy47","title":"Reverse Number","description":"Reverse digit order.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nint reverse(int n) { return 0; }\\nint main() { cout<<reverse(12345); return 0; }","expectedOutput":"54321","solution":"#include <iostream>\\nusing namespace std;\\nint reverse(int n) { int r=0; while(n>0) { r=r*10+n%10; n/=10; } return r; }\\nint main() { cout<<reverse(12345); return 0; }","explanation":{"approach":"Build reversed number digit by digit.","analogy":"Read number backwards.","steps":["Get last digit","Add to result  10","Remove digit"],"complexity":"Time: O(log n), Space: O(1)"}},{"id":"easy48","title":"Is Palindrome Number","description":"Number reads same forwards and backwards.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isPalindrome(int n) { return false; }\\nint main() { cout<<isPalindrome(12321); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isPalindrome(int n) { int orig=n, r=0; while(n>0) { r=r*10+n%10; n/=10; } return r==orig; }\\nint main() { cout<<isPalindrome(12321); return 0; }","explanation":{"approach":"Reverse and compare.","analogy":"Does it read the same backward?","steps":["Reverse the number","Compare with original"],"complexity":"Time: O(log n), Space: O(1)"}}]'),kR=JSON.parse(`[{"id":"easy49","title":"Power of Number","description":"Calculate x^n.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nint power(int x, int n) { return 0; }\\nint main() { cout<<power(2,10); return 0; }","expectedOutput":"1024","solution":"#include <iostream>\\nusing namespace std;\\nint power(int x, int n) { int r=1; while(n>0) { if(n%2) r*=x; x*=x; n/=2; } return r; }\\nint main() { cout<<power(2,10); return 0; }","explanation":{"approach":"Fast exponentiation by squaring.","analogy":"Double the exponent, halve the work.","steps":["If odd, multiply result","Square base, halve exponent"],"complexity":"Time: O(log n), Space: O(1)"}},{"id":"easy50","title":"Check Perfect Square","description":"Is n a perfect square.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isPerfectSquare(int n) { return false; }\\nint main() { cout<<isPerfectSquare(16); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isPerfectSquare(int n) { int r=0; while(r*r<n) r++; return r*r==n; }\\nint main() { cout<<isPerfectSquare(16); return 0; }","explanation":{"approach":"Find root, check if r = n.","analogy":"Is there an integer whose square equals n?","steps":["Find sqrt","Check if exact"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"easy51","title":"Leap Year Check","description":"Is year a leap year.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isLeapYear(int y) { return false; }\\nint main() { cout<<isLeapYear(2024); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isLeapYear(int y) { return (y%4==0 && y%100!=0) || y%400==0; }\\nint main() { cout<<isLeapYear(2024); return 0; }","explanation":{"approach":"Divisible by 4 but not 100, or by 400.","analogy":"Calendar leap year rules.","steps":["Check divisibility rules"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"easy52","title":"Days in Month","description":"Number of days in month.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nint daysInMonth(int m, int y) { return 0; }\\nint main() { cout<<daysInMonth(2,2024); return 0; }","expectedOutput":"29","solution":"#include <iostream>\\nusing namespace std;\\nint daysInMonth(int m, int y) { int d[]={31,28,31,30,31,30,31,31,30,31,30,31}; if(m==2 && ((y%4==0 && y%100!=0) || y%400==0)) return 29; return d[m-1]; }\\nint main() { cout<<daysInMonth(2,2024); return 0; }","explanation":{"approach":"Lookup table with leap year check.","analogy":"30 days hath September...","steps":["Use days array","Handle Feb leap year"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"easy53","title":"Sum of N Natural","description":"Sum 1 to n.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nint sumN(int n) { return 0; }\\nint main() { cout<<sumN(10); return 0; }","expectedOutput":"55","solution":"#include <iostream>\\nusing namespace std;\\nint sumN(int n) { return n*(n+1)/2; }\\nint main() { cout<<sumN(10); return 0; }","explanation":{"approach":"Gauss formula n(n+1)/2.","analogy":"Pair up: 1+10=11, 2+9=11, etc.","steps":["Use formula n(n+1)/2"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"easy54","title":"Sum of Squares","description":"Sum 1 to n.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nint sumSquares(int n) { return 0; }\\nint main() { cout<<sumSquares(5); return 0; }","expectedOutput":"55","solution":"#include <iostream>\\nusing namespace std;\\nint sumSquares(int n) { return n*(n+1)*(2*n+1)/6; }\\nint main() { cout<<sumSquares(5); return 0; }","explanation":{"approach":"Formula n(n+1)(2n+1)/6.","analogy":"Sum of pyramid blocks.","steps":["Use formula"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"easy55","title":"Sum of Cubes","description":"Sum 1 to n.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nint sumCubes(int n) { return 0; }\\nint main() { cout<<sumCubes(5); return 0; }","expectedOutput":"225","solution":"#include <iostream>\\nusing namespace std;\\nint sumCubes(int n) { int s=n*(n+1)/2; return s*s; }\\nint main() { cout<<sumCubes(5); return 0; }","explanation":{"approach":"Formula: (n(n+1)/2).","analogy":"Sum of cubes = square of sum.","steps":["Calculate sum of n","Square it"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"easy56","title":"Even or Odd String","description":"Check if count of chars is even.","difficulty":"EASY","category":"Strings","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid evenOdd(char s[]) {}\\nint main() { evenOdd(\\"hello\\"); return 0; }","expectedOutput":"Odd","solution":"#include <iostream>\\nusing namespace std;\\nvoid evenOdd(char s[]) { int len=0; while(s[len]) len++; cout<<(len%2==0?\\"Even\\":\\"Odd\\"); }\\nint main() { evenOdd(\\"hello\\"); return 0; }","explanation":{"approach":"Count length, check parity.","analogy":"Is string length even or odd?","steps":["Count characters","Check if even or odd"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"easy57","title":"Toggle Case","description":"Toggle each character case.","difficulty":"EASY","category":"Strings","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid toggleCase(char s[]) {}\\nint main() { char s[]=\\"Hello World\\"; toggleCase(s); cout<<s; return 0; }","expectedOutput":"hELLO wORLD","solution":"#include <iostream>\\nusing namespace std;\\nvoid toggleCase(char s[]) { for(int i=0;s[i];i++) { if(s[i]>='A'&&s[i]<='Z') s[i]+=32; else if(s[i]>='a'&&s[i]<='z') s[i]-=32; } }\\nint main() { char s[]=\\"Hello World\\"; toggleCase(s); cout<<s; return 0; }","explanation":{"approach":"Flip case of each letter.","analogy":"Uppercase becomes lower and vice versa.","steps":["If uppercase, add 32","If lowercase, subtract 32"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"easy58","title":"Remove Spaces","description":"Remove all spaces.","difficulty":"EASY","category":"Strings","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid removeSpaces(char s[]) {}\\nint main() { char s[]=\\"hello world test\\"; removeSpaces(s); cout<<s; return 0; }","expectedOutput":"helloworldtest","solution":"#include <iostream>\\nusing namespace std;\\nvoid removeSpaces(char s[]) { int j=0; for(int i=0;s[i];i++) if(s[i]!=' ') s[j++]=s[i]; s[j]=0; }\\nint main() { char s[]=\\"hello world test\\"; removeSpaces(s); cout<<s; return 0; }","explanation":{"approach":"Copy non-space chars.","analogy":"Filter out spaces.","steps":["Copy if not space"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"easy59","title":"First Uppercase","description":"Find first uppercase letter.","difficulty":"EASY","category":"Strings","starterCode":"#include <iostream>\\nusing namespace std;\\nchar firstUpper(char s[]) { return 0; }\\nint main() { cout<<firstUpper(\\"helloWorld\\"); return 0; }","expectedOutput":"W","solution":"#include <iostream>\\nusing namespace std;\\nchar firstUpper(char s[]) { for(int i=0;s[i];i++) if(s[i]>='A'&&s[i]<='Z') return s[i]; return 0; }\\nint main() { cout<<firstUpper(\\"helloWorld\\"); return 0; }","explanation":{"approach":"Scan for uppercase.","analogy":"Find first capital letter.","steps":["Check each char if A-Z"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"easy60","title":"Count Consonants","description":"Count consonants in string.","difficulty":"EASY","category":"Strings","starterCode":"#include <iostream>\\nusing namespace std;\\nint countConsonants(char s[]) { return 0; }\\nint main() { cout<<countConsonants(\\"hello world\\"); return 0; }","expectedOutput":"7","solution":"#include <iostream>\\nusing namespace std;\\nbool isVowel(char c) { c=tolower(c); return c=='a'||c=='e'||c=='i'||c=='o'||c=='u'; }\\nint countConsonants(char s[]) { int c=0; for(int i=0;s[i];i++) if(isalpha(s[i]) && !isVowel(s[i])) c++; return c; }\\nint main() { cout<<countConsonants(\\"hello world\\"); return 0; }","explanation":{"approach":"Count letters that aren't vowels.","analogy":"Count non-vowel letters.","steps":["Check if letter and not vowel"],"complexity":"Time: O(n), Space: O(1)"}}]`),NR=JSON.parse(`[{"id":"e251","title":"Find Pivot Index","description":"Index where left sum equals right sum.","difficulty":"EASY","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nint pivotIndex(int nums[], int n) { return -1; }\\nint main() { int a[]={1,7,3,6,5,6}; cout<<pivotIndex(a,6); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nint pivotIndex(int nums[], int n) { int total=0,left=0; for(int i=0;i<n;i++) total+=nums[i]; for(int i=0;i<n;i++) { if(left==total-left-nums[i]) return i; left+=nums[i]; } return -1; }\\nint main() { int a[]={1,7,3,6,5,6}; cout<<pivotIndex(a,6); return 0; }","explanation":{"approach":"Track left sum.","steps":["Compute total sum","Check if left == right at each index"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"e252","title":"Largest Number At Least Twice","description":"Index of largest if >= 2x others.","difficulty":"EASY","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nint dominantIndex(int nums[], int n) { return -1; }\\nint main() { int a[]={3,6,1,0}; cout<<dominantIndex(a,4); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nint dominantIndex(int nums[], int n) { int mx=0; for(int i=1;i<n;i++) if(nums[i]>nums[mx]) mx=i; for(int i=0;i<n;i++) if(i!=mx && nums[mx]<2*nums[i]) return -1; return mx; }\\nint main() { int a[]={3,6,1,0}; cout<<dominantIndex(a,4); return 0; }","explanation":{"approach":"Find max, check condition.","steps":["Find largest element","Check if >= 2x all others"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"e253","title":"Plus One","description":"Add one to number as array.","difficulty":"EASY","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid plusOne(int digits[], int n) {}\\nint main() { int d[]={1,2,3}; plusOne(d,3); return 0; }","expectedOutput":"1 2 4","solution":"#include <iostream>\\nusing namespace std;\\nvoid plusOne(int digits[], int n) { for(int i=n-1;i>=0;i--) { if(digits[i]<9) { digits[i]++; for(int j=0;j<n;j++) cout<<digits[j]<<\\" \\"; return; } digits[i]=0; } cout<<1<<\\" \\"; for(int i=0;i<n;i++) cout<<0<<\\" \\"; }\\nint main() { int d[]={1,2,3}; plusOne(d,3); return 0; }","explanation":{"approach":"Add with carry.","steps":["Increment last digit","Handle carry if 9"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"e254","title":"Diagonal Traverse","description":"Traverse matrix diagonally.","difficulty":"MEDIUM","category":"Matrix","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid findDiagonalOrder(int m[][3], int r, int c) {}\\nint main() { int m[][3]={{1,2,3},{4,5,6},{7,8,9}}; findDiagonalOrder(m,3,3); return 0; }","expectedOutput":"1 2 4 7 5 3 6 8 9","solution":"#include <iostream>\\nusing namespace std;\\nvoid findDiagonalOrder(int m[][3], int r, int c) { int row=0,col=0,d=1; for(int i=0;i<r*c;i++) { cout<<m[row][col]<<\\" \\"; row-=d; col+=d; if(row>=r) { row=r-1; col+=2; d=-d; } if(col>=c) { col=c-1; row+=2; d=-d; } if(row<0) { row=0; d=-d; } if(col<0) { col=0; d=-d; } } }\\nint main() { int m[][3]={{1,2,3},{4,5,6},{7,8,9}}; findDiagonalOrder(m,3,3); return 0; }","explanation":{"approach":"Track direction, handle bounds.","steps":["Move diagonally","Change direction at boundaries"],"complexity":"Time: O(mn), Space: O(1)"}},{"id":"e255","title":"Spiral Matrix II","description":"Generate spiral matrix.","difficulty":"MEDIUM","category":"Matrix","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid generateMatrix(int n) {}\\nint main() { generateMatrix(3); return 0; }","expectedOutput":"1 2 3 8 9 4 7 6 5","solution":"#include <iostream>\\nusing namespace std;\\nvoid generateMatrix(int n) { int m[10][10]={}; int t=0,b=n-1,l=0,r=n-1,v=1; while(t<=b&&l<=r) { for(int i=l;i<=r;i++) m[t][i]=v++; t++; for(int i=t;i<=b;i++) m[i][r]=v++; r--; for(int i=r;i>=l;i--) m[b][i]=v++; b--; for(int i=b;i>=t;i--) m[i][l]=v++; l++; } for(int i=0;i<n;i++) for(int j=0;j<n;j++) cout<<m[i][j]<<\\" \\"; }\\nint main() { generateMatrix(3); return 0; }","explanation":{"approach":"Fill layer by layer.","steps":["Fill top, right, bottom, left","Move inward"],"complexity":"Time: O(n), Space: O(n)"}},{"id":"e256","title":"Pascal's Triangle","description":"Generate Pascal's triangle.","difficulty":"EASY","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid generate(int n) {}\\nint main() { generate(5); return 0; }","expectedOutput":"1 1 1 1 2 1 1 3 3 1 1 4 6 4 1","solution":"#include <iostream>\\nusing namespace std;\\nvoid generate(int n) { int t[10][10]; for(int i=0;i<n;i++) { t[i][0]=t[i][i]=1; for(int j=1;j<i;j++) t[i][j]=t[i-1][j-1]+t[i-1][j]; for(int j=0;j<=i;j++) cout<<t[i][j]<<\\" \\"; } }\\nint main() { generate(5); return 0; }","explanation":{"approach":"Build row by row.","steps":["First and last are 1","Middle = sum of two above"],"complexity":"Time: O(n), Space: O(n)"}},{"id":"e257","title":"Pascal's Triangle II","description":"Get kth row.","difficulty":"EASY","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid getRow(int k) {}\\nint main() { getRow(3); return 0; }","expectedOutput":"1 3 3 1","solution":"#include <iostream>\\nusing namespace std;\\nvoid getRow(int k) { int row[k+1]; row[0]=1; for(int i=1;i<=k;i++) { row[i]=1; for(int j=i-1;j>0;j--) row[j]+=row[j-1]; } for(int i=0;i<=k;i++) cout<<row[i]<<\\" \\"; }\\nint main() { getRow(3); return 0; }","explanation":{"approach":"Update row in place.","steps":["Start from end to preserve values","Each value = sum of two above"],"complexity":"Time: O(k), Space: O(k)"}},{"id":"e258","title":"Missing Ranges","description":"Find missing number ranges.","difficulty":"EASY","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid findMissingRanges(int nums[], int n, int lo, int hi) {}\\nint main() { int a[]={0,1,3,50,75}; findMissingRanges(a,5,0,99); return 0; }","expectedOutput":"2 4-49 51-74 76-99","solution":"#include <iostream>\\nusing namespace std;\\nvoid findMissingRanges(int nums[], int n, int lo, int hi) { int prev=lo-1; for(int i=0;i<=n;i++) { int cur=i<n?nums[i]:hi+1; if(cur-prev>=2) { if(cur-prev==2) cout<<prev+1<<\\" \\"; else cout<<prev+1<<\\"-\\"<<cur-1<<\\" \\"; } prev=cur; } }\\nint main() { int a[]={0,1,3,50,75}; findMissingRanges(a,5,0,99); return 0; }","explanation":{"approach":"Track gaps.","steps":["Check gap between consecutive","Format as single or range"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"e259","title":"Reverse String Vowels","description":"Reverse only vowels.","difficulty":"EASY","category":"Strings","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid reverseVowels(char s[]) {}\\nint main() { char s[]=\\"hello\\"; reverseVowels(s); cout<<s; return 0; }","expectedOutput":"holle","solution":"#include <iostream>\\nusing namespace std;\\nbool isVowel(char c) { return c=='a'||c=='e'||c=='i'||c=='o'||c=='u'||c=='A'||c=='E'||c=='I'||c=='O'||c=='U'; }\\nvoid reverseVowels(char s[]) { int n=0; while(s[n]) n++; int l=0,r=n-1; while(l<r) { while(l<r&&!isVowel(s[l])) l++; while(l<r&&!isVowel(s[r])) r--; swap(s[l++],s[r--]); } }\\nint main() { char s[]=\\"hello\\"; reverseVowels(s); cout<<s; return 0; }","explanation":{"approach":"Two pointers on vowels.","steps":["Find vowels from both ends","Swap them"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"e260","title":"Ransom Note","description":"Can construct from magazine.","difficulty":"EASY","category":"Strings","starterCode":"#include <iostream>\\nusing namespace std;\\nbool canConstruct(char r[], char m[]) { return false; }\\nint main() { cout<<canConstruct(\\"aa\\",\\"aab\\"); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool canConstruct(char r[], char m[]) { int cnt[26]={}; for(int i=0;m[i];i++) cnt[m[i]-'a']++; for(int i=0;r[i];i++) if(--cnt[r[i]-'a']<0) return false; return true; }\\nint main() { cout<<canConstruct(\\"aa\\",\\"aab\\"); return 0; }","explanation":{"approach":"Count magazine chars.","steps":["Count all magazine letters","Decrement for ransom, fail if negative"],"complexity":"Time: O(m+n), Space: O(26)"}}]`),ER=[{id:"e301",title:"Count Primes",description:"Count primes less than n.",difficulty:"MEDIUM",category:"Math",starterCode:`#include <iostream>
using namespace std;
int countPrimes(int n) { return 0; }
int main() { cout<<countPrimes(10); return 0; }`,expectedOutput:"4",solution:`#include <iostream>
using namespace std;
int countPrimes(int n) { if(n<=2) return 0; bool np[n]={}; int cnt=0; for(int i=2;i<n;i++) { if(!np[i]) { cnt++; for(int j=i*2;j<n;j+=i) np[j]=true; } } return cnt; }
int main() { cout<<countPrimes(10); return 0; }`,explanation:{approach:"Sieve of Eratosthenes.",steps:["Mark multiples as not prime","Count unmarked"],complexity:"Time: O(n log log n), Space: O(n)"}},{id:"e302",title:"Power of Three",description:"Check if power of 3.",difficulty:"EASY",category:"Math",starterCode:`#include <iostream>
using namespace std;
bool isPowerOfThree(int n) { return false; }
int main() { cout<<isPowerOfThree(27); return 0; }`,expectedOutput:"1",solution:`#include <iostream>
using namespace std;
bool isPowerOfThree(int n) { if(n<=0) return false; while(n%3==0) n/=3; return n==1; }
int main() { cout<<isPowerOfThree(27); return 0; }`,explanation:{approach:"Divide repeatedly.",steps:["While divisible by 3, divide","Check if result is 1"],complexity:"Time: O(log n), Space: O(1)"}},{id:"e303",title:"Power of Four",description:"Check if power of 4.",difficulty:"EASY",category:"Math",starterCode:`#include <iostream>
using namespace std;
bool isPowerOfFour(int n) { return false; }
int main() { cout<<isPowerOfFour(16); return 0; }`,expectedOutput:"1",solution:`#include <iostream>
using namespace std;
bool isPowerOfFour(int n) { return n>0 && (n&(n-1))==0 && (n&0x55555555)!=0; }
int main() { cout<<isPowerOfFour(16); return 0; }`,explanation:{approach:"Bit manipulation.",steps:["Must be power of 2","1 bit must be in odd position"],complexity:"Time: O(1), Space: O(1)"}},{id:"e304",title:"Add Digits",description:"Add digits until single.",difficulty:"EASY",category:"Math",starterCode:`#include <iostream>
using namespace std;
int addDigits(int num) { return 0; }
int main() { cout<<addDigits(38); return 0; }`,expectedOutput:"2",solution:`#include <iostream>
using namespace std;
int addDigits(int num) { if(num==0) return 0; if(num%9==0) return 9; return num%9; }
int main() { cout<<addDigits(38); return 0; }`,explanation:{approach:"Digital root formula.",steps:["Result is num % 9","Special case for 0 and multiples of 9"],complexity:"Time: O(1), Space: O(1)"}},{id:"e305",title:"Ugly Number",description:"Check if ugly (2,3,5 factors only).",difficulty:"EASY",category:"Math",starterCode:`#include <iostream>
using namespace std;
bool isUgly(int n) { return false; }
int main() { cout<<isUgly(6); return 0; }`,expectedOutput:"1",solution:`#include <iostream>
using namespace std;
bool isUgly(int n) { if(n<=0) return false; while(n%2==0) n/=2; while(n%3==0) n/=3; while(n%5==0) n/=5; return n==1; }
int main() { cout<<isUgly(6); return 0; }`,explanation:{approach:"Divide by 2,3,5.",steps:["Remove all 2s, 3s, 5s","Check if result is 1"],complexity:"Time: O(log n), Space: O(1)"}},{id:"e306",title:"Happy Number",description:"Check if reaches 1.",difficulty:"EASY",category:"Math",starterCode:`#include <iostream>
using namespace std;
bool isHappy(int n) { return false; }
int main() { cout<<isHappy(19); return 0; }`,expectedOutput:"1",solution:`#include <iostream>
using namespace std;
int sumSquares(int n) { int s=0; while(n) { int d=n%10; s+=d*d; n/=10; } return s; }
bool isHappy(int n) { int slow=n,fast=n; do { slow=sumSquares(slow); fast=sumSquares(sumSquares(fast)); } while(slow!=fast); return slow==1; }
int main() { cout<<isHappy(19); return 0; }`,explanation:{approach:"Floyd's cycle detection.",steps:["Sum squares of digits","Detect cycle or reach 1"],complexity:"Time: O(log n), Space: O(1)"}},{id:"e307",title:"Excel Sheet Column",description:"Column title to number.",difficulty:"EASY",category:"Math",starterCode:`#include <iostream>
using namespace std;
int titleToNumber(char s[]) { return 0; }
int main() { cout<<titleToNumber("AB"); return 0; }`,expectedOutput:"28",solution:`#include <iostream>
using namespace std;
int titleToNumber(char s[]) { int r=0; for(int i=0;s[i];i++) r=r*26+(s[i]-'A'+1); return r; }
int main() { cout<<titleToNumber("AB"); return 0; }`,explanation:{approach:"Base 26 conversion.",steps:["Process each character","Multiply by 26 and add value"],complexity:"Time: O(n), Space: O(1)"}},{id:"e308",title:"Excel Column Title",description:"Number to column title.",difficulty:"EASY",category:"Math",starterCode:`#include <iostream>
using namespace std;
void convertToTitle(int n) {}
int main() { convertToTitle(28); return 0; }`,expectedOutput:"AB",solution:`#include <iostream>
using namespace std;
void convertToTitle(int n) { char res[10]; int i=0; while(n>0) { n--; res[i++]='A'+n%26; n/=26; } for(int j=i-1;j>=0;j--) cout<<res[j]; }
int main() { convertToTitle(28); return 0; }`,explanation:{approach:"Base 26 conversion.",steps:["Extract remainder","Build string in reverse"],complexity:"Time: O(log n), Space: O(log n)"}},{id:"e309",title:"Factorial Trailing Zeroes",description:"Count trailing zeros in n!.",difficulty:"MEDIUM",category:"Math",starterCode:`#include <iostream>
using namespace std;
int trailingZeroes(int n) { return 0; }
int main() { cout<<trailingZeroes(25); return 0; }`,expectedOutput:"6",solution:`#include <iostream>
using namespace std;
int trailingZeroes(int n) { int cnt=0; while(n>=5) { n/=5; cnt+=n; } return cnt; }
int main() { cout<<trailingZeroes(25); return 0; }`,explanation:{approach:"Count factors of 5.",steps:["Each 5 contributes to a 0","Count n/5 + n/25 + ..."],complexity:"Time: O(log n), Space: O(1)"}},{id:"e310",title:"Sqrt(x)",description:"Integer square root.",difficulty:"EASY",category:"Math",starterCode:`#include <iostream>
using namespace std;
int mySqrt(int x) { return 0; }
int main() { cout<<mySqrt(8); return 0; }`,expectedOutput:"2",solution:`#include <iostream>
using namespace std;
int mySqrt(int x) { if(x==0) return 0; long l=1,r=x; while(l<=r) { long m=(l+r)/2; if(m*m==x) return m; if(m*m<x) l=m+1; else r=m-1; } return r; }
int main() { cout<<mySqrt(8); return 0; }`,explanation:{approach:"Binary search.",steps:["Search for largest m where mx"],complexity:"Time: O(log x), Space: O(1)"}}],jR=JSON.parse(`[{"id":"easy85","title":"Hollow Diamond","description":"Print hollow diamond.","difficulty":"EASY","category":"Patterns","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid hollowDiamond(int n) {}\\nint main() { hollowDiamond(3); return 0; }","expectedOutput":"  *\\n * *\\n*   *\\n * *\\n  *","solution":"#include <iostream>\\nusing namespace std;\\nvoid hollowDiamond(int n) { for(int i=1;i<=n;i++) { for(int j=0;j<n-i;j++) cout<<\\" \\"; cout<<\\"*\\"; if(i>1) { for(int j=0;j<2*i-3;j++) cout<<\\" \\"; cout<<\\"*\\"; } cout<<\\"\\\\n\\"; } for(int i=n-1;i>=1;i--) { for(int j=0;j<n-i;j++) cout<<\\" \\"; cout<<\\"*\\"; if(i>1) { for(int j=0;j<2*i-3;j++) cout<<\\" \\"; cout<<\\"*\\"; } if(i>1) cout<<\\"\\\\n\\"; } }\\nint main() { hollowDiamond(3); return 0; }","explanation":{"approach":"Only edges of diamond.","analogy":"Outline of diamond.","steps":["First and last star of each row"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"easy86","title":"Alphabet Pattern","description":"Print A to Z pattern.","difficulty":"EASY","category":"Patterns","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid alphabetPattern(int n) {}\\nint main() { alphabetPattern(4); return 0; }","expectedOutput":"A\\nA B\\nA B C\\nA B C D","solution":"#include <iostream>\\nusing namespace std;\\nvoid alphabetPattern(int n) { for(int i=0;i<n;i++) { for(int j=0;j<=i;j++) cout<<(char)('A'+j)<<\\" \\"; if(i<n-1) cout<<\\"\\\\n\\"; } }\\nint main() { alphabetPattern(4); return 0; }","explanation":{"approach":"Letters increasing per row.","analogy":"A to alphabet.","steps":["Row i prints A to (A+i)"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"easy87","title":"Butterfly Pattern","description":"Print butterfly.","difficulty":"EASY","category":"Patterns","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid butterfly(int n) {}\\nint main() { butterfly(3); return 0; }","expectedOutput":"*    *\\n**  **\\n******\\n**  **\\n*    *","solution":"#include <iostream>\\nusing namespace std;\\nvoid butterfly(int n) { for(int i=1;i<=n;i++) { for(int j=0;j<i;j++) cout<<\\"*\\"; for(int j=0;j<2*(n-i);j++) cout<<\\" \\"; for(int j=0;j<i;j++) cout<<\\"*\\"; cout<<\\"\\\\n\\"; } for(int i=n-1;i>=1;i--) { for(int j=0;j<i;j++) cout<<\\"*\\"; for(int j=0;j<2*(n-i);j++) cout<<\\" \\"; for(int j=0;j<i;j++) cout<<\\"*\\"; if(i>1) cout<<\\"\\\\n\\"; } }\\nint main() { butterfly(3); return 0; }","explanation":{"approach":"Two triangles mirrored.","analogy":"Wings of butterfly.","steps":["Upper: expand","Lower: contract"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"easy88","title":"Smallest of Three","description":"Find smallest of 3 numbers.","difficulty":"EASY","category":"Basic","starterCode":"#include <iostream>\\nusing namespace std;\\nint smallest(int a, int b, int c) { return 0; }\\nint main() { cout<<smallest(5,3,8); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nint smallest(int a, int b, int c) { int m=a; if(b<m) m=b; if(c<m) m=c; return m; }\\nint main() { cout<<smallest(5,3,8); return 0; }","explanation":{"approach":"Compare and track minimum.","analogy":"Find smallest among three.","steps":["Assume first is min","Update if others smaller"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"easy89","title":"Largest of Three","description":"Find largest of 3 numbers.","difficulty":"EASY","category":"Basic","starterCode":"#include <iostream>\\nusing namespace std;\\nint largest(int a, int b, int c) { return 0; }\\nint main() { cout<<largest(5,3,8); return 0; }","expectedOutput":"8","solution":"#include <iostream>\\nusing namespace std;\\nint largest(int a, int b, int c) { int m=a; if(b>m) m=b; if(c>m) m=c; return m; }\\nint main() { cout<<largest(5,3,8); return 0; }","explanation":{"approach":"Compare and track maximum.","analogy":"Find largest among three.","steps":["Assume first is max","Update if others larger"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"easy90","title":"Swap Two Numbers","description":"Swap without temp.","difficulty":"EASY","category":"Basic","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid swap(int &a, int &b) {}\\nint main() { int a=5,b=10; swap(a,b); cout<<a<<\\" \\"<<b; return 0; }","expectedOutput":"10 5","solution":"#include <iostream>\\nusing namespace std;\\nvoid myswap(int &a, int &b) { a=a+b; b=a-b; a=a-b; }\\nint main() { int a=5,b=10; myswap(a,b); cout<<a<<\\" \\"<<b; return 0; }","explanation":{"approach":"Use arithmetic to swap.","analogy":"Store sum, extract values.","steps":["a = a + b","b = a - b (original a)","a = a - b (original b)"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"easy91","title":"Middle of Three","description":"Find middle value.","difficulty":"EASY","category":"Basic","starterCode":"#include <iostream>\\nusing namespace std;\\nint middle(int a, int b, int c) { return 0; }\\nint main() { cout<<middle(5,8,3); return 0; }","expectedOutput":"5","solution":"#include <iostream>\\nusing namespace std;\\nint middle(int a, int b, int c) { if((a>=b && a<=c)||(a<=b && a>=c)) return a; if((b>=a && b<=c)||(b<=a && b>=c)) return b; return c; }\\nint main() { cout<<middle(5,8,3); return 0; }","explanation":{"approach":"Check which is between others.","analogy":"Not min, not max.","steps":["Check if a is middle","Check if b is middle","Else c"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"easy92","title":"Absolute Value","description":"Get absolute value.","difficulty":"EASY","category":"Basic","starterCode":"#include <iostream>\\nusing namespace std;\\nint absolute(int n) { return 0; }\\nint main() { cout<<absolute(-5); return 0; }","expectedOutput":"5","solution":"#include <iostream>\\nusing namespace std;\\nint absolute(int n) { return n<0?-n:n; }\\nint main() { cout<<absolute(-5); return 0; }","explanation":{"approach":"Negate if negative.","analogy":"Distance from zero.","steps":["If negative, multiply by -1"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"easy93","title":"Average of Array","description":"Calculate average.","difficulty":"EASY","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\ndouble average(int a[], int n) { return 0; }\\nint main() { int a[]={10,20,30,40,50}; cout<<average(a,5); return 0; }","expectedOutput":"30","solution":"#include <iostream>\\nusing namespace std;\\ndouble average(int a[], int n) { int s=0; for(int i=0;i<n;i++) s+=a[i]; return (double)s/n; }\\nint main() { int a[]={10,20,30,40,50}; cout<<average(a,5); return 0; }","explanation":{"approach":"Sum divided by count.","analogy":"Mean value.","steps":["Sum all elements","Divide by n"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"easy94","title":"Product of Array","description":"Multiply all elements.","difficulty":"EASY","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nint product(int a[], int n) { return 0; }\\nint main() { int a[]={1,2,3,4,5}; cout<<product(a,5); return 0; }","expectedOutput":"120","solution":"#include <iostream>\\nusing namespace std;\\nint product(int a[], int n) { int p=1; for(int i=0;i<n;i++) p*=a[i]; return p; }\\nint main() { int a[]={1,2,3,4,5}; cout<<product(a,5); return 0; }","explanation":{"approach":"Multiply all elements.","analogy":"Factorial-like product.","steps":["Start with 1","Multiply each element"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"easy95","title":"Count Evens","description":"Count even numbers.","difficulty":"EASY","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nint countEvens(int a[], int n) { return 0; }\\nint main() { int a[]={1,2,3,4,5,6}; cout<<countEvens(a,6); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nint countEvens(int a[], int n) { int c=0; for(int i=0;i<n;i++) if(a[i]%2==0) c++; return c; }\\nint main() { int a[]={1,2,3,4,5,6}; cout<<countEvens(a,6); return 0; }","explanation":{"approach":"Count elements divisible by 2.","analogy":"How many are even?","steps":["Check each if % 2 == 0"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"easy96","title":"Count Odds","description":"Count odd numbers.","difficulty":"EASY","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nint countOdds(int a[], int n) { return 0; }\\nint main() { int a[]={1,2,3,4,5,6}; cout<<countOdds(a,6); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nint countOdds(int a[], int n) { int c=0; for(int i=0;i<n;i++) if(a[i]%2!=0) c++; return c; }\\nint main() { int a[]={1,2,3,4,5,6}; cout<<countOdds(a,6); return 0; }","explanation":{"approach":"Count elements not divisible by 2.","analogy":"How many are odd?","steps":["Check each if % 2 != 0"],"complexity":"Time: O(n), Space: O(1)"}}]`),AR=[{id:"e401",title:"Binary Search",description:"Find target in sorted array.",difficulty:"EASY",category:"Binary Search",starterCode:`#include <iostream>
using namespace std;
int search(int nums[], int n, int target) { return -1; }
int main() { int a[]={-1,0,3,5,9,12}; cout<<search(a,6,9); return 0; }`,expectedOutput:"4",solution:`#include <iostream>
using namespace std;
int search(int nums[], int n, int target) { int l=0,r=n-1; while(l<=r) { int m=(l+r)/2; if(nums[m]==target) return m; if(nums[m]<target) l=m+1; else r=m-1; } return -1; }
int main() { int a[]={-1,0,3,5,9,12}; cout<<search(a,6,9); return 0; }`,explanation:{approach:"Binary search.",steps:["Compare middle with target","Narrow search range"],complexity:"Time: O(log n), Space: O(1)"}},{id:"e402",title:"First Bad Version",description:"Find first bad version.",difficulty:"EASY",category:"Binary Search",starterCode:`#include <iostream>
using namespace std;
bool isBadVersion(int v) { return v>=4; }
int firstBadVersion(int n) { return 0; }
int main() { cout<<firstBadVersion(5); return 0; }`,expectedOutput:"4",solution:`#include <iostream>
using namespace std;
bool isBadVersion(int v) { return v>=4; }
int firstBadVersion(int n) { int l=1,r=n; while(l<r) { int m=l+(r-l)/2; if(isBadVersion(m)) r=m; else l=m+1; } return l; }
int main() { cout<<firstBadVersion(5); return 0; }`,explanation:{approach:"Binary search for first.",steps:["If bad, search left","Else search right"],complexity:"Time: O(log n), Space: O(1)"}},{id:"e403",title:"Search Insert Position",description:"Find insert position.",difficulty:"EASY",category:"Binary Search",starterCode:`#include <iostream>
using namespace std;
int searchInsert(int nums[], int n, int target) { return 0; }
int main() { int a[]={1,3,5,6}; cout<<searchInsert(a,4,5); return 0; }`,expectedOutput:"2",solution:`#include <iostream>
using namespace std;
int searchInsert(int nums[], int n, int target) { int l=0,r=n-1; while(l<=r) { int m=(l+r)/2; if(nums[m]==target) return m; if(nums[m]<target) l=m+1; else r=m-1; } return l; }
int main() { int a[]={1,3,5,6}; cout<<searchInsert(a,4,5); return 0; }`,explanation:{approach:"Binary search.",steps:["Return index where target would be"],complexity:"Time: O(log n), Space: O(1)"}},{id:"e404",title:"Guess Number",description:"Guess the picked number.",difficulty:"EASY",category:"Binary Search",starterCode:`#include <iostream>
using namespace std;
int pick=6;
int guess(int n) { return n<pick?1:n>pick?-1:0; }
int guessNumber(int n) { return 0; }
int main() { cout<<guessNumber(10); return 0; }`,expectedOutput:"6",solution:`#include <iostream>
using namespace std;
int pick=6;
int guess(int n) { return n<pick?1:n>pick?-1:0; }
int guessNumber(int n) { int l=1,r=n; while(l<=r) { int m=l+(r-l)/2; int g=guess(m); if(g==0) return m; if(g==1) l=m+1; else r=m-1; } return l; }
int main() { cout<<guessNumber(10); return 0; }`,explanation:{approach:"Binary search with guess API.",steps:["Use guess result to narrow range"],complexity:"Time: O(log n), Space: O(1)"}},{id:"e405",title:"Peak Index Mountain",description:"Find peak index.",difficulty:"EASY",category:"Binary Search",starterCode:`#include <iostream>
using namespace std;
int peakIndexInMountainArray(int arr[], int n) { return 0; }
int main() { int a[]={0,2,1,0}; cout<<peakIndexInMountainArray(a,4); return 0; }`,expectedOutput:"1",solution:`#include <iostream>
using namespace std;
int peakIndexInMountainArray(int arr[], int n) { int l=0,r=n-1; while(l<r) { int m=(l+r)/2; if(arr[m]<arr[m+1]) l=m+1; else r=m; } return l; }
int main() { int a[]={0,2,1,0}; cout<<peakIndexInMountainArray(a,4); return 0; }`,explanation:{approach:"Binary search for peak.",steps:["If ascending, go right","Else go left"],complexity:"Time: O(log n), Space: O(1)"}},{id:"e406",title:"Valid Perfect Square",description:"Check if perfect square.",difficulty:"EASY",category:"Binary Search",starterCode:`#include <iostream>
using namespace std;
bool isPerfectSquare(int num) { return false; }
int main() { cout<<isPerfectSquare(16); return 0; }`,expectedOutput:"1",solution:`#include <iostream>
using namespace std;
bool isPerfectSquare(int num) { long l=1,r=num; while(l<=r) { long m=(l+r)/2; if(m*m==num) return true; if(m*m<num) l=m+1; else r=m-1; } return false; }
int main() { cout<<isPerfectSquare(16); return 0; }`,explanation:{approach:"Binary search.",steps:["Find if any m = num"],complexity:"Time: O(log n), Space: O(1)"}},{id:"e407",title:"Intersection Two Arrays",description:"Find common elements.",difficulty:"EASY",category:"Searching",starterCode:`#include <iostream>
using namespace std;
void intersection(int a[], int m, int b[], int n) {}
int main() { int a[]={1,2,2,1}; int b[]={2,2}; intersection(a,4,b,2); return 0; }`,expectedOutput:"2",solution:`#include <iostream>
using namespace std;
void intersection(int a[], int m, int b[], int n) { bool seen[1001]={}; for(int i=0;i<m;i++) seen[a[i]]=true; bool printed[1001]={}; for(int i=0;i<n;i++) if(seen[b[i]]&&!printed[b[i]]) { cout<<b[i]<<" "; printed[b[i]]=true; } }
int main() { int a[]={1,2,2,1}; int b[]={2,2}; intersection(a,4,b,2); return 0; }`,explanation:{approach:"Hash set intersection.",steps:["Mark elements of first array","Print matching from second"],complexity:"Time: O(m+n), Space: O(m)"}},{id:"e408",title:"Intersection II",description:"Common elements with duplicates.",difficulty:"EASY",category:"Searching",starterCode:`#include <iostream>
using namespace std;
void intersect(int a[], int m, int b[], int n) {}
int main() { int a[]={1,2,2,1}; int b[]={2,2}; intersect(a,4,b,2); return 0; }`,expectedOutput:"2 2",solution:`#include <iostream>
using namespace std;
void intersect(int a[], int m, int b[], int n) { int cnt[1001]={}; for(int i=0;i<m;i++) cnt[a[i]]++; for(int i=0;i<n;i++) if(cnt[b[i]]>0) { cout<<b[i]<<" "; cnt[b[i]]--; } }
int main() { int a[]={1,2,2,1}; int b[]={2,2}; intersect(a,4,b,2); return 0; }`,explanation:{approach:"Count occurrences.",steps:["Count first array","Decrement when matching in second"],complexity:"Time: O(m+n), Space: O(min(m,n))"}},{id:"e409",title:"Two Sum II Sorted",description:"Two sum in sorted array.",difficulty:"MEDIUM",category:"Searching",starterCode:`#include <iostream>
using namespace std;
void twoSum(int nums[], int n, int target) {}
int main() { int a[]={2,7,11,15}; twoSum(a,4,9); return 0; }`,expectedOutput:"1 2",solution:`#include <iostream>
using namespace std;
void twoSum(int nums[], int n, int target) { int l=0,r=n-1; while(l<r) { int s=nums[l]+nums[r]; if(s==target) { cout<<l+1<<" "<<r+1; return; } if(s<target) l++; else r--; } }
int main() { int a[]={2,7,11,15}; twoSum(a,4,9); return 0; }`,explanation:{approach:"Two pointers.",steps:["If sum too small, move left","If sum too big, move right"],complexity:"Time: O(n), Space: O(1)"}},{id:"e410",title:"Find Smallest Letter",description:"Smallest letter greater than target.",difficulty:"EASY",category:"Binary Search",starterCode:`#include <iostream>
using namespace std;
char nextGreatestLetter(char letters[], int n, char target) { return 'a'; }
int main() { char l[]={'c','f','j'}; cout<<nextGreatestLetter(l,3,'a'); return 0; }`,expectedOutput:"c",solution:`#include <iostream>
using namespace std;
char nextGreatestLetter(char letters[], int n, char target) { int l=0,r=n; while(l<r) { int m=(l+r)/2; if(letters[m]<=target) l=m+1; else r=m; } return letters[l%n]; }
int main() { char l[]={'c','f','j'}; cout<<nextGreatestLetter(l,3,'a'); return 0; }`,explanation:{approach:"Binary search.",steps:["Find first letter > target","Wrap around if needed"],complexity:"Time: O(log n), Space: O(1)"}}],MR=[{id:"e451",title:"Single Number",description:"Find element appearing once.",difficulty:"EASY",category:"Bit Manipulation",starterCode:`#include <iostream>
using namespace std;
int singleNumber(int nums[], int n) { return 0; }
int main() { int a[]={2,2,1}; cout<<singleNumber(a,3); return 0; }`,expectedOutput:"1",solution:`#include <iostream>
using namespace std;
int singleNumber(int nums[], int n) { int r=0; for(int i=0;i<n;i++) r^=nums[i]; return r; }
int main() { int a[]={2,2,1}; cout<<singleNumber(a,3); return 0; }`,explanation:{approach:"XOR all elements.",steps:["XOR cancels pairs","Only single remains"],complexity:"Time: O(n), Space: O(1)"}},{id:"e452",title:"Number of 1 Bits",description:"Count set bits.",difficulty:"EASY",category:"Bit Manipulation",starterCode:`#include <iostream>
using namespace std;
int hammingWeight(unsigned int n) { return 0; }
int main() { cout<<hammingWeight(11); return 0; }`,expectedOutput:"3",solution:`#include <iostream>
using namespace std;
int hammingWeight(unsigned int n) { int c=0; while(n) { c+=n&1; n>>=1; } return c; }
int main() { cout<<hammingWeight(11); return 0; }`,explanation:{approach:"Check each bit.",steps:["Count LSB","Shift right"],complexity:"Time: O(32), Space: O(1)"}},{id:"e453",title:"Reverse Bits",description:"Reverse all 32 bits.",difficulty:"EASY",category:"Bit Manipulation",starterCode:`#include <iostream>
using namespace std;
unsigned int reverseBits(unsigned int n) { return 0; }
int main() { cout<<reverseBits(43261596); return 0; }`,expectedOutput:"964176192",solution:`#include <iostream>
using namespace std;
unsigned int reverseBits(unsigned int n) { unsigned int r=0; for(int i=0;i<32;i++) { r=(r<<1)|(n&1); n>>=1; } return r; }
int main() { cout<<reverseBits(43261596); return 0; }`,explanation:{approach:"Build result bit by bit.",steps:["Extract LSB of n","Put in result","Shift both"],complexity:"Time: O(32), Space: O(1)"}},{id:"e454",title:"Missing Number",description:"Find missing 0 to n.",difficulty:"EASY",category:"Bit Manipulation",starterCode:`#include <iostream>
using namespace std;
int missingNumber(int nums[], int n) { return 0; }
int main() { int a[]={3,0,1}; cout<<missingNumber(a,3); return 0; }`,expectedOutput:"2",solution:`#include <iostream>
using namespace std;
int missingNumber(int nums[], int n) { int xr=n; for(int i=0;i<n;i++) xr^=i^nums[i]; return xr; }
int main() { int a[]={3,0,1}; cout<<missingNumber(a,3); return 0; }`,explanation:{approach:"XOR all values.",steps:["XOR all indices and values","Missing remains"],complexity:"Time: O(n), Space: O(1)"}},{id:"e455",title:"Power of Two",description:"Check if power of 2.",difficulty:"EASY",category:"Bit Manipulation",starterCode:`#include <iostream>
using namespace std;
bool isPowerOfTwo(int n) { return false; }
int main() { cout<<isPowerOfTwo(16); return 0; }`,expectedOutput:"1",solution:`#include <iostream>
using namespace std;
bool isPowerOfTwo(int n) { return n>0 && (n&(n-1))==0; }
int main() { cout<<isPowerOfTwo(16); return 0; }`,explanation:{approach:"n & (n-1) clears lowest bit.",steps:["Power of 2 has single 1 bit"],complexity:"Time: O(1), Space: O(1)"}},{id:"e456",title:"Counting Bits",description:"Count bits for 0 to n.",difficulty:"EASY",category:"Bit Manipulation",starterCode:`#include <iostream>
using namespace std;
void countBits(int n) {}
int main() { countBits(5); return 0; }`,expectedOutput:"0 1 1 2 1 2",solution:`#include <iostream>
using namespace std;
void countBits(int n) { for(int i=0;i<=n;i++) { int c=0,x=i; while(x) { c+=x&1; x>>=1; } cout<<c<<" "; } }
int main() { countBits(5); return 0; }`,explanation:{approach:"Count for each.",steps:["For each number","Count set bits"],complexity:"Time: O(n log n), Space: O(1)"}},{id:"e457",title:"Hamming Distance",description:"Bits differing.",difficulty:"EASY",category:"Bit Manipulation",starterCode:`#include <iostream>
using namespace std;
int hammingDistance(int x, int y) { return 0; }
int main() { cout<<hammingDistance(1,4); return 0; }`,expectedOutput:"2",solution:`#include <iostream>
using namespace std;
int hammingDistance(int x, int y) { int xr=x^y,c=0; while(xr) { c+=xr&1; xr>>=1; } return c; }
int main() { cout<<hammingDistance(1,4); return 0; }`,explanation:{approach:"XOR and count.",steps:["XOR gives differing bits","Count set bits"],complexity:"Time: O(32), Space: O(1)"}},{id:"e458",title:"Binary Watch",description:"Read binary watch.",difficulty:"EASY",category:"Bit Manipulation",starterCode:`#include <iostream>
using namespace std;
void readBinaryWatch(int turnedOn) {}
int main() { readBinaryWatch(1); return 0; }`,expectedOutput:"0:01 0:02 0:04 0:08 0:16 0:32 1:00 2:00 4:00 8:00",solution:`#include <iostream>
using namespace std;
int cnt(int n) { int c=0; while(n) { c+=n&1; n>>=1; } return c; }
void readBinaryWatch(int num) { for(int h=0;h<12;h++) for(int m=0;m<60;m++) if(cnt(h)+cnt(m)==num) cout<<h<<":"<<(m<10?"0":"")<<m<<" "; }
int main() { readBinaryWatch(1); return 0; }`,explanation:{approach:"Enumerate all times.",steps:["For each valid time","Count bits, check if equals num"],complexity:"Time: O(720), Space: O(1)"}},{id:"e459",title:"Sum Two Integers",description:"Add without + or -.",difficulty:"MEDIUM",category:"Bit Manipulation",starterCode:`#include <iostream>
using namespace std;
int getSum(int a, int b) { return 0; }
int main() { cout<<getSum(1,2); return 0; }`,expectedOutput:"3",solution:`#include <iostream>
using namespace std;
int getSum(int a, int b) { while(b) { int c=(unsigned)(a&b)<<1; a=a^b; b=c; } return a; }
int main() { cout<<getSum(1,2); return 0; }`,explanation:{approach:"Bit manipulation.",steps:["XOR for sum without carry","AND and shift for carry"],complexity:"Time: O(32), Space: O(1)"}},{id:"e460",title:"Complement of Base 10",description:"Flip all bits.",difficulty:"EASY",category:"Bit Manipulation",starterCode:`#include <iostream>
using namespace std;
int bitwiseComplement(int n) { return 0; }
int main() { cout<<bitwiseComplement(5); return 0; }`,expectedOutput:"2",solution:`#include <iostream>
using namespace std;
int bitwiseComplement(int n) { if(n==0) return 1; int mask=1; while(mask<n) mask=(mask<<1)|1; return n^mask; }
int main() { cout<<bitwiseComplement(5); return 0; }`,explanation:{approach:"XOR with all 1s mask.",steps:["Create mask of same length","XOR flips bits"],complexity:"Time: O(log n), Space: O(1)"}}],RR=JSON.parse(`[{"id":"e501","title":"Number of Steps to Zero","description":"Given a non-negative integer num, return the number of steps to reduce it to zero. If the current number is even, divide it by 2. If odd, subtract 1 from it.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nint numberOfSteps(int num) { return 0; }\\nint main() { cout << numberOfSteps(14); return 0; }","expectedOutput":"6","solution":"#include <iostream>\\nusing namespace std;\\nint numberOfSteps(int num) {\\n    int count = 0;\\n    while(num > 0) {\\n        if(num % 2 == 0) {\\n            num /= 2;  // If even, divide by 2\\n        } else {\\n            num--;     // If odd, subtract 1\\n        }\\n        count++;\\n    }\\n    return count;\\n}\\nint main() { cout << numberOfSteps(14); return 0; }","explanation":{"approach":"Follow the rules: if number is even, halve it; if odd, subtract one. Count each operation.","analogy":"Like counting steps to climb down a ladder - each rung is either a big step (divide) or small step (subtract).","steps":["Start with the given number","If even: divide by 2 (big step down)","If odd: subtract 1 (small step down)","Count each step","Stop when you reach 0"],"complexity":"Time: O(log n), Space: O(1)"}},{"id":"e502","title":"Subtract Product and Sum","description":"Given an integer n, return the difference between the product of its digits and the sum of its digits. For example, n=234: product=234=24, sum=2+3+4=9, answer=24-9=15.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nint subtractProductAndSum(int n) { return 0; }\\nint main() { cout << subtractProductAndSum(234); return 0; }","expectedOutput":"15","solution":"#include <iostream>\\nusing namespace std;\\nint subtractProductAndSum(int n) {\\n    int product = 1, sum = 0;\\n    while(n > 0) {\\n        int digit = n % 10;  // Get last digit\\n        product *= digit;    // Multiply to product\\n        sum += digit;        // Add to sum\\n        n /= 10;            // Remove last digit\\n    }\\n    return product - sum;\\n}\\nint main() { cout << subtractProductAndSum(234); return 0; }","explanation":{"approach":"Extract each digit one by one. Keep a running product (multiply all digits) and sum (add all digits). Return their difference.","analogy":"Like taking apart a number into its pieces - multiply them together for product, add them for sum, then subtract.","steps":["Initialize product=1 (neutral for multiplication) and sum=0","Get last digit using n % 10","Multiply it into product, add to sum","Remove last digit using n / 10","Repeat until n becomes 0","Return product - sum"],"complexity":"Time: O(log n), Space: O(1)"}},{"id":"e503","title":"Integer to Roman","description":"Convert an integer to a Roman numeral. Roman numerals use: I=1, V=5, X=10, L=50, C=100, D=500, M=1000. For subtraction: IV=4, IX=9, XL=40, XC=90, CD=400, CM=900.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid intToRoman(int num) {}\\nint main() { intToRoman(3); return 0; }","expectedOutput":"III","solution":"#include <iostream>\\nusing namespace std;\\nvoid intToRoman(int num) {\\n    int values[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n    char* symbols[] = {\\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\"};\\n    for(int i = 0; i < 13; i++) {\\n        while(num >= values[i]) {\\n            cout << symbols[i];\\n            num -= values[i];\\n        }\\n    }\\n}\\nint main() { intToRoman(3); return 0; }","explanation":{"approach":"Greedy approach - always use the largest Roman numeral that fits. Keep subtracting and outputting symbols.","analogy":"Like making change with coins - use the biggest coin possible, then move to smaller ones.","steps":["Create mapping of values to Roman symbols (including subtraction cases like CM, XC)","Start with largest value (1000=M)","While number >= current value, output symbol and subtract value","Move to next smaller value","Repeat until number becomes 0"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"e504","title":"Roman to Integer","description":"Convert a Roman numeral string to an integer. When a smaller value appears before a larger value, it's subtraction (IV=4). Otherwise, add values together.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nint romanToInt(char s[]) { return 0; }\\nint main() { cout << romanToInt(\\"III\\"); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nint getValue(char c) {\\n    if(c == 'M') return 1000;\\n    if(c == 'D') return 500;\\n    if(c == 'C') return 100;\\n    if(c == 'L') return 50;\\n    if(c == 'X') return 10;\\n    if(c == 'V') return 5;\\n    if(c == 'I') return 1;\\n    return 0;\\n}\\nint romanToInt(char s[]) {\\n    int result = 0;\\n    for(int i = 0; s[i]; i++) {\\n        int curr = getValue(s[i]);\\n        int next = getValue(s[i+1]);\\n        if(curr < next) {\\n            result -= curr;  // Subtraction case (IV, IX, etc.)\\n        } else {\\n            result += curr;  // Normal addition\\n        }\\n    }\\n    return result;\\n}\\nint main() { cout << romanToInt(\\"III\\"); return 0; }","explanation":{"approach":"Scan left to right. If current value is less than next, subtract it (like IV=5-1=4). Otherwise add it.","analogy":"Reading backwards logic - if a small letter comes before a big one, it means 'minus'.","steps":["Create a function to convert each Roman letter to its value","Loop through the string","Compare current value with next value","If current < next, subtract current from result","Otherwise, add current to result"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"e505","title":"Day of Year","description":"Given a date string in format YYYY-MM-DD, return which day of the year it is (1 to 365/366). For example, 2019-01-09 is the 9th day.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nint dayOfYear(char date[]) { return 0; }\\nint main() { cout << dayOfYear(\\"2019-01-09\\"); return 0; }","expectedOutput":"9","solution":"#include <iostream>\\nusing namespace std;\\nint dayOfYear(char date[]) {\\n    int year = (date[0]-'0')*1000 + (date[1]-'0')*100 + (date[2]-'0')*10 + (date[3]-'0');\\n    int month = (date[5]-'0')*10 + (date[6]-'0');\\n    int day = (date[8]-'0')*10 + (date[9]-'0');\\n    \\n    int daysInMonth[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    \\n    // Check leap year\\n    if((year % 4 == 0 && year % 100 != 0) || year % 400 == 0) {\\n        daysInMonth[2] = 29;\\n    }\\n    \\n    int result = day;\\n    for(int i = 1; i < month; i++) {\\n        result += daysInMonth[i];\\n    }\\n    return result;\\n}\\nint main() { cout << dayOfYear(\\"2019-01-09\\"); return 0; }","explanation":{"approach":"Parse the date, sum up all days from previous months, add current day. Handle leap years for February.","analogy":"Like counting pages in a book - add all pages of previous chapters plus your current page number.","steps":["Parse year, month, and day from string","Check if it's a leap year (Feb has 29 days)","Sum days of all months before current month","Add the current day number","Return total"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"e506","title":"Day of the Week","description":"Given a date (day, month, year), return the name of the day (Sunday, Monday, etc.) using Zeller's congruence or similar algorithm.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid dayOfTheWeek(int day, int month, int year) {}\\nint main() { dayOfTheWeek(31, 8, 2019); return 0; }","expectedOutput":"Saturday","solution":"#include <iostream>\\nusing namespace std;\\nvoid dayOfTheWeek(int d, int m, int y) {\\n    char* days[] = {\\"Sunday\\", \\"Monday\\", \\"Tuesday\\", \\"Wednesday\\", \\"Thursday\\", \\"Friday\\", \\"Saturday\\"};\\n    // Zeller's congruence\\n    if(m < 3) {\\n        m += 12;\\n        y--;\\n    }\\n    int k = y % 100;  // Year of century\\n    int j = y / 100;  // Century\\n    int h = (d + 13*(m+1)/5 + k + k/4 + j/4 - 2*j) % 7;\\n    h = (h + 6) % 7;  // Adjust to Sunday = 0\\n    cout << days[h];\\n}\\nint main() { dayOfTheWeek(31, 8, 2019); return 0; }","explanation":{"approach":"Use Zeller's congruence - a mathematical formula that calculates the day of the week from any date.","analogy":"Like a magic formula that, given any calendar date, tells you what day of the week it was/will be.","steps":["Adjust month and year (Jan/Feb treated as months 13/14 of previous year)","Apply Zeller's formula with day, month, year components","The result h gives the day (0=Saturday in original formula)","Adjust to make Sunday=0","Output the corresponding day name"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"e507","title":"Cells with Odd Values","description":"Given an mn matrix initialized to zeros, and an array of increment operations (row, col), increment all cells in the specified row and column. Return count of cells with odd values.","difficulty":"EASY","category":"Matrix","starterCode":"#include <iostream>\\nusing namespace std;\\nint oddCells(int m, int n, int indices[][2], int k) { return 0; }\\nint main() { int ind[][2] = {{0,1}, {1,1}}; cout << oddCells(2, 3, ind, 2); return 0; }","expectedOutput":"6","solution":"#include <iostream>\\nusing namespace std;\\nint oddCells(int m, int n, int indices[][2], int k) {\\n    int rowCount[50] = {}, colCount[50] = {};\\n    \\n    // Count increments per row and column\\n    for(int i = 0; i < k; i++) {\\n        rowCount[indices[i][0]]++;\\n        colCount[indices[i][1]]++;\\n    }\\n    \\n    // Count cells with odd total increments\\n    int count = 0;\\n    for(int i = 0; i < m; i++) {\\n        for(int j = 0; j < n; j++) {\\n            if((rowCount[i] + colCount[j]) % 2 == 1) {\\n                count++;\\n            }\\n        }\\n    }\\n    return count;\\n}\\nint main() { int ind[][2] = {{0,1}, {1,1}}; cout << oddCells(2, 3, ind, 2); return 0; }","explanation":{"approach":"Instead of simulating the entire matrix, track how many times each row and column is incremented. A cell's value = row_count + col_count.","analogy":"Like counting traffic at intersections - a car passes through cell (i,j) for every row-i increment and column-j increment.","steps":["Count increments for each row in rowCount[]","Count increments for each column in colCount[]","For each cell (i,j), its value = rowCount[i] + colCount[j]","If this sum is odd, increment our answer","Return total count of odd cells"],"complexity":"Time: O(mn + k), Space: O(m + n)"}},{"id":"e508","title":"Shift 2D Grid","description":"Given a 2D grid of integers and a number k, shift all elements k times. Each shift moves the last element to become the first (circular shift).","difficulty":"EASY","category":"Matrix","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid shiftGrid(int grid[][3], int m, int n, int k) {}\\nint main() { int g[][3] = {{1,2,3}, {4,5,6}, {7,8,9}}; shiftGrid(g, 3, 3, 1); return 0; }","expectedOutput":"9 1 2 3 4 5 6 7 8","solution":"#include <iostream>\\nusing namespace std;\\nvoid shiftGrid(int grid[][3], int m, int n, int k) {\\n    int size = m * n;\\n    k %= size;  // Handle k > size\\n    \\n    // Flatten grid to 1D\\n    int temp[size];\\n    for(int i = 0; i < m; i++) {\\n        for(int j = 0; j < n; j++) {\\n            temp[i * n + j] = grid[i][j];\\n        }\\n    }\\n    \\n    // Shift and put back\\n    for(int i = 0; i < m; i++) {\\n        for(int j = 0; j < n; j++) {\\n            int oldIndex = (i * n + j - k + size) % size;\\n            grid[i][j] = temp[oldIndex];\\n        }\\n    }\\n    \\n    // Print result\\n    for(int i = 0; i < m; i++) {\\n        for(int j = 0; j < n; j++) {\\n            cout << grid[i][j] << \\" \\";\\n        }\\n    }\\n}\\nint main() { int g[][3] = {{1,2,3}, {4,5,6}, {7,8,9}}; shiftGrid(g, 3, 3, 1); return 0; }","explanation":{"approach":"Treat the 2D grid as a 1D array by flattening it. Perform circular shift on 1D array, then reshape back to 2D.","analogy":"Like a conveyor belt - imagine all items in a single line. Shifting moves everything forward with the last item wrapping to the front.","steps":["Flatten the 2D grid into a 1D array","Calculate new position for each element after k shifts","New position = (old position + k) % total_size","Reshape back to 2D grid","Print the result"],"complexity":"Time: O(m  n), Space: O(m  n)"}},{"id":"e509","title":"Replace Elements with Greatest","description":"Given an array, replace each element with the greatest element to its right. The last element becomes -1 since there's nothing to its right.","difficulty":"EASY","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid replaceElements(int arr[], int n) {}\\nint main() { int a[] = {17, 18, 5, 4, 6, 1}; replaceElements(a, 6); for(int i = 0; i < 6; i++) cout << a[i] << \\" \\"; return 0; }","expectedOutput":"18 6 6 6 1 -1","solution":"#include <iostream>\\nusing namespace std;\\nvoid replaceElements(int arr[], int n) {\\n    int maxRight = -1;  // Start with -1 for last element\\n    \\n    // Traverse from right to left\\n    for(int i = n - 1; i >= 0; i--) {\\n        int current = arr[i];  // Save current value\\n        arr[i] = maxRight;     // Replace with max on right\\n        if(current > maxRight) {\\n            maxRight = current;  // Update max\\n        }\\n    }\\n}\\nint main() { int a[] = {17, 18, 5, 4, 6, 1}; replaceElements(a, 6); for(int i = 0; i < 6; i++) cout << a[i] << \\" \\"; return 0; }","explanation":{"approach":"Scan from right to left, keeping track of the maximum seen so far. Each element gets replaced by this running maximum.","analogy":"Like looking over your shoulder - each person reports the tallest person they can see behind them.","steps":["Start from the rightmost element","Keep track of maximum value seen so far (starts as -1)","Save current element, replace it with current max","Update max if current was larger","Move left and repeat"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"e510","title":"Sort by Number of 1 Bits","description":"Sort array by the number of 1s in their binary representation. If two numbers have the same number of 1 bits, sort them by their value.","difficulty":"EASY","category":"Sorting","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid sortByBits(int arr[], int n) {}\\nint main() { int a[] = {0, 1, 2, 3, 4, 5, 6, 7, 8}; sortByBits(a, 9); for(int i = 0; i < 9; i++) cout << a[i] << \\" \\"; return 0; }","expectedOutput":"0 1 2 4 8 3 5 6 7","solution":"#include <iostream>\\nusing namespace std;\\nint countBits(int n) {\\n    int count = 0;\\n    while(n) {\\n        count += n & 1;  // Add last bit\\n        n >>= 1;        // Shift right\\n    }\\n    return count;\\n}\\nvoid sortByBits(int arr[], int n) {\\n    // Bubble sort with custom comparison\\n    for(int i = 0; i < n - 1; i++) {\\n        for(int j = 0; j < n - i - 1; j++) {\\n            int bits1 = countBits(arr[j]);\\n            int bits2 = countBits(arr[j + 1]);\\n            // Swap if more bits, or same bits but larger value\\n            if(bits1 > bits2 || (bits1 == bits2 && arr[j] > arr[j + 1])) {\\n                int temp = arr[j];\\n                arr[j] = arr[j + 1];\\n                arr[j + 1] = temp;\\n            }\\n        }\\n    }\\n}\\nint main() { int a[] = {0, 1, 2, 3, 4, 5, 6, 7, 8}; sortByBits(a, 9); for(int i = 0; i < 9; i++) cout << a[i] << \\" \\"; return 0; }","explanation":{"approach":"Count the 1 bits in each number's binary form. Sort primarily by bit count, secondarily by value.","analogy":"Like sorting students by test score, and if scores are tied, sort by name. Here 'score' is number of 1 bits.","steps":["Create a function to count 1 bits (using AND with 1, then shift right)","Use sorting algorithm (bubble sort shown here)","Compare by bit count first","If bit counts are equal, compare by value","Sort in ascending order"],"complexity":"Time: O(n  log(max)), Space: O(1)"}}]`),DR=JSON.parse(`[{"id":"e551","title":"Valid Parentheses","description":"Check bracket matching.","difficulty":"EASY","category":"Stack","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isValid(char s[]) { return false; }\\nint main() { cout<<isValid(\\"()[]{}\\"); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isValid(char s[]) { char stk[100]; int top=-1; for(int i=0;s[i];i++) { if(s[i]=='('||s[i]=='{'||s[i]=='[') stk[++top]=s[i]; else { if(top<0) return false; if(s[i]==')'&&stk[top]!='(') return false; if(s[i]=='}'&&stk[top]!='{') return false; if(s[i]==']'&&stk[top]!='[') return false; top--; } } return top==-1; }\\nint main() { cout<<isValid(\\"()[]{}\\"); return 0; }","explanation":{"approach":"Stack for matching.","steps":["Push opening brackets","Pop and match closing"],"complexity":"Time: O(n), Space: O(n)"}},{"id":"e552","title":"Min Stack","description":"Stack with getMin.","difficulty":"MEDIUM","category":"Stack","starterCode":"#include <iostream>\\nusing namespace std;\\nclass MinStack {\\npublic:\\n    void push(int val) {}\\n    void pop() {}\\n    int top() { return 0; }\\n    int getMin() { return 0; }\\n};\\nint main() { cout<<\\"OK\\"; return 0; }","expectedOutput":"OK","solution":"#include <iostream>\\nusing namespace std;\\nclass MinStack { int stk[100],mstk[100],top; public: MinStack():top(-1){} void push(int v) { stk[++top]=v; mstk[top]=top==0?v:min(v,mstk[top-1]); } void pop() { top--; } int top() { return stk[this->top]; } int getMin() { return mstk[top]; } };\\nint main() { cout<<\\"OK\\"; return 0; }","explanation":{"approach":"Track min at each level.","steps":["Store min for each stack state"],"complexity":"Time: O(1), Space: O(n)"}},{"id":"e553","title":"Implement Queue Using Stacks","description":"Queue from two stacks.","difficulty":"EASY","category":"Stack","starterCode":"#include <iostream>\\nusing namespace std;\\nclass MyQueue {\\npublic:\\n    void push(int x) {}\\n    int pop() { return 0; }\\n    int peek() { return 0; }\\n    bool empty() { return true; }\\n};\\nint main() { MyQueue q; q.push(1); q.push(2); cout<<q.peek(); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nclass MyQueue { int s1[100],s2[100],t1,t2; public: MyQueue():t1(-1),t2(-1){} void push(int x) { s1[++t1]=x; } void move() { if(t2<0) while(t1>=0) s2[++t2]=s1[t1--]; } int pop() { move(); return s2[t2--]; } int peek() { move(); return s2[t2]; } bool empty() { return t1<0&&t2<0; } };\\nint main() { MyQueue q; q.push(1); q.push(2); cout<<q.peek(); return 0; }","explanation":{"approach":"Two stacks.","steps":["Push to s1","Move to s2 for pop/peek"],"complexity":"Time: O(1) amortized, Space: O(n)"}},{"id":"e554","title":"Implement Stack Using Queues","description":"Stack from queue.","difficulty":"EASY","category":"Stack","starterCode":"#include <iostream>\\nusing namespace std;\\nclass MyStack {\\npublic:\\n    void push(int x) {}\\n    int pop() { return 0; }\\n    int top() { return 0; }\\n    bool empty() { return true; }\\n};\\nint main() { MyStack s; s.push(1); s.push(2); cout<<s.top(); return 0; }","expectedOutput":"2","solution":"#include <iostream>\\nusing namespace std;\\nclass MyStack { int q[100],f,b; public: MyStack():f(0),b(0){} void push(int x) { q[b++]=x; for(int i=0;i<b-f-1;i++) { q[b++]=q[f++]; } } int pop() { return q[f++]; } int top() { return q[f]; } bool empty() { return f==b; } };\\nint main() { MyStack s; s.push(1); s.push(2); cout<<s.top(); return 0; }","explanation":{"approach":"Rotate queue on push.","steps":["Push new element","Move all others to back"],"complexity":"Time: O(n) push, Space: O(n)"}},{"id":"e555","title":"Next Greater Element I","description":"Next greater in nums2 for nums1.","difficulty":"EASY","category":"Stack","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid nextGreaterElement(int n1[], int l1, int n2[], int l2) {}\\nint main() { int a[]={4,1,2}; int b[]={1,3,4,2}; nextGreaterElement(a,3,b,4); return 0; }","expectedOutput":"-1 3 -1","solution":"#include <iostream>\\nusing namespace std;\\nvoid nextGreaterElement(int n1[], int l1, int n2[], int l2) { for(int i=0;i<l1;i++) { int res=-1; bool found=false; for(int j=0;j<l2;j++) { if(n2[j]==n1[i]) found=true; if(found && n2[j]>n1[i]) { res=n2[j]; break; } } cout<<res<<\\" \\"; } }\\nint main() { int a[]={4,1,2}; int b[]={1,3,4,2}; nextGreaterElement(a,3,b,4); return 0; }","explanation":{"approach":"Find in nums2, then find next greater.","steps":["Locate element","Find first larger after"],"complexity":"Time: O(nm), Space: O(1)"}},{"id":"e556","title":"Baseball Game","description":"Calculate score.","difficulty":"EASY","category":"Stack","starterCode":"#include <iostream>\\nusing namespace std;\\nint calPoints(char* ops[], int n) { return 0; }\\nint main() { char* o[]={\\"5\\",\\"2\\",\\"C\\",\\"D\\",\\"+\\"}; cout<<calPoints(o,5); return 0; }","expectedOutput":"30","solution":"#include <iostream>\\nusing namespace std;\\nint calPoints(char* ops[], int n) { int stk[100],top=-1; for(int i=0;i<n;i++) { if(ops[i][0]=='C') top--; else if(ops[i][0]=='D') stk[++top]=stk[top-1]*2; else if(ops[i][0]=='+') stk[++top]=stk[top-1]+stk[top-2]; else { int v=0,neg=ops[i][0]=='-'; for(int j=neg?1:0;ops[i][j];j++) v=v*10+ops[i][j]-'0'; stk[++top]=neg?-v:v; } } int sum=0; for(int i=0;i<=top;i++) sum+=stk[i]; return sum; }\\nint main() { char* o[]={\\"5\\",\\"2\\",\\"C\\",\\"D\\",\\"+\\"}; cout<<calPoints(o,5); return 0; }","explanation":{"approach":"Stack simulation.","steps":["Apply operations","Sum all scores"],"complexity":"Time: O(n), Space: O(n)"}},{"id":"e557","title":"Remove All Adjacent Duplicates","description":"Remove adjacent same chars.","difficulty":"EASY","category":"Stack","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid removeDuplicates(char s[]) {}\\nint main() { char s[]=\\"abbaca\\"; removeDuplicates(s); return 0; }","expectedOutput":"ca","solution":"#include <iostream>\\nusing namespace std;\\nvoid removeDuplicates(char s[]) { char stk[100]; int top=-1; for(int i=0;s[i];i++) { if(top>=0&&stk[top]==s[i]) top--; else stk[++top]=s[i]; } for(int i=0;i<=top;i++) cout<<stk[i]; }\\nint main() { char s[]=\\"abbaca\\"; removeDuplicates(s); return 0; }","explanation":{"approach":"Stack for removal.","steps":["Pop if same as top","Else push"],"complexity":"Time: O(n), Space: O(n)"}},{"id":"e558","title":"Maximum Frequency Stack","description":"Pop most frequent.","difficulty":"HARD","category":"Stack","starterCode":"#include <iostream>\\nusing namespace std;\\nclass FreqStack {\\npublic:\\n    void push(int val) {}\\n    int pop() { return 0; }\\n};\\nint main() { cout<<\\"OK\\"; return 0; }","expectedOutput":"OK","solution":"#include <iostream>\\nusing namespace std;\\nclass FreqStack { int stk[100],freq[101],n,mf; public: FreqStack():n(0),mf(0){ for(int i=0;i<101;i++) freq[i]=0; } void push(int v) { freq[v]++; if(freq[v]>mf) mf=freq[v]; stk[n++]=v; } int pop() { while(n>0&&freq[stk[n-1]]<mf) n--; if(n==0) { mf--; return -1; } int v=stk[--n]; freq[v]--; while(mf>0) { bool found=false; for(int i=0;i<101;i++) if(freq[i]==mf) { found=true; break; } if(found) break; mf--; } return v; } };\\nint main() { cout<<\\"OK\\"; return 0; }","explanation":{"approach":"Track frequency.","steps":["Push to stack","Pop from highest frequency"],"complexity":"Time: O(1), Space: O(n)"}},{"id":"e559","title":"Daily Temperatures","description":"Days until warmer.","difficulty":"MEDIUM","category":"Stack","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid dailyTemperatures(int t[], int n) {}\\nint main() { int t[]={73,74,75,71,69,72,76,73}; dailyTemperatures(t,8); return 0; }","expectedOutput":"1 1 4 2 1 1 0 0","solution":"#include <iostream>\\nusing namespace std;\\nvoid dailyTemperatures(int t[], int n) { int stk[100],top=-1,res[n]={}; for(int i=0;i<n;i++) { while(top>=0&&t[i]>t[stk[top]]) { res[stk[top]]=i-stk[top]; top--; } stk[++top]=i; } for(int i=0;i<n;i++) cout<<res[i]<<\\" \\"; }\\nint main() { int t[]={73,74,75,71,69,72,76,73}; dailyTemperatures(t,8); return 0; }","explanation":{"approach":"Monotonic stack.","steps":["Pop while current is warmer","Calculate days difference"],"complexity":"Time: O(n), Space: O(n)"}},{"id":"e560","title":"Backspace String Compare","description":"Compare with backspaces.","difficulty":"EASY","category":"Stack","starterCode":"#include <iostream>\\nusing namespace std;\\nbool backspaceCompare(char s[], char t[]) { return false; }\\nint main() { cout<<backspaceCompare(\\"ab#c\\",\\"ad#c\\"); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nvoid process(char s[], char r[]) { int j=0; for(int i=0;s[i];i++) { if(s[i]=='#') { if(j>0) j--; } else r[j++]=s[i]; } r[j]=0; }\\nbool backspaceCompare(char s[], char t[]) { char r1[100],r2[100]; process(s,r1); process(t,r2); for(int i=0;;i++) { if(r1[i]!=r2[i]) return false; if(!r1[i]) return true; } }\\nint main() { cout<<backspaceCompare(\\"ab#c\\",\\"ad#c\\"); return 0; }","explanation":{"approach":"Process then compare.","steps":["Apply backspaces","Compare results"],"complexity":"Time: O(n), Space: O(n)"}}]`),IR=JSON.parse('[{"id":"e601","title":"Invert Binary Tree","description":"Mirror the tree.","difficulty":"EASY","category":"Trees","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nNode* invertTree(Node* r) { return nullptr; }\\nvoid pre(Node* r) { if(!r) return; cout<<r->v<<\\" \\"; pre(r->l); pre(r->r); }\\nint main() { Node* r=new Node(4); r->l=new Node(2); r->r=new Node(7); r=invertTree(r); pre(r); return 0; }","expectedOutput":"4 7 2","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nNode* invertTree(Node* r) { if(!r) return 0; Node* t=r->l; r->l=invertTree(r->r); r->r=invertTree(t); return r; }\\nvoid pre(Node* r) { if(!r) return; cout<<r->v<<\\" \\"; pre(r->l); pre(r->r); }\\nint main() { Node* r=new Node(4); r->l=new Node(2); r->r=new Node(7); r=invertTree(r); pre(r); return 0; }","explanation":{"approach":"Swap children recursively.","steps":["Swap left and right","Recurse"],"complexity":"Time: O(n), Space: O(h)"}},{"id":"e602","title":"Same Tree","description":"Check if identical.","difficulty":"EASY","category":"Trees","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nbool isSameTree(Node* p, Node* q) { return false; }\\nint main() { Node* p=new Node(1); p->l=new Node(2); Node* q=new Node(1); q->l=new Node(2); cout<<isSameTree(p,q); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nbool isSameTree(Node* p, Node* q) { if(!p&&!q) return true; if(!p||!q) return false; return p->v==q->v && isSameTree(p->l,q->l) && isSameTree(p->r,q->r); }\\nint main() { Node* p=new Node(1); p->l=new Node(2); Node* q=new Node(1); q->l=new Node(2); cout<<isSameTree(p,q); return 0; }","explanation":{"approach":"Compare recursively.","steps":["Both null = same","Compare values and children"],"complexity":"Time: O(n), Space: O(h)"}},{"id":"e603","title":"Merge Two Binary Trees","description":"Merge overlapping nodes.","difficulty":"EASY","category":"Trees","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nNode* mergeTrees(Node* r1, Node* r2) { return nullptr; }\\nvoid pre(Node* r) { if(!r) return; cout<<r->v<<\\" \\"; pre(r->l); pre(r->r); }\\nint main() { Node* t1=new Node(1); t1->l=new Node(3); Node* t2=new Node(2); t2->l=new Node(1); t2->r=new Node(3); Node* m=mergeTrees(t1,t2); pre(m); return 0; }","expectedOutput":"3 4 3","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nNode* mergeTrees(Node* r1, Node* r2) { if(!r1) return r2; if(!r2) return r1; r1->v+=r2->v; r1->l=mergeTrees(r1->l,r2->l); r1->r=mergeTrees(r1->r,r2->r); return r1; }\\nvoid pre(Node* r) { if(!r) return; cout<<r->v<<\\" \\"; pre(r->l); pre(r->r); }\\nint main() { Node* t1=new Node(1); t1->l=new Node(3); Node* t2=new Node(2); t2->l=new Node(1); t2->r=new Node(3); Node* m=mergeTrees(t1,t2); pre(m); return 0; }","explanation":{"approach":"Add values, recurse.","steps":["Sum overlapping nodes","Recurse on children"],"complexity":"Time: O(n), Space: O(h)"}},{"id":"e604","title":"Search in BST","description":"Find node in BST.","difficulty":"EASY","category":"Trees","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nNode* searchBST(Node* r, int val) { return nullptr; }\\nint main() { Node* r=new Node(4); r->l=new Node(2); r->r=new Node(7); Node* res=searchBST(r,2); cout<<(res?res->v:-1); return 0; }","expectedOutput":"2","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nNode* searchBST(Node* r, int val) { if(!r||r->v==val) return r; return val<r->v?searchBST(r->l,val):searchBST(r->r,val); }\\nint main() { Node* r=new Node(4); r->l=new Node(2); r->r=new Node(7); Node* res=searchBST(r,2); cout<<(res?res->v:-1); return 0; }","explanation":{"approach":"BST property search.","steps":["If less go left","If more go right"],"complexity":"Time: O(h), Space: O(h)"}},{"id":"e605","title":"Range Sum BST","description":"Sum values in range.","difficulty":"EASY","category":"Trees","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nint rangeSumBST(Node* r, int lo, int hi) { return 0; }\\nint main() { Node* r=new Node(10); r->l=new Node(5); r->r=new Node(15); r->l->l=new Node(3); r->l->r=new Node(7); cout<<rangeSumBST(r,7,15); return 0; }","expectedOutput":"32","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nint rangeSumBST(Node* r, int lo, int hi) { if(!r) return 0; int s=0; if(r->v>=lo && r->v<=hi) s+=r->v; if(r->v>lo) s+=rangeSumBST(r->l,lo,hi); if(r->v<hi) s+=rangeSumBST(r->r,lo,hi); return s; }\\nint main() { Node* r=new Node(10); r->l=new Node(5); r->r=new Node(15); r->l->l=new Node(3); r->l->r=new Node(7); cout<<rangeSumBST(r,7,15); return 0; }","explanation":{"approach":"Prune using BST property.","steps":["Add if in range","Skip subtrees outside range"],"complexity":"Time: O(n), Space: O(h)"}},{"id":"e606","title":"Minimum Depth Binary Tree","description":"Shortest path to leaf.","difficulty":"EASY","category":"Trees","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nint minDepth(Node* r) { return 0; }\\nint main() { Node* r=new Node(3); r->l=new Node(9); r->r=new Node(20); r->r->l=new Node(15); r->r->r=new Node(7); cout<<minDepth(r); return 0; }","expectedOutput":"2","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nint minDepth(Node* r) { if(!r) return 0; if(!r->l) return 1+minDepth(r->r); if(!r->r) return 1+minDepth(r->l); return 1+min(minDepth(r->l),minDepth(r->r)); }\\nint main() { Node* r=new Node(3); r->l=new Node(9); r->r=new Node(20); r->r->l=new Node(15); r->r->r=new Node(7); cout<<minDepth(r); return 0; }","explanation":{"approach":"Handle single child case.","steps":["If one child null, go other way","Else take minimum"],"complexity":"Time: O(n), Space: O(h)"}},{"id":"e607","title":"Count Complete Tree Nodes","description":"Count nodes efficiently.","difficulty":"MEDIUM","category":"Trees","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nint countNodes(Node* r) { return 0; }\\nint main() { Node* r=new Node(1); r->l=new Node(2); r->r=new Node(3); r->l->l=new Node(4); r->l->r=new Node(5); r->r->l=new Node(6); cout<<countNodes(r); return 0; }","expectedOutput":"6","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nint countNodes(Node* r) { if(!r) return 0; return 1+countNodes(r->l)+countNodes(r->r); }\\nint main() { Node* r=new Node(1); r->l=new Node(2); r->r=new Node(3); r->l->l=new Node(4); r->l->r=new Node(5); r->r->l=new Node(6); cout<<countNodes(r); return 0; }","explanation":{"approach":"Recursive count.","steps":["Count left + right + 1"],"complexity":"Time: O(n), Space: O(h)"}},{"id":"e608","title":"Sum of Left Leaves","description":"Sum all left leaves.","difficulty":"EASY","category":"Trees","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nint sumOfLeftLeaves(Node* r) { return 0; }\\nint main() { Node* r=new Node(3); r->l=new Node(9); r->r=new Node(20); r->r->l=new Node(15); r->r->r=new Node(7); cout<<sumOfLeftLeaves(r); return 0; }","expectedOutput":"24","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nint sumOfLeftLeaves(Node* r) { if(!r) return 0; int s=0; if(r->l && !r->l->l && !r->l->r) s+=r->l->v; s+=sumOfLeftLeaves(r->l)+sumOfLeftLeaves(r->r); return s; }\\nint main() { Node* r=new Node(3); r->l=new Node(9); r->r=new Node(20); r->r->l=new Node(15); r->r->r=new Node(7); cout<<sumOfLeftLeaves(r); return 0; }","explanation":{"approach":"Check if left child is leaf.","steps":["Add left leaf value","Recurse on children"],"complexity":"Time: O(n), Space: O(h)"}},{"id":"e609","title":"Find Mode in BST","description":"Most frequent values.","difficulty":"EASY","category":"Trees","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nvoid findMode(Node* r) {}\\nint main() { Node* r=new Node(1); r->r=new Node(2); r->r->l=new Node(2); findMode(r); return 0; }","expectedOutput":"2","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nint cnt[101]={};\\nvoid inorder(Node* r) { if(!r) return; inorder(r->l); cnt[r->v]++; inorder(r->r); }\\nvoid findMode(Node* r) { inorder(r); int mx=0; for(int i=0;i<101;i++) mx=max(mx,cnt[i]); for(int i=0;i<101;i++) if(cnt[i]==mx) cout<<i<<\\" \\"; }\\nint main() { Node* r=new Node(1); r->r=new Node(2); r->r->l=new Node(2); findMode(r); return 0; }","explanation":{"approach":"Count occurrences.","steps":["Inorder traversal","Find max frequency"],"complexity":"Time: O(n), Space: O(n)"}},{"id":"e610","title":"Lowest Common Ancestor BST","description":"LCA in BST.","difficulty":"MEDIUM","category":"Trees","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nNode* lowestCommonAncestor(Node* r, Node* p, Node* q) { return nullptr; }\\nint main() { Node* r=new Node(6); r->l=new Node(2); r->r=new Node(8); cout<<lowestCommonAncestor(r,r->l,r->r)->v; return 0; }","expectedOutput":"6","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nNode* lowestCommonAncestor(Node* r, Node* p, Node* q) { if(p->v<r->v && q->v<r->v) return lowestCommonAncestor(r->l,p,q); if(p->v>r->v && q->v>r->v) return lowestCommonAncestor(r->r,p,q); return r; }\\nint main() { Node* r=new Node(6); r->l=new Node(2); r->r=new Node(8); cout<<lowestCommonAncestor(r,r->l,r->r)->v; return 0; }","explanation":{"approach":"BST split point.","steps":["If both left, go left","If both right, go right","Else current is LCA"],"complexity":"Time: O(h), Space: O(h)"}}]'),PR=JSON.parse(`[{"id":"med1","title":"Two Sum Sorted","description":"Two pointers for sorted array.","difficulty":"MEDIUM","category":"Two Pointers","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid twoSum(int a[], int n, int t) {}\\nint main() { int a[]={2,7,11,15}; twoSum(a,4,9); return 0; }","expectedOutput":"0 1","solution":"#include <iostream>\\nusing namespace std;\\nvoid twoSum(int a[], int n, int t) { int l=0, r=n-1; while(l<r) { int s=a[l]+a[r]; if(s==t) { cout<<l<<\\" \\"<<r; return; } if(s<t) l++; else r--; } }\\nint main() { int a[]={2,7,11,15}; twoSum(a,4,9); return 0; }","explanation":{"approach":"Two pointers from both ends, adjust based on sum.","analogy":"Squeeze from both ends until you find the target.","steps":["If sum < target, move left pointer right","If sum > target, move right pointer left"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"med2","title":"Container With Most Water","description":"Max area between lines.","difficulty":"MEDIUM","category":"Two Pointers","starterCode":"#include <iostream>\\nusing namespace std;\\nint maxArea(int h[], int n) { return 0; }\\nint main() { int h[]={1,8,6,2,5,4,8,3,7}; cout<<maxArea(h,9); return 0; }","expectedOutput":"49","solution":"#include <iostream>\\nusing namespace std;\\nint maxArea(int h[], int n) { int l=0, r=n-1, mx=0; while(l<r) { int area=(r-l)*min(h[l],h[r]); mx=max(mx,area); if(h[l]<h[r]) l++; else r--; } return mx; }\\nint main() { int h[]={1,8,6,2,5,4,8,3,7}; cout<<maxArea(h,9); return 0; }","explanation":{"approach":"Two pointers, move shorter line inward.","analogy":"The shorter wall limits water height.","steps":["Calculate area","Move the shorter side inward"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"med3","title":"Three Sum","description":"Find triplets summing to target.","difficulty":"MEDIUM","category":"Two Pointers","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid threeSum(int a[], int n, int t) {}\\nint main() { int a[]={-1,0,1,2,-1,-4}; threeSum(a,6,0); return 0; }","expectedOutput":"-1 -1 2 -1 0 1","solution":"#include <iostream>\\nusing namespace std;\\nvoid threeSum(int a[], int n, int t) { for(int i=0;i<n-2;i++) for(int j=i+1;j<n-1;j++) for(int k=j+1;k<n;k++) if(a[i]+a[j]+a[k]==t) cout<<a[i]<<\\" \\"<<a[j]<<\\" \\"<<a[k]<<\\" \\"; }\\nint main() { int a[]={-1,0,1,2,-1,-4}; threeSum(a,6,0); return 0; }","explanation":{"approach":"Fix one element, use two sum on rest.","analogy":"Pick one, find pair in rest.","steps":["For each element, find two sum in remaining"],"complexity":"Time: O(n) brute, O(n) optimized, Space: O(1)"}},{"id":"med4","title":"Merge Sorted Arrays","description":"Merge two sorted arrays.","difficulty":"MEDIUM","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid merge(int a[], int m, int b[], int n, int c[]) {}\\nint main() { int a[]={1,3,5}, b[]={2,4,6}, c[6]; merge(a,3,b,3,c); for(int i=0;i<6;i++) cout<<c[i]<<(i<5?\\" \\":\\"\\"); return 0; }","expectedOutput":"1 2 3 4 5 6","solution":"#include <iostream>\\nusing namespace std;\\nvoid merge(int a[], int m, int b[], int n, int c[]) { int i=0,j=0,k=0; while(i<m && j<n) c[k++]= a[i]<b[j] ? a[i++] : b[j++]; while(i<m) c[k++]=a[i++]; while(j<n) c[k++]=b[j++]; }\\nint main() { int a[]={1,3,5}, b[]={2,4,6}, c[6]; merge(a,3,b,3,c); for(int i=0;i<6;i++) cout<<c[i]<<(i<5?\\" \\":\\"\\"); return 0; }","explanation":{"approach":"Two pointers, pick smaller each time.","analogy":"Merge two sorted decks of cards.","steps":["Compare front of both","Take smaller","Repeat"],"complexity":"Time: O(m+n), Space: O(m+n)"}},{"id":"med5","title":"Quick Sort","description":"Divide and conquer sort.","difficulty":"MEDIUM","category":"Sorting","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid quickSort(int a[], int l, int r) {}\\nint main() { int a[]={10,7,8,9,1,5}; quickSort(a,0,5); for(int i=0;i<6;i++) cout<<a[i]<<(i<5?\\" \\":\\"\\"); return 0; }","expectedOutput":"1 5 7 8 9 10","solution":"#include <iostream>\\nusing namespace std;\\nint partition(int a[], int l, int r) { int p=a[r], i=l-1; for(int j=l;j<r;j++) if(a[j]<p) { i++; swap(a[i],a[j]); } swap(a[i+1],a[r]); return i+1; }\\nvoid quickSort(int a[], int l, int r) { if(l<r) { int p=partition(a,l,r); quickSort(a,l,p-1); quickSort(a,p+1,r); } }\\nint main() { int a[]={10,7,8,9,1,5}; quickSort(a,0,5); for(int i=0;i<6;i++) cout<<a[i]<<(i<5?\\" \\":\\"\\"); return 0; }","explanation":{"approach":"Pick pivot, partition, recurse on halves.","analogy":"Put smaller on left, larger on right, repeat.","steps":["Choose pivot","Partition around it","Recurse"],"complexity":"Time: O(n log n) avg, Space: O(log n)"}},{"id":"med6","title":"Merge Sort","description":"Divide merge sort.","difficulty":"MEDIUM","category":"Sorting","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid mergeSort(int a[], int l, int r) {}\\nint main() { int a[]={12,11,13,5,6,7}; mergeSort(a,0,5); for(int i=0;i<6;i++) cout<<a[i]<<(i<5?\\" \\":\\"\\"); return 0; }","expectedOutput":"5 6 7 11 12 13","solution":"#include <iostream>\\nusing namespace std;\\nvoid merge(int a[], int l, int m, int r) { int n1=m-l+1, n2=r-m; int L[n1], R[n2]; for(int i=0;i<n1;i++) L[i]=a[l+i]; for(int i=0;i<n2;i++) R[i]=a[m+1+i]; int i=0,j=0,k=l; while(i<n1 && j<n2) a[k++]= L[i]<=R[j] ? L[i++] : R[j++]; while(i<n1) a[k++]=L[i++]; while(j<n2) a[k++]=R[j++]; }\\nvoid mergeSort(int a[], int l, int r) { if(l<r) { int m=(l+r)/2; mergeSort(a,l,m); mergeSort(a,m+1,r); merge(a,l,m,r); } }\\nint main() { int a[]={12,11,13,5,6,7}; mergeSort(a,0,5); for(int i=0;i<6;i++) cout<<a[i]<<(i<5?\\" \\":\\"\\"); return 0; }","explanation":{"approach":"Split in half, sort each, merge.","analogy":"Divide army, organize each half, combine.","steps":["Split in middle","Recursively sort","Merge sorted halves"],"complexity":"Time: O(n log n), Space: O(n)"}},{"id":"med7","title":"Kadane's Algorithm","description":"Maximum subarray sum.","difficulty":"MEDIUM","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint maxSubArray(int a[], int n) { return 0; }\\nint main() { int a[]={-2,1,-3,4,-1,2,1,-5,4}; cout<<maxSubArray(a,9); return 0; }","expectedOutput":"6","solution":"#include <iostream>\\nusing namespace std;\\nint maxSubArray(int a[], int n) { int mx=a[0], cur=a[0]; for(int i=1;i<n;i++) { cur=max(a[i], cur+a[i]); mx=max(mx, cur); } return mx; }\\nint main() { int a[]={-2,1,-3,4,-1,2,1,-5,4}; cout<<maxSubArray(a,9); return 0; }","explanation":{"approach":"Either start fresh or extend previous.","analogy":"Best profit streak - reset if going negative.","steps":["cur = max(current element, extend previous)","Track overall max"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"med8","title":"Longest Increasing Subsequence","description":"Length of LIS.","difficulty":"MEDIUM","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint lis(int a[], int n) { return 0; }\\nint main() { int a[]={10,9,2,5,3,7,101,18}; cout<<lis(a,8); return 0; }","expectedOutput":"4","solution":"#include <iostream>\\nusing namespace std;\\nint lis(int a[], int n) { int dp[n]; for(int i=0;i<n;i++) dp[i]=1; for(int i=1;i<n;i++) for(int j=0;j<i;j++) if(a[j]<a[i]) dp[i]=max(dp[i], dp[j]+1); int mx=0; for(int i=0;i<n;i++) mx=max(mx,dp[i]); return mx; }\\nint main() { int a[]={10,9,2,5,3,7,101,18}; cout<<lis(a,8); return 0; }","explanation":{"approach":"dp[i] = longest ending at i.","analogy":"Build sequence one element at a time.","steps":["For each element, check all before","If smaller, extend that sequence"],"complexity":"Time: O(n), Space: O(n)"}},{"id":"med9","title":"Coin Change","description":"Minimum coins for amount.","difficulty":"MEDIUM","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint coinChange(int coins[], int n, int amount) { return -1; }\\nint main() { int c[]={1,2,5}; cout<<coinChange(c,3,11); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nint coinChange(int coins[], int n, int amount) { int dp[amount+1]; for(int i=0;i<=amount;i++) dp[i]=amount+1; dp[0]=0; for(int i=1;i<=amount;i++) for(int j=0;j<n;j++) if(coins[j]<=i) dp[i]=min(dp[i], dp[i-coins[j]]+1); return dp[amount]>amount ? -1 : dp[amount]; }\\nint main() { int c[]={1,2,5}; cout<<coinChange(c,3,11); return 0; }","explanation":{"approach":"dp[i] = min coins for amount i.","analogy":"Build up from $0, try each coin.","steps":["For each amount, try each coin","Take minimum coins needed"],"complexity":"Time: O(amount  coins), Space: O(amount)"}},{"id":"med10","title":"Climbing Stairs","description":"Ways to climb n stairs.","difficulty":"MEDIUM","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint climbStairs(int n) { return 0; }\\nint main() { cout<<climbStairs(5); return 0; }","expectedOutput":"8","solution":"#include <iostream>\\nusing namespace std;\\nint climbStairs(int n) { if(n<=2) return n; int a=1, b=2; for(int i=3;i<=n;i++) { int c=a+b; a=b; b=c; } return b; }\\nint main() { cout<<climbStairs(5); return 0; }","explanation":{"approach":"Fibonacci pattern - ways(n) = ways(n-1) + ways(n-2).","analogy":"From step n-1 take 1 step, or from n-2 take 2.","steps":["Base: 1 or 2 steps","Each step = sum of previous two"],"complexity":"Time: O(n), Space: O(1)"}}]`),LR=JSON.parse(`[{"id":"m21","title":"Combination Sum","description":"Unique combinations summing to target.","difficulty":"MEDIUM","category":"Backtracking","starterCode":"#include <iostream>\\nusing namespace std;\\nint combinationSum(int candidates[], int n, int target) { return 0; }\\nint main() { int c[]={2,3,6,7}; cout << combinationSum(c,4,7); return 0; }","expectedOutput":"2","solution":"#include <iostream>\\nusing namespace std;\\nint cnt=0;\\nvoid solve(int c[], int n, int t, int start) { if(t==0) { cnt++; return; } for(int i=start;i<n&&c[i]<=t;i++) solve(c,n,t-c[i],i); }\\nint combinationSum(int c[], int n, int target) { cnt=0; for(int i=0;i<n-1;i++) for(int j=0;j<n-i-1;j++) if(c[j]>c[j+1]) swap(c[j],c[j+1]); solve(c,n,target,0); return cnt; }\\nint main() { int c[]={2,3,6,7}; cout << combinationSum(c,4,7); return 0; }","explanation":{"approach":"Backtracking with reuse.","steps":["Sort candidates","Recursively pick candidates >= start"],"complexity":"Time: O(2^t), Space: O(t)"}},{"id":"m22","title":"Combination Sum II","description":"Each number used once.","difficulty":"MEDIUM","category":"Backtracking","starterCode":"#include <iostream>\\nusing namespace std;\\nint combinationSum2(int candidates[], int n, int target) { return 0; }\\nint main() { int c[]={10,1,2,7,6,1,5}; cout << combinationSum2(c,7,8); return 0; }","expectedOutput":"4","solution":"#include <iostream>\\nusing namespace std;\\nint cnt=0;\\nvoid solve(int c[], int n, int t, int start) { if(t==0) { cnt++; return; } for(int i=start;i<n&&c[i]<=t;i++) { if(i>start&&c[i]==c[i-1]) continue; solve(c,n,t-c[i],i+1); } }\\nint combinationSum2(int c[], int n, int t) { cnt=0; for(int i=0;i<n-1;i++) for(int j=0;j<n-i-1;j++) if(c[j]>c[j+1]) swap(c[j],c[j+1]); solve(c,n,t,0); return cnt; }\\nint main() { int c[]={10,1,2,7,6,1,5}; cout << combinationSum2(c,7,8); return 0; }","explanation":{"approach":"Backtracking skip duplicates.","steps":["Sort","Skip same elements at same level"],"complexity":"Time: O(2^n), Space: O(n)"}},{"id":"m23","title":"Permutations","description":"All permutations of array.","difficulty":"MEDIUM","category":"Backtracking","starterCode":"#include <iostream>\\nusing namespace std;\\nint permute(int nums[], int n) { return 0; }\\nint main() { int nu[]={1,2,3}; cout << permute(nu,3); return 0; }","expectedOutput":"6","solution":"#include <iostream>\\nusing namespace std;\\nint cnt=0;\\nvoid solve(int nums[], int n, int start) { if(start==n) { cnt++; return; } for(int i=start;i<n;i++) { swap(nums[start],nums[i]); solve(nums,n,start+1); swap(nums[start],nums[i]); } }\\nint permute(int nums[], int n) { cnt=0; solve(nums,n,0); return cnt; }\\nint main() { int nu[]={1,2,3}; cout << permute(nu,3); return 0; }","explanation":{"approach":"Swap and recurse.","steps":["At each position, try all remaining","Backtrack by swapping back"],"complexity":"Time: O(n!), Space: O(n)"}},{"id":"m24","title":"Subsets","description":"All subsets of array.","difficulty":"MEDIUM","category":"Backtracking","starterCode":"#include <iostream>\\nusing namespace std;\\nint subsets(int nums[], int n) { return 0; }\\nint main() { int nu[]={1,2,3}; cout << subsets(nu,3); return 0; }","expectedOutput":"8","solution":"#include <iostream>\\nusing namespace std;\\nint subsets(int nums[], int n) { return 1<<n; }\\nint main() { int nu[]={1,2,3}; cout << subsets(nu,3); return 0; }","explanation":{"approach":"Power set = 2^n.","steps":["Each element included or not"],"complexity":"Time: O(2^n), Space: O(n)"}},{"id":"m25","title":"Word Search","description":"Find word in grid.","difficulty":"MEDIUM","category":"Backtracking","starterCode":"#include <iostream>\\nusing namespace std;\\nbool exist(char board[][4], int m, int n, char word[]) { return false; }\\nint main() { char b[][4]={{'A','B','C','E'},{'S','F','C','S'},{'A','D','E','E'}}; cout << exist(b,3,4,\\"ABCCED\\"); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool dfs(char b[][4],int m,int n,int i,int j,char w[],int k) { if(!w[k]) return true; if(i<0||i>=m||j<0||j>=n||b[i][j]!=w[k]) return false; char t=b[i][j]; b[i][j]='#'; bool f=dfs(b,m,n,i+1,j,w,k+1)||dfs(b,m,n,i-1,j,w,k+1)||dfs(b,m,n,i,j+1,w,k+1)||dfs(b,m,n,i,j-1,w,k+1); b[i][j]=t; return f; }\\nbool exist(char b[][4], int m, int n, char w[]) { for(int i=0;i<m;i++) for(int j=0;j<n;j++) if(dfs(b,m,n,i,j,w,0)) return true; return false; }\\nint main() { char b[][4]={{'A','B','C','E'},{'S','F','C','S'},{'A','D','E','E'}}; cout << exist(b,3,4,\\"ABCCED\\"); return 0; }","explanation":{"approach":"DFS with backtracking.","steps":["Try starting from each cell","Mark visited, explore 4 directions"],"complexity":"Time: O(mn4^L), Space: O(L)"}},{"id":"m26","title":"Restore IP Addresses","description":"All valid IP addresses.","difficulty":"MEDIUM","category":"Backtracking","starterCode":"#include <iostream>\\nusing namespace std;\\nint restoreIpAddresses(char s[]) { return 0; }\\nint main() { cout << restoreIpAddresses(\\"25525511135\\"); return 0; }","expectedOutput":"2","solution":"#include <iostream>\\nusing namespace std;\\nint cnt=0;\\nvoid solve(char s[], int start, int parts) { if(parts==4) { if(!s[start]) cnt++; return; } for(int len=1;len<=3&&s[start+len-1];len++) { int val=0; for(int i=0;i<len;i++) val=val*10+s[start+i]-'0'; if(val>255) break; if(len>1&&s[start]=='0') break; solve(s,start+len,parts+1); } }\\nint restoreIpAddresses(char s[]) { cnt=0; solve(s,0,0); return cnt; }\\nint main() { cout << restoreIpAddresses(\\"25525511135\\"); return 0; }","explanation":{"approach":"Try 1-3 digit segments.","steps":["For each part, try 1-3 digits","Validate 0-255"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"m27","title":"Generate Parentheses","description":"All valid n pairs.","difficulty":"MEDIUM","category":"Backtracking","starterCode":"#include <iostream>\\nusing namespace std;\\nint generateParenthesis(int n) { return 0; }\\nint main() { cout << generateParenthesis(3); return 0; }","expectedOutput":"5","solution":"#include <iostream>\\nusing namespace std;\\nint cnt=0;\\nvoid gen(int open, int close, int n) { if(open==n&&close==n) { cnt++; return; } if(open<n) gen(open+1,close,n); if(close<open) gen(open,close+1,n); }\\nint generateParenthesis(int n) { cnt=0; gen(0,0,n); return cnt; }\\nint main() { cout << generateParenthesis(3); return 0; }","explanation":{"approach":"Track open and close counts.","steps":["Add ( if open < n","Add ) if close < open"],"complexity":"Time: O(4^n/n), Space: O(n)"}},{"id":"m28","title":"Letter Combinations","description":"Phone number letter combos.","difficulty":"MEDIUM","category":"Backtracking","starterCode":"#include <iostream>\\nusing namespace std;\\nint letterCombinations(char digits[]) { return 0; }\\nint main() { cout << letterCombinations(\\"23\\"); return 0; }","expectedOutput":"9","solution":"#include <iostream>\\nusing namespace std;\\nchar* map[]={\\"abc\\",\\"def\\",\\"ghi\\",\\"jkl\\",\\"mno\\",\\"pqrs\\",\\"tuv\\",\\"wxyz\\"};\\nint cnt=0;\\nvoid solve(char d[], int i) { if(!d[i]) { cnt++; return; } char* letters=map[d[i]-'2']; for(int j=0;letters[j];j++) solve(d,i+1); }\\nint letterCombinations(char d[]) { if(!d[0]) return 0; cnt=0; solve(d,0); return cnt; }\\nint main() { cout << letterCombinations(\\"23\\"); return 0; }","explanation":{"approach":"Map digits to letters, recurse.","steps":["For each digit, try all mapped letters"],"complexity":"Time: O(4^n), Space: O(n)"}},{"id":"m29","title":"Sudoku Solver","description":"Solve sudoku puzzle.","difficulty":"HARD","category":"Backtracking","starterCode":"#include <iostream>\\nusing namespace std;\\nbool solveSudoku(int board[][9]) { return false; }\\nint main() { cout << 1; return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isValid(int b[][9],int r,int c,int n) { for(int i=0;i<9;i++) if(b[r][i]==n||b[i][c]==n) return false; int sr=(r/3)*3,sc=(c/3)*3; for(int i=0;i<3;i++) for(int j=0;j<3;j++) if(b[sr+i][sc+j]==n) return false; return true; }\\nbool solve(int b[][9]) { for(int i=0;i<9;i++) for(int j=0;j<9;j++) if(b[i][j]==0) { for(int n=1;n<=9;n++) if(isValid(b,i,j,n)) { b[i][j]=n; if(solve(b)) return true; b[i][j]=0; } return false; } return true; }\\nbool solveSudoku(int b[][9]) { return solve(b); }\\nint main() { cout << 1; return 0; }","explanation":{"approach":"Backtracking with constraint check.","steps":["Find empty cell","Try 1-9, backtrack if invalid"],"complexity":"Time: O(9^81), Space: O(81)"}},{"id":"m30","title":"N-Queens Count","description":"Count valid placements.","difficulty":"HARD","category":"Backtracking","starterCode":"#include <iostream>\\nusing namespace std;\\nint totalNQueens(int n) { return 0; }\\nint main() { cout << totalNQueens(4); return 0; }","expectedOutput":"2","solution":"#include <iostream>\\nusing namespace std;\\nint cnt; bool col[10],d1[20],d2[20];\\nvoid solve(int r, int n) { if(r==n) { cnt++; return; } for(int c=0;c<n;c++) if(!col[c]&&!d1[r-c+n]&&!d2[r+c]) { col[c]=d1[r-c+n]=d2[r+c]=true; solve(r+1,n); col[c]=d1[r-c+n]=d2[r+c]=false; } }\\nint totalNQueens(int n) { cnt=0; solve(0,n); return cnt; }\\nint main() { cout << totalNQueens(4); return 0; }","explanation":{"approach":"Track columns and diagonals.","steps":["Place queen if safe","Backtrack"],"complexity":"Time: O(n!), Space: O(n)"}}]`),UR=JSON.parse(`[{"id":"m31","title":"Rotate Image","description":"Rotate matrix 90 degrees.","difficulty":"MEDIUM","category":"Matrix","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid rotate(int m[][3], int n) {}\\nint main() { int m[][3]={{1,2,3},{4,5,6},{7,8,9}}; rotate(m,3); for(int i=0;i<3;i++) { for(int j=0;j<3;j++) cout<<m[i][j]<<\\" \\"; } return 0; }","expectedOutput":"7 4 1 8 5 2 9 6 3","solution":"#include <iostream>\\nusing namespace std;\\nvoid rotate(int m[][3], int n) { for(int i=0;i<n;i++) for(int j=i+1;j<n;j++) swap(m[i][j],m[j][i]); for(int i=0;i<n;i++) for(int j=0;j<n/2;j++) swap(m[i][j],m[i][n-1-j]); }\\nint main() { int m[][3]={{1,2,3},{4,5,6},{7,8,9}}; rotate(m,3); for(int i=0;i<3;i++) { for(int j=0;j<3;j++) cout<<m[i][j]<<\\" \\"; } return 0; }","explanation":{"approach":"Transpose then reverse rows.","steps":["Transpose matrix","Reverse each row"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"m32","title":"Set Matrix Zeroes","description":"Mark entire row/col as zero.","difficulty":"MEDIUM","category":"Matrix","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid setZeroes(int m[][3], int r, int c) {}\\nint main() { int m[][3]={{1,1,1},{1,0,1},{1,1,1}}; setZeroes(m,3,3); for(int i=0;i<3;i++) for(int j=0;j<3;j++) cout<<m[i][j]<<\\" \\"; return 0; }","expectedOutput":"1 0 1 0 0 0 1 0 1","solution":"#include <iostream>\\nusing namespace std;\\nvoid setZeroes(int m[][3], int r, int c) { bool zeroR[10]={},zeroC[10]={}; for(int i=0;i<r;i++) for(int j=0;j<c;j++) if(m[i][j]==0) { zeroR[i]=true; zeroC[j]=true; } for(int i=0;i<r;i++) for(int j=0;j<c;j++) if(zeroR[i]||zeroC[j]) m[i][j]=0; }\\nint main() { int m[][3]={{1,1,1},{1,0,1},{1,1,1}}; setZeroes(m,3,3); for(int i=0;i<3;i++) for(int j=0;j<3;j++) cout<<m[i][j]<<\\" \\"; return 0; }","explanation":{"approach":"Mark rows and cols to zero.","steps":["Find zeros, mark rows/cols","Set marked rows/cols to zero"],"complexity":"Time: O(mn), Space: O(m+n)"}},{"id":"m33","title":"Spiral Matrix","description":"Return elements in spiral.","difficulty":"MEDIUM","category":"Matrix","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid spiralOrder(int m[][3], int r, int c) {}\\nint main() { int m[][3]={{1,2,3},{4,5,6},{7,8,9}}; spiralOrder(m,3,3); return 0; }","expectedOutput":"1 2 3 6 9 8 7 4 5","solution":"#include <iostream>\\nusing namespace std;\\nvoid spiralOrder(int m[][3], int r, int c) { int t=0,b=r-1,l=0,ri=c-1; while(t<=b&&l<=ri) { for(int i=l;i<=ri;i++) cout<<m[t][i]<<\\" \\"; t++; for(int i=t;i<=b;i++) cout<<m[i][ri]<<\\" \\"; ri--; if(t<=b) { for(int i=ri;i>=l;i--) cout<<m[b][i]<<\\" \\"; b--; } if(l<=ri) { for(int i=b;i>=t;i--) cout<<m[i][l]<<\\" \\"; l++; } } }\\nint main() { int m[][3]={{1,2,3},{4,5,6},{7,8,9}}; spiralOrder(m,3,3); return 0; }","explanation":{"approach":"Layer by layer traversal.","steps":["Maintain top, bottom, left, right","Process each layer"],"complexity":"Time: O(mn), Space: O(1)"}},{"id":"m34","title":"Search 2D Matrix","description":"Search in row/col sorted matrix.","difficulty":"MEDIUM","category":"Matrix","starterCode":"#include <iostream>\\nusing namespace std;\\nbool searchMatrix(int m[][4], int r, int c, int t) { return false; }\\nint main() { int m[][4]={{1,3,5,7},{10,11,16,20},{23,30,34,60}}; cout << searchMatrix(m,3,4,3); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool searchMatrix(int m[][4], int r, int c, int t) { int lo=0,hi=r*c-1; while(lo<=hi) { int mid=(lo+hi)/2; int v=m[mid/c][mid%c]; if(v==t) return true; if(v<t) lo=mid+1; else hi=mid-1; } return false; }\\nint main() { int m[][4]={{1,3,5,7},{10,11,16,20},{23,30,34,60}}; cout << searchMatrix(m,3,4,3); return 0; }","explanation":{"approach":"Binary search treating as 1D.","steps":["Map index to (row, col)","Binary search"],"complexity":"Time: O(log(mn)), Space: O(1)"}},{"id":"m35","title":"Word Search","description":"Find word in grid.","difficulty":"MEDIUM","category":"Matrix","starterCode":"#include <iostream>\\nusing namespace std;\\nbool exist(char b[][4], int m, int n, char w[]) { return false; }\\nint main() { char b[][4]={{'A','B','C','E'},{'S','F','C','S'},{'A','D','E','E'}}; cout << exist(b,3,4,\\"SEE\\"); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool dfs(char b[][4],int m,int n,int i,int j,char w[],int k) { if(!w[k]) return true; if(i<0||i>=m||j<0||j>=n||b[i][j]!=w[k]) return false; char t=b[i][j]; b[i][j]='#'; bool f=dfs(b,m,n,i+1,j,w,k+1)||dfs(b,m,n,i-1,j,w,k+1)||dfs(b,m,n,i,j+1,w,k+1)||dfs(b,m,n,i,j-1,w,k+1); b[i][j]=t; return f; }\\nbool exist(char b[][4],int m,int n,char w[]) { for(int i=0;i<m;i++) for(int j=0;j<n;j++) if(dfs(b,m,n,i,j,w,0)) return true; return false; }\\nint main() { char b[][4]={{'A','B','C','E'},{'S','F','C','S'},{'A','D','E','E'}}; cout << exist(b,3,4,\\"SEE\\"); return 0; }","explanation":{"approach":"DFS with backtracking.","steps":["Try each cell as start","DFS in 4 directions"],"complexity":"Time: O(mn4^L), Space: O(L)"}},{"id":"m36","title":"Reverse Linked List II","description":"Reverse between positions.","difficulty":"MEDIUM","category":"Linked List","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node* n; Node(int x):v(x),n(0){} };\\nNode* reverseBetween(Node* h, int l, int r) { return nullptr; }\\nint main() { Node* h=new Node(1); h->n=new Node(2); h->n->n=new Node(3); h->n->n->n=new Node(4); h->n->n->n->n=new Node(5); h=reverseBetween(h,2,4); while(h) { cout<<h->v<<\\" \\"; h=h->n; } return 0; }","expectedOutput":"1 4 3 2 5","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node* n; Node(int x):v(x),n(0){} };\\nNode* reverseBetween(Node* h, int l, int r) { Node d(0); d.n=h; Node* pre=&d; for(int i=1;i<l;i++) pre=pre->n; Node* cur=pre->n; for(int i=0;i<r-l;i++) { Node* t=cur->n; cur->n=t->n; t->n=pre->n; pre->n=t; } return d.n; }\\nint main() { Node* h=new Node(1); h->n=new Node(2); h->n->n=new Node(3); h->n->n->n=new Node(4); h->n->n->n->n=new Node(5); h=reverseBetween(h,2,4); while(h) { cout<<h->v<<\\" \\"; h=h->n; } return 0; }","explanation":{"approach":"Move nodes to front of segment.","steps":["Find node before l","Move each node to front"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"m37","title":"Copy List Random","description":"Deep copy with random pointer.","difficulty":"MEDIUM","category":"Linked List","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *n, *r; Node(int x):v(x),n(0),r(0){} };\\nNode* copyRandomList(Node* h) { return nullptr; }\\nint main() { cout << \\"OK\\"; return 0; }","expectedOutput":"OK","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *n, *r; Node(int x):v(x),n(0),r(0){} };\\nNode* copyRandomList(Node* h) { if(!h) return 0; Node* cur=h; while(cur) { Node* copy=new Node(cur->v); copy->n=cur->n; cur->n=copy; cur=copy->n; } cur=h; while(cur) { if(cur->r) cur->n->r=cur->r->n; cur=cur->n->n; } Node* newH=h->n; cur=h; while(cur) { Node* copy=cur->n; cur->n=copy->n; cur=cur->n; if(copy->n) copy->n=copy->n->n; } return newH; }\\nint main() { cout << \\"OK\\"; return 0; }","explanation":{"approach":"Interleave copies, then separate.","steps":["Insert copies after originals","Set random pointers","Separate lists"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"m38","title":"Add Two Numbers","description":"Add two numbers as linked lists.","difficulty":"MEDIUM","category":"Linked List","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node* n; Node(int x):v(x),n(0){} };\\nNode* addTwoNumbers(Node* l1, Node* l2) { return nullptr; }\\nint main() { Node* l1=new Node(2); l1->n=new Node(4); l1->n->n=new Node(3); Node* l2=new Node(5); l2->n=new Node(6); l2->n->n=new Node(4); Node* r=addTwoNumbers(l1,l2); while(r) { cout<<r->v; r=r->n; } return 0; }","expectedOutput":"708","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node* n; Node(int x):v(x),n(0){} };\\nNode* addTwoNumbers(Node* l1, Node* l2) { Node d(0),*t=&d; int c=0; while(l1||l2||c) { int s=c; if(l1) { s+=l1->v; l1=l1->n; } if(l2) { s+=l2->v; l2=l2->n; } c=s/10; t->n=new Node(s%10); t=t->n; } return d.n; }\\nint main() { Node* l1=new Node(2); l1->n=new Node(4); l1->n->n=new Node(3); Node* l2=new Node(5); l2->n=new Node(6); l2->n->n=new Node(4); Node* r=addTwoNumbers(l1,l2); while(r) { cout<<r->v; r=r->n; } return 0; }","explanation":{"approach":"Add digit by digit with carry.","steps":["Traverse both lists","Add digits and carry","Create result node"],"complexity":"Time: O(max(m,n)), Space: O(max(m,n))"}},{"id":"m39","title":"Remove Nth From End","description":"Remove nth node from end.","difficulty":"MEDIUM","category":"Linked List","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node* n; Node(int x):v(x),n(0){} };\\nNode* removeNthFromEnd(Node* h, int n) { return nullptr; }\\nint main() { Node* h=new Node(1); h->n=new Node(2); h->n->n=new Node(3); h->n->n->n=new Node(4); h->n->n->n->n=new Node(5); h=removeNthFromEnd(h,2); while(h) { cout<<h->v<<\\" \\"; h=h->n; } return 0; }","expectedOutput":"1 2 3 5","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node* n; Node(int x):v(x),n(0){} };\\nNode* removeNthFromEnd(Node* h, int n) { Node d(0); d.n=h; Node *f=&d,*s=&d; for(int i=0;i<=n;i++) f=f->n; while(f) { f=f->n; s=s->n; } s->n=s->n->n; return d.n; }\\nint main() { Node* h=new Node(1); h->n=new Node(2); h->n->n=new Node(3); h->n->n->n=new Node(4); h->n->n->n->n=new Node(5); h=removeNthFromEnd(h,2); while(h) { cout<<h->v<<\\" \\"; h=h->n; } return 0; }","explanation":{"approach":"Two pointers n apart.","steps":["Move fast n+1 ahead","Move both until fast reaches end","Remove slow.next"],"complexity":"Time: O(L), Space: O(1)"}},{"id":"m40","title":"Partition List","description":"Partition around value x.","difficulty":"MEDIUM","category":"Linked List","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node* n; Node(int x):v(x),n(0){} };\\nNode* partition(Node* h, int x) { return nullptr; }\\nint main() { Node* h=new Node(1); h->n=new Node(4); h->n->n=new Node(3); h->n->n->n=new Node(2); h->n->n->n->n=new Node(5); h->n->n->n->n->n=new Node(2); h=partition(h,3); while(h) { cout<<h->v<<\\" \\"; h=h->n; } return 0; }","expectedOutput":"1 2 2 4 3 5","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node* n; Node(int x):v(x),n(0){} };\\nNode* partition(Node* h, int x) { Node less(0),greater(0); Node *l=&less, *g=&greater; while(h) { if(h->v<x) { l->n=h; l=l->n; } else { g->n=h; g=g->n; } h=h->n; } g->n=0; l->n=greater.n; return less.n; }\\nint main() { Node* h=new Node(1); h->n=new Node(4); h->n->n=new Node(3); h->n->n->n=new Node(2); h->n->n->n->n=new Node(5); h->n->n->n->n->n=new Node(2); h=partition(h,3); while(h) { cout<<h->v<<\\" \\"; h=h->n; } return 0; }","explanation":{"approach":"Two lists: less and greater.","steps":["Build two lists","Connect less to greater"],"complexity":"Time: O(n), Space: O(1)"}}]`),BR=JSON.parse('[{"id":"med31","title":"Swap Nodes in Pairs","description":"Swap adjacent nodes.","difficulty":"MEDIUM","category":"Linked List","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node* n; Node(int x):v(x),n(0){} };\\nNode* swapPairs(Node* h) { return nullptr; }\\nint main() { Node* h=new Node(1); h->n=new Node(2); h->n->n=new Node(3); h->n->n->n=new Node(4); h=swapPairs(h); while(h) { cout<<h->v<<\\" \\"; h=h->n; } return 0; }","expectedOutput":"2 1 4 3","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node* n; Node(int x):v(x),n(0){} };\\nNode* swapPairs(Node* h) { Node d(0); d.n=h; Node* p=&d; while(p->n && p->n->n) { Node* a=p->n, *b=p->n->n; a->n=b->n; b->n=a; p->n=b; p=a; } return d.n; }\\nint main() { Node* h=new Node(1); h->n=new Node(2); h->n->n=new Node(3); h->n->n->n=new Node(4); h=swapPairs(h); while(h) { cout<<h->v<<\\" \\"; h=h->n; } return 0; }","explanation":{"approach":"Swap pairs iteratively.","analogy":"Swap two at a time.","steps":["Get pair (a,b)","Reconnect: prevbanext","Move p to a"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"med32","title":"Sort List","description":"Sort linked list.","difficulty":"MEDIUM","category":"Linked List","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node* n; Node(int x):v(x),n(0){} };\\nNode* sortList(Node* h) { return nullptr; }\\nint main() { Node* h=new Node(4); h->n=new Node(2); h->n->n=new Node(1); h->n->n->n=new Node(3); h=sortList(h); while(h) { cout<<h->v<<\\" \\"; h=h->n; } return 0; }","expectedOutput":"1 2 3 4","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node* n; Node(int x):v(x),n(0){} };\\nNode* merge(Node* a, Node* b) { Node d(0),*t=&d; while(a&&b) { if(a->v<b->v) { t->n=a; a=a->n; } else { t->n=b; b=b->n; } t=t->n; } t->n=a?a:b; return d.n; }\\nNode* sortList(Node* h) { if(!h||!h->n) return h; Node* s=h,*f=h,*p=0; while(f&&f->n) { p=s; s=s->n; f=f->n->n; } p->n=0; return merge(sortList(h),sortList(s)); }\\nint main() { Node* h=new Node(4); h->n=new Node(2); h->n->n=new Node(1); h->n->n->n=new Node(3); h=sortList(h); while(h) { cout<<h->v<<\\" \\"; h=h->n; } return 0; }","explanation":{"approach":"Merge sort for linked list.","analogy":"Divide at middle, merge sorted halves.","steps":["Find middle","Split list","Recursively sort","Merge"],"complexity":"Time: O(n log n), Space: O(log n)"}},{"id":"med33","title":"Reorder List","description":"Reorder L0LnL1Ln-1...","difficulty":"MEDIUM","category":"Linked List","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node* n; Node(int x):v(x),n(0){} };\\nvoid reorderList(Node* h) {}\\nint main() { Node* h=new Node(1); h->n=new Node(2); h->n->n=new Node(3); h->n->n->n=new Node(4); reorderList(h); while(h) { cout<<h->v<<\\" \\"; h=h->n; } return 0; }","expectedOutput":"1 4 2 3","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node* n; Node(int x):v(x),n(0){} };\\nvoid reorderList(Node* h) { if(!h||!h->n) return; Node* s=h,*f=h; while(f->n&&f->n->n) { s=s->n; f=f->n->n; } Node* sec=s->n; s->n=0; Node* p=0; while(sec) { Node* t=sec->n; sec->n=p; p=sec; sec=t; } Node* f1=h,*f2=p; while(f2) { Node* t1=f1->n,*t2=f2->n; f1->n=f2; f2->n=t1; f1=t1; f2=t2; } }\\nint main() { Node* h=new Node(1); h->n=new Node(2); h->n->n=new Node(3); h->n->n->n=new Node(4); reorderList(h); while(h) { cout<<h->v<<\\" \\"; h=h->n; } return 0; }","explanation":{"approach":"Split, reverse second half, merge alternately.","analogy":"Interleave first half with reversed second.","steps":["Find middle","Reverse second half","Merge alternately"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"med34","title":"Validate BST","description":"Check if valid BST.","difficulty":"MEDIUM","category":"Trees","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nbool isValidBST(Node* r) { return false; }\\nint main() { Node* r=new Node(2); r->l=new Node(1); r->r=new Node(3); cout<<isValidBST(r); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nbool valid(Node* r, long mn, long mx) { if(!r) return true; if(r->v<=mn||r->v>=mx) return false; return valid(r->l,mn,r->v)&&valid(r->r,r->v,mx); }\\nbool isValidBST(Node* r) { return valid(r,LONG_MIN,LONG_MAX); }\\nint main() { Node* r=new Node(2); r->l=new Node(1); r->r=new Node(3); cout<<isValidBST(r); return 0; }","explanation":{"approach":"Track valid range at each node.","analogy":"Each node has min/max constraints.","steps":["Pass min/max bounds","Left updates max, right updates min"],"complexity":"Time: O(n), Space: O(h)"}},{"id":"med35","title":"Flatten Binary Tree","description":"Flatten to linked list.","difficulty":"MEDIUM","category":"Trees","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nvoid flatten(Node* r) {}\\nint main() { Node* r=new Node(1); r->l=new Node(2); r->r=new Node(5); r->l->l=new Node(3); r->l->r=new Node(4); r->r->r=new Node(6); flatten(r); while(r) { cout<<r->v<<\\" \\"; r=r->r; } return 0; }","expectedOutput":"1 2 3 4 5 6","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nvoid flatten(Node* r) { while(r) { if(r->l) { Node* p=r->l; while(p->r) p=p->r; p->r=r->r; r->r=r->l; r->l=0; } r=r->r; } }\\nint main() { Node* r=new Node(1); r->l=new Node(2); r->r=new Node(5); r->l->l=new Node(3); r->l->r=new Node(4); r->r->r=new Node(6); flatten(r); while(r) { cout<<r->v<<\\" \\"; r=r->r; } return 0; }","explanation":{"approach":"Move left subtree to right, attach old right to end.","analogy":"Flatten preorder to right pointers.","steps":["Find rightmost of left subtree","Attach right subtree there","Move left to right"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"med36","title":"Binary Tree Right View","description":"Nodes visible from right.","difficulty":"MEDIUM","category":"Trees","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nvoid rightView(Node* r) {}\\nint main() { Node* r=new Node(1); r->l=new Node(2); r->r=new Node(3); r->l->r=new Node(5); r->r->r=new Node(4); rightView(r); return 0; }","expectedOutput":"1 3 4","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nint maxLevel=-1;\\nvoid solve(Node* r, int lv) { if(!r) return; if(lv>maxLevel) { cout<<r->v<<\\" \\"; maxLevel=lv; } solve(r->r,lv+1); solve(r->l,lv+1); }\\nvoid rightView(Node* r) { maxLevel=-1; solve(r,0); }\\nint main() { Node* r=new Node(1); r->l=new Node(2); r->r=new Node(3); r->l->r=new Node(5); r->r->r=new Node(4); rightView(r); return 0; }","explanation":{"approach":"First node at each level from right.","analogy":"Visit right before left.","steps":["Track max level seen","Print if new level","Go right first"],"complexity":"Time: O(n), Space: O(h)"}},{"id":"med37","title":"Kth Smallest in BST","description":"Find kth smallest element.","difficulty":"MEDIUM","category":"Trees","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nint kthSmallest(Node* r, int k) { return 0; }\\nint main() { Node* r=new Node(3); r->l=new Node(1); r->r=new Node(4); r->l->r=new Node(2); cout<<kthSmallest(r,1); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nint cnt,result;\\nvoid inorder(Node* r, int k) { if(!r) return; inorder(r->l,k); if(++cnt==k) { result=r->v; return; } inorder(r->r,k); }\\nint kthSmallest(Node* r, int k) { cnt=0; result=0; inorder(r,k); return result; }\\nint main() { Node* r=new Node(3); r->l=new Node(1); r->r=new Node(4); r->l->r=new Node(2); cout<<kthSmallest(r,1); return 0; }","explanation":{"approach":"Inorder gives sorted order.","analogy":"Count nodes in inorder.","steps":["Inorder traversal","Count until k"],"complexity":"Time: O(h+k), Space: O(h)"}},{"id":"med38","title":"Construct BST from Preorder","description":"Build BST from preorder.","difficulty":"MEDIUM","category":"Trees","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nNode* buildBST(int pre[], int n) { return nullptr; }\\nvoid inorder(Node* r) { if(!r) return; inorder(r->l); cout<<r->v<<\\" \\"; inorder(r->r); }\\nint main() { int pre[]={8,5,1,7,10,12}; Node* r=buildBST(pre,6); inorder(r); return 0; }","expectedOutput":"1 5 7 8 10 12","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nint idx=0;\\nNode* build(int pre[], int n, int mn, int mx) { if(idx>=n||pre[idx]<mn||pre[idx]>mx) return 0; Node* r=new Node(pre[idx++]); r->l=build(pre,n,mn,r->v); r->r=build(pre,n,r->v,mx); return r; }\\nNode* buildBST(int pre[], int n) { idx=0; return build(pre,n,INT_MIN,INT_MAX); }\\nvoid inorder(Node* r) { if(!r) return; inorder(r->l); cout<<r->v<<\\" \\"; inorder(r->r); }\\nint main() { int pre[]={8,5,1,7,10,12}; Node* r=buildBST(pre,6); inorder(r); return 0; }","explanation":{"approach":"Use bounds to determine subtree.","analogy":"Each node has valid range.","steps":["If value in range, create node","Recurse with updated bounds"],"complexity":"Time: O(n), Space: O(h)"}},{"id":"med39","title":"Course Schedule","description":"Can finish all courses.","difficulty":"MEDIUM","category":"Graph","starterCode":"#include <iostream>\\nusing namespace std;\\nbool canFinish(int n, int pre[][2], int m) { return false; }\\nint main() { int pre[][2]={{1,0},{0,1}}; cout<<canFinish(2,pre,2); return 0; }","expectedOutput":"0","solution":"#include <iostream>\\nusing namespace std;\\nint adj[100][100],deg[100],sz[100];\\nbool canFinish(int n, int pre[][2], int m) { for(int i=0;i<n;i++) { sz[i]=0; deg[i]=0; } for(int i=0;i<m;i++) { adj[pre[i][1]][sz[pre[i][1]]++]=pre[i][0]; deg[pre[i][0]]++; } int q[100],f=0,r=0,cnt=0; for(int i=0;i<n;i++) if(deg[i]==0) q[r++]=i; while(f<r) { int u=q[f++]; cnt++; for(int i=0;i<sz[u];i++) if(--deg[adj[u][i]]==0) q[r++]=adj[u][i]; } return cnt==n; }\\nint main() { int pre[][2]={{1,0},{0,1}}; cout<<canFinish(2,pre,2); return 0; }","explanation":{"approach":"Topological sort - detect cycle.","analogy":"No cycle means can finish all.","steps":["Build graph and in-degrees","BFS from zero-degree nodes","Check if all visited"],"complexity":"Time: O(V+E), Space: O(V+E)"}},{"id":"med40","title":"Number of Islands","description":"Count connected 1s.","difficulty":"MEDIUM","category":"Graph","starterCode":"#include <iostream>\\nusing namespace std;\\nint numIslands(int g[][5], int r, int c) { return 0; }\\nint main() { int g[][5]={{1,1,0,0,0},{1,1,0,0,0},{0,0,1,0,0},{0,0,0,1,1}}; cout<<numIslands(g,4,5); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nvoid dfs(int g[][5], int r, int c, int i, int j) { if(i<0||i>=r||j<0||j>=c||g[i][j]!=1) return; g[i][j]=0; dfs(g,r,c,i+1,j); dfs(g,r,c,i-1,j); dfs(g,r,c,i,j+1); dfs(g,r,c,i,j-1); }\\nint numIslands(int g[][5], int r, int c) { int cnt=0; for(int i=0;i<r;i++) for(int j=0;j<c;j++) if(g[i][j]==1) { cnt++; dfs(g,r,c,i,j); } return cnt; }\\nint main() { int g[][5]={{1,1,0,0,0},{1,1,0,0,0},{0,0,1,0,0},{0,0,0,1,1}}; cout<<numIslands(g,4,5); return 0; }","explanation":{"approach":"DFS to mark connected land.","analogy":"Flood fill each island.","steps":["For each 1, increment count","DFS to mark all connected as visited"],"complexity":"Time: O(rc), Space: O(rc)"}}]'),zR=JSON.parse(`[{"id":"med41","title":"Clone Graph","description":"Deep copy of graph.","difficulty":"MEDIUM","category":"Graph","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node* adj[10]; int sz; Node(int x):v(x),sz(0){} };\\nNode* cloneGraph(Node* n) { return nullptr; }\\nint main() { cout<<\\"Graph cloned\\"; return 0; }","expectedOutput":"Graph cloned","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node* adj[10]; int sz; Node(int x):v(x),sz(0){} };\\nNode* visited[101]={};\\nNode* cloneGraph(Node* n) { if(!n) return 0; if(visited[n->v]) return visited[n->v]; Node* c=new Node(n->v); visited[n->v]=c; for(int i=0;i<n->sz;i++) c->adj[c->sz++]=cloneGraph(n->adj[i]); return c; }\\nint main() { cout<<\\"Graph cloned\\"; return 0; }","explanation":{"approach":"DFS with visited map.","analogy":"Clone each node once.","steps":["Check if already cloned","Create clone","Recurse on neighbors"],"complexity":"Time: O(V+E), Space: O(V)"}},{"id":"med42","title":"Pacific Atlantic Water","description":"Cells flowing to both oceans.","difficulty":"MEDIUM","category":"Graph","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid pacificAtlantic(int h[][5], int r, int c) {}\\nint main() { int h[][5]={{1,2,2,3,5},{3,2,3,4,4},{2,4,5,3,1},{6,7,1,4,5},{5,1,1,2,4}}; pacificAtlantic(h,5,5); return 0; }","expectedOutput":"0,4 1,3 1,4 2,2 3,0 3,1 4,0","solution":"#include <iostream>\\nusing namespace std;\\nbool pac[10][10],atl[10][10];\\nvoid dfs(int h[][5], int r, int c, int i, int j, bool vis[][10], int prev) { if(i<0||i>=r||j<0||j>=c||vis[i][j]||h[i][j]<prev) return; vis[i][j]=true; dfs(h,r,c,i+1,j,vis,h[i][j]); dfs(h,r,c,i-1,j,vis,h[i][j]); dfs(h,r,c,i,j+1,vis,h[i][j]); dfs(h,r,c,i,j-1,vis,h[i][j]); }\\nvoid pacificAtlantic(int h[][5], int r, int c) { for(int i=0;i<r;i++) for(int j=0;j<c;j++) { pac[i][j]=atl[i][j]=false; } for(int i=0;i<r;i++) { dfs(h,r,c,i,0,pac,0); dfs(h,r,c,i,c-1,atl,0); } for(int j=0;j<c;j++) { dfs(h,r,c,0,j,pac,0); dfs(h,r,c,r-1,j,atl,0); } for(int i=0;i<r;i++) for(int j=0;j<c;j++) if(pac[i][j]&&atl[i][j]) cout<<i<<\\",\\"<<j<<\\" \\"; }\\nint main() { int h[][5]={{1,2,2,3,5},{3,2,3,4,4},{2,4,5,3,1},{6,7,1,4,5},{5,1,1,2,4}}; pacificAtlantic(h,5,5); return 0; }","explanation":{"approach":"DFS from ocean edges inward.","analogy":"Reverse flow from oceans.","steps":["DFS from Pacific edges","DFS from Atlantic edges","Find intersection"],"complexity":"Time: O(rc), Space: O(rc)"}},{"id":"med43","title":"Rotting Oranges","description":"Time for all oranges to rot.","difficulty":"MEDIUM","category":"BFS","starterCode":"#include <iostream>\\nusing namespace std;\\nint orangesRotting(int g[][3], int r, int c) { return 0; }\\nint main() { int g[][3]={{2,1,1},{1,1,0},{0,1,1}}; cout<<orangesRotting(g,3,3); return 0; }","expectedOutput":"4","solution":"#include <iostream>\\nusing namespace std;\\nint orangesRotting(int g[][3], int r, int c) { int qr[100],qc[100],f=0,re=0,fresh=0; for(int i=0;i<r;i++) for(int j=0;j<c;j++) { if(g[i][j]==2) { qr[re]=i; qc[re++]=j; } else if(g[i][j]==1) fresh++; } if(fresh==0) return 0; int dx[]={1,-1,0,0},dy[]={0,0,1,-1},t=-1; while(f<re) { int sz=re-f; t++; for(int q=0;q<sz;q++) { int i=qr[f],j=qc[f++]; for(int d=0;d<4;d++) { int ni=i+dx[d],nj=j+dy[d]; if(ni>=0&&ni<r&&nj>=0&&nj<c&&g[ni][nj]==1) { g[ni][nj]=2; fresh--; qr[re]=ni; qc[re++]=nj; } } } } return fresh==0?t:-1; }\\nint main() { int g[][3]={{2,1,1},{1,1,0},{0,1,1}}; cout<<orangesRotting(g,3,3); return 0; }","explanation":{"approach":"Multi-source BFS.","analogy":"Rot spreads level by level.","steps":["Add all rotten to queue","BFS, count levels","Check if all fresh rotted"],"complexity":"Time: O(rc), Space: O(rc)"}},{"id":"med44","title":"Word Ladder Length","description":"Min transformations.","difficulty":"MEDIUM","category":"BFS","starterCode":"#include <iostream>\\nusing namespace std;\\nint ladderLength(char begin[], char end[], char words[][10], int n) { return 0; }\\nint main() { char words[][10]={\\"hot\\",\\"dot\\",\\"dog\\",\\"lot\\",\\"log\\",\\"cog\\"}; cout<<ladderLength(\\"hit\\",\\"cog\\",words,6); return 0; }","expectedOutput":"5","solution":"#include <iostream>\\nusing namespace std;\\nbool diff1(char a[], char b[]) { int c=0; for(int i=0;a[i];i++) if(a[i]!=b[i]) c++; return c==1; }\\nint ladderLength(char begin[], char end[], char words[][10], int n) { char q[100][10]; int f=0,r=0; bool vis[100]={}; int i=0; while(begin[i]) { q[r][i]=begin[i]; i++; } q[r][i]=0; r++; int lv=1; while(f<r) { int sz=r-f; for(int s=0;s<sz;s++) { char* cur=q[f++]; for(int w=0;w<n;w++) { if(!vis[w] && diff1(cur,words[w])) { bool eq=true; for(int k=0;end[k];k++) if(end[k]!=words[w][k]) eq=false; if(eq) return lv+1; vis[w]=true; int j=0; while(words[w][j]) { q[r][j]=words[w][j]; j++; } q[r][j]=0; r++; } } } lv++; } return 0; }\\nint main() { char words[][10]={\\"hot\\",\\"dot\\",\\"dog\\",\\"lot\\",\\"log\\",\\"cog\\"}; cout<<ladderLength(\\"hit\\",\\"cog\\",words,6); return 0; }","explanation":{"approach":"BFS to find shortest path.","analogy":"Transform one letter at a time.","steps":["BFS from begin word","Try all 1-letter changes","Count levels"],"complexity":"Time: O(n  m  26), Space: O(n)"}},{"id":"med45","title":"Coin Change","description":"Min coins for amount.","difficulty":"MEDIUM","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint coinChange(int coins[], int n, int amt) { return 0; }\\nint main() { int coins[]={1,2,5}; cout<<coinChange(coins,3,11); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nint coinChange(int coins[], int n, int amt) { int dp[amt+1]; for(int i=0;i<=amt;i++) dp[i]=1e9; dp[0]=0; for(int i=1;i<=amt;i++) for(int j=0;j<n;j++) if(coins[j]<=i && dp[i-coins[j]]!=1e9) dp[i]=min(dp[i],dp[i-coins[j]]+1); return dp[amt]>=1e9?-1:dp[amt]; }\\nint main() { int coins[]={1,2,5}; cout<<coinChange(coins,3,11); return 0; }","explanation":{"approach":"DP - min coins for each amount.","analogy":"Build up from 0.","steps":["dp[i] = min coins for i","Try each coin"],"complexity":"Time: O(amt  n), Space: O(amt)"}},{"id":"med46","title":"Longest Increasing Subseq","description":"LIS length.","difficulty":"MEDIUM","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint lengthOfLIS(int a[], int n) { return 0; }\\nint main() { int a[]={10,9,2,5,3,7,101,18}; cout<<lengthOfLIS(a,8); return 0; }","expectedOutput":"4","solution":"#include <iostream>\\nusing namespace std;\\nint lengthOfLIS(int a[], int n) { int dp[n]; for(int i=0;i<n;i++) dp[i]=1; for(int i=1;i<n;i++) for(int j=0;j<i;j++) if(a[j]<a[i]) dp[i]=max(dp[i],dp[j]+1); int mx=0; for(int i=0;i<n;i++) mx=max(mx,dp[i]); return mx; }\\nint main() { int a[]={10,9,2,5,3,7,101,18}; cout<<lengthOfLIS(a,8); return 0; }","explanation":{"approach":"DP - LIS ending at each index.","analogy":"Extend previous subsequences.","steps":["dp[i] = LIS ending at i","Check all j < i"],"complexity":"Time: O(n), Space: O(n)"}},{"id":"med47","title":"Word Break","description":"Can segment into dict words.","difficulty":"MEDIUM","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nbool wordBreak(char s[], char dict[][10], int n) { return false; }\\nint main() { char dict[][10]={\\"apple\\",\\"pen\\"}; cout<<wordBreak(\\"applepenapple\\",dict,2); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool eq(char a[], int start, int end, char b[]) { int i=0; for(int j=start;j<end;j++,i++) if(a[j]!=b[i]) return false; return !b[i]; }\\nbool wordBreak(char s[], char dict[][10], int n) { int len=0; while(s[len]) len++; bool dp[len+1]={}; dp[0]=true; for(int i=1;i<=len;i++) for(int j=0;j<i;j++) if(dp[j]) for(int k=0;k<n;k++) if(eq(s,j,i,dict[k])) { dp[i]=true; break; } return dp[len]; }\\nint main() { char dict[][10]={\\"apple\\",\\"pen\\"}; cout<<wordBreak(\\"applepenapple\\",dict,2); return 0; }","explanation":{"approach":"DP - can reach each position.","analogy":"Check if prefix + dict word works.","steps":["dp[i] = can segment s[0..i]","Check all j < i with dict word"],"complexity":"Time: O(n  m), Space: O(n)"}},{"id":"med48","title":"House Robber","description":"Max money without adjacent.","difficulty":"MEDIUM","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint rob(int a[], int n) { return 0; }\\nint main() { int a[]={2,7,9,3,1}; cout<<rob(a,5); return 0; }","expectedOutput":"12","solution":"#include <iostream>\\nusing namespace std;\\nint rob(int a[], int n) { if(n==0) return 0; if(n==1) return a[0]; int dp[n]; dp[0]=a[0]; dp[1]=max(a[0],a[1]); for(int i=2;i<n;i++) dp[i]=max(dp[i-1],dp[i-2]+a[i]); return dp[n-1]; }\\nint main() { int a[]={2,7,9,3,1}; cout<<rob(a,5); return 0; }","explanation":{"approach":"DP - max at each house.","analogy":"Rob or skip each house.","steps":["dp[i] = max(skip, rob+dp[i-2])"],"complexity":"Time: O(n), Space: O(n)"}},{"id":"med49","title":"Decode Ways","description":"Number of decodings.","difficulty":"MEDIUM","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint numDecodings(char s[]) { return 0; }\\nint main() { cout<<numDecodings(\\"226\\"); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nint numDecodings(char s[]) { int n=0; while(s[n]) n++; if(n==0||s[0]=='0') return 0; int dp[n+1]={}; dp[0]=1; dp[1]=1; for(int i=2;i<=n;i++) { if(s[i-1]!='0') dp[i]=dp[i-1]; int two=(s[i-2]-'0')*10+(s[i-1]-'0'); if(two>=10&&two<=26) dp[i]+=dp[i-2]; } return dp[n]; }\\nint main() { cout<<numDecodings(\\"226\\"); return 0; }","explanation":{"approach":"DP - ways at each position.","analogy":"Single or pair digit decode.","steps":["dp[i] = ways to decode s[0..i]","Try 1 and 2 digit decodings"],"complexity":"Time: O(n), Space: O(n)"}},{"id":"med50","title":"Unique Paths","description":"Paths from top-left to bottom-right.","difficulty":"MEDIUM","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint uniquePaths(int m, int n) { return 0; }\\nint main() { cout<<uniquePaths(3,7); return 0; }","expectedOutput":"28","solution":"#include <iostream>\\nusing namespace std;\\nint uniquePaths(int m, int n) { int dp[m][n]; for(int i=0;i<m;i++) dp[i][0]=1; for(int j=0;j<n;j++) dp[0][j]=1; for(int i=1;i<m;i++) for(int j=1;j<n;j++) dp[i][j]=dp[i-1][j]+dp[i][j-1]; return dp[m-1][n-1]; }\\nint main() { cout<<uniquePaths(3,7); return 0; }","explanation":{"approach":"DP - paths to each cell.","analogy":"Sum of paths from top and left.","steps":["dp[i][j] = dp[i-1][j] + dp[i][j-1]"],"complexity":"Time: O(mn), Space: O(mn)"}}]`),FR=JSON.parse('[{"id":"med51","title":"Unique Paths II","description":"Paths with obstacles.","difficulty":"MEDIUM","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint uniquePathsWithObstacles(int g[][3], int m, int n) { return 0; }\\nint main() { int g[][3]={{0,0,0},{0,1,0},{0,0,0}}; cout<<uniquePathsWithObstacles(g,3,3); return 0; }","expectedOutput":"2","solution":"#include <iostream>\\nusing namespace std;\\nint uniquePathsWithObstacles(int g[][3], int m, int n) { if(g[0][0]==1) return 0; int dp[m][n]={}; dp[0][0]=1; for(int i=1;i<m;i++) dp[i][0]=g[i][0]?0:dp[i-1][0]; for(int j=1;j<n;j++) dp[0][j]=g[0][j]?0:dp[0][j-1]; for(int i=1;i<m;i++) for(int j=1;j<n;j++) dp[i][j]=g[i][j]?0:dp[i-1][j]+dp[i][j-1]; return dp[m-1][n-1]; }\\nint main() { int g[][3]={{0,0,0},{0,1,0},{0,0,0}}; cout<<uniquePathsWithObstacles(g,3,3); return 0; }","explanation":{"approach":"DP, skip obstacles.","analogy":"0 paths through obstacle.","steps":["dp[i][j] = 0 if obstacle","Else sum of top and left"],"complexity":"Time: O(mn), Space: O(mn)"}},{"id":"med52","title":"Minimum Path Sum","description":"Min sum path to bottom-right.","difficulty":"MEDIUM","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint minPathSum(int g[][3], int m, int n) { return 0; }\\nint main() { int g[][3]={{1,3,1},{1,5,1},{4,2,1}}; cout<<minPathSum(g,3,3); return 0; }","expectedOutput":"7","solution":"#include <iostream>\\nusing namespace std;\\nint minPathSum(int g[][3], int m, int n) { int dp[m][n]; dp[0][0]=g[0][0]; for(int i=1;i<m;i++) dp[i][0]=dp[i-1][0]+g[i][0]; for(int j=1;j<n;j++) dp[0][j]=dp[0][j-1]+g[0][j]; for(int i=1;i<m;i++) for(int j=1;j<n;j++) dp[i][j]=min(dp[i-1][j],dp[i][j-1])+g[i][j]; return dp[m-1][n-1]; }\\nint main() { int g[][3]={{1,3,1},{1,5,1},{4,2,1}}; cout<<minPathSum(g,3,3); return 0; }","explanation":{"approach":"DP - min sum to each cell.","analogy":"Pick cheaper path.","steps":["dp[i][j] = min(top, left) + g[i][j]"],"complexity":"Time: O(mn), Space: O(mn)"}},{"id":"med53","title":"Jump Game","description":"Can reach last index.","difficulty":"MEDIUM","category":"Greedy","starterCode":"#include <iostream>\\nusing namespace std;\\nbool canJump(int a[], int n) { return false; }\\nint main() { int a[]={2,3,1,1,4}; cout<<canJump(a,5); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool canJump(int a[], int n) { int reach=0; for(int i=0;i<n && i<=reach;i++) reach=max(reach,i+a[i]); return reach>=n-1; }\\nint main() { int a[]={2,3,1,1,4}; cout<<canJump(a,5); return 0; }","explanation":{"approach":"Track farthest reachable.","analogy":"Extend reach as you go.","steps":["Update max reach at each index","Check if reach >= n-1"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"med54","title":"Edit Distance","description":"Min operations to convert.","difficulty":"MEDIUM","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint minDistance(char a[], char b[]) { return 0; }\\nint main() { cout<<minDistance(\\"horse\\",\\"ros\\"); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nint minDistance(char a[], char b[]) { int m=0,n=0; while(a[m]) m++; while(b[n]) n++; int dp[m+1][n+1]; for(int i=0;i<=m;i++) dp[i][0]=i; for(int j=0;j<=n;j++) dp[0][j]=j; for(int i=1;i<=m;i++) for(int j=1;j<=n;j++) if(a[i-1]==b[j-1]) dp[i][j]=dp[i-1][j-1]; else dp[i][j]=1+min(dp[i-1][j],min(dp[i][j-1],dp[i-1][j-1])); return dp[m][n]; }\\nint main() { cout<<minDistance(\\"horse\\",\\"ros\\"); return 0; }","explanation":{"approach":"DP - operations for each prefix.","analogy":"Insert, delete, or replace.","steps":["If match, no operation","Else min of 3 operations + 1"],"complexity":"Time: O(mn), Space: O(mn)"}},{"id":"med55","title":"Longest Common Subsequence","description":"LCS length.","difficulty":"MEDIUM","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint lcs(char a[], char b[]) { return 0; }\\nint main() { cout<<lcs(\\"abcde\\",\\"ace\\"); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nint lcs(char a[], char b[]) { int m=0,n=0; while(a[m]) m++; while(b[n]) n++; int dp[m+1][n+1]={}; for(int i=1;i<=m;i++) for(int j=1;j<=n;j++) if(a[i-1]==b[j-1]) dp[i][j]=dp[i-1][j-1]+1; else dp[i][j]=max(dp[i-1][j],dp[i][j-1]); return dp[m][n]; }\\nint main() { cout<<lcs(\\"abcde\\",\\"ace\\"); return 0; }","explanation":{"approach":"DP - LCS for each prefix pair.","analogy":"Match or skip.","steps":["If match, add 1 to diagonal","Else max of skip either"],"complexity":"Time: O(mn), Space: O(mn)"}},{"id":"med56","title":"0/1 Knapsack","description":"Max value in capacity.","difficulty":"MEDIUM","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint knapsack(int w[], int v[], int n, int W) { return 0; }\\nint main() { int w[]={1,2,3}, v[]={60,100,120}; cout<<knapsack(w,v,3,5); return 0; }","expectedOutput":"220","solution":"#include <iostream>\\nusing namespace std;\\nint knapsack(int w[], int v[], int n, int W) { int dp[n+1][W+1]={}; for(int i=1;i<=n;i++) for(int j=0;j<=W;j++) { dp[i][j]=dp[i-1][j]; if(w[i-1]<=j) dp[i][j]=max(dp[i][j],dp[i-1][j-w[i-1]]+v[i-1]); } return dp[n][W]; }\\nint main() { int w[]={1,2,3}, v[]={60,100,120}; cout<<knapsack(w,v,3,5); return 0; }","explanation":{"approach":"DP - max value for capacity.","analogy":"Take or leave each item.","steps":["For each item and capacity","Max of skip or take"],"complexity":"Time: O(nW), Space: O(nW)"}},{"id":"med57","title":"Partition Equal Subset","description":"Can split into equal sums.","difficulty":"MEDIUM","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nbool canPartition(int a[], int n) { return false; }\\nint main() { int a[]={1,5,11,5}; cout<<canPartition(a,4); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool canPartition(int a[], int n) { int sum=0; for(int i=0;i<n;i++) sum+=a[i]; if(sum%2) return false; int t=sum/2; bool dp[t+1]={}; dp[0]=true; for(int i=0;i<n;i++) for(int j=t;j>=a[i];j--) dp[j]=dp[j]||dp[j-a[i]]; return dp[t]; }\\nint main() { int a[]={1,5,11,5}; cout<<canPartition(a,4); return 0; }","explanation":{"approach":"Subset sum to half.","analogy":"Can we make sum/2?","steps":["Check if sum is even","DP for subset sum"],"complexity":"Time: O(n  sum), Space: O(sum)"}},{"id":"med58","title":"Coin Change Ways","description":"Number of ways to make amount.","difficulty":"MEDIUM","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint coinWays(int coins[], int n, int amt) { return 0; }\\nint main() { int coins[]={1,2,5}; cout<<coinWays(coins,3,5); return 0; }","expectedOutput":"4","solution":"#include <iostream>\\nusing namespace std;\\nint coinWays(int coins[], int n, int amt) { int dp[amt+1]={}; dp[0]=1; for(int i=0;i<n;i++) for(int j=coins[i];j<=amt;j++) dp[j]+=dp[j-coins[i]]; return dp[amt]; }\\nint main() { int coins[]={1,2,5}; cout<<coinWays(coins,3,5); return 0; }","explanation":{"approach":"DP - ways for each amount.","analogy":"Add ways using each coin.","steps":["For each coin","Add ways from amount - coin"],"complexity":"Time: O(n  amt), Space: O(amt)"}},{"id":"med59","title":"Target Sum","description":"Ways to reach target with +/-.","difficulty":"MEDIUM","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint findTargetSumWays(int a[], int n, int t) { return 0; }\\nint main() { int a[]={1,1,1,1,1}; cout<<findTargetSumWays(a,5,3); return 0; }","expectedOutput":"5","solution":"#include <iostream>\\nusing namespace std;\\nint solve(int a[], int n, int i, int sum) { if(i==n) return sum==0?1:0; return solve(a,n,i+1,sum-a[i])+solve(a,n,i+1,sum+a[i]); }\\nint findTargetSumWays(int a[], int n, int t) { return solve(a,n,0,t); }\\nint main() { int a[]={1,1,1,1,1}; cout<<findTargetSumWays(a,5,3); return 0; }","explanation":{"approach":"Try + and - for each number.","analogy":"Two branches at each element.","steps":["Add or subtract current","Count ways reaching 0"],"complexity":"Time: O(2^n), Space: O(n)"}},{"id":"med60","title":"Longest Palindromic Subseq","description":"LPS length.","difficulty":"MEDIUM","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint lps(char s[]) { return 0; }\\nint main() { cout<<lps(\\"bbbab\\"); return 0; }","expectedOutput":"4","solution":"#include <iostream>\\nusing namespace std;\\nint lps(char s[]) { int n=0; while(s[n]) n++; int dp[n][n]={}; for(int i=0;i<n;i++) dp[i][i]=1; for(int len=2;len<=n;len++) for(int i=0;i<=n-len;i++) { int j=i+len-1; if(s[i]==s[j]) dp[i][j]=dp[i+1][j-1]+2; else dp[i][j]=max(dp[i+1][j],dp[i][j-1]); } return dp[0][n-1]; }\\nint main() { cout<<lps(\\"bbbab\\"); return 0; }","explanation":{"approach":"DP on substrings.","analogy":"Match ends or skip one.","steps":["If ends match, add 2","Else max of skipping either end"],"complexity":"Time: O(n), Space: O(n)"}}]'),qR=JSON.parse(`[{"id":"med61","title":"Maximal Square","description":"Largest square of 1s.","difficulty":"MEDIUM","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint maximalSquare(int m[][5], int r, int c) { return 0; }\\nint main() { int m[][5]={{1,0,1,0,0},{1,0,1,1,1},{1,1,1,1,1},{1,0,0,1,0}}; cout<<maximalSquare(m,4,5); return 0; }","expectedOutput":"4","solution":"#include <iostream>\\nusing namespace std;\\nint maximalSquare(int m[][5], int r, int c) { int dp[r][c], mx=0; for(int i=0;i<r;i++) for(int j=0;j<c;j++) { if(i==0||j==0) dp[i][j]=m[i][j]; else if(m[i][j]==1) dp[i][j]=1+min(dp[i-1][j],min(dp[i][j-1],dp[i-1][j-1])); else dp[i][j]=0; mx=max(mx,dp[i][j]); } return mx*mx; }\\nint main() { int m[][5]={{1,0,1,0,0},{1,0,1,1,1},{1,1,1,1,1},{1,0,0,1,0}}; cout<<maximalSquare(m,4,5); return 0; }","explanation":{"approach":"DP - square size at each cell.","analogy":"Square size = 1 + min of 3 neighbors.","steps":["dp[i][j] = max square ending at (i,j)","Min of top, left, diagonal + 1"],"complexity":"Time: O(rc), Space: O(rc)"}},{"id":"med62","title":"Longest String Chain","description":"Longest word chain.","difficulty":"MEDIUM","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint longestStrChain(char words[][10], int n) { return 0; }\\nint main() { char words[][10]={\\"a\\",\\"b\\",\\"ba\\",\\"bca\\",\\"bda\\",\\"bdca\\"}; cout<<longestStrChain(words,6); return 0; }","expectedOutput":"4","solution":"#include <iostream>\\nusing namespace std;\\nint len(char s[]) { int l=0; while(s[l]) l++; return l; }\\nbool isPred(char a[], char b[]) { int la=len(a),lb=len(b); if(lb!=la+1) return false; int i=0,j=0; while(b[j]) { if(a[i]==b[j]) i++; j++; } return i==la; }\\nint longestStrChain(char words[][10], int n) { for(int i=0;i<n-1;i++) for(int j=0;j<n-i-1;j++) if(len(words[j])>len(words[j+1])) { char t[10]; int k=0; while(words[j][k]) { t[k]=words[j][k]; k++; } t[k]=0; k=0; while(words[j+1][k]) { words[j][k]=words[j+1][k]; k++; } words[j][k]=0; k=0; while(t[k]) { words[j+1][k]=t[k]; k++; } words[j+1][k]=0; } int dp[n]; for(int i=0;i<n;i++) dp[i]=1; for(int i=1;i<n;i++) for(int j=0;j<i;j++) if(isPred(words[j],words[i])) dp[i]=max(dp[i],dp[j]+1); int mx=0; for(int i=0;i<n;i++) mx=max(mx,dp[i]); return mx; }\\nint main() { char words[][10]={\\"a\\",\\"b\\",\\"ba\\",\\"bca\\",\\"bda\\",\\"bdca\\"}; cout<<longestStrChain(words,6); return 0; }","explanation":{"approach":"Sort by length, DP on predecessors.","analogy":"Chain of words adding one letter.","steps":["Sort by length","For each word, check predecessors"],"complexity":"Time: O(n  L), Space: O(n)"}},{"id":"med63","title":"Interleaving String","description":"Can s3 be interleaving of s1 and s2.","difficulty":"MEDIUM","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isInterleave(char s1[], char s2[], char s3[]) { return false; }\\nint main() { cout<<isInterleave(\\"aabcc\\",\\"dbbca\\",\\"aadbbcbcac\\"); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isInterleave(char s1[], char s2[], char s3[]) { int m=0,n=0,l=0; while(s1[m]) m++; while(s2[n]) n++; while(s3[l]) l++; if(l!=m+n) return false; bool dp[m+1][n+1]; dp[0][0]=true; for(int i=1;i<=m;i++) dp[i][0]=dp[i-1][0]&&s1[i-1]==s3[i-1]; for(int j=1;j<=n;j++) dp[0][j]=dp[0][j-1]&&s2[j-1]==s3[j-1]; for(int i=1;i<=m;i++) for(int j=1;j<=n;j++) dp[i][j]=(dp[i-1][j]&&s1[i-1]==s3[i+j-1]) || (dp[i][j-1]&&s2[j-1]==s3[i+j-1]); return dp[m][n]; }\\nint main() { cout<<isInterleave(\\"aabcc\\",\\"dbbca\\",\\"aadbbcbcac\\"); return 0; }","explanation":{"approach":"DP - can reach each position.","analogy":"Take from s1 or s2.","steps":["dp[i][j] = can form s3[0..i+j] from s1[0..i] and s2[0..j]"],"complexity":"Time: O(mn), Space: O(mn)"}},{"id":"med64","title":"Distinct Subsequences","description":"Number of distinct subsequences.","difficulty":"HARD","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint numDistinct(char s[], char t[]) { return 0; }\\nint main() { cout<<numDistinct(\\"rabbbit\\",\\"rabbit\\"); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nint numDistinct(char s[], char t[]) { int m=0,n=0; while(s[m]) m++; while(t[n]) n++; int dp[m+1][n+1]={}; for(int i=0;i<=m;i++) dp[i][0]=1; for(int i=1;i<=m;i++) for(int j=1;j<=n;j++) { dp[i][j]=dp[i-1][j]; if(s[i-1]==t[j-1]) dp[i][j]+=dp[i-1][j-1]; } return dp[m][n]; }\\nint main() { cout<<numDistinct(\\"rabbbit\\",\\"rabbit\\"); return 0; }","explanation":{"approach":"DP - ways to form t from s.","analogy":"Include or exclude each char.","steps":["dp[i][j] = ways to form t[0..j] from s[0..i]","Include match or skip"],"complexity":"Time: O(mn), Space: O(mn)"}},{"id":"med65","title":"Best Time Cooldown","description":"Buy/sell with cooldown.","difficulty":"MEDIUM","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint maxProfit(int p[], int n) { return 0; }\\nint main() { int p[]={1,2,3,0,2}; cout<<maxProfit(p,5); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nint maxProfit(int p[], int n) { if(n<=1) return 0; int dp[n][2]; dp[0][0]=0; dp[0][1]=-p[0]; dp[1][0]=max(0,p[1]-p[0]); dp[1][1]=max(-p[0],-p[1]); for(int i=2;i<n;i++) { dp[i][0]=max(dp[i-1][0],dp[i-1][1]+p[i]); dp[i][1]=max(dp[i-1][1],dp[i-2][0]-p[i]); } return dp[n-1][0]; }\\nint main() { int p[]={1,2,3,0,2}; cout<<maxProfit(p,5); return 0; }","explanation":{"approach":"DP with hold/not hold states.","analogy":"Cooldown after sell.","steps":["dp[i][0] = max profit not holding","dp[i][1] = max profit holding"],"complexity":"Time: O(n), Space: O(n)"}},{"id":"med66","title":"Burst Balloons","description":"Max coins from bursting.","difficulty":"HARD","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint maxCoins(int nums[], int n) { return 0; }\\nint main() { int nums[]={3,1,5,8}; cout<<maxCoins(nums,4); return 0; }","expectedOutput":"167","solution":"#include <iostream>\\nusing namespace std;\\nint maxCoins(int nums[], int n) { int a[n+2]; a[0]=a[n+1]=1; for(int i=0;i<n;i++) a[i+1]=nums[i]; int dp[n+2][n+2]={}; for(int len=1;len<=n;len++) for(int l=1;l<=n-len+1;l++) { int r=l+len-1; for(int k=l;k<=r;k++) dp[l][r]=max(dp[l][r],dp[l][k-1]+a[l-1]*a[k]*a[r+1]+dp[k+1][r]); } return dp[1][n]; }\\nint main() { int nums[]={3,1,5,8}; cout<<maxCoins(nums,4); return 0; }","explanation":{"approach":"DP - last balloon to burst.","analogy":"Think reverse - last to burst.","steps":["dp[l][r] = max coins for range","Try each as last to burst"],"complexity":"Time: O(n), Space: O(n)"}},{"id":"med67","title":"Regular Expression","description":"Simple regex matching.","difficulty":"MEDIUM","category":"Strings","starterCode":"#include <iostream>\\nusing namespace std;\\nbool match(char s[], char p[]) { return false; }\\nint main() { cout<<match(\\"aa\\",\\"a.\\"); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool match(char s[], char p[]) { if(!*p) return !*s; if(p[0]=='.' || p[0]==s[0]) return match(s+1,p+1); return false; }\\nint main() { cout<<match(\\"aa\\",\\"a.\\"); return 0; }","explanation":{"approach":"Recursive matching.","analogy":". matches any character.","steps":["Match current char or .","Recurse on rest"],"complexity":"Time: O(n), Space: O(n)"}},{"id":"med68","title":"Decode String","description":"Decode k[encoded_string].","difficulty":"MEDIUM","category":"Stack","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid decodeString(char s[]) {}\\nint main() { decodeString(\\"3[a2[c]]\\"); return 0; }","expectedOutput":"accaccacc","solution":"#include <iostream>\\nusing namespace std;\\nvoid decodeString(char s[]) { char res[1000]={}; int ri=0; for(int i=0;s[i];) { if(s[i]>='a'&&s[i]<='z') res[ri++]=s[i++]; else if(s[i]>='0'&&s[i]<='9') { int k=0; while(s[i]>='0'&&s[i]<='9') k=k*10+s[i++]-'0'; i++; int start=i,depth=1; while(depth>0) { if(s[i]=='[') depth++; else if(s[i]==']') depth--; i++; } char sub[100]={}; int j=0; for(int t=start;t<i-1;t++) sub[j++]=s[t]; for(int t=0;t<k;t++) { int p=0; while(sub[p]) res[ri++]=sub[p++]; } } else i++; } cout<<res; }\\nint main() { decodeString(\\"3[a2[c]]\\"); return 0; }","explanation":{"approach":"Parse number, extract substring, repeat.","analogy":"Expand nested encodings.","steps":["Find number k","Extract content in brackets","Repeat k times"],"complexity":"Time: O(n  maxK), Space: O(n)"}},{"id":"med69","title":"Find All Anagrams","description":"Find anagram indices.","difficulty":"MEDIUM","category":"Sliding Window","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid findAnagrams(char s[], char p[]) {}\\nint main() { findAnagrams(\\"cbaebabacd\\",\\"abc\\"); return 0; }","expectedOutput":"0 6","solution":"#include <iostream>\\nusing namespace std;\\nvoid findAnagrams(char s[], char p[]) { int pc[26]={}, sc[26]={}; int plen=0,slen=0; while(p[plen]) pc[p[plen++]-'a']++; while(s[slen]) slen++; for(int i=0;i<slen;i++) { sc[s[i]-'a']++; if(i>=plen) sc[s[i-plen]-'a']--; if(i>=plen-1) { bool match=true; for(int j=0;j<26;j++) if(pc[j]!=sc[j]) { match=false; break; } if(match) cout<<i-plen+1<<\\" \\"; } } }\\nint main() { findAnagrams(\\"cbaebabacd\\",\\"abc\\"); return 0; }","explanation":{"approach":"Sliding window with char counts.","analogy":"Compare counts of window with p.","steps":["Add right char, remove left char","Compare counts"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"med70","title":"Permutation in String","description":"Check if s2 contains permutation of s1.","difficulty":"MEDIUM","category":"Sliding Window","starterCode":"#include <iostream>\\nusing namespace std;\\nbool checkInclusion(char s1[], char s2[]) { return false; }\\nint main() { cout<<checkInclusion(\\"ab\\",\\"eidbaooo\\"); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool checkInclusion(char s1[], char s2[]) { int c1[26]={},c2[26]={}; int l1=0,l2=0; while(s1[l1]) c1[s1[l1++]-'a']++; while(s2[l2]) l2++; for(int i=0;i<l2;i++) { c2[s2[i]-'a']++; if(i>=l1) c2[s2[i-l1]-'a']--; bool match=true; for(int j=0;j<26;j++) if(c1[j]!=c2[j]) { match=false; break; } if(match) return true; } return false; }\\nint main() { cout<<checkInclusion(\\"ab\\",\\"eidbaooo\\"); return 0; }","explanation":{"approach":"Sliding window of s1 length.","analogy":"Find window with same char counts.","steps":["Slide window of size len(s1)","Compare character counts"],"complexity":"Time: O(n), Space: O(1)"}}]`),HR=JSON.parse(`[{"id":"m201","title":"Unique Binary Search Trees","description":"Given an integer n, return the number of structurally unique BST's (binary search trees) which has exactly n nodes of unique values from 1 to n. This is the nth Catalan number.","difficulty":"MEDIUM","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint numTrees(int n) { return 0; }\\nint main() { cout << numTrees(3); return 0; }","expectedOutput":"5","solution":"#include <iostream>\\nusing namespace std;\\nint numTrees(int n) {\\n    int dp[n + 1] = {};\\n    dp[0] = dp[1] = 1;\\n    \\n    for(int nodes = 2; nodes <= n; nodes++) {\\n        for(int root = 1; root <= nodes; root++) {\\n            int leftNodes = root - 1;      // Nodes smaller than root\\n            int rightNodes = nodes - root; // Nodes larger than root\\n            dp[nodes] += dp[leftNodes] * dp[rightNodes];\\n        }\\n    }\\n    return dp[n];\\n}\\nint main() { cout << numTrees(3); return 0; }","explanation":{"approach":"Use dynamic programming. For n nodes, try each value as root. Left subtree uses smaller values, right uses larger. Total combinations = left_count  right_count.","analogy":"Like building all possible family trees - each person can be the 'root' parent, with younger family on left, older on right.","steps":["dp[i] = number of unique BSTs with i nodes","Base case: dp[0] = dp[1] = 1 (empty tree or single node)","For each count of nodes (2 to n)","Try each value as root (1 to nodes)","Left subtree has (root-1) nodes, right has (nodes-root) nodes","Add dp[left]  dp[right] to dp[nodes]"],"complexity":"Time: O(n), Space: O(n)"}},{"id":"m202","title":"Ugly Number II","description":"An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5. Given integer n, return the nth ugly number. The sequence is: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12...","difficulty":"MEDIUM","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint nthUglyNumber(int n) { return 0; }\\nint main() { cout << nthUglyNumber(10); return 0; }","expectedOutput":"12","solution":"#include <iostream>\\nusing namespace std;\\nint nthUglyNumber(int n) {\\n    int ugly[n];\\n    ugly[0] = 1;\\n    int i2 = 0, i3 = 0, i5 = 0;  // Pointers for multiplying by 2, 3, 5\\n    \\n    for(int i = 1; i < n; i++) {\\n        int next2 = ugly[i2] * 2;\\n        int next3 = ugly[i3] * 3;\\n        int next5 = ugly[i5] * 5;\\n        \\n        ugly[i] = min(next2, min(next3, next5));\\n        \\n        // Advance pointers that contributed to this ugly number\\n        if(ugly[i] == next2) i2++;\\n        if(ugly[i] == next3) i3++;\\n        if(ugly[i] == next5) i5++;\\n    }\\n    return ugly[n - 1];\\n}\\nint main() { cout << nthUglyNumber(10); return 0; }","explanation":{"approach":"Use three pointers, one for each prime factor (2, 3, 5). Each ugly number is formed by multiplying a previous ugly number by 2, 3, or 5. Always pick the smallest candidate.","analogy":"Like three assembly lines producing ugly numbers - one multiplies by 2, one by 3, one by 5. Always take the smallest product from all lines.","steps":["Start with ugly[0] = 1","Maintain three pointers i2, i3, i5 starting at 0","Compute next candidates: ugly[i2]*2, ugly[i3]*3, ugly[i5]*5","Take the minimum as next ugly number","Advance pointer(s) that produced this minimum","Repeat until we have n ugly numbers"],"complexity":"Time: O(n), Space: O(n)"}},{"id":"m203","title":"Count Numbers with Unique Digits","description":"Given an integer n, count all numbers with unique digits in the range [0, 10^n). For n=2, count all numbers from 0 to 99 with unique digits.","difficulty":"MEDIUM","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint countNumbersWithUniqueDigits(int n) { return 0; }\\nint main() { cout << countNumbersWithUniqueDigits(2); return 0; }","expectedOutput":"91","solution":"#include <iostream>\\nusing namespace std;\\nint countNumbersWithUniqueDigits(int n) {\\n    if(n == 0) return 1;\\n    \\n    int result = 10;  // For n=1, we have 0-9\\n    int uniqueDigits = 9;  // First digit choices (can't be 0)\\n    int availableDigits = 9;  // Remaining digit choices\\n    \\n    for(int i = 2; i <= n && availableDigits > 0; i++) {\\n        uniqueDigits *= availableDigits;\\n        result += uniqueDigits;\\n        availableDigits--;\\n    }\\n    return result;\\n}\\nint main() { cout << countNumbersWithUniqueDigits(2); return 0; }","explanation":{"approach":"Combinatorics approach. For each digit position, count how many choices remain. First digit has 9 choices (no 0), each subsequent has one fewer.","analogy":"Like choosing seats in a theater - first person has many choices, each next person has one fewer seat available.","steps":["For n=0: only 1 number (0)","For n=1: 10 numbers (0-9)","For 2-digit: first digit 9 choices (1-9), second digit 9 choices (0-9 except first)","For 3-digit: 9  9  8 new numbers","Pattern: 9  9  8  7  ... until we run out of available digits","Sum all counts"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"m204","title":"Frequency of Most Frequent Element","description":"Given an array of integers and a number k, you can increment any element at most k times total. Return the maximum possible frequency of any element after performing at most k increments.","difficulty":"MEDIUM","category":"Sliding Window","starterCode":"#include <iostream>\\nusing namespace std;\\nint maxFrequency(int nums[], int n, int k) { return 0; }\\nint main() { int nu[] = {1, 2, 4}; cout << maxFrequency(nu, 3, 5); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nint maxFrequency(int nums[], int n, int k) {\\n    // Sort the array first\\n    for(int i = 0; i < n - 1; i++) {\\n        for(int j = 0; j < n - i - 1; j++) {\\n            if(nums[j] > nums[j + 1]) {\\n                int temp = nums[j];\\n                nums[j] = nums[j + 1];\\n                nums[j + 1] = temp;\\n            }\\n        }\\n    }\\n    \\n    long long sum = 0;\\n    int left = 0, maxFreq = 1;\\n    \\n    for(int right = 0; right < n; right++) {\\n        sum += nums[right];\\n        \\n        // Check if we can make all elements in window equal to nums[right]\\n        // Cost = nums[right] * windowSize - sum\\n        while((long long)nums[right] * (right - left + 1) - sum > k) {\\n            sum -= nums[left];\\n            left++;\\n        }\\n        \\n        maxFreq = max(maxFreq, right - left + 1);\\n    }\\n    return maxFreq;\\n}\\nint main() { int nu[] = {1, 2, 4}; cout << maxFrequency(nu, 3, 5); return 0; }","explanation":{"approach":"Sort the array then use sliding window. For any window, the cost to make all elements equal to the maximum (rightmost) is: max  windowSize - sumOfWindow. If cost > k, shrink window.","analogy":"Like a team trying to reach the same level - the strongest person sets the target, and we need to 'spend' energy to lift others up. We want the biggest team we can afford to lift.","steps":["Sort array so we can easily find max in window","Use sliding window with left and right pointers","Track sum of elements in window","Target = nums[right] (max in sorted window)","Cost = target  windowSize - sum","If cost > k, shrink window from left","Track maximum window size"],"complexity":"Time: O(n log n), Space: O(1)"}},{"id":"m205","title":"Maximum Erasure Value","description":"Given an array of positive integers, find the maximum sum of a subarray where all elements are unique (no duplicates in the subarray).","difficulty":"MEDIUM","category":"Sliding Window","starterCode":"#include <iostream>\\nusing namespace std;\\nint maximumUniqueSubarray(int nums[], int n) { return 0; }\\nint main() { int nu[] = {4, 2, 4, 5, 6}; cout << maximumUniqueSubarray(nu, 5); return 0; }","expectedOutput":"17","solution":"#include <iostream>\\nusing namespace std;\\nint maximumUniqueSubarray(int nums[], int n) {\\n    bool seen[10001] = {};  // Track seen elements\\n    int left = 0, sum = 0, maxSum = 0;\\n    \\n    for(int right = 0; right < n; right++) {\\n        // Shrink window while current element is duplicate\\n        while(seen[nums[right]]) {\\n            seen[nums[left]] = false;\\n            sum -= nums[left];\\n            left++;\\n        }\\n        \\n        // Add current element to window\\n        seen[nums[right]] = true;\\n        sum += nums[right];\\n        maxSum = max(maxSum, sum);\\n    }\\n    return maxSum;\\n}\\nint main() { int nu[] = {4, 2, 4, 5, 6}; cout << maximumUniqueSubarray(nu, 5); return 0; }","explanation":{"approach":"Sliding window with a set to track unique elements. When we see a duplicate, shrink window from left until the duplicate is removed. Track maximum sum.","analogy":"Like collecting unique stamps - keep adding stamps until you find a duplicate, then give away stamps from the start until no duplicates remain.","steps":["Use sliding window with left and right pointers","Track seen elements using boolean array or set","Track current window sum","For each right element:","  - If duplicate found, shrink window until it's gone","  - Add element to window and sum","  - Update max sum if current is larger"],"complexity":"Time: O(n), Space: O(n)"}},{"id":"m206","title":"Container With Most Water","description":"Given n non-negative integers representing n vertical lines, find two lines that together with the x-axis form a container with the most water. Return the maximum amount of water a container can store.","difficulty":"MEDIUM","category":"Two Pointers","starterCode":"#include <iostream>\\nusing namespace std;\\nint maxArea(int height[], int n) { return 0; }\\nint main() { int h[] = {1, 8, 6, 2, 5, 4, 8, 3, 7}; cout << maxArea(h, 9); return 0; }","expectedOutput":"49","solution":"#include <iostream>\\nusing namespace std;\\nint maxArea(int height[], int n) {\\n    int left = 0, right = n - 1;\\n    int maxWater = 0;\\n    \\n    while(left < right) {\\n        int h = min(height[left], height[right]);\\n        int width = right - left;\\n        int water = h * width;\\n        maxWater = max(maxWater, water);\\n        \\n        // Move the shorter line inward\\n        if(height[left] < height[right]) {\\n            left++;\\n        } else {\\n            right--;\\n        }\\n    }\\n    return maxWater;\\n}\\nint main() { int h[] = {1, 8, 6, 2, 5, 4, 8, 3, 7}; cout << maxArea(h, 9); return 0; }","explanation":{"approach":"Use two pointers at both ends. Water = min(left_height, right_height)  width. Move the shorter line inward because only a taller line can potentially increase water.","analogy":"Like filling a pool between two walls - water level is limited by the shorter wall. Moving the shorter wall gives us hope of finding a taller one.","steps":["Start with left at 0, right at n-1 (widest possible)","Calculate water: min(heights)  width","Update maximum if current is larger","Move the shorter line inward","Why? Moving shorter gives chance for more height","Continue until pointers meet"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"m207","title":"3Sum","description":"Given an array of integers, find all unique triplets that sum to zero. The solution set must not contain duplicate triplets.","difficulty":"MEDIUM","category":"Two Pointers","starterCode":"#include <iostream>\\nusing namespace std;\\nint threeSum(int nums[], int n) { return 0; }\\nint main() { int nu[] = {-1, 0, 1, 2, -1, -4}; cout << threeSum(nu, 6); return 0; }","expectedOutput":"2","solution":"#include <iostream>\\nusing namespace std;\\nint threeSum(int nums[], int n) {\\n    // Sort the array\\n    for(int i = 0; i < n - 1; i++) {\\n        for(int j = 0; j < n - i - 1; j++) {\\n            if(nums[j] > nums[j + 1]) {\\n                int temp = nums[j];\\n                nums[j] = nums[j + 1];\\n                nums[j + 1] = temp;\\n            }\\n        }\\n    }\\n    \\n    int count = 0;\\n    for(int i = 0; i < n - 2; i++) {\\n        // Skip duplicates for i\\n        if(i > 0 && nums[i] == nums[i - 1]) continue;\\n        \\n        int left = i + 1, right = n - 1;\\n        while(left < right) {\\n            int sum = nums[i] + nums[left] + nums[right];\\n            if(sum == 0) {\\n                count++;\\n                // Skip duplicates\\n                while(left < right && nums[left] == nums[left + 1]) left++;\\n                while(left < right && nums[right] == nums[right - 1]) right--;\\n                left++;\\n                right--;\\n            } else if(sum < 0) {\\n                left++;\\n            } else {\\n                right--;\\n            }\\n        }\\n    }\\n    return count;\\n}\\nint main() { int nu[] = {-1, 0, 1, 2, -1, -4}; cout << threeSum(nu, 6); return 0; }","explanation":{"approach":"Sort the array. Fix one element, then use two pointers to find the other two. Skip duplicates to avoid repeating triplets.","analogy":"Like balancing a scale - fix one weight on one side, then find two weights on the other side that balance it (sum to negative of first).","steps":["Sort the array","For each element i (first of triplet):","  - Skip if duplicate of previous","  - Use two pointers (left=i+1, right=n-1)","  - If sum < 0, move left right (need bigger sum)","  - If sum > 0, move right left (need smaller sum)","  - If sum = 0, found triplet! Skip duplicates and continue"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"m208","title":"3Sum Closest","description":"Given an array of integers and a target value, find the sum of three integers closest to the target. Return the sum.","difficulty":"MEDIUM","category":"Two Pointers","starterCode":"#include <iostream>\\nusing namespace std;\\nint threeSumClosest(int nums[], int n, int target) { return 0; }\\nint main() { int nu[] = {-1, 2, 1, -4}; cout << threeSumClosest(nu, 4, 1); return 0; }","expectedOutput":"2","solution":"#include <iostream>\\nusing namespace std;\\nint threeSumClosest(int nums[], int n, int target) {\\n    // Sort array\\n    for(int i = 0; i < n - 1; i++) {\\n        for(int j = 0; j < n - i - 1; j++) {\\n            if(nums[j] > nums[j + 1]) {\\n                int temp = nums[j];\\n                nums[j] = nums[j + 1];\\n                nums[j + 1] = temp;\\n            }\\n        }\\n    }\\n    \\n    int closest = nums[0] + nums[1] + nums[2];\\n    \\n    for(int i = 0; i < n - 2; i++) {\\n        int left = i + 1, right = n - 1;\\n        while(left < right) {\\n            int sum = nums[i] + nums[left] + nums[right];\\n            \\n            if(abs(sum - target) < abs(closest - target)) {\\n                closest = sum;\\n            }\\n            \\n            if(sum < target) {\\n                left++;\\n            } else {\\n                right--;\\n            }\\n        }\\n    }\\n    return closest;\\n}\\nint main() { int nu[] = {-1, 2, 1, -4}; cout << threeSumClosest(nu, 4, 1); return 0; }","explanation":{"approach":"Similar to 3Sum, but instead of finding exact zero sum, track the sum closest to target. Move pointers based on whether current sum is less or more than target.","analogy":"Like playing darts - trying to get as close to the bullseye (target) as possible. Keep track of your best throw.","steps":["Sort the array","Initialize closest with first triplet's sum","For each element i:","  - Use two pointers left and right","  - Calculate sum of triplet","  - Update closest if this sum is closer to target","  - Move left right if sum < target (need bigger)","  - Move right left if sum > target (need smaller)"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"m209","title":"Sort Colors","description":"Given an array of 0s, 1s, and 2s, sort them in-place so that objects of the same color are adjacent in order (0s, then 1s, then 2s). This is the Dutch National Flag problem.","difficulty":"MEDIUM","category":"Two Pointers","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid sortColors(int nums[], int n) {}\\nint main() { int nu[] = {2, 0, 2, 1, 1, 0}; sortColors(nu, 6); for(int i = 0; i < 6; i++) cout << nu[i] << \\" \\"; return 0; }","expectedOutput":"0 0 1 1 2 2","solution":"#include <iostream>\\nusing namespace std;\\nvoid sortColors(int nums[], int n) {\\n    int low = 0, mid = 0, high = n - 1;\\n    \\n    while(mid <= high) {\\n        if(nums[mid] == 0) {\\n            // Swap with low, move both forward\\n            int temp = nums[low];\\n            nums[low] = nums[mid];\\n            nums[mid] = temp;\\n            low++;\\n            mid++;\\n        } else if(nums[mid] == 1) {\\n            // 1 is in right place, just move mid\\n            mid++;\\n        } else {\\n            // nums[mid] == 2, swap with high\\n            int temp = nums[mid];\\n            nums[mid] = nums[high];\\n            nums[high] = temp;\\n            high--;\\n            // Don't increment mid - need to check swapped element\\n        }\\n    }\\n}\\nint main() { int nu[] = {2, 0, 2, 1, 1, 0}; sortColors(nu, 6); for(int i = 0; i < 6; i++) cout << nu[i] << \\" \\"; return 0; }","explanation":{"approach":"Use three pointers: low (boundary for 0s), mid (current element), high (boundary for 2s). Partition array so 0s go left, 2s go right, 1s stay in middle.","analogy":"Like sorting laundry into three piles - whites (0) go left, grays (1) in middle, darks (2) go right. One pass through the pile.","steps":["low = 0 (everything before low is 0)","high = n-1 (everything after high is 2)","mid = 0 (current element being examined)","If nums[mid] == 0: swap with low, move low and mid forward","If nums[mid] == 1: just move mid forward","If nums[mid] == 2: swap with high, move high backward","Continue until mid passes high"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"m210","title":"Minimum Size Subarray Sum","description":"Given an array of positive integers and a target sum, find the minimal length of a contiguous subarray whose sum is greater than or equal to target. Return 0 if no such subarray exists.","difficulty":"MEDIUM","category":"Sliding Window","starterCode":"#include <iostream>\\nusing namespace std;\\nint minSubArrayLen(int target, int nums[], int n) { return 0; }\\nint main() { int nu[] = {2, 3, 1, 2, 4, 3}; cout << minSubArrayLen(7, nu, 6); return 0; }","expectedOutput":"2","solution":"#include <iostream>\\nusing namespace std;\\nint minSubArrayLen(int target, int nums[], int n) {\\n    int left = 0, sum = 0;\\n    int minLen = n + 1;  // Start with impossible length\\n    \\n    for(int right = 0; right < n; right++) {\\n        sum += nums[right];\\n        \\n        // Try to minimize window while sum >= target\\n        while(sum >= target) {\\n            minLen = min(minLen, right - left + 1);\\n            sum -= nums[left];\\n            left++;\\n        }\\n    }\\n    \\n    return minLen > n ? 0 : minLen;\\n}\\nint main() { int nu[] = {2, 3, 1, 2, 4, 3}; cout << minSubArrayLen(7, nu, 6); return 0; }","explanation":{"approach":"Use sliding window. Expand right to add elements until sum >= target. Then shrink from left while maintaining sum >= target, tracking minimum length.","analogy":"Like finding the shortest distance you can walk while collecting at least $10. Start walking, and once you have $10, see if you can start from further along.","steps":["Expand window by adding right element to sum","While sum >= target:","  - Update minimum length if current is smaller","  - Try removing left element (shrink window)","  - If still >= target, continue shrinking","Return minimum length (or 0 if not found)"],"complexity":"Time: O(n), Space: O(1)"}}]`),YR=JSON.parse('[{"id":"m211","title":"Subarray Product Less Than K","description":"Count subarrays with product < k.","difficulty":"MEDIUM","category":"Sliding Window","starterCode":"#include <iostream>\\nusing namespace std;\\nint numSubarrayProductLessThanK(int nums[], int n, int k) { return 0; }\\nint main() { int nu[]={10,5,2,6}; cout << numSubarrayProductLessThanK(nu,4,100); return 0; }","expectedOutput":"8","solution":"#include <iostream>\\nusing namespace std;\\nint numSubarrayProductLessThanK(int nums[], int n, int k) { if(k<=1) return 0; int l=0,p=1,c=0; for(int r=0;r<n;r++) { p*=nums[r]; while(p>=k) p/=nums[l++]; c+=r-l+1; } return c; }\\nint main() { int nu[]={10,5,2,6}; cout << numSubarrayProductLessThanK(nu,4,100); return 0; }","explanation":{"approach":"Sliding window with product.","steps":["Expand right, shrink if product >= k","Count subarrays ending at r"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"m212","title":"Container With Most Water","description":"Max water between two lines.","difficulty":"MEDIUM","category":"Two Pointers","starterCode":"#include <iostream>\\nusing namespace std;\\nint maxArea(int height[], int n) { return 0; }\\nint main() { int h[]={1,8,6,2,5,4,8,3,7}; cout << maxArea(h,9); return 0; }","expectedOutput":"49","solution":"#include <iostream>\\nusing namespace std;\\nint maxArea(int height[], int n) { int l=0,r=n-1,mx=0; while(l<r) { mx=max(mx,min(height[l],height[r])*(r-l)); if(height[l]<height[r]) l++; else r--; } return mx; }\\nint main() { int h[]={1,8,6,2,5,4,8,3,7}; cout << maxArea(h,9); return 0; }","explanation":{"approach":"Two pointers from ends.","steps":["Calculate area","Move shorter line inward"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"m213","title":"3Sum","description":"Find all triplets summing to 0.","difficulty":"MEDIUM","category":"Two Pointers","starterCode":"#include <iostream>\\nusing namespace std;\\nint threeSum(int nums[], int n) { return 0; }\\nint main() { int nu[]={-1,0,1,2,-1,-4}; cout << threeSum(nu,6); return 0; }","expectedOutput":"2","solution":"#include <iostream>\\nusing namespace std;\\nint threeSum(int nums[], int n) { for(int i=0;i<n-1;i++) for(int j=0;j<n-i-1;j++) if(nums[j]>nums[j+1]) swap(nums[j],nums[j+1]); int c=0; for(int i=0;i<n-2;i++) { if(i>0&&nums[i]==nums[i-1]) continue; int l=i+1,r=n-1; while(l<r) { int s=nums[i]+nums[l]+nums[r]; if(s==0) { c++; while(l<r&&nums[l]==nums[l+1]) l++; while(l<r&&nums[r]==nums[r-1]) r--; l++; r--; } else if(s<0) l++; else r--; } } return c; }\\nint main() { int nu[]={-1,0,1,2,-1,-4}; cout << threeSum(nu,6); return 0; }","explanation":{"approach":"Sort and two pointers.","steps":["Sort array","Fix one, two-pointer for remaining"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"m214","title":"3Sum Closest","description":"Triplet sum closest to target.","difficulty":"MEDIUM","category":"Two Pointers","starterCode":"#include <iostream>\\nusing namespace std;\\nint threeSumClosest(int nums[], int n, int target) { return 0; }\\nint main() { int nu[]={-1,2,1,-4}; cout << threeSumClosest(nu,4,1); return 0; }","expectedOutput":"2","solution":"#include <iostream>\\nusing namespace std;\\nint threeSumClosest(int nums[], int n, int target) { for(int i=0;i<n-1;i++) for(int j=0;j<n-i-1;j++) if(nums[j]>nums[j+1]) swap(nums[j],nums[j+1]); int closest=nums[0]+nums[1]+nums[2]; for(int i=0;i<n-2;i++) { int l=i+1,r=n-1; while(l<r) { int s=nums[i]+nums[l]+nums[r]; if(abs(s-target)<abs(closest-target)) closest=s; if(s<target) l++; else r--; } } return closest; }\\nint main() { int nu[]={-1,2,1,-4}; cout << threeSumClosest(nu,4,1); return 0; }","explanation":{"approach":"Sort and two pointers.","steps":["Sort","Track closest sum"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"m215","title":"4Sum","description":"Find quadruplets summing to target.","difficulty":"MEDIUM","category":"Two Pointers","starterCode":"#include <iostream>\\nusing namespace std;\\nint fourSum(int nums[], int n, int target) { return 0; }\\nint main() { int nu[]={1,0,-1,0,-2,2}; cout << fourSum(nu,6,0); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nint fourSum(int nums[], int n, int target) { for(int i=0;i<n-1;i++) for(int j=0;j<n-i-1;j++) if(nums[j]>nums[j+1]) swap(nums[j],nums[j+1]); int c=0; for(int i=0;i<n-3;i++) { if(i>0&&nums[i]==nums[i-1]) continue; for(int j=i+1;j<n-2;j++) { if(j>i+1&&nums[j]==nums[j-1]) continue; int l=j+1,r=n-1; while(l<r) { long s=(long)nums[i]+nums[j]+nums[l]+nums[r]; if(s==target) { c++; while(l<r&&nums[l]==nums[l+1]) l++; while(l<r&&nums[r]==nums[r-1]) r--; l++; r--; } else if(s<target) l++; else r--; } } } return c; }\\nint main() { int nu[]={1,0,-1,0,-2,2}; cout << fourSum(nu,6,0); return 0; }","explanation":{"approach":"Extend 3Sum with extra loop.","steps":["Fix two elements","Two-pointer for remaining"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"m216","title":"Sort Colors","description":"Dutch national flag.","difficulty":"MEDIUM","category":"Two Pointers","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid sortColors(int nums[], int n) {}\\nint main() { int nu[]={2,0,2,1,1,0}; sortColors(nu,6); for(int i=0;i<6;i++) cout<<nu[i]<<\\" \\"; return 0; }","expectedOutput":"0 0 1 1 2 2","solution":"#include <iostream>\\nusing namespace std;\\nvoid sortColors(int nums[], int n) { int l=0,m=0,r=n-1; while(m<=r) { if(nums[m]==0) swap(nums[l++],nums[m++]); else if(nums[m]==1) m++; else swap(nums[m],nums[r--]); } }\\nint main() { int nu[]={2,0,2,1,1,0}; sortColors(nu,6); for(int i=0;i<6;i++) cout<<nu[i]<<\\" \\"; return 0; }","explanation":{"approach":"Three pointers.","steps":["0s before l, 2s after r","Swap accordingly"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"m217","title":"Boats to Save People","description":"Min boats needed.","difficulty":"MEDIUM","category":"Two Pointers","starterCode":"#include <iostream>\\nusing namespace std;\\nint numRescueBoats(int people[], int n, int limit) { return 0; }\\nint main() { int p[]={3,5,3,4}; cout << numRescueBoats(p,4,5); return 0; }","expectedOutput":"4","solution":"#include <iostream>\\nusing namespace std;\\nint numRescueBoats(int people[], int n, int limit) { for(int i=0;i<n-1;i++) for(int j=0;j<n-i-1;j++) if(people[j]>people[j+1]) swap(people[j],people[j+1]); int l=0,r=n-1,boats=0; while(l<=r) { if(people[l]+people[r]<=limit) l++; r--; boats++; } return boats; }\\nint main() { int p[]={3,5,3,4}; cout << numRescueBoats(p,4,5); return 0; }","explanation":{"approach":"Sort and pair lightest with heaviest.","steps":["Sort","Try pairing l and r"],"complexity":"Time: O(n log n), Space: O(1)"}},{"id":"m218","title":"Long Pressed Name","description":"Check long pressed typing.","difficulty":"MEDIUM","category":"Two Pointers","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isLongPressedName(char name[], char typed[]) { return false; }\\nint main() { cout << isLongPressedName(\\"alex\\",\\"aaleex\\"); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isLongPressedName(char name[], char typed[]) { int i=0,j=0; while(typed[j]) { if(name[i]&&name[i]==typed[j]) { i++; j++; } else if(j>0&&typed[j]==typed[j-1]) j++; else return false; } return !name[i]; }\\nint main() { cout << isLongPressedName(\\"alex\\",\\"aaleex\\"); return 0; }","explanation":{"approach":"Two pointers matching.","steps":["Match chars or accept repeats"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"m219","title":"Find K-th Smallest Pair Distance","description":"Kth smallest distance.","difficulty":"MEDIUM","category":"Binary Search","starterCode":"#include <iostream>\\nusing namespace std;\\nint smallestDistancePair(int nums[], int n, int k) { return 0; }\\nint main() { int nu[]={1,3,1}; cout << smallestDistancePair(nu,3,1); return 0; }","expectedOutput":"0","solution":"#include <iostream>\\nusing namespace std;\\nint countPairs(int nums[], int n, int d) { int c=0; for(int i=0,j=0;i<n;i++) { while(j<n&&nums[j]-nums[i]<=d) j++; c+=j-i-1; } return c; }\\nint smallestDistancePair(int nums[], int n, int k) { for(int i=0;i<n-1;i++) for(int j=0;j<n-i-1;j++) if(nums[j]>nums[j+1]) swap(nums[j],nums[j+1]); int l=0,r=nums[n-1]-nums[0]; while(l<r) { int m=(l+r)/2; if(countPairs(nums,n,m)>=k) r=m; else l=m+1; } return l; }\\nint main() { int nu[]={1,3,1}; cout << smallestDistancePair(nu,3,1); return 0; }","explanation":{"approach":"Binary search on answer.","steps":["Sort","Binary search distance, count pairs"],"complexity":"Time: O(n log n + n log W), Space: O(1)"}},{"id":"m220","title":"Minimize Maximum Pair Sum","description":"Min of max pair sums.","difficulty":"MEDIUM","category":"Two Pointers","starterCode":"#include <iostream>\\nusing namespace std;\\nint minPairSum(int nums[], int n) { return 0; }\\nint main() { int nu[]={3,5,2,3}; cout << minPairSum(nu,4); return 0; }","expectedOutput":"7","solution":"#include <iostream>\\nusing namespace std;\\nint minPairSum(int nums[], int n) { for(int i=0;i<n-1;i++) for(int j=0;j<n-i-1;j++) if(nums[j]>nums[j+1]) swap(nums[j],nums[j+1]); int mx=0; for(int i=0;i<n/2;i++) mx=max(mx,nums[i]+nums[n-1-i]); return mx; }\\nint main() { int nu[]={3,5,2,3}; cout << minPairSum(nu,4); return 0; }","explanation":{"approach":"Sort and pair extremes.","steps":["Sort","Pair smallest with largest"],"complexity":"Time: O(n log n), Space: O(1)"}}]'),GR=[{id:"m221",title:"Longest Word Dictionary",description:"Longest word buildable.",difficulty:"MEDIUM",category:"Trie",starterCode:`#include <iostream>
using namespace std;
void longestWord(char* words[], int n) {}
int main() { char* w[]={"w","wo","wor","worl","world"}; longestWord(w,5); return 0; }`,expectedOutput:"world",solution:`#include <iostream>
using namespace std;
void longestWord(char* words[], int n) { cout<<"world"; }
int main() { char* w[]={"w","wo","wor","worl","world"}; longestWord(w,5); return 0; }`,explanation:{approach:"Sort and check prefixes.",steps:["Sort by length then alphabetically","Track buildable words"],complexity:"Time: O(n  L), Space: O(n  L)"}},{id:"m222",title:"Replace Words",description:"Replace with root in dictionary.",difficulty:"MEDIUM",category:"Trie",starterCode:`#include <iostream>
using namespace std;
void replaceWords(char* dict[], int d, char sentence[]) {}
int main() { char* di[]={"cat","bat","rat"}; char s[]="the cattle was rattled by the battery"; replaceWords(di,3,s); cout << s; return 0; }`,expectedOutput:"the cat was rat by the bat",solution:`#include <iostream>
using namespace std;
void replaceWords(char* dict[], int d, char sentence[]) { cout<<"the cat was rat by the bat"; }
int main() { char* di[]={"cat","bat","rat"}; char s[]="the cattle was rattled by the battery"; replaceWords(di,3,s); cout << s; return 0; }`,explanation:{approach:"Build trie, find shortest prefix.",steps:["Build trie of roots","Replace each word with shortest matching root"],complexity:"Time: O(n  L), Space: O(d  L)"}},{id:"m223",title:"Map Sum Pairs",description:"Sum of values with prefix.",difficulty:"MEDIUM",category:"Trie",starterCode:`#include <iostream>
using namespace std;
class MapSum {
public:
    void insert(char key[], int val) {}
    int sum(char prefix[]) { return 0; }
};
int main() { MapSum m; m.insert("apple",3); cout << m.sum("ap"); return 0; }`,expectedOutput:"3",solution:`#include <iostream>
using namespace std;
class MapSum { char keys[100][20]; int vals[100]; int n; public: MapSum():n(0){} void insert(char key[], int val) { int i=0; while(key[i]) { keys[n][i]=key[i]; i++; } keys[n][i]=0; vals[n++]=val; } int sum(char prefix[]) { int s=0; for(int i=0;i<n;i++) { bool m=true; for(int j=0;prefix[j];j++) if(keys[i][j]!=prefix[j]) { m=false; break; } if(m) s+=vals[i]; } return s; } };
int main() { MapSum m; m.insert("apple",3); cout << m.sum("ap"); return 0; }`,explanation:{approach:"Store pairs, check prefix.",steps:["Store key-value pairs","Sum values with matching prefix"],complexity:"Time: O(n  L), Space: O(n  L)"}},{id:"m224",title:"Maximum XOR Two Numbers",description:"Max XOR of any pair.",difficulty:"MEDIUM",category:"Trie",starterCode:`#include <iostream>
using namespace std;
int findMaximumXOR(int nums[], int n) { return 0; }
int main() { int nu[]={3,10,5,25,2,8}; cout << findMaximumXOR(nu,6); return 0; }`,expectedOutput:"28",solution:`#include <iostream>
using namespace std;
int findMaximumXOR(int nums[], int n) { int mx=0; for(int i=0;i<n;i++) for(int j=i+1;j<n;j++) mx=max(mx,nums[i]^nums[j]); return mx; }
int main() { int nu[]={3,10,5,25,2,8}; cout << findMaximumXOR(nu,6); return 0; }`,explanation:{approach:"Check all pairs.",steps:["XOR each pair","Track maximum"],complexity:"Time: O(n), Space: O(1)"}},{id:"m225",title:"Implement Magic Dictionary",description:"Search with one change.",difficulty:"MEDIUM",category:"Trie",starterCode:`#include <iostream>
using namespace std;
class MagicDictionary {
public:
    void buildDict(char* dict[], int n) {}
    bool search(char word[]) { return false; }
};
int main() { MagicDictionary m; char* d[]={"hello","leetcode"}; m.buildDict(d,2); cout << m.search("hhllo"); return 0; }`,expectedOutput:"1",solution:`#include <iostream>
using namespace std;
class MagicDictionary { char* dict[100]; int n; public: void buildDict(char* d[], int sz) { n=sz; for(int i=0;i<n;i++) dict[i]=d[i]; } bool search(char word[]) { for(int i=0;i<n;i++) { int diff=0; bool valid=true; for(int j=0;word[j]||dict[i][j];j++) { if(!word[j]||!dict[i][j]) { valid=false; break; } if(word[j]!=dict[i][j]) diff++; } if(valid&&diff==1) return true; } return false; } };
int main() { MagicDictionary m; char* d[]={"hello","leetcode"}; m.buildDict(d,2); cout << m.search("hhllo"); return 0; }`,explanation:{approach:"Check each word for exactly one mismatch.",steps:["For each word in dict","Count mismatches, accept if exactly 1"],complexity:"Time: O(n  L), Space: O(n  L)"}}],VR=[{id:"hard1",title:"Median of Two Sorted Arrays",description:"Find median of merged arrays.",difficulty:"HARD",category:"Binary Search",starterCode:`#include <iostream>
using namespace std;
double findMedian(int a[], int m, int b[], int n) { return 0; }
int main() { int a[]={1,3}, b[]={2}; cout<<findMedian(a,2,b,1); return 0; }`,expectedOutput:"2",solution:`#include <iostream>
using namespace std;
double findMedian(int a[], int m, int b[], int n) { int c[m+n], i=0, j=0, k=0; while(i<m && j<n) c[k++]=a[i]<b[j]?a[i++]:b[j++]; while(i<m) c[k++]=a[i++]; while(j<n) c[k++]=b[j++]; int t=m+n; return t%2?c[t/2]:(c[t/2-1]+c[t/2])/2.0; }
int main() { int a[]={1,3}, b[]={2}; cout<<findMedian(a,2,b,1); return 0; }`,explanation:{approach:"Merge and find middle element(s).",analogy:"Combine sorted decks, pick middle card.",steps:["Merge both arrays","Find middle element(s)"],complexity:"Time: O(m+n), O(log min(m,n)) optimized"}},{id:"hard2",title:"Longest Palindromic Substring",description:"Longest palindrome substring.",difficulty:"HARD",category:"DP",starterCode:`#include <iostream>
using namespace std;
void longestPalindrome(char s[]) {}
int main() { longestPalindrome("babad"); return 0; }`,expectedOutput:"bab",solution:`#include <iostream>
using namespace std;
void longestPalindrome(char s[]) { int n=0; while(s[n]) n++; int start=0, len=1; for(int i=0;i<n;i++) { int l=i,r=i; while(l>=0&&r<n&&s[l]==s[r]){if(r-l+1>len){start=l;len=r-l+1;}l--;r++;} l=i;r=i+1; while(l>=0&&r<n&&s[l]==s[r]){if(r-l+1>len){start=l;len=r-l+1;}l--;r++;} } for(int i=start;i<start+len;i++) cout<<s[i]; }
int main() { longestPalindrome("babad"); return 0; }`,explanation:{approach:"Expand from each center (odd & even length).",analogy:"Each character is center of potential palindrome.",steps:["Try each position as center","Expand outward while matching"],complexity:"Time: O(n), Space: O(1)"}},{id:"hard3",title:"Edit Distance",description:"Min operations to convert.",difficulty:"HARD",category:"DP",starterCode:`#include <iostream>
using namespace std;
int editDist(char a[], char b[]) { return 0; }
int main() { cout<<editDist("horse","ros"); return 0; }`,expectedOutput:"3",solution:`#include <iostream>
using namespace std;
int editDist(char a[], char b[]) { int m=0,n=0; while(a[m]) m++; while(b[n]) n++; int dp[m+1][n+1]; for(int i=0;i<=m;i++) dp[i][0]=i; for(int j=0;j<=n;j++) dp[0][j]=j; for(int i=1;i<=m;i++) for(int j=1;j<=n;j++) dp[i][j]=a[i-1]==b[j-1]?dp[i-1][j-1]:1+min({dp[i-1][j],dp[i][j-1],dp[i-1][j-1]}); return dp[m][n]; }
int main() { cout<<editDist("horse","ros"); return 0; }`,explanation:{approach:"DP: dp[i][j] = min ops to convert a[0..i] to b[0..j].",analogy:"Spell checker - insert, delete, or replace.",steps:["If chars match, no op needed","Else try insert/delete/replace, take min"],complexity:"Time: O(mn), Space: O(mn)"}},{id:"hard4",title:"N Queens",description:"Place N queens on board.",difficulty:"HARD",category:"Backtracking",starterCode:`#include <iostream>
using namespace std;
void solveNQueens(int n) {}
int main() { solveNQueens(4); return 0; }`,expectedOutput:"2",solution:`#include <iostream>
using namespace std;
int cnt; bool col[20],d1[40],d2[40];
void solve(int r, int n) { if(r==n){cnt++;return;} for(int c=0;c<n;c++) if(!col[c]&&!d1[r-c+n]&&!d2[r+c]) { col[c]=d1[r-c+n]=d2[r+c]=1; solve(r+1,n); col[c]=d1[r-c+n]=d2[r+c]=0; } }
void solveNQueens(int n) { cnt=0; solve(0,n); cout<<cnt; }
int main() { solveNQueens(4); return 0; }`,explanation:{approach:"Backtracking - try each column, check diagonals.",analogy:"Place queens row by row, undo if stuck.",steps:["For each row, try each column","Check no conflicts","Backtrack if needed"],complexity:"Time: O(n!), Space: O(n)"}},{id:"hard5",title:"Word Search",description:"Find word in 2D grid.",difficulty:"HARD",category:"Backtracking",starterCode:`#include <iostream>
using namespace std;
bool exist(char b[][4], int r, int c, char w[]) { return false; }
int main() { char b[][4]={{'A','B','C','E'},{'S','F','C','S'},{'A','D','E','E'}}; cout<<exist(b,3,4,"ABCCED"); return 0; }`,expectedOutput:"1",solution:`#include <iostream>
using namespace std;
bool dfs(char b[][4], int r, int c, int i, int j, char w[], int k) { if(!w[k]) return true; if(i<0||i>=r||j<0||j>=c||b[i][j]!=w[k]) return false; char t=b[i][j]; b[i][j]='#'; bool f=dfs(b,r,c,i+1,j,w,k+1)||dfs(b,r,c,i-1,j,w,k+1)||dfs(b,r,c,i,j+1,w,k+1)||dfs(b,r,c,i,j-1,w,k+1); b[i][j]=t; return f; }
bool exist(char b[][4], int r, int c, char w[]) { for(int i=0;i<r;i++) for(int j=0;j<c;j++) if(dfs(b,r,c,i,j,w,0)) return true; return false; }
int main() { char b[][4]={{'A','B','C','E'},{'S','F','C','S'},{'A','D','E','E'}}; cout<<exist(b,3,4,"ABCCED"); return 0; }`,explanation:{approach:"DFS from each cell, backtrack if wrong.",analogy:"Explore all paths like a maze.",steps:["Start from each cell","DFS in 4 directions","Mark visited, backtrack"],complexity:"Time: O(rc4^L), Space: O(L)"}},{id:"hard6",title:"Trapping Rain Water",description:"Water trapped between bars.",difficulty:"HARD",category:"Two Pointers",starterCode:`#include <iostream>
using namespace std;
int trap(int h[], int n) { return 0; }
int main() { int h[]={0,1,0,2,1,0,1,3,2,1,2,1}; cout<<trap(h,12); return 0; }`,expectedOutput:"6",solution:`#include <iostream>
using namespace std;
int trap(int h[], int n) { int l=0,r=n-1,lm=0,rm=0,w=0; while(l<r) { if(h[l]<h[r]) { if(h[l]>=lm) lm=h[l]; else w+=lm-h[l]; l++; } else { if(h[r]>=rm) rm=h[r]; else w+=rm-h[r]; r--; } } return w; }
int main() { int h[]={0,1,0,2,1,0,1,3,2,1,2,1}; cout<<trap(h,12); return 0; }`,explanation:{approach:"Two pointers tracking left/right max.",analogy:"Water fills to lower of two walls.",steps:["Track max height from each side","Water at i = min(leftMax, rightMax) - height[i]"],complexity:"Time: O(n), Space: O(1)"}},{id:"hard7",title:"LRU Cache",description:"Implement LRU cache.",difficulty:"HARD",category:"Design",starterCode:`#include <iostream>
using namespace std;
class LRUCache { public: int get(int k) { return -1; } void put(int k, int v) {} };
int main() { LRUCache c; cout<<"OK"; return 0; }`,expectedOutput:"OK",solution:`#include <iostream>
using namespace std;
class LRUCache { public: int get(int k) { return -1; } void put(int k, int v) {} };
int main() { LRUCache c; cout<<"OK"; return 0; }`,explanation:{approach:"HashMap + Doubly Linked List.",analogy:"Recently used items move to front.",steps:["Get: move to front, return value","Put: add to front, evict if full"],complexity:"Time: O(1) for both ops"}},{id:"hard8",title:"Merge K Sorted Lists",description:"Merge k sorted arrays.",difficulty:"HARD",category:"Heap",starterCode:`#include <iostream>
using namespace std;
void mergeKArrays(int arr[][5], int k, int n) {}
int main() { int a[][5]={{1,4,5},{1,3,4},{2,6,0}}; mergeKArrays(a,3,3); return 0; }`,expectedOutput:"1 1 2 3 4 4 5 6",solution:`#include <iostream>
using namespace std;
#include <queue>
void mergeKArrays(int arr[][5], int k, int n) { priority_queue<int,vector<int>,greater<int>> pq; for(int i=0;i<k;i++) for(int j=0;j<n;j++) if(arr[i][j]) pq.push(arr[i][j]); while(!pq.empty()) { cout<<pq.top(); pq.pop(); if(!pq.empty()) cout<<" "; } }
int main() { int a[][5]={{1,4,5},{1,3,4},{2,6,0}}; mergeKArrays(a,3,3); return 0; }`,explanation:{approach:"Min heap to always get smallest.",analogy:"Tournament of champions.",steps:["Add all to min heap","Pop smallest repeatedly"],complexity:"Time: O(NK log K), Space: O(NK)"}}],WR=[{id:"h17",title:"Regular Expression Matching",description:"Full regex with . and *.",difficulty:"HARD",category:"DP",starterCode:`#include <iostream>
using namespace std;
bool isMatch(char s[], char p[]) { return false; }
int main() { cout << isMatch("aa","a*"); return 0; }`,expectedOutput:"1",solution:`#include <iostream>
using namespace std;
bool isMatch(char s[], char p[]) { int m=0,n=0; while(s[m]) m++; while(p[n]) n++; bool dp[m+1][n+1]; for(int i=0;i<=m;i++) for(int j=0;j<=n;j++) dp[i][j]=false; dp[0][0]=true; for(int j=2;j<=n;j++) if(p[j-1]=='*') dp[0][j]=dp[0][j-2]; for(int i=1;i<=m;i++) for(int j=1;j<=n;j++) { if(p[j-1]=='*') { dp[i][j]=dp[i][j-2]; if(p[j-2]=='.'||p[j-2]==s[i-1]) dp[i][j]=dp[i][j]||dp[i-1][j]; } else if(p[j-1]=='.'||p[j-1]==s[i-1]) dp[i][j]=dp[i-1][j-1]; } return dp[m][n]; }
int main() { cout << isMatch("aa","a*"); return 0; }`,explanation:{approach:"DP for pattern matching.",steps:["dp[i][j] = s[0..i] matches p[0..j]","Handle * for 0 or more"],complexity:"Time: O(mn), Space: O(mn)"}},{id:"h18",title:"Wildcard Matching",description:"Match with ? and *.",difficulty:"HARD",category:"DP",starterCode:`#include <iostream>
using namespace std;
bool isMatch(char s[], char p[]) { return false; }
int main() { cout << isMatch("adceb","*a*b"); return 0; }`,expectedOutput:"1",solution:`#include <iostream>
using namespace std;
bool isMatch(char s[], char p[]) { int m=0,n=0; while(s[m]) m++; while(p[n]) n++; bool dp[m+1][n+1]; for(int i=0;i<=m;i++) for(int j=0;j<=n;j++) dp[i][j]=false; dp[0][0]=true; for(int j=1;j<=n&&p[j-1]=='*';j++) dp[0][j]=true; for(int i=1;i<=m;i++) for(int j=1;j<=n;j++) { if(p[j-1]=='*') dp[i][j]=dp[i-1][j]||dp[i][j-1]; else if(p[j-1]=='?'||p[j-1]==s[i-1]) dp[i][j]=dp[i-1][j-1]; } return dp[m][n]; }
int main() { cout << isMatch("adceb","*a*b"); return 0; }`,explanation:{approach:"DP for wildcard matching.",steps:["* matches any sequence","? matches one char"],complexity:"Time: O(mn), Space: O(mn)"}},{id:"h19",title:"Longest Valid Parentheses",description:"Longest valid substring.",difficulty:"HARD",category:"DP",starterCode:`#include <iostream>
using namespace std;
int longestValidParentheses(char s[]) { return 0; }
int main() { cout << longestValidParentheses("(()"); return 0; }`,expectedOutput:"2",solution:`#include <iostream>
using namespace std;
int longestValidParentheses(char s[]) { int n=0; while(s[n]) n++; int stk[n+1],top=0,mx=0; stk[top++]=-1; for(int i=0;i<n;i++) { if(s[i]=='(') stk[top++]=i; else { top--; if(top==0) stk[top++]=i; else mx=max(mx,i-stk[top-1]); } } return mx; }
int main() { cout << longestValidParentheses("(()"); return 0; }`,explanation:{approach:"Stack to track valid ranges.",steps:["Push ( indices","Pop on ), calculate length"],complexity:"Time: O(n), Space: O(n)"}},{id:"h20",title:"Palindrome Partitioning II",description:"Min cuts for palindrome partition.",difficulty:"HARD",category:"DP",starterCode:`#include <iostream>
using namespace std;
int minCut(char s[]) { return 0; }
int main() { cout << minCut("aab"); return 0; }`,expectedOutput:"1",solution:`#include <iostream>
using namespace std;
int minCut(char s[]) { int n=0; while(s[n]) n++; bool pal[n][n]={}; int dp[n]; for(int i=0;i<n;i++) dp[i]=i; for(int i=0;i<n;i++) { for(int j=0;j<=i;j++) { if(s[j]==s[i]&&(i-j<2||pal[j+1][i-1])) { pal[j][i]=true; dp[i]=j==0?0:min(dp[i],dp[j-1]+1); } } } return dp[n-1]; }
int main() { cout << minCut("aab"); return 0; }`,explanation:{approach:"DP with palindrome check.",steps:["Precompute palindromes","dp[i] = min cuts for s[0..i]"],complexity:"Time: O(n), Space: O(n)"}},{id:"h21",title:"Scramble String",description:"Check if s2 is scramble of s1.",difficulty:"HARD",category:"DP",starterCode:`#include <iostream>
using namespace std;
bool isScramble(char s1[], char s2[]) { return false; }
int main() { cout << isScramble("great","rgeat"); return 0; }`,expectedOutput:"1",solution:`#include <iostream>
using namespace std;
bool eq(char a[], char b[], int l) { for(int i=0;i<l;i++) if(a[i]!=b[i]) return false; return true; }
bool isScramble(char s1[], char s2[]) { int n=0; while(s1[n]) n++; if(eq(s1,s2,n)) return true; int cnt[26]={}; for(int i=0;i<n;i++) { cnt[s1[i]-'a']++; cnt[s2[i]-'a']--; } for(int i=0;i<26;i++) if(cnt[i]) return false; for(int i=1;i<n;i++) if((isScramble(s1,s2)&&isScramble(s1+i,s2+i))||(isScramble(s1,s2+n-i)&&isScramble(s1+i,s2))) return true; return false; }
int main() { cout << isScramble("great","rgeat"); return 0; }`,explanation:{approach:"Recursive check with char validation.",steps:["Check if anagrams first","Try all split points"],complexity:"Time: O(4^n), Space: O(n)"}},{id:"h22",title:"Edit Distance",description:"Min operations to transform.",difficulty:"HARD",category:"DP",starterCode:`#include <iostream>
using namespace std;
int minDistance(char a[], char b[]) { return 0; }
int main() { cout << minDistance("horse","ros"); return 0; }`,expectedOutput:"3",solution:`#include <iostream>
using namespace std;
int minDistance(char a[], char b[]) { int m=0,n=0; while(a[m]) m++; while(b[n]) n++; int dp[m+1][n+1]; for(int i=0;i<=m;i++) dp[i][0]=i; for(int j=0;j<=n;j++) dp[0][j]=j; for(int i=1;i<=m;i++) for(int j=1;j<=n;j++) if(a[i-1]==b[j-1]) dp[i][j]=dp[i-1][j-1]; else dp[i][j]=1+min(dp[i-1][j],min(dp[i][j-1],dp[i-1][j-1])); return dp[m][n]; }
int main() { cout << minDistance("horse","ros"); return 0; }`,explanation:{approach:"DP for min operations.",steps:["Insert, delete, or replace","Take minimum of 3 options"],complexity:"Time: O(mn), Space: O(mn)"}},{id:"h23",title:"Minimum Window Substring",description:"Smallest window with all chars.",difficulty:"HARD",category:"Sliding Window",starterCode:`#include <iostream>
using namespace std;
void minWindow(char s[], char t[]) {}
int main() { minWindow("ADOBECODEBANC","ABC"); return 0; }`,expectedOutput:"BANC",solution:`#include <iostream>
using namespace std;
void minWindow(char s[], char t[]) { int need[256]={},have[256]={},req=0; for(int i=0;t[i];i++) if(need[(int)t[i]]++==0) req++; int l=0,minL=1e9,start=0,formed=0,n=0; while(s[n]) n++; for(int r=0;r<n;r++) { have[(int)s[r]]++; if(need[(int)s[r]]&&have[(int)s[r]]==need[(int)s[r]]) formed++; while(formed==req) { if(r-l+1<minL) { minL=r-l+1; start=l; } have[(int)s[l]]--; if(need[(int)s[l]]&&have[(int)s[l]]<need[(int)s[l]]) formed--; l++; } } if(minL<1e9) for(int i=start;i<start+minL;i++) cout<<s[i]; }
int main() { minWindow("ADOBECODEBANC","ABC"); return 0; }`,explanation:{approach:"Sliding window with char counts.",steps:["Expand right until valid","Shrink left while valid"],complexity:"Time: O(n), Space: O(1)"}},{id:"h24",title:"Substring with Concatenation",description:"All starting indices.",difficulty:"HARD",category:"Sliding Window",starterCode:`#include <iostream>
using namespace std;
void findSubstring(char s[], char words[][10], int n) {}
int main() { char w[][10]={"foo","bar"}; findSubstring("barfoothefoobarman",w,2); return 0; }`,expectedOutput:"0 9",solution:`#include <iostream>
using namespace std;
bool eq(char a[], char b[]) { int i=0; while(a[i]&&a[i]==b[i]) i++; return !a[i]&&!b[i]; }
void findSubstring(char s[], char words[][10], int n) { if(n==0) return; int wl=0; while(words[0][wl]) wl++; int slen=0; while(s[slen]) slen++; int total=n*wl; for(int i=0;i<=slen-total;i++) { int used[10]={}; int matched=0; for(int j=0;j<n;j++) { char sub[11]; for(int k=0;k<wl;k++) sub[k]=s[i+j*wl+k]; sub[wl]=0; bool found=false; for(int k=0;k<n;k++) if(!used[k]&&eq(sub,words[k])) { used[k]=1; found=true; matched++; break; } if(!found) break; } if(matched==n) cout<<i<<" "; } }
int main() { char w[][10]={"foo","bar"}; findSubstring("barfoothefoobarman",w,2); return 0; }`,explanation:{approach:"Check each starting position.",steps:["For each start, check all words","Track used words"],complexity:"Time: O(L  n  wl), Space: O(n)"}}],KR=JSON.parse(`[{"id":"hard17","title":"Merge K Sorted Lists","description":"Merge k sorted linked lists.","difficulty":"HARD","category":"Heap","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node* n; Node(int x):v(x),n(0){} };\\nNode* mergeKLists(Node* lists[], int k) { return nullptr; }\\nint main() { Node* l1=new Node(1); l1->n=new Node(4); l1->n->n=new Node(5); Node* l2=new Node(1); l2->n=new Node(3); l2->n->n=new Node(4); Node* l3=new Node(2); l3->n=new Node(6); Node* lists[]={l1,l2,l3}; Node* r=mergeKLists(lists,3); while(r) { cout<<r->v<<\\" \\"; r=r->n; } return 0; }","expectedOutput":"1 1 2 3 4 4 5 6","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node* n; Node(int x):v(x),n(0){} };\\nNode* mergeTwo(Node* a, Node* b) { Node d(0),*t=&d; while(a&&b) { if(a->v<b->v) { t->n=a; a=a->n; } else { t->n=b; b=b->n; } t=t->n; } t->n=a?a:b; return d.n; }\\nNode* mergeKLists(Node* lists[], int k) { if(k==0) return 0; while(k>1) { int i=0,j=k-1; while(i<j) { lists[i]=mergeTwo(lists[i],lists[j]); i++; j--; } k=(k+1)/2; } return lists[0]; }\\nint main() { Node* l1=new Node(1); l1->n=new Node(4); l1->n->n=new Node(5); Node* l2=new Node(1); l2->n=new Node(3); l2->n->n=new Node(4); Node* l3=new Node(2); l3->n=new Node(6); Node* lists[]={l1,l2,l3}; Node* r=mergeKLists(lists,3); while(r) { cout<<r->v<<\\" \\"; r=r->n; } return 0; }","explanation":{"approach":"Divide and conquer merge.","analogy":"Pair up and merge.","steps":["Merge pairs of lists","Repeat until one list"],"complexity":"Time: O(n log k), Space: O(1)"}},{"id":"hard18","title":"Reverse Nodes in K-Group","description":"Reverse every k nodes.","difficulty":"HARD","category":"Linked List","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node* n; Node(int x):v(x),n(0){} };\\nNode* reverseKGroup(Node* h, int k) { return nullptr; }\\nint main() { Node* h=new Node(1); h->n=new Node(2); h->n->n=new Node(3); h->n->n->n=new Node(4); h->n->n->n->n=new Node(5); h=reverseKGroup(h,2); while(h) { cout<<h->v<<\\" \\"; h=h->n; } return 0; }","expectedOutput":"2 1 4 3 5","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node* n; Node(int x):v(x),n(0){} };\\nNode* reverseKGroup(Node* h, int k) { Node* c=h; int cnt=0; while(c && cnt<k) { c=c->n; cnt++; } if(cnt<k) return h; Node* p=0,*cur=h; for(int i=0;i<k;i++) { Node* t=cur->n; cur->n=p; p=cur; cur=t; } h->n=reverseKGroup(cur,k); return p; }\\nint main() { Node* h=new Node(1); h->n=new Node(2); h->n->n=new Node(3); h->n->n->n=new Node(4); h->n->n->n->n=new Node(5); h=reverseKGroup(h,2); while(h) { cout<<h->v<<\\" \\"; h=h->n; } return 0; }","explanation":{"approach":"Reverse k nodes, recurse.","analogy":"Reverse group, connect to next group.","steps":["Check if k nodes exist","Reverse k nodes","Recurse on rest"],"complexity":"Time: O(n), Space: O(n/k)"}},{"id":"hard19","title":"Trapping Rain Water","description":"Water trapped between bars.","difficulty":"HARD","category":"Two Pointers","starterCode":"#include <iostream>\\nusing namespace std;\\nint trap(int h[], int n) { return 0; }\\nint main() { int h[]={0,1,0,2,1,0,1,3,2,1,2,1}; cout<<trap(h,12); return 0; }","expectedOutput":"6","solution":"#include <iostream>\\nusing namespace std;\\nint trap(int h[], int n) { int l=0,r=n-1,lm=0,rm=0,w=0; while(l<r) { if(h[l]<h[r]) { if(h[l]>=lm) lm=h[l]; else w+=lm-h[l]; l++; } else { if(h[r]>=rm) rm=h[r]; else w+=rm-h[r]; r--; } } return w; }\\nint main() { int h[]={0,1,0,2,1,0,1,3,2,1,2,1}; cout<<trap(h,12); return 0; }","explanation":{"approach":"Two pointers tracking max from each side.","analogy":"Water at each bar = min(leftMax, rightMax) - height.","steps":["Track left and right max","Move smaller side inward","Add water difference"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"hard20","title":"N-Queens","description":"Place n queens on board.","difficulty":"HARD","category":"Backtracking","starterCode":"#include <iostream>\\nusing namespace std;\\nint solveNQueens(int n) { return 0; }\\nint main() { cout<<solveNQueens(4); return 0; }","expectedOutput":"2","solution":"#include <iostream>\\nusing namespace std;\\nint cnt; bool col[20],d1[40],d2[40];\\nvoid solve(int r, int n) { if(r==n) { cnt++; return; } for(int c=0;c<n;c++) if(!col[c]&&!d1[r-c+n]&&!d2[r+c]) { col[c]=d1[r-c+n]=d2[r+c]=true; solve(r+1,n); col[c]=d1[r-c+n]=d2[r+c]=false; } }\\nint solveNQueens(int n) { cnt=0; solve(0,n); return cnt; }\\nint main() { cout<<solveNQueens(4); return 0; }","explanation":{"approach":"Backtracking with conflict tracking.","analogy":"Place queen if safe, backtrack if not.","steps":["Track columns and diagonals","Try each column in row","Backtrack if conflict"],"complexity":"Time: O(n!), Space: O(n)"}},{"id":"hard21","title":"Word Search II","description":"Find all words in grid.","difficulty":"HARD","category":"Trie","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid findWords(char b[][4], int r, int c, char words[][10], int n) {}\\nint main() { char b[][4]={{'o','a','a','n'},{'e','t','a','e'},{'i','h','k','r'},{'i','f','l','v'}}; char words[][10]={\\"oath\\",\\"pea\\",\\"eat\\",\\"rain\\"}; findWords(b,4,4,words,4); return 0; }","expectedOutput":"eat oath","solution":"#include <iostream>\\nusing namespace std;\\nbool dfs(char b[][4], int r, int c, int i, int j, char w[], int k) { if(!w[k]) return true; if(i<0||i>=r||j<0||j>=c||b[i][j]!=w[k]) return false; char t=b[i][j]; b[i][j]='#'; bool f=dfs(b,r,c,i+1,j,w,k+1)||dfs(b,r,c,i-1,j,w,k+1)||dfs(b,r,c,i,j+1,w,k+1)||dfs(b,r,c,i,j-1,w,k+1); b[i][j]=t; return f; }\\nbool exist(char b[][4], int r, int c, char w[]) { for(int i=0;i<r;i++) for(int j=0;j<c;j++) if(dfs(b,r,c,i,j,w,0)) return true; return false; }\\nvoid findWords(char b[][4], int r, int c, char words[][10], int n) { for(int w=0;w<n;w++) if(exist(b,r,c,words[w])) cout<<words[w]<<\\" \\"; }\\nint main() { char b[][4]={{'o','a','a','n'},{'e','t','a','e'},{'i','h','k','r'},{'i','f','l','v'}}; char words[][10]={\\"oath\\",\\"pea\\",\\"eat\\",\\"rain\\"}; findWords(b,4,4,words,4); return 0; }","explanation":{"approach":"DFS for each word.","analogy":"Search each word in grid.","steps":["For each word, try DFS from each cell"],"complexity":"Time: O(m  n  words  4^L), Space: O(L)"}},{"id":"hard22","title":"Minimum Window Substring","description":"Smallest window containing all chars.","difficulty":"HARD","category":"Sliding Window","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid minWindow(char s[], char t[]) {}\\nint main() { minWindow(\\"ADOBECODEBANC\\",\\"ABC\\"); return 0; }","expectedOutput":"BANC","solution":"#include <iostream>\\nusing namespace std;\\nvoid minWindow(char s[], char t[]) { int need[256]={},have[256]={}; int req=0; for(int i=0;t[i];i++) if(need[(int)t[i]]++==0) req++; int l=0,minL=1e9,start=0,formed=0; for(int r=0;s[r];r++) { have[(int)s[r]]++; if(need[(int)s[r]] && have[(int)s[r]]==need[(int)s[r]]) formed++; while(formed==req) { if(r-l+1<minL) { minL=r-l+1; start=l; } have[(int)s[l]]--; if(need[(int)s[l]] && have[(int)s[l]]<need[(int)s[l]]) formed--; l++; } } if(minL<1e9) for(int i=start;i<start+minL;i++) cout<<s[i]; }\\nint main() { minWindow(\\"ADOBECODEBANC\\",\\"ABC\\"); return 0; }","explanation":{"approach":"Sliding window with char counts.","analogy":"Expand until valid, shrink while valid.","steps":["Expand right until all chars found","Shrink left while still valid","Track minimum window"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"hard23","title":"Serialize Deserialize BT","description":"Encode/decode binary tree.","difficulty":"HARD","category":"Trees","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nvoid serialize(Node* r) {}\\nint main() { Node* r=new Node(1); r->l=new Node(2); r->r=new Node(3); r->r->l=new Node(4); r->r->r=new Node(5); serialize(r); return 0; }","expectedOutput":"1 2 # # 3 4 # # 5 # #","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nvoid serialize(Node* r) { if(!r) { cout<<\\"# \\"; return; } cout<<r->v<<\\" \\"; serialize(r->l); serialize(r->r); }\\nint main() { Node* r=new Node(1); r->l=new Node(2); r->r=new Node(3); r->r->l=new Node(4); r->r->r=new Node(5); serialize(r); return 0; }","explanation":{"approach":"Preorder with null markers.","analogy":"Encode structure with placeholders.","steps":["Print value or # for null","Recurse left then right"],"complexity":"Time: O(n), Space: O(n)"}},{"id":"hard24","title":"Binary Tree Max Path Sum","description":"Maximum path sum.","difficulty":"HARD","category":"Trees","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nint maxPathSum(Node* r) { return 0; }\\nint main() { Node* r=new Node(-10); r->l=new Node(9); r->r=new Node(20); r->r->l=new Node(15); r->r->r=new Node(7); cout<<maxPathSum(r); return 0; }","expectedOutput":"42","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nint maxSum;\\nint solve(Node* r) { if(!r) return 0; int l=max(0,solve(r->l)); int ri=max(0,solve(r->r)); maxSum=max(maxSum,l+ri+r->v); return r->v+max(l,ri); }\\nint maxPathSum(Node* r) { maxSum=-1e9; solve(r); return maxSum; }\\nint main() { Node* r=new Node(-10); r->l=new Node(9); r->r=new Node(20); r->r->l=new Node(15); r->r->r=new Node(7); cout<<maxPathSum(r); return 0; }","explanation":{"approach":"DFS returning max single path.","analogy":"At each node, consider path through it.","steps":["Return max path going up","Update global with path through node"],"complexity":"Time: O(n), Space: O(h)"}}]`),QR=JSON.parse(`[{"id":"hard25","title":"LRU Cache","description":"Implement LRU cache.","difficulty":"HARD","category":"Design","starterCode":"#include <iostream>\\nusing namespace std;\\nclass LRUCache { public: LRUCache(int cap) {} int get(int k) { return -1; } void put(int k, int v) {} };\\nint main() { LRUCache c(2); c.put(1,1); c.put(2,2); cout<<c.get(1)<<\\" \\"; c.put(3,3); cout<<c.get(2); return 0; }","expectedOutput":"1 -1","solution":"#include <iostream>\\nusing namespace std;\\nclass LRUCache { int cap,sz; int keys[100],vals[100]; int find(int k) { for(int i=0;i<sz;i++) if(keys[i]==k) return i; return -1; } void moveToFront(int i) { int k=keys[i],v=vals[i]; for(int j=i;j>0;j--) { keys[j]=keys[j-1]; vals[j]=vals[j-1]; } keys[0]=k; vals[0]=v; } public: LRUCache(int c):cap(c),sz(0){} int get(int k) { int i=find(k); if(i<0) return -1; moveToFront(i); return vals[0]; } void put(int k, int v) { int i=find(k); if(i>=0) { vals[i]=v; moveToFront(i); return; } if(sz<cap) sz++; for(int j=sz-1;j>0;j--) { keys[j]=keys[j-1]; vals[j]=vals[j-1]; } keys[0]=k; vals[0]=v; } };\\nint main() { LRUCache c(2); c.put(1,1); c.put(2,2); cout<<c.get(1)<<\\" \\"; c.put(3,3); cout<<c.get(2); return 0; }","explanation":{"approach":"Array with move to front.","analogy":"Most recently used at front.","steps":["Find key, move to front","Evict last if full"],"complexity":"Time: O(n), Space: O(n)"}},{"id":"hard26","title":"Find Median Stream","description":"Median from data stream.","difficulty":"HARD","category":"Design","starterCode":"#include <iostream>\\nusing namespace std;\\nclass MedianFinder { public: void addNum(int n) {} double findMedian() { return 0; } };\\nint main() { MedianFinder mf; mf.addNum(1); mf.addNum(2); cout<<mf.findMedian()<<\\" \\"; mf.addNum(3); cout<<mf.findMedian(); return 0; }","expectedOutput":"1.5 2","solution":"#include <iostream>\\nusing namespace std;\\nclass MedianFinder { int data[100],sz; public: MedianFinder():sz(0){} void addNum(int n) { int i=sz++; data[i]=n; while(i>0 && data[i]<data[i-1]) { swap(data[i],data[i-1]); i--; } } double findMedian() { if(sz%2) return data[sz/2]; return (data[sz/2-1]+data[sz/2])/2.0; } };\\nint main() { MedianFinder mf; mf.addNum(1); mf.addNum(2); cout<<mf.findMedian()<<\\" \\"; mf.addNum(3); cout<<mf.findMedian(); return 0; }","explanation":{"approach":"Keep sorted array.","analogy":"Insert in sorted order.","steps":["Insert and bubble to correct position","Return middle element(s)"],"complexity":"Time: O(n), Space: O(n)"}},{"id":"hard27","title":"Word Ladder","description":"Shortest transformation.","difficulty":"HARD","category":"BFS","starterCode":"#include <iostream>\\nusing namespace std;\\nint ladderLength(char begin[], char end[], char words[][10], int n) { return 0; }\\nint main() { char words[][10]={\\"hot\\",\\"dot\\",\\"dog\\",\\"lot\\",\\"log\\",\\"cog\\"}; cout<<ladderLength(\\"hit\\",\\"cog\\",words,6); return 0; }","expectedOutput":"5","solution":"#include <iostream>\\nusing namespace std;\\nbool diff1(char a[], char b[]) { int c=0; for(int i=0;a[i];i++) if(a[i]!=b[i]) c++; return c==1; }\\nbool eq(char a[], char b[]) { int i=0; while(a[i] && a[i]==b[i]) i++; return !a[i] && !b[i]; }\\nint ladderLength(char begin[], char end[], char words[][10], int n) { char q[100][10]; int f=0,r=0; bool vis[100]={}; int i=0; while(begin[i]) { q[r][i]=begin[i]; i++; } q[r++][i]=0; int lv=1; while(f<r) { int sz=r-f; for(int s=0;s<sz;s++) { for(int w=0;w<n;w++) { if(!vis[w] && diff1(q[f],words[w])) { if(eq(words[w],end)) return lv+1; vis[w]=true; int j=0; while(words[w][j]) { q[r][j]=words[w][j]; j++; } q[r++][j]=0; } } f++; } lv++; } return 0; }\\nint main() { char words[][10]={\\"hot\\",\\"dot\\",\\"dog\\",\\"lot\\",\\"log\\",\\"cog\\"}; cout<<ladderLength(\\"hit\\",\\"cog\\",words,6); return 0; }","explanation":{"approach":"BFS shortest path.","analogy":"One letter change at a time.","steps":["BFS from begin","Try all 1-letter changes","Count levels"],"complexity":"Time: O(n  m  26), Space: O(n)"}},{"id":"hard28","title":"Alien Dictionary","description":"Order of alien alphabet.","difficulty":"HARD","category":"Graph","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid alienOrder(char words[][10], int n) {}\\nint main() { char words[][10]={\\"wrt\\",\\"wrf\\",\\"er\\",\\"ett\\",\\"rftt\\"}; alienOrder(words,5); return 0; }","expectedOutput":"wertf","solution":"#include <iostream>\\nusing namespace std;\\nvoid alienOrder(char words[][10], int n) { int adj[26][26]={},deg[26]={},sz[26]={}; bool exists[26]={}; for(int i=0;i<n;i++) for(int j=0;words[i][j];j++) exists[words[i][j]-'a']=true; for(int i=0;i<n-1;i++) { int j=0; while(words[i][j] && words[i][j]==words[i+1][j]) j++; if(words[i][j] && words[i+1][j]) { int u=words[i][j]-'a',v=words[i+1][j]-'a'; adj[u][sz[u]++]=v; deg[v]++; } } int q[26],f=0,r=0; for(int i=0;i<26;i++) if(exists[i] && deg[i]==0) q[r++]=i; while(f<r) { int u=q[f++]; cout<<(char)('a'+u); for(int i=0;i<sz[u];i++) if(--deg[adj[u][i]]==0) q[r++]=adj[u][i]; } }\\nint main() { char words[][10]={\\"wrt\\",\\"wrf\\",\\"er\\",\\"ett\\",\\"rftt\\"}; alienOrder(words,5); return 0; }","explanation":{"approach":"Topological sort from comparisons.","analogy":"Build graph from word order.","steps":["Compare adjacent words for order","Build graph edges","Topological sort"],"complexity":"Time: O(C), Space: O(1)"}},{"id":"hard29","title":"Critical Connections","description":"Find bridges in graph.","difficulty":"HARD","category":"Graph","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid criticalConnections(int n, int edges[][2], int m) {}\\nint main() { int edges[][2]={{0,1},{1,2},{2,0},{1,3}}; criticalConnections(4,edges,4); return 0; }","expectedOutput":"1-3","solution":"#include <iostream>\\nusing namespace std;\\nint adj[10][10],sz[10],disc[10],low[10],timer=0;\\nvoid dfs(int u, int p) { disc[u]=low[u]=++timer; for(int i=0;i<sz[u];i++) { int v=adj[u][i]; if(!disc[v]) { dfs(v,u); low[u]=min(low[u],low[v]); if(low[v]>disc[u]) cout<<u<<\\"-\\"<<v<<\\" \\"; } else if(v!=p) low[u]=min(low[u],disc[v]); } }\\nvoid criticalConnections(int n, int edges[][2], int m) { for(int i=0;i<n;i++) { sz[i]=0; disc[i]=0; low[i]=0; } for(int i=0;i<m;i++) { adj[edges[i][0]][sz[edges[i][0]]++]=edges[i][1]; adj[edges[i][1]][sz[edges[i][1]]++]=edges[i][0]; } for(int i=0;i<n;i++) if(!disc[i]) dfs(i,-1); }\\nint main() { int edges[][2]={{0,1},{1,2},{2,0},{1,3}}; criticalConnections(4,edges,4); return 0; }","explanation":{"approach":"Tarjan's bridge finding.","analogy":"Edge is bridge if no back edge goes around.","steps":["Track discovery and low times","Bridge if low[v] > disc[u]"],"complexity":"Time: O(V+E), Space: O(V)"}},{"id":"hard30","title":"Count Smaller After","description":"Count smaller elements to right.","difficulty":"HARD","category":"Divide and Conquer","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid countSmaller(int a[], int n) {}\\nint main() { int a[]={5,2,6,1}; countSmaller(a,4); return 0; }","expectedOutput":"2 1 1 0","solution":"#include <iostream>\\nusing namespace std;\\nvoid countSmaller(int a[], int n) { int res[n]={}; for(int i=0;i<n;i++) for(int j=i+1;j<n;j++) if(a[j]<a[i]) res[i]++; for(int i=0;i<n;i++) cout<<res[i]<<\\" \\"; }\\nint main() { int a[]={5,2,6,1}; countSmaller(a,4); return 0; }","explanation":{"approach":"Count smaller elements to right.","analogy":"Compare with all following elements.","steps":["For each element","Count smaller to the right"],"complexity":"Time: O(n), Space: O(n)"}},{"id":"hard31","title":"Skyline Problem","description":"Building skyline outline.","difficulty":"HARD","category":"Divide and Conquer","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid getSkyline(int buildings[][3], int n) {}\\nint main() { int b[][3]={{2,9,10},{3,7,15},{5,12,12},{15,20,10},{19,24,8}}; getSkyline(b,5); return 0; }","expectedOutput":"2,10 3,15 7,12 12,0 15,10 20,8 24,0","solution":"#include <iostream>\\nusing namespace std;\\nvoid getSkyline(int buildings[][3], int n) { int events[2*n][3], k=0; for(int i=0;i<n;i++) { events[k][0]=buildings[i][0]; events[k][1]=buildings[i][2]; events[k++][2]=1; events[k][0]=buildings[i][1]; events[k][1]=buildings[i][2]; events[k++][2]=0; } for(int i=0;i<2*n-1;i++) for(int j=0;j<2*n-i-1;j++) if(events[j][0]>events[j+1][0]) { swap(events[j][0],events[j+1][0]); swap(events[j][1],events[j+1][1]); swap(events[j][2],events[j+1][2]); } int active[100],az=0,lastH=-1; for(int i=0;i<2*n;i++) { if(events[i][2]) active[az++]=events[i][1]; else { for(int j=0;j<az;j++) if(active[j]==events[i][1]) { active[j]=active[--az]; break; } } int maxH=0; for(int j=0;j<az;j++) maxH=max(maxH,active[j]); if(maxH!=lastH) { cout<<events[i][0]<<\\",\\"<<maxH<<\\" \\"; lastH=maxH; } } }\\nint main() { int b[][3]={{2,9,10},{3,7,15},{5,12,12},{15,20,10},{19,24,8}}; getSkyline(b,5); return 0; }","explanation":{"approach":"Line sweep with events.","analogy":"Track max height at each x.","steps":["Create start/end events","Sweep and track active heights"],"complexity":"Time: O(n), Space: O(n)"}},{"id":"hard32","title":"Smallest Range","description":"Range covering all lists.","difficulty":"HARD","category":"Heap","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid smallestRange(int nums[][5], int k, int sizes[]) {}\\nint main() { int nums[][5]={{4,10,15,24,26},{0,9,12,20},{5,18,22,30}}; int sizes[]={5,4,4}; smallestRange(nums,3,sizes); return 0; }","expectedOutput":"20-24","solution":"#include <iostream>\\nusing namespace std;\\nvoid smallestRange(int nums[][5], int k, int sizes[]) { int idx[k]={}; int minR=0,maxR=1e9; while(true) { int mi=0,mx=0; for(int i=0;i<k;i++) { if(nums[i][idx[i]]<nums[mi][idx[mi]]) mi=i; if(nums[i][idx[i]]>nums[mx][idx[mx]]) mx=i; } if(nums[mx][idx[mx]]-nums[mi][idx[mi]]<maxR-minR) { minR=nums[mi][idx[mi]]; maxR=nums[mx][idx[mx]]; } idx[mi]++; if(idx[mi]>=sizes[mi]) break; } cout<<minR<<\\"-\\"<<maxR; }\\nint main() { int nums[][5]={{4,10,15,24,26},{0,9,12,20},{5,18,22,30}}; int sizes[]={5,4,4}; smallestRange(nums,3,sizes); return 0; }","explanation":{"approach":"Expand minimum pointer.","analogy":"Keep one from each list.","steps":["Track pointers to each list","Advance minimum each time"],"complexity":"Time: O(n  k), Space: O(k)"}}]`),XR=JSON.parse(`[{"id":"h126","title":"Longest Substring with At Least K Repeating","description":"Given a string s and an integer k, return the length of the longest substring where every character appears at least k times in that substring.","difficulty":"HARD","category":"Divide Conquer","starterCode":"#include <iostream>\\nusing namespace std;\\nint longestSubstring(char s[], int k) { return 0; }\\nint main() { cout << longestSubstring(\\"aaabb\\", 3); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nint longestSubstring(char s[], int k) {\\n    int n = 0;\\n    while(s[n]) n++;\\n    if(n == 0) return 0;\\n    \\n    // Count frequency of each character\\n    int count[26] = {};\\n    for(int i = 0; i < n; i++) {\\n        count[s[i] - 'a']++;\\n    }\\n    \\n    // Find first character with count < k (invalid character)\\n    for(int i = 0; i < n; i++) {\\n        if(count[s[i] - 'a'] < k) {\\n            // Split at this character and recurse\\n            int maxLen = 0;\\n            int start = 0;\\n            for(int j = 0; j <= n; j++) {\\n                if(j == n || count[s[j] - 'a'] < k) {\\n                    if(j > start) {\\n                        char sub[j - start + 1];\\n                        for(int t = start; t < j; t++) sub[t - start] = s[t];\\n                        sub[j - start] = 0;\\n                        int len = longestSubstring(sub, k);\\n                        if(len > maxLen) maxLen = len;\\n                    }\\n                    start = j + 1;\\n                }\\n            }\\n            return maxLen;\\n        }\\n    }\\n    \\n    // All characters appear at least k times\\n    return n;\\n}\\nint main() { cout << longestSubstring(\\"aaabb\\", 3); return 0; }","explanation":{"approach":"Divide and conquer. Find any character that appears less than k times - it cannot be part of the answer. Split the string at that character and recursively solve each part.","analogy":"Like removing weak links from a chain - if any character can't meet the quota, it breaks the chain, and we work on the remaining pieces.","steps":["Count frequency of each character","Find a character appearing < k times (if any)","If found, it's a 'bad' character that can't be in the answer","Split string at all occurrences of bad characters","Recursively find longest valid substring in each piece","If no bad character found, entire string is valid"],"complexity":"Time: O(26  n), Space: O(n) due to recursion"}},{"id":"h127","title":"IPO","description":"You have initial capital and can complete at most k projects. Each project has a profit and requires minimum capital. Find the maximum capital you can have after completing at most k projects.","difficulty":"HARD","category":"Heap","starterCode":"#include <iostream>\\nusing namespace std;\\nint findMaximizedCapital(int k, int w, int profits[], int capital[], int n) { return 0; }\\nint main() { int p[] = {1, 2, 3}; int c[] = {0, 1, 1}; cout << findMaximizedCapital(2, 0, p, c, 3); return 0; }","expectedOutput":"4","solution":"#include <iostream>\\nusing namespace std;\\nint findMaximizedCapital(int k, int w, int profits[], int capital[], int n) {\\n    for(int i = 0; i < k; i++) {\\n        int bestIdx = -1;\\n        int bestProfit = 0;\\n        \\n        // Find project with maximum profit that we can afford\\n        for(int j = 0; j < n; j++) {\\n            if(capital[j] <= w && profits[j] > bestProfit) {\\n                bestProfit = profits[j];\\n                bestIdx = j;\\n            }\\n        }\\n        \\n        if(bestIdx == -1) break;  // No affordable project\\n        \\n        w += profits[bestIdx];     // Complete project, add profit\\n        capital[bestIdx] = 1e9;    // Mark as used\\n    }\\n    return w;\\n}\\nint main() { int p[] = {1, 2, 3}; int c[] = {0, 1, 1}; cout << findMaximizedCapital(2, 0, p, c, 3); return 0; }","explanation":{"approach":"Greedy approach - always pick the most profitable project from all currently affordable projects. After each project, your capital increases, potentially unlocking more projects.","analogy":"Like a startup founder - always take the best-paying job you can afford to do now, which gives you more money to take on even better opportunities.","steps":["Start with initial capital w","Repeat k times (or until no project available):","  - Find all projects with capital requirement <= w","  - Pick the one with maximum profit","  - Add profit to capital","  - Mark project as completed","Return final capital"],"complexity":"Time: O(k  n), Space: O(1)"}},{"id":"h128","title":"Sliding Window Median","description":"Given an array and a window size k, return the median of each sliding window as it moves from left to right.","difficulty":"HARD","category":"Heap","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid medianSlidingWindow(int nums[], int n, int k) {}\\nint main() { int n[] = {1, 3, -1, -3, 5, 3, 6, 7}; medianSlidingWindow(n, 8, 3); return 0; }","expectedOutput":"1 -1 -1 3 5 6","solution":"#include <iostream>\\nusing namespace std;\\nvoid medianSlidingWindow(int nums[], int n, int k) {\\n    for(int i = 0; i <= n - k; i++) {\\n        // Copy window elements and sort\\n        int window[k];\\n        for(int j = 0; j < k; j++) {\\n            window[j] = nums[i + j];\\n        }\\n        \\n        // Sort window\\n        for(int a = 0; a < k - 1; a++) {\\n            for(int b = 0; b < k - a - 1; b++) {\\n                if(window[b] > window[b + 1]) {\\n                    int temp = window[b];\\n                    window[b] = window[b + 1];\\n                    window[b + 1] = temp;\\n                }\\n            }\\n        }\\n        \\n        // Print median (middle element for odd k)\\n        cout << window[k / 2] << \\" \\";\\n    }\\n}\\nint main() { int n[] = {1, 3, -1, -3, 5, 3, 6, 7}; medianSlidingWindow(n, 8, 3); return 0; }","explanation":{"approach":"For each window position, copy the k elements, sort them, and find the median. The median is the middle element (for odd k) or average of two middle elements (for even k).","analogy":"Like a moving spotlight on an orchestra - at each position, you arrange the musicians by height and pick the one in the middle.","steps":["For each starting position i from 0 to n-k:","  - Extract window elements nums[i] to nums[i+k-1]","  - Sort these k elements","  - Median is at index k/2 (for odd k)","  - Output the median"],"complexity":"Time: O(n  k log k), Space: O(k)"}},{"id":"h129","title":"Find Median from Data Stream","description":"Design a data structure that supports adding numbers and finding the running median (the middle value if sorted).","difficulty":"HARD","category":"Heap","starterCode":"#include <iostream>\\nusing namespace std;\\nclass MedianFinder {\\npublic:\\n    void addNum(int num) {}\\n    double findMedian() { return 0; }\\n};\\nint main() { MedianFinder m; m.addNum(1); m.addNum(2); cout << m.findMedian(); return 0; }","expectedOutput":"1.5","solution":"#include <iostream>\\nusing namespace std;\\nclass MedianFinder {\\n    int arr[100];\\n    int n;\\npublic:\\n    MedianFinder() : n(0) {}\\n    \\n    void addNum(int num) {\\n        // Insert in sorted position\\n        arr[n] = num;\\n        int i = n;\\n        while(i > 0 && arr[i] < arr[i - 1]) {\\n            int temp = arr[i];\\n            arr[i] = arr[i - 1];\\n            arr[i - 1] = temp;\\n            i--;\\n        }\\n        n++;\\n    }\\n    \\n    double findMedian() {\\n        if(n % 2 == 1) {\\n            return arr[n / 2];\\n        } else {\\n            return (arr[n / 2 - 1] + arr[n / 2]) / 2.0;\\n        }\\n    }\\n};\\nint main() { MedianFinder m; m.addNum(1); m.addNum(2); cout << m.findMedian(); return 0; }","explanation":{"approach":"Maintain a sorted array. When adding a number, insert it in the correct sorted position. Finding median is just looking at the middle element(s).","analogy":"Like keeping a sorted card deck - each new card goes in its proper place, so finding the middle card is instant.","steps":["Maintain array in sorted order","addNum: Insert number and shift to maintain sorted order","findMedian: If odd count, return middle element","If even count, return average of two middle elements"],"complexity":"Time: O(n) insert, O(1) median. Space: O(n)"}},{"id":"h130","title":"Critical Connections in a Network","description":"Find all critical connections (bridges) in a network. A bridge is an edge that, when removed, disconnects the graph into separate components.","difficulty":"HARD","category":"Graph","starterCode":"#include <iostream>\\nusing namespace std;\\nint criticalConnections(int n, int connections[][2], int c) { return 0; }\\nint main() { int conn[][2] = {{0,1}, {1,2}, {2,0}, {1,3}}; cout << criticalConnections(4, conn, 4); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nint disc[10], low[10], timer_val = 0;\\n\\nvoid dfs(int adj[][10], int sz[], int u, int parent) {\\n    disc[u] = low[u] = ++timer_val;\\n    \\n    for(int i = 0; i < sz[u]; i++) {\\n        int v = adj[u][i];\\n        if(disc[v] == 0) {\\n            dfs(adj, sz, v, u);\\n            low[u] = min(low[u], low[v]);\\n        } else if(v != parent) {\\n            low[u] = min(low[u], disc[v]);\\n        }\\n    }\\n}\\n\\nint criticalConnections(int n, int connections[][2], int c) {\\n    int adj[10][10], sz[10] = {};\\n    \\n    // Build adjacency list\\n    for(int i = 0; i < c; i++) {\\n        int u = connections[i][0], v = connections[i][1];\\n        adj[u][sz[u]++] = v;\\n        adj[v][sz[v]++] = u;\\n    }\\n    \\n    // Run DFS\\n    dfs(adj, sz, 0, -1);\\n    \\n    // Count bridges\\n    int bridges = 0;\\n    for(int i = 0; i < c; i++) {\\n        int u = connections[i][0], v = connections[i][1];\\n        if(low[v] > disc[u] || low[u] > disc[v]) {\\n            bridges++;\\n        }\\n    }\\n    return bridges;\\n}\\nint main() { int conn[][2] = {{0,1}, {1,2}, {2,0}, {1,3}}; cout << criticalConnections(4, conn, 4); return 0; }","explanation":{"approach":"Use Tarjan's Algorithm. Track discovery time and lowest reachable time for each node. An edge (u,v) is a bridge if low[v] > disc[u], meaning v can't reach back to u or earlier without this edge.","analogy":"Like finding which bridge, if destroyed, would isolate an island. If there's no other path to reach back, that bridge is critical.","steps":["Build adjacency list from connections","DFS from node 0, tracking:","  - disc[u]: when node u was discovered","  - low[u]: earliest node reachable from u's subtree","For each unvisited neighbor, recurse and update low","For visited neighbor (not parent), update low","Edge (u,v) is bridge if low[v] > disc[u]"],"complexity":"Time: O(V + E), Space: O(V)"}},{"id":"h131","title":"Edit Distance","description":"Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2. Operations are: insert, delete, or replace a character.","difficulty":"HARD","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint minDistance(char a[], char b[]) { return 0; }\\nint main() { cout << minDistance(\\"horse\\", \\"ros\\"); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nint minDistance(char a[], char b[]) {\\n    int m = 0, n = 0;\\n    while(a[m]) m++;\\n    while(b[n]) n++;\\n    \\n    int dp[m + 1][n + 1];\\n    \\n    // Base cases\\n    for(int i = 0; i <= m; i++) dp[i][0] = i;  // Delete all\\n    for(int j = 0; j <= n; j++) dp[0][j] = j;  // Insert all\\n    \\n    for(int i = 1; i <= m; i++) {\\n        for(int j = 1; j <= n; j++) {\\n            if(a[i - 1] == b[j - 1]) {\\n                dp[i][j] = dp[i - 1][j - 1];  // No operation needed\\n            } else {\\n                dp[i][j] = 1 + min(dp[i - 1][j],      // Delete from a\\n                              min(dp[i][j - 1],       // Insert into a\\n                                  dp[i - 1][j - 1])); // Replace\\n            }\\n        }\\n    }\\n    return dp[m][n];\\n}\\nint main() { cout << minDistance(\\"horse\\", \\"ros\\"); return 0; }","explanation":{"approach":"Dynamic programming. dp[i][j] = minimum operations to convert first i characters of a to first j characters of b. If characters match, no operation needed. Otherwise, try insert/delete/replace and take minimum.","analogy":"Like autocorrect suggesting the shortest path to fix a typo - what's the minimum number of letter changes needed?","steps":["dp[i][j] = min ops to convert a[0..i-1] to b[0..j-1]","Base: dp[i][0] = i (delete all), dp[0][j] = j (insert all)","If a[i-1] == b[j-1]: dp[i][j] = dp[i-1][j-1]","Else: dp[i][j] = 1 + min(","  dp[i-1][j]   (delete from a),","  dp[i][j-1]   (insert into a),","  dp[i-1][j-1] (replace))"],"complexity":"Time: O(m  n), Space: O(m  n)"}},{"id":"h132","title":"Regular Expression Matching","description":"Implement regular expression matching with support for '.' (matches any single character) and '*' (matches zero or more of the preceding element).","difficulty":"HARD","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isMatch(char s[], char p[]) { return false; }\\nint main() { cout << isMatch(\\"aa\\", \\"a*\\"); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isMatch(char s[], char p[]) {\\n    int m = 0, n = 0;\\n    while(s[m]) m++;\\n    while(p[n]) n++;\\n    \\n    bool dp[m + 1][n + 1];\\n    for(int i = 0; i <= m; i++)\\n        for(int j = 0; j <= n; j++)\\n            dp[i][j] = false;\\n    \\n    dp[0][0] = true;\\n    \\n    // Handle patterns like a*, a*b*, a*b*c* matching empty string\\n    for(int j = 2; j <= n; j++) {\\n        if(p[j - 1] == '*') {\\n            dp[0][j] = dp[0][j - 2];\\n        }\\n    }\\n    \\n    for(int i = 1; i <= m; i++) {\\n        for(int j = 1; j <= n; j++) {\\n            if(p[j - 1] == '*') {\\n                // * matches zero of preceding\\n                dp[i][j] = dp[i][j - 2];\\n                // OR * matches one or more (if preceding matches current char)\\n                if(p[j - 2] == '.' || p[j - 2] == s[i - 1]) {\\n                    dp[i][j] = dp[i][j] || dp[i - 1][j];\\n                }\\n            } else if(p[j - 1] == '.' || p[j - 1] == s[i - 1]) {\\n                dp[i][j] = dp[i - 1][j - 1];\\n            }\\n        }\\n    }\\n    return dp[m][n];\\n}\\nint main() { cout << isMatch(\\"aa\\", \\"a*\\"); return 0; }","explanation":{"approach":"Dynamic programming. dp[i][j] = does s[0..i-1] match p[0..j-1]? Handle * specially - it can match 0 or more of the preceding character.","analogy":"Like a flexible template matching - '.' is a wildcard for one character, '*' means 'repeat the previous thing any number of times'.","steps":["dp[i][j] = true if s[0..i-1] matches p[0..j-1]","If p[j-1] is regular char or '.': dp[i][j] = dp[i-1][j-1] if chars match","If p[j-1] is '*':","  - Zero occurrences: dp[i][j-2]","  - One or more: if p[j-2] matches s[i-1], then dp[i-1][j]"],"complexity":"Time: O(m  n), Space: O(m  n)"}},{"id":"h133","title":"Trapping Rain Water","description":"Given n non-negative integers representing an elevation map, compute how much water it can trap after raining. Water is trapped above lower bars between taller bars.","difficulty":"HARD","category":"Two Pointers","starterCode":"#include <iostream>\\nusing namespace std;\\nint trap(int h[], int n) { return 0; }\\nint main() { int h[] = {0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1}; cout << trap(h, 12); return 0; }","expectedOutput":"6","solution":"#include <iostream>\\nusing namespace std;\\nint trap(int h[], int n) {\\n    int left = 0, right = n - 1;\\n    int leftMax = 0, rightMax = 0;\\n    int water = 0;\\n    \\n    while(left < right) {\\n        if(h[left] < h[right]) {\\n            if(h[left] >= leftMax) {\\n                leftMax = h[left];\\n            } else {\\n                water += leftMax - h[left];\\n            }\\n            left++;\\n        } else {\\n            if(h[right] >= rightMax) {\\n                rightMax = h[right];\\n            } else {\\n                water += rightMax - h[right];\\n            }\\n            right--;\\n        }\\n    }\\n    return water;\\n}\\nint main() { int h[] = {0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1}; cout << trap(h, 12); return 0; }","explanation":{"approach":"Two pointers from both ends, tracking maximum heights seen from each side. Water at any position = min(leftMax, rightMax) - height. We process from the shorter side since that determines the water level.","analogy":"Like filling a pool between mountains - water level is determined by the shorter side. Process from the shorter side since it limits how much water can be held.","steps":["Two pointers: left at start, right at end","Track leftMax (tallest bar from left) and rightMax (from right)","If h[left] < h[right]: water level limited by left side","  - If h[left] >= leftMax: new wall, update leftMax","  - Else: water trapped = leftMax - h[left]","Process whichever side is shorter"],"complexity":"Time: O(n), Space: O(1)"}}]`),$R=[{id:"h136",title:"Island Perimeter",description:"Calculate island perimeter.",difficulty:"EASY",category:"Matrix",starterCode:`#include <iostream>
using namespace std;
int islandPerimeter(int grid[][4], int r, int c) { return 0; }
int main() { int g[][4]={{0,1,0,0},{1,1,1,0},{0,1,0,0},{1,1,0,0}}; cout<<islandPerimeter(g,4,4); return 0; }`,expectedOutput:"16",solution:`#include <iostream>
using namespace std;
int islandPerimeter(int grid[][4], int r, int c) { int p=0; for(int i=0;i<r;i++) for(int j=0;j<c;j++) if(grid[i][j]) { p+=4; if(i>0&&grid[i-1][j]) p-=2; if(j>0&&grid[i][j-1]) p-=2; } return p; }
int main() { int g[][4]={{0,1,0,0},{1,1,1,0},{0,1,0,0},{1,1,0,0}}; cout<<islandPerimeter(g,4,4); return 0; }`,explanation:{approach:"Count edges minus shared.",steps:["Each land adds 4 edges","Subtract 2 for each adjacent land"],complexity:"Time: O(mn), Space: O(1)"}},{id:"h137",title:"Best Time Buy Sell III",description:"Max profit with 2 transactions.",difficulty:"HARD",category:"DP",starterCode:`#include <iostream>
using namespace std;
int maxProfit(int prices[], int n) { return 0; }
int main() { int p[]={3,3,5,0,0,3,1,4}; cout<<maxProfit(p,8); return 0; }`,expectedOutput:"6",solution:`#include <iostream>
using namespace std;
int maxProfit(int prices[], int n) { int b1=1e9,b2=1e9,p1=0,p2=0; for(int i=0;i<n;i++) { b1=min(b1,prices[i]); p1=max(p1,prices[i]-b1); b2=min(b2,prices[i]-p1); p2=max(p2,prices[i]-b2); } return p2; }
int main() { int p[]={3,3,5,0,0,3,1,4}; cout<<maxProfit(p,8); return 0; }`,explanation:{approach:"Track two transactions.",steps:["b1, p1 for first transaction","b2, p2 for second using p1"],complexity:"Time: O(n), Space: O(1)"}},{id:"h138",title:"Best Time Buy Sell IV",description:"Max profit with k transactions.",difficulty:"HARD",category:"DP",starterCode:`#include <iostream>
using namespace std;
int maxProfit(int k, int prices[], int n) { return 0; }
int main() { int p[]={2,4,1}; cout<<maxProfit(2,p,3); return 0; }`,expectedOutput:"2",solution:`#include <iostream>
using namespace std;
int maxProfit(int k, int prices[], int n) { if(n==0||k==0) return 0; if(k>=n/2) { int p=0; for(int i=1;i<n;i++) if(prices[i]>prices[i-1]) p+=prices[i]-prices[i-1]; return p; } int dp[k+1][n]; for(int i=0;i<=k;i++) dp[i][0]=0; for(int j=0;j<n;j++) dp[0][j]=0; for(int i=1;i<=k;i++) { int mx=-prices[0]; for(int j=1;j<n;j++) { dp[i][j]=max(dp[i][j-1],prices[j]+mx); mx=max(mx,dp[i-1][j-1]-prices[j]); } } return dp[k][n-1]; }
int main() { int p[]={2,4,1}; cout<<maxProfit(2,p,3); return 0; }`,explanation:{approach:"DP with k transactions.",steps:["dp[i][j] = max profit with i transactions up to day j","Optimize with running max"],complexity:"Time: O(kn), Space: O(kn)"}},{id:"h139",title:"Distinct Subsequences",description:"Count subsequences matching t.",difficulty:"HARD",category:"DP",starterCode:`#include <iostream>
using namespace std;
int numDistinct(char s[], char t[]) { return 0; }
int main() { cout<<numDistinct("rabbbit","rabbit"); return 0; }`,expectedOutput:"3",solution:`#include <iostream>
using namespace std;
int numDistinct(char s[], char t[]) { int m=0,n=0; while(s[m]) m++; while(t[n]) n++; int dp[m+1][n+1]; for(int i=0;i<=m;i++) dp[i][0]=1; for(int j=1;j<=n;j++) dp[0][j]=0; for(int i=1;i<=m;i++) for(int j=1;j<=n;j++) dp[i][j]=dp[i-1][j]+(s[i-1]==t[j-1]?dp[i-1][j-1]:0); return dp[m][n]; }
int main() { cout<<numDistinct("rabbbit","rabbit"); return 0; }`,explanation:{approach:"DP counting subsequences.",steps:["dp[i][j] = ways to form t[0..j] from s[0..i]","Add dp[i-1][j-1] if chars match"],complexity:"Time: O(mn), Space: O(mn)"}},{id:"h140",title:"Interleaving String",description:"Can s3 be formed by interleaving s1 and s2.",difficulty:"HARD",category:"DP",starterCode:`#include <iostream>
using namespace std;
bool isInterleave(char s1[], char s2[], char s3[]) { return false; }
int main() { cout<<isInterleave("aabcc","dbbca","aadbbcbcac"); return 0; }`,expectedOutput:"1",solution:`#include <iostream>
using namespace std;
bool isInterleave(char s1[], char s2[], char s3[]) { int m=0,n=0,l=0; while(s1[m]) m++; while(s2[n]) n++; while(s3[l]) l++; if(m+n!=l) return false; bool dp[m+1][n+1]; dp[0][0]=true; for(int i=1;i<=m;i++) dp[i][0]=dp[i-1][0]&&s1[i-1]==s3[i-1]; for(int j=1;j<=n;j++) dp[0][j]=dp[0][j-1]&&s2[j-1]==s3[j-1]; for(int i=1;i<=m;i++) for(int j=1;j<=n;j++) dp[i][j]=(dp[i-1][j]&&s1[i-1]==s3[i+j-1])||(dp[i][j-1]&&s2[j-1]==s3[i+j-1]); return dp[m][n]; }
int main() { cout<<isInterleave("aabcc","dbbca","aadbbcbcac"); return 0; }`,explanation:{approach:"DP for interleaving.",steps:["dp[i][j] = s1[0..i] and s2[0..j] can form s3[0..i+j]","Check if next char matches s1 or s2"],complexity:"Time: O(mn), Space: O(mn)"}},{id:"h141",title:"Largest Rectangle Histogram",description:"Max rectangle area.",difficulty:"HARD",category:"Stack",starterCode:`#include <iostream>
using namespace std;
int largestRectangleArea(int heights[], int n) { return 0; }
int main() { int h[]={2,1,5,6,2,3}; cout<<largestRectangleArea(h,6); return 0; }`,expectedOutput:"10",solution:`#include <iostream>
using namespace std;
int largestRectangleArea(int h[], int n) { int stk[n+1],top=-1,mx=0; for(int i=0;i<=n;i++) { int cur=i==n?0:h[i]; while(top>=0&&cur<h[stk[top]]) { int ht=h[stk[top--]]; int w=top<0?i:i-stk[top]-1; mx=max(mx,ht*w); } stk[++top]=i; } return mx; }
int main() { int h[]={2,1,5,6,2,3}; cout<<largestRectangleArea(h,6); return 0; }`,explanation:{approach:"Stack for nearest smaller.",steps:["Stack stores increasing indices","Pop when smaller found","Calculate area with popped as height"],complexity:"Time: O(n), Space: O(n)"}},{id:"h142",title:"Maximal Rectangle",description:"Max rectangle of 1s in matrix.",difficulty:"HARD",category:"Stack",starterCode:`#include <iostream>
using namespace std;
int maximalRectangle(char m[][5], int r, int c) { return 0; }
int main() { char m[][5]={{"10100"},{"10111"},{"11111"},{"10010"}}; cout<<maximalRectangle(m,4,5); return 0; }`,expectedOutput:"6",solution:`#include <iostream>
using namespace std;
int largestRect(int h[], int n) { int stk[n+1],top=-1,mx=0; for(int i=0;i<=n;i++) { int cur=i==n?0:h[i]; while(top>=0&&cur<h[stk[top]]) { int ht=h[stk[top--]]; int w=top<0?i:i-stk[top]-1; mx=max(mx,ht*w); } stk[++top]=i; } return mx; }
int maximalRectangle(char m[][5], int r, int c) { int h[c]={}; int mx=0; for(int i=0;i<r;i++) { for(int j=0;j<c;j++) h[j]=m[i][j]=='1'?h[j]+1:0; mx=max(mx,largestRect(h,c)); } return mx; }
int main() { char m[][5]={{"10100"},{"10111"},{"11111"},{"10010"}}; cout<<maximalRectangle(m,4,5); return 0; }`,explanation:{approach:"Reduce to histogram problem.",steps:["Build histogram heights row by row","Apply largest rectangle in histogram"],complexity:"Time: O(mn), Space: O(n)"}},{id:"h143",title:"Trapping Rain Water",description:"Water trapped between bars.",difficulty:"HARD",category:"Stack",starterCode:`#include <iostream>
using namespace std;
int trap(int h[], int n) { return 0; }
int main() { int h[]={0,1,0,2,1,0,1,3,2,1,2,1}; cout<<trap(h,12); return 0; }`,expectedOutput:"6",solution:`#include <iostream>
using namespace std;
int trap(int h[], int n) { int l=0,r=n-1,lm=0,rm=0,w=0; while(l<r) { if(h[l]<h[r]) { if(h[l]>=lm) lm=h[l]; else w+=lm-h[l]; l++; } else { if(h[r]>=rm) rm=h[r]; else w+=rm-h[r]; r--; } } return w; }
int main() { int h[]={0,1,0,2,1,0,1,3,2,1,2,1}; cout<<trap(h,12); return 0; }`,explanation:{approach:"Two pointers with max tracking.",steps:["Track left and right max","Move smaller side","Add water = max - current"],complexity:"Time: O(n), Space: O(1)"}}],ZR=JSON.parse('[{"id":"h151","title":"Dungeon Game","description":"Min health to reach princess.","difficulty":"HARD","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint calculateMinimumHP(int d[][3], int r, int c) { return 0; }\\nint main() { int d[][3]={{-2,-3,3},{-5,-10,1},{10,30,-5}}; cout<<calculateMinimumHP(d,3,3); return 0; }","expectedOutput":"7","solution":"#include <iostream>\\nusing namespace std;\\nint calculateMinimumHP(int d[][3], int r, int c) { int dp[r][c]; dp[r-1][c-1]=max(1,1-d[r-1][c-1]); for(int i=r-2;i>=0;i--) dp[i][c-1]=max(1,dp[i+1][c-1]-d[i][c-1]); for(int j=c-2;j>=0;j--) dp[r-1][j]=max(1,dp[r-1][j+1]-d[r-1][j]); for(int i=r-2;i>=0;i--) for(int j=c-2;j>=0;j--) dp[i][j]=max(1,min(dp[i+1][j],dp[i][j+1])-d[i][j]); return dp[0][0]; }\\nint main() { int d[][3]={{-2,-3,3},{-5,-10,1},{10,30,-5}}; cout<<calculateMinimumHP(d,3,3); return 0; }","explanation":{"approach":"DP from bottom-right.","steps":["dp[i][j] = min health needed at (i,j)","Work backwards from target"],"complexity":"Time: O(mn), Space: O(mn)"}},{"id":"h152","title":"Cherry Pickup","description":"Max cherries round trip.","difficulty":"HARD","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint cherryPickup(int g[][3], int n) { return 0; }\\nint main() { int g[][3]={{0,1,-1},{1,0,-1},{1,1,1}}; cout<<cherryPickup(g,3); return 0; }","expectedOutput":"5","solution":"#include <iostream>\\nusing namespace std;\\nint cherryPickup(int g[][3], int n) { int dp[n][n][n]; for(int i=0;i<n;i++) for(int j=0;j<n;j++) for(int k=0;k<n;k++) dp[i][j][k]=-1e9; dp[0][0][0]=g[0][0]; for(int r1=0;r1<n;r1++) for(int c1=0;c1<n;c1++) for(int r2=0;r2<n;r2++) { int c2=r1+c1-r2; if(c2<0||c2>=n||g[r1][c1]==-1||g[r2][c2]==-1) continue; int v=dp[r1][c1][r2]; if(r1>0) v=max(v,dp[r1-1][c1][r2]); if(c1>0) v=max(v,dp[r1][c1-1][r2]); if(r2>0) v=max(v,dp[r1][c1][r2-1]); if(r1>0&&r2>0) v=max(v,dp[r1-1][c1][r2-1]); if(v<0) continue; v+=g[r1][c1]; if(r1!=r2) v+=g[r2][c2]; dp[r1][c1][r2]=v; } return max(0,dp[n-1][n-1][n-1]); }\\nint main() { int g[][3]={{0,1,-1},{1,0,-1},{1,1,1}}; cout<<cherryPickup(g,3); return 0; }","explanation":{"approach":"Two paths simultaneously.","steps":["Simulate two people going together","dp[r1][c1][r2] with c2 derived"],"complexity":"Time: O(n), Space: O(n)"}},{"id":"h153","title":"Super Egg Drop","description":"Min moves for k eggs n floors.","difficulty":"HARD","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint superEggDrop(int k, int n) { return 0; }\\nint main() { cout<<superEggDrop(2,6); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nint superEggDrop(int k, int n) { int dp[n+1][k+1]; for(int i=0;i<=n;i++) for(int j=0;j<=k;j++) dp[i][j]=0; for(int m=1;m<=n;m++) { for(int j=1;j<=k;j++) dp[m][j]=dp[m-1][j-1]+dp[m-1][j]+1; if(dp[m][k]>=n) return m; } return n; }\\nint main() { cout<<superEggDrop(2,6); return 0; }","explanation":{"approach":"DP on moves.","steps":["dp[m][k] = max floors checkable with m moves, k eggs","Stop when >= n"],"complexity":"Time: O(kn), Space: O(kn)"}},{"id":"h154","title":"Count Different Palindromes","description":"Count distinct palindromic subseq.","difficulty":"HARD","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint countPalindromicSubsequences(char s[]) { return 0; }\\nint main() { cout<<countPalindromicSubsequences(\\"bccb\\"); return 0; }","expectedOutput":"6","solution":"#include <iostream>\\nusing namespace std;\\nint countPalindromicSubsequences(char s[]) { int n=0; while(s[n]) n++; int dp[n][n]; for(int i=0;i<n;i++) { dp[i][i]=1; for(int j=0;j<i;j++) dp[i][j]=0; } for(int len=2;len<=n;len++) for(int i=0;i<=n-len;i++) { int j=i+len-1; if(s[i]==s[j]) { int l=i+1,r=j-1; while(l<=r&&s[l]!=s[i]) l++; while(l<=r&&s[r]!=s[i]) r--; if(l>r) dp[i][j]=dp[i+1][j-1]*2+2; else if(l==r) dp[i][j]=dp[i+1][j-1]*2+1; else dp[i][j]=dp[i+1][j-1]*2-dp[l+1][r-1]; } else dp[i][j]=dp[i+1][j]+dp[i][j-1]-dp[i+1][j-1]; } return dp[0][n-1]; }\\nint main() { cout<<countPalindromicSubsequences(\\"bccb\\"); return 0; }","explanation":{"approach":"DP with inclusion-exclusion.","steps":["If s[i]==s[j], expand from middle","Handle duplicates carefully"],"complexity":"Time: O(n), Space: O(n)"}},{"id":"h155","title":"Frog Jump","description":"Can frog cross river.","difficulty":"HARD","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nbool canCross(int stones[], int n) { return false; }\\nint main() { int s[]={0,1,3,5,6,8,12,17}; cout<<canCross(s,8); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool canCross(int stones[], int n) { if(n<2) return true; if(stones[1]!=1) return false; bool dp[n][n+1]; for(int i=0;i<n;i++) for(int k=0;k<=n;k++) dp[i][k]=false; dp[0][0]=true; for(int i=0;i<n;i++) for(int k=0;k<=n;k++) if(dp[i][k]) for(int j=i+1;j<n;j++) { int jump=stones[j]-stones[i]; if(jump>=k-1&&jump<=k+1&&jump<=n) dp[j][jump]=true; } for(int k=0;k<=n;k++) if(dp[n-1][k]) return true; return false; }\\nint main() { int s[]={0,1,3,5,6,8,12,17}; cout<<canCross(s,8); return 0; }","explanation":{"approach":"DP tracking positions and jumps.","steps":["dp[i][k] = can reach stone i with jump k","Try k-1, k, k+1 from each"],"complexity":"Time: O(n), Space: O(n)"}},{"id":"h156","title":"Split Array Largest Sum","description":"Min largest sum splitting into m.","difficulty":"HARD","category":"Binary Search","starterCode":"#include <iostream>\\nusing namespace std;\\nint splitArray(int nums[], int n, int m) { return 0; }\\nint main() { int a[]={7,2,5,10,8}; cout<<splitArray(a,5,2); return 0; }","expectedOutput":"18","solution":"#include <iostream>\\nusing namespace std;\\nbool canSplit(int nums[], int n, int m, int mx) { int cnt=1; long sum=0; for(int i=0;i<n;i++) { if(nums[i]>mx) return false; if(sum+nums[i]<=mx) sum+=nums[i]; else { cnt++; sum=nums[i]; } } return cnt<=m; }\\nint splitArray(int nums[], int n, int m) { long l=0,r=0; for(int i=0;i<n;i++) { l=max(l,(long)nums[i]); r+=nums[i]; } while(l<r) { long mid=(l+r)/2; if(canSplit(nums,n,m,mid)) r=mid; else l=mid+1; } return l; }\\nint main() { int a[]={7,2,5,10,8}; cout<<splitArray(a,5,2); return 0; }","explanation":{"approach":"Binary search on answer.","steps":["Binary search max sum","Greedily check if can split into m parts"],"complexity":"Time: O(n log S), Space: O(1)"}},{"id":"h157","title":"Koko Eating Bananas","description":"Min eating speed.","difficulty":"MEDIUM","category":"Binary Search","starterCode":"#include <iostream>\\nusing namespace std;\\nint minEatingSpeed(int piles[], int n, int h) { return 0; }\\nint main() { int p[]={3,6,7,11}; cout<<minEatingSpeed(p,4,8); return 0; }","expectedOutput":"4","solution":"#include <iostream>\\nusing namespace std;\\nbool canEat(int p[], int n, int h, int k) { int time=0; for(int i=0;i<n;i++) time+=(p[i]+k-1)/k; return time<=h; }\\nint minEatingSpeed(int p[], int n, int h) { int l=1,r=0; for(int i=0;i<n;i++) r=max(r,p[i]); while(l<r) { int m=(l+r)/2; if(canEat(p,n,h,m)) r=m; else l=m+1; } return l; }\\nint main() { int p[]={3,6,7,11}; cout<<minEatingSpeed(p,4,8); return 0; }","explanation":{"approach":"Binary search on speed.","steps":["Check if speed k is enough","Binary search for minimum"],"complexity":"Time: O(n log M), Space: O(1)"}},{"id":"h158","title":"Median of Two Sorted","description":"Find median of two sorted arrays.","difficulty":"HARD","category":"Binary Search","starterCode":"#include <iostream>\\nusing namespace std;\\ndouble findMedianSortedArrays(int a[], int m, int b[], int n) { return 0; }\\nint main() { int a[]={1,3}; int b[]={2}; cout<<findMedianSortedArrays(a,2,b,1); return 0; }","expectedOutput":"2","solution":"#include <iostream>\\nusing namespace std;\\ndouble findMedianSortedArrays(int a[], int m, int b[], int n) { if(m>n) return findMedianSortedArrays(b,n,a,m); int l=0,r=m; while(l<=r) { int i=(l+r)/2; int j=(m+n+1)/2-i; int al=i==0?-1e9:a[i-1]; int ar=i==m?1e9:a[i]; int bl=j==0?-1e9:b[j-1]; int br=j==n?1e9:b[j]; if(al<=br&&bl<=ar) { if((m+n)%2) return max(al,bl); return (max(al,bl)+min(ar,br))/2.0; } if(al>br) r=i-1; else l=i+1; } return 0; }\\nint main() { int a[]={1,3}; int b[]={2}; cout<<findMedianSortedArrays(a,2,b,1); return 0; }","explanation":{"approach":"Binary search on partition.","steps":["Partition both arrays","Find correct partition point"],"complexity":"Time: O(log min(m,n)), Space: O(1)"}}]'),JR=JSON.parse('[{"id":"h161","title":"Count of Range Sum","description":"Count range sums in [lo, hi].","difficulty":"HARD","category":"Divide Conquer","starterCode":"#include <iostream>\\nusing namespace std;\\nint countRangeSum(int nums[], int n, int lo, int hi) { return 0; }\\nint main() { int a[]={-2,5,-1}; cout<<countRangeSum(a,3,-2,2); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nint countRangeSum(int nums[], int n, int lo, int hi) { int cnt=0; for(int i=0;i<n;i++) { long sum=0; for(int j=i;j<n;j++) { sum+=nums[j]; if(sum>=lo&&sum<=hi) cnt++; } } return cnt; }\\nint main() { int a[]={-2,5,-1}; cout<<countRangeSum(a,3,-2,2); return 0; }","explanation":{"approach":"Check all subarrays.","steps":["For each start","Extend and check sum in range"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"h162","title":"Reverse Pairs","description":"Count i<j where nums[i]>2*nums[j].","difficulty":"HARD","category":"Divide Conquer","starterCode":"#include <iostream>\\nusing namespace std;\\nint reversePairs(int nums[], int n) { return 0; }\\nint main() { int a[]={1,3,2,3,1}; cout<<reversePairs(a,5); return 0; }","expectedOutput":"2","solution":"#include <iostream>\\nusing namespace std;\\nint reversePairs(int nums[], int n) { int cnt=0; for(int i=0;i<n;i++) for(int j=i+1;j<n;j++) if(nums[i]>(long)2*nums[j]) cnt++; return cnt; }\\nint main() { int a[]={1,3,2,3,1}; cout<<reversePairs(a,5); return 0; }","explanation":{"approach":"Check all pairs.","steps":["For each pair (i,j) where i<j","Check if nums[i] > 2*nums[j]"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"h163","title":"LRU Cache","description":"Implement LRU cache.","difficulty":"HARD","category":"Design","starterCode":"#include <iostream>\\nusing namespace std;\\nclass LRUCache {\\npublic:\\n    LRUCache(int capacity) {}\\n    int get(int key) { return -1; }\\n    void put(int key, int value) {}\\n};\\nint main() { LRUCache c(2); c.put(1,1); c.put(2,2); cout<<c.get(1); c.put(3,3); cout<<c.get(2); return 0; }","expectedOutput":"1-1","solution":"#include <iostream>\\nusing namespace std;\\nclass LRUCache { int cap; int keys[10],vals[10],times[10],n,t; public: LRUCache(int c):cap(c),n(0),t(0){} int find(int k) { for(int i=0;i<n;i++) if(keys[i]==k) return i; return -1; } int get(int k) { int i=find(k); if(i<0) return -1; times[i]=++t; return vals[i]; } void put(int k, int v) { int i=find(k); if(i>=0) { vals[i]=v; times[i]=++t; return; } if(n<cap) { keys[n]=k; vals[n]=v; times[n++]=++t; } else { int mn=0; for(int j=1;j<n;j++) if(times[j]<times[mn]) mn=j; keys[mn]=k; vals[mn]=v; times[mn]=++t; } } };\\nint main() { LRUCache c(2); c.put(1,1); c.put(2,2); cout<<c.get(1); c.put(3,3); cout<<c.get(2); return 0; }","explanation":{"approach":"Track access times.","steps":["On get/put, update access time","Evict least recently used"],"complexity":"Time: O(n) per op, Space: O(cap)"}},{"id":"h164","title":"Min Stack","description":"Stack with getMin.","difficulty":"HARD","category":"Design","starterCode":"#include <iostream>\\nusing namespace std;\\nclass MinStack {\\npublic:\\n    void push(int val) {}\\n    void pop() {}\\n    int top() { return 0; }\\n    int getMin() { return 0; }\\n};\\nint main() { MinStack s; s.push(-2); s.push(0); s.push(-3); cout<<s.getMin(); s.pop(); cout<<s.top(); cout<<s.getMin(); return 0; }","expectedOutput":"-30-2","solution":"#include <iostream>\\nusing namespace std;\\nclass MinStack { int stk[100],mstk[100],top,mtop; public: MinStack():top(-1),mtop(-1){} void push(int v) { stk[++top]=v; if(mtop<0||v<=mstk[mtop]) mstk[++mtop]=v; } void pop() { if(stk[top--]==mstk[mtop]) mtop--; } int top() { return stk[this->top]; } int getMin() { return mstk[mtop]; } };\\nint main() { MinStack s; s.push(-2); s.push(0); s.push(-3); cout<<s.getMin(); s.pop(); cout<<s.top(); cout<<s.getMin(); return 0; }","explanation":{"approach":"Two stacks.","steps":["Main stack for values","Min stack for running minimum"],"complexity":"Time: O(1) all ops, Space: O(n)"}},{"id":"h165","title":"Find Median Data Stream","description":"Running median.","difficulty":"HARD","category":"Design","starterCode":"#include <iostream>\\nusing namespace std;\\nclass MedianFinder {\\npublic:\\n    void addNum(int num) {}\\n    double findMedian() { return 0; }\\n};\\nint main() { MedianFinder m; m.addNum(1); m.addNum(2); cout<<m.findMedian(); m.addNum(3); cout<<m.findMedian(); return 0; }","expectedOutput":"1.52","solution":"#include <iostream>\\nusing namespace std;\\nclass MedianFinder { int a[100],n; public: MedianFinder():n(0){} void addNum(int v) { int i=n++; a[i]=v; while(i>0&&a[i]<a[i-1]) { swap(a[i],a[i-1]); i--; } } double findMedian() { if(n%2) return a[n/2]; return (a[n/2-1]+a[n/2])/2.0; } };\\nint main() { MedianFinder m; m.addNum(1); m.addNum(2); cout<<m.findMedian(); m.addNum(3); cout<<m.findMedian(); return 0; }","explanation":{"approach":"Sorted array.","steps":["Insert and maintain sorted order","Return middle element(s)"],"complexity":"Time: O(n) insert, O(1) median"}},{"id":"h166","title":"Serialize Deserialize BST","description":"Convert tree to string and back.","difficulty":"HARD","category":"Design","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nvoid serialize(Node* r) {}\\nNode* deserialize() { return nullptr; }\\nint main() { Node* r=new Node(2); r->l=new Node(1); r->r=new Node(3); serialize(r); cout<<\\"OK\\"; return 0; }","expectedOutput":"OK","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nvoid serialize(Node* r) { if(!r) { cout<<\\"# \\"; return; } cout<<r->v<<\\" \\"; serialize(r->l); serialize(r->r); }\\nNode* deserialize() { return nullptr; }\\nint main() { Node* r=new Node(2); r->l=new Node(1); r->r=new Node(3); serialize(r); cout<<\\"OK\\"; return 0; }","explanation":{"approach":"Preorder with null markers.","steps":["Output value or # for null","Reconstruct using preorder"],"complexity":"Time: O(n), Space: O(n)"}},{"id":"h167","title":"All Oone Data Structure","description":"Inc/dec with getMax/getMin.","difficulty":"HARD","category":"Design","starterCode":"#include <iostream>\\nusing namespace std;\\nclass AllOne {\\npublic:\\n    void inc(char key[]) {}\\n    void dec(char key[]) {}\\n    void getMaxKey() {}\\n    void getMinKey() {}\\n};\\nint main() { AllOne a; cout<<\\"OK\\"; return 0; }","expectedOutput":"OK","solution":"#include <iostream>\\nusing namespace std;\\nclass AllOne { char keys[100][20]; int cnt[100]; int n; public: AllOne():n(0){} int find(char k[]) { for(int i=0;i<n;i++) { bool eq=true; for(int j=0;k[j]||keys[i][j];j++) if(k[j]!=keys[i][j]) { eq=false; break; } if(eq) return i; } return -1; } void inc(char k[]) { int i=find(k); if(i<0) { for(int j=0;k[j];j++) keys[n][j]=k[j]; keys[n][strlen(k)]=0; cnt[n++]=1; } else cnt[i]++; } void dec(char k[]) { int i=find(k); if(i>=0) cnt[i]--; } void getMaxKey() { int mx=0; for(int i=1;i<n;i++) if(cnt[i]>cnt[mx]) mx=i; if(n>0) cout<<keys[mx]; } void getMinKey() { int mn=0; for(int i=1;i<n;i++) if(cnt[i]>0&&cnt[i]<cnt[mn]) mn=i; if(n>0) cout<<keys[mn]; } };\\nint main() { AllOne a; cout<<\\"OK\\"; return 0; }","explanation":{"approach":"Track key-count pairs.","steps":["Store keys and their counts","Find max/min by scanning"],"complexity":"Time: O(n), Space: O(n)"}},{"id":"h168","title":"Max Frequency Stack","description":"Pop most frequent element.","difficulty":"HARD","category":"Design","starterCode":"#include <iostream>\\nusing namespace std;\\nclass FreqStack {\\npublic:\\n    void push(int val) {}\\n    int pop() { return 0; }\\n};\\nint main() { FreqStack f; f.push(5); f.push(7); f.push(5); f.push(7); f.push(4); f.push(5); cout<<f.pop(); return 0; }","expectedOutput":"5","solution":"#include <iostream>\\nusing namespace std;\\nclass FreqStack { int stk[100][100],stkSz[100],freq[101],maxFreq,n; public: FreqStack():maxFreq(0),n(0){ for(int i=0;i<100;i++) stkSz[i]=0; for(int i=0;i<101;i++) freq[i]=0; } void push(int v) { freq[v]++; int f=freq[v]; stk[f][stkSz[f]++]=v; maxFreq=max(maxFreq,f); } int pop() { int v=stk[maxFreq][--stkSz[maxFreq]]; freq[v]--; if(stkSz[maxFreq]==0) maxFreq--; return v; } };\\nint main() { FreqStack f; f.push(5); f.push(7); f.push(5); f.push(7); f.push(4); f.push(5); cout<<f.pop(); return 0; }","explanation":{"approach":"Stack per frequency.","steps":["Push to stack[freq]","Pop from highest frequency stack"],"complexity":"Time: O(1), Space: O(n)"}}]'),e5=JSON.parse(`[{"id":"core1","title":"Factorial Recursion","description":"Calculate factorial recursively.","difficulty":"EASY","category":"Recursion","starterCode":"#include <iostream>\\nusing namespace std;\\nint factorial(int n) { return 0; }\\nint main() { cout<<factorial(5); return 0; }","expectedOutput":"120","solution":"#include <iostream>\\nusing namespace std;\\nint factorial(int n) { if(n <= 1) return 1; return n * factorial(n-1); }\\nint main() { cout<<factorial(5); return 0; }","explanation":{"approach":"n! = n  (n-1)! with base case 1! = 1","analogy":"Like Russian dolls - each level unwraps until you reach smallest doll.","steps":["Base: if n1, return 1","Recursive: return n  factorial(n-1)"],"complexity":"Time: O(n), Space: O(n)"}},{"id":"core2","title":"Fibonacci Recursion","description":"Nth Fibonacci number.","difficulty":"EASY","category":"Recursion","starterCode":"#include <iostream>\\nusing namespace std;\\nint fib(int n) { return 0; }\\nint main() { cout<<fib(10); return 0; }","expectedOutput":"55","solution":"#include <iostream>\\nusing namespace std;\\nint fib(int n) { if(n <= 1) return n; return fib(n-1) + fib(n-2); }\\nint main() { cout<<fib(10); return 0; }","explanation":{"approach":"F(n) = F(n-1) + F(n-2), base F(0)=0, F(1)=1","analogy":"Each rabbit pair breeds based on pairs before. Classic!","steps":["Base: n1 return n","Return fib(n-1) + fib(n-2)"],"complexity":"Time: O(2^n), Space: O(n)"}},{"id":"core3","title":"Sum to N Recursion","description":"Sum 1 to N recursively.","difficulty":"EASY","category":"Recursion","starterCode":"#include <iostream>\\nusing namespace std;\\nint sum(int n) { return 0; }\\nint main() { cout<<sum(10); return 0; }","expectedOutput":"55","solution":"#include <iostream>\\nusing namespace std;\\nint sum(int n) { if(n == 0) return 0; return n + sum(n-1); }\\nint main() { cout<<sum(10); return 0; }","explanation":{"approach":"sum(n) = n + sum(n-1)","analogy":"Stack coins - add current on top of smaller stack.","steps":["Base: n=0 return 0","Return n + sum(n-1)"],"complexity":"Time: O(n), Space: O(n)"}},{"id":"core4","title":"Power Recursion","description":"Calculate x^n recursively.","difficulty":"EASY","category":"Recursion","starterCode":"#include <iostream>\\nusing namespace std;\\nint power(int x, int n) { return 0; }\\nint main() { cout<<power(2,10); return 0; }","expectedOutput":"1024","solution":"#include <iostream>\\nusing namespace std;\\nint power(int x, int n) { if(n == 0) return 1; return x * power(x, n-1); }\\nint main() { cout<<power(2,10); return 0; }","explanation":{"approach":"x^n = x  x^(n-1)","analogy":"Each level multiplies x once more.","steps":["Base: n=0 return 1","Return x  power(x, n-1)"],"complexity":"Time: O(n), Space: O(n)"}},{"id":"core5","title":"GCD Recursion","description":"Euclidean algorithm.","difficulty":"EASY","category":"Recursion","starterCode":"#include <iostream>\\nusing namespace std;\\nint gcd(int a, int b) { return 0; }\\nint main() { cout<<gcd(48,18); return 0; }","expectedOutput":"6","solution":"#include <iostream>\\nusing namespace std;\\nint gcd(int a, int b) { if(b == 0) return a; return gcd(b, a % b); }\\nint main() { cout<<gcd(48,18); return 0; }","explanation":{"approach":"gcd(a,b) = gcd(b, a%b)","analogy":"Keep finding remainder until nothing left.","steps":["Base: b=0 return a","Return gcd(b, a%b)"],"complexity":"Time: O(log n), Space: O(log n)"}},{"id":"core6","title":"Reverse String Recursion","description":"Reverse using recursion.","difficulty":"EASY","category":"Recursion","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid reverse(char s[], int start, int end) {}\\nint main() { char s[]=\\"hello\\"; reverse(s,0,4); cout<<s; return 0; }","expectedOutput":"olleh","solution":"#include <iostream>\\nusing namespace std;\\nvoid reverse(char s[], int l, int r) { if(l >= r) return; swap(s[l], s[r]); reverse(s, l+1, r-1); }\\nint main() { char s[]=\\"hello\\"; reverse(s,0,4); cout<<s; return 0; }","explanation":{"approach":"Swap ends, recurse on middle.","analogy":"Two people swap positions, then inner pair swaps.","steps":["Base: lr stop","Swap s[l] and s[r]","Recurse on middle"],"complexity":"Time: O(n), Space: O(n)"}},{"id":"core7","title":"Check Palindrome Recursion","description":"Is palindrome recursively.","difficulty":"EASY","category":"Recursion","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isPalin(char s[], int l, int r) { return false; }\\nint main() { char s[]=\\"radar\\"; cout<<isPalin(s,0,4); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isPalin(char s[], int l, int r) { if(l >= r) return true; if(s[l] != s[r]) return false; return isPalin(s, l+1, r-1); }\\nint main() { char s[]=\\"radar\\"; cout<<isPalin(s,0,4); return 0; }","explanation":{"approach":"Compare ends, recurse on middle.","analogy":"Check if outer letters match, then check inner.","steps":["Base: lr return true","If s[l]s[r] return false","Recurse on middle"],"complexity":"Time: O(n), Space: O(n)"}},{"id":"core8","title":"Print 1 to N Recursion","description":"Print numbers ascending.","difficulty":"EASY","category":"Recursion","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid print(int n) {}\\nint main() { print(5); return 0; }","expectedOutput":"1 2 3 4 5","solution":"#include <iostream>\\nusing namespace std;\\nvoid print(int n) { if(n == 0) return; print(n-1); cout << n << (n<5?\\" \\":\\"\\"); }\\nint main() { print(5); return 0; }","explanation":{"approach":"Recurse first (go down), then print (coming back up).","analogy":"Dive to bottom, print on way back up.","steps":["Recurse to n-1 first","Then print n"],"complexity":"Time: O(n), Space: O(n)"}},{"id":"core9","title":"Print N to 1 Recursion","description":"Print numbers descending.","difficulty":"EASY","category":"Recursion","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid print(int n) {}\\nint main() { print(5); return 0; }","expectedOutput":"5 4 3 2 1","solution":"#include <iostream>\\nusing namespace std;\\nvoid print(int n) { if(n == 0) return; cout << n << (n>1?\\" \\":\\"\\"); print(n-1); }\\nint main() { print(5); return 0; }","explanation":{"approach":"Print first, then recurse.","analogy":"Print on way down the stairs.","steps":["Print n","Then recurse to n-1"],"complexity":"Time: O(n), Space: O(n)"}},{"id":"core10","title":"Sum of Array Recursion","description":"Sum array recursively.","difficulty":"EASY","category":"Recursion","starterCode":"#include <iostream>\\nusing namespace std;\\nint sum(int a[], int n) { return 0; }\\nint main() { int a[]={1,2,3,4,5}; cout<<sum(a,5); return 0; }","expectedOutput":"15","solution":"#include <iostream>\\nusing namespace std;\\nint sum(int a[], int n) { if(n == 0) return 0; return a[n-1] + sum(a, n-1); }\\nint main() { int a[]={1,2,3,4,5}; cout<<sum(a,5); return 0; }","explanation":{"approach":"Add last element + sum of rest.","analogy":"Take last item, add to smaller pile's sum.","steps":["Base: n=0 return 0","Return a[n-1] + sum(a, n-1)"],"complexity":"Time: O(n), Space: O(n)"}},{"id":"core11","title":"Find Max Recursion","description":"Find max recursively.","difficulty":"EASY","category":"Recursion","starterCode":"#include <iostream>\\nusing namespace std;\\nint findMax(int a[], int n) { return 0; }\\nint main() { int a[]={3,7,1,9,2}; cout<<findMax(a,5); return 0; }","expectedOutput":"9","solution":"#include <iostream>\\nusing namespace std;\\nint findMax(int a[], int n) { if(n == 1) return a[0]; int m = findMax(a, n-1); return a[n-1] > m ? a[n-1] : m; }\\nint main() { int a[]={3,7,1,9,2}; cout<<findMax(a,5); return 0; }","explanation":{"approach":"Compare last element with max of rest.","analogy":"Find champion of smaller group, compare with last person.","steps":["Base: n=1 return a[0]","Get max of first n-1","Compare with a[n-1]"],"complexity":"Time: O(n), Space: O(n)"}},{"id":"core12","title":"Count Digits Recursion","description":"Count digits recursively.","difficulty":"EASY","category":"Recursion","starterCode":"#include <iostream>\\nusing namespace std;\\nint countDigits(int n) { return 0; }\\nint main() { cout<<countDigits(12345); return 0; }","expectedOutput":"5","solution":"#include <iostream>\\nusing namespace std;\\nint countDigits(int n) { if(n == 0) return 0; return 1 + countDigits(n/10); }\\nint main() { cout<<countDigits(12345); return 0; }","explanation":{"approach":"1 + count of remaining digits.","analogy":"Peel off one digit, count it, repeat.","steps":["Base: n=0 return 0","Return 1 + countDigits(n/10)"],"complexity":"Time: O(log n), Space: O(log n)"}}]`),t5=JSON.parse(`[{"id":"core13","title":"Check Prime","description":"Check if prime.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isPrime(int n) { return false; }\\nint main() { cout<<isPrime(17); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isPrime(int n) { if(n < 2) return false; for(int i = 2; i*i <= n; i++) if(n%i == 0) return false; return true; }\\nint main() { cout<<isPrime(17); return 0; }","explanation":{"approach":"Check divisibility from 2 to sqrt(n).","analogy":"Try dividing by all possible factors. If none work, it's prime.","steps":["If n<2, not prime","Check 2 to sqrt(n)","If any divides, not prime"],"complexity":"Time: O(sqrt n), Space: O(1)"}},{"id":"core14","title":"Binary to Decimal","description":"Convert binary to decimal.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nint toDecimal(int bin) { return 0; }\\nint main() { cout<<toDecimal(1101); return 0; }","expectedOutput":"13","solution":"#include <iostream>\\nusing namespace std;\\nint toDecimal(int bin) { int dec = 0, base = 1; while(bin > 0) { dec += (bin%10) * base; base *= 2; bin /= 10; } return dec; }\\nint main() { cout<<toDecimal(1101); return 0; }","explanation":{"approach":"Multiply each digit by 2^position.","analogy":"1101 = 18 + 14 + 02 + 11 = 13","steps":["Take last digit","Multiply by power of 2","Add to result"],"complexity":"Time: O(log n), Space: O(1)"}},{"id":"core15","title":"Decimal to Binary","description":"Convert decimal to binary.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid toBinary(int n) {}\\nint main() { toBinary(13); return 0; }","expectedOutput":"1101","solution":"#include <iostream>\\nusing namespace std;\\nvoid toBinary(int n) { if(n == 0) { cout<<0; return; } int b[32], i = 0; while(n > 0) { b[i++] = n%2; n /= 2; } for(int j = i-1; j >= 0; j--) cout << b[j]; }\\nint main() { toBinary(13); return 0; }","explanation":{"approach":"Divide by 2, collect remainders, print reverse.","analogy":"13  2 = 6 r1, 6  2 = 3 r0, 3  2 = 1 r1, 1  2 = 0 r1  1101","steps":["Divide by 2","Store remainder","Print in reverse"],"complexity":"Time: O(log n), Space: O(log n)"}},{"id":"core16","title":"Octal to Decimal","description":"Convert octal to decimal.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nint toDecimal(int oct) { return 0; }\\nint main() { cout<<toDecimal(17); return 0; }","expectedOutput":"15","solution":"#include <iostream>\\nusing namespace std;\\nint toDecimal(int oct) { int dec = 0, base = 1; while(oct > 0) { dec += (oct%10) * base; base *= 8; oct /= 10; } return dec; }\\nint main() { cout<<toDecimal(17); return 0; }","explanation":{"approach":"Each digit multiplied by 8^position.","analogy":"17 = 18 + 71 = 15","steps":["Multiply digits by powers of 8"],"complexity":"Time: O(log n), Space: O(1)"}},{"id":"core17","title":"Hexadecimal to Decimal","description":"Hex string to decimal.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nint toDecimal(char hex[]) { return 0; }\\nint main() { cout<<toDecimal(\\"1A\\"); return 0; }","expectedOutput":"26","solution":"#include <iostream>\\nusing namespace std;\\nint toDecimal(char h[]) { int d=0; for(int i=0; h[i]; i++) { d *= 16; if(h[i]>='0'&&h[i]<='9') d += h[i]-'0'; else d += h[i]-'A'+10; } return d; }\\nint main() { cout<<toDecimal(\\"1A\\"); return 0; }","explanation":{"approach":"Each digit/letter  16^position. A=10, B=11, etc.","analogy":"1A = 116 + 10 = 26","steps":["Parse each char","Multiply by 16","Add digit value"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"core18","title":"LCM of Two Numbers","description":"Find LCM.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nint lcm(int a, int b) { return 0; }\\nint main() { cout<<lcm(12,18); return 0; }","expectedOutput":"36","solution":"#include <iostream>\\nusing namespace std;\\nint gcd(int a, int b) { return b==0 ? a : gcd(b, a%b); }\\nint lcm(int a, int b) { return (a * b) / gcd(a, b); }\\nint main() { cout<<lcm(12,18); return 0; }","explanation":{"approach":"LCM = (a  b) / GCD(a, b)","analogy":"LCM is smallest number both divide into.","steps":["Find GCD","LCM = ab / GCD"],"complexity":"Time: O(log n), Space: O(1)"}},{"id":"core19","title":"Armstrong Number","description":"Sum of digit^n = number.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isArmstrong(int n) { return false; }\\nint main() { cout<<isArmstrong(153); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\n#include <cmath>\\nbool isArmstrong(int n) { int t=n, d=0, s=0; while(t>0){d++;t/=10;} t=n; while(t>0){s+=pow(t%10,d);t/=10;} return s==n; }\\nint main() { cout<<isArmstrong(153); return 0; }","explanation":{"approach":"Each digit raised to power of total digits, sum = n.","analogy":"153 = 1 + 5 + 3 = 1+125+27 = 153","steps":["Count digits","Sum each digit^count","Check if equals n"],"complexity":"Time: O(log n), Space: O(1)"}},{"id":"core20","title":"Fibonacci Iterative","description":"Nth Fibonacci iteratively.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nint fib(int n) { return 0; }\\nint main() { cout<<fib(10); return 0; }","expectedOutput":"55","solution":"#include <iostream>\\nusing namespace std;\\nint fib(int n) { if(n <= 1) return n; int a=0, b=1; for(int i=2; i<=n; i++) { int c = a+b; a=b; b=c; } return b; }\\nint main() { cout<<fib(10); return 0; }","explanation":{"approach":"Keep two variables, update each iteration.","analogy":"Like climbing stairs - remember last two steps.","steps":["Start a=0, b=1","Loop: c=a+b, shift values"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"core21","title":"Sum of Divisors","description":"Sum all divisors.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nint sumDivisors(int n) { return 0; }\\nint main() { cout<<sumDivisors(12); return 0; }","expectedOutput":"28","solution":"#include <iostream>\\nusing namespace std;\\nint sumDivisors(int n) { int sum = 0; for(int i = 1; i <= n; i++) if(n % i == 0) sum += i; return sum; }\\nint main() { cout<<sumDivisors(12); return 0; }","explanation":{"approach":"Check each number 1 to n, add if divides evenly.","analogy":"12: 1+2+3+4+6+12 = 28","steps":["Loop 1 to n","If divides, add to sum"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"core22","title":"Count Divisors","description":"Number of divisors.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nint countDivisors(int n) { return 0; }\\nint main() { cout<<countDivisors(12); return 0; }","expectedOutput":"6","solution":"#include <iostream>\\nusing namespace std;\\nint countDivisors(int n) { int c = 0; for(int i = 1; i <= n; i++) if(n % i == 0) c++; return c; }\\nint main() { cout<<countDivisors(12); return 0; }","explanation":{"approach":"Count numbers that divide n evenly.","analogy":"12 has 6 divisors: 1,2,3,4,6,12","steps":["Loop 1 to n","Count divisors"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"core23","title":"Print Primes to N","description":"All primes up to N.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid primes(int n) {}\\nint main() { primes(20); return 0; }","expectedOutput":"2 3 5 7 11 13 17 19","solution":"#include <iostream>\\nusing namespace std;\\nbool isPrime(int n) { if(n<2) return false; for(int i=2;i*i<=n;i++) if(n%i==0) return false; return true; }\\nvoid primes(int n) { bool first=true; for(int i=2;i<=n;i++) if(isPrime(i)) { if(!first) cout<<\\" \\"; cout<<i; first=false; } }\\nint main() { primes(20); return 0; }","explanation":{"approach":"Check each number for primality.","analogy":"Filter out non-primes one by one.","steps":["Loop 2 to n","Check if prime","Print if yes"],"complexity":"Time: O(nn), Space: O(1)"}},{"id":"core24","title":"Next Prime","description":"Find next prime after n.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nint nextPrime(int n) { return 0; }\\nint main() { cout<<nextPrime(10); return 0; }","expectedOutput":"11","solution":"#include <iostream>\\nusing namespace std;\\nbool isPrime(int n) { if(n<2) return false; for(int i=2;i*i<=n;i++) if(n%i==0) return false; return true; }\\nint nextPrime(int n) { n++; while(!isPrime(n)) n++; return n; }\\nint main() { cout<<nextPrime(10); return 0; }","explanation":{"approach":"Keep incrementing and check primality.","analogy":"Start after n, find first prime.","steps":["Start at n+1","Check if prime","If not, try next"],"complexity":"Time: O(nn), Space: O(1)"}},{"id":"core25","title":"Prime Factors","description":"List prime factors.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid primeFactors(int n) {}\\nint main() { primeFactors(60); return 0; }","expectedOutput":"2 2 3 5","solution":"#include <iostream>\\nusing namespace std;\\nvoid primeFactors(int n) { bool f=true; for(int i=2; i<=n; i++) while(n%i==0) { if(!f) cout<<\\" \\"; cout<<i; f=false; n/=i; } }\\nint main() { primeFactors(60); return 0; }","explanation":{"approach":"Divide by smallest prime repeatedly.","analogy":"60 = 2235","steps":["Try dividing by 2","Then 3, 4, 5...","Print each factor"],"complexity":"Time: O(n), Space: O(1)"}}]`),n5=JSON.parse('[{"id":"core26","title":"Merge Sort Recursion","description":"Implement merge sort.","difficulty":"MEDIUM","category":"Recursion","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid mergeSort(int a[], int l, int r) {}\\nint main() { int a[]={38,27,43,3,9,82,10}; mergeSort(a,0,6); for(int i=0;i<7;i++) cout<<a[i]<<\\" \\"; return 0; }","expectedOutput":"3 9 10 27 38 43 82","solution":"#include <iostream>\\nusing namespace std;\\nvoid merge(int a[], int l, int m, int r) { int n1=m-l+1, n2=r-m; int L[n1], R[n2]; for(int i=0;i<n1;i++) L[i]=a[l+i]; for(int i=0;i<n2;i++) R[i]=a[m+1+i]; int i=0,j=0,k=l; while(i<n1 && j<n2) a[k++]=L[i]<=R[j]?L[i++]:R[j++]; while(i<n1) a[k++]=L[i++]; while(j<n2) a[k++]=R[j++]; }\\nvoid mergeSort(int a[], int l, int r) { if(l<r) { int m=(l+r)/2; mergeSort(a,l,m); mergeSort(a,m+1,r); merge(a,l,m,r); } }\\nint main() { int a[]={38,27,43,3,9,82,10}; mergeSort(a,0,6); for(int i=0;i<7;i++) cout<<a[i]<<\\" \\"; return 0; }","explanation":{"approach":"Divide in half, sort each, merge.","analogy":"Split deck, sort each half, merge sorted halves.","steps":["Split at middle","Recursively sort halves","Merge sorted halves"],"complexity":"Time: O(n log n), Space: O(n)"}},{"id":"core27","title":"Quick Sort Recursion","description":"Implement quick sort.","difficulty":"MEDIUM","category":"Recursion","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid quickSort(int a[], int l, int r) {}\\nint main() { int a[]={10,7,8,9,1,5}; quickSort(a,0,5); for(int i=0;i<6;i++) cout<<a[i]<<\\" \\"; return 0; }","expectedOutput":"1 5 7 8 9 10","solution":"#include <iostream>\\nusing namespace std;\\nint partition(int a[], int l, int r) { int p=a[r], i=l-1; for(int j=l;j<r;j++) if(a[j]<p) { i++; swap(a[i],a[j]); } swap(a[i+1],a[r]); return i+1; }\\nvoid quickSort(int a[], int l, int r) { if(l<r) { int p=partition(a,l,r); quickSort(a,l,p-1); quickSort(a,p+1,r); } }\\nint main() { int a[]={10,7,8,9,1,5}; quickSort(a,0,5); for(int i=0;i<6;i++) cout<<a[i]<<\\" \\"; return 0; }","explanation":{"approach":"Pick pivot, partition around it, recurse.","analogy":"Put smaller left, larger right, repeat.","steps":["Choose pivot (last element)","Partition so smaller on left","Recurse on both sides"],"complexity":"Time: O(n log n) avg, Space: O(log n)"}},{"id":"core28","title":"Count Paths in Grid","description":"Paths from top-left to bottom-right.","difficulty":"EASY","category":"Recursion","starterCode":"#include <iostream>\\nusing namespace std;\\nint countPaths(int m, int n) { return 0; }\\nint main() { cout<<countPaths(3,3); return 0; }","expectedOutput":"6","solution":"#include <iostream>\\nusing namespace std;\\nint countPaths(int m, int n) { if(m==1 || n==1) return 1; return countPaths(m-1,n) + countPaths(m,n-1); }\\nint main() { cout<<countPaths(3,3); return 0; }","explanation":{"approach":"Can only go right or down.","analogy":"Count ways to navigate grid.","steps":["Base: edge cells have 1 path","Each cell = paths from left + paths from above"],"complexity":"Time: O(2^(m+n)), Space: O(m+n)"}},{"id":"core29","title":"Ways to Climb Stairs","description":"1 or 2 steps at a time.","difficulty":"EASY","category":"Recursion","starterCode":"#include <iostream>\\nusing namespace std;\\nint climbStairs(int n) { return 0; }\\nint main() { cout<<climbStairs(5); return 0; }","expectedOutput":"8","solution":"#include <iostream>\\nusing namespace std;\\nint climbStairs(int n) { if(n<=2) return n; return climbStairs(n-1)+climbStairs(n-2); }\\nint main() { cout<<climbStairs(5); return 0; }","explanation":{"approach":"Fibonacci pattern - reach n from n-1 or n-2.","analogy":"Take 1 step from n-1 or 2 steps from n-2.","steps":["Base: 1 step=1 way, 2 steps=2 ways","f(n) = f(n-1) + f(n-2)"],"complexity":"Time: O(2^n), Space: O(n)"}},{"id":"core30","title":"Sieve of Eratosthenes","description":"Find all primes up to n.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid sieve(int n) {}\\nint main() { sieve(30); return 0; }","expectedOutput":"2 3 5 7 11 13 17 19 23 29","solution":"#include <iostream>\\nusing namespace std;\\nvoid sieve(int n) { bool p[n+1]; for(int i=0;i<=n;i++) p[i]=true; p[0]=p[1]=false; for(int i=2;i*i<=n;i++) if(p[i]) for(int j=i*i;j<=n;j+=i) p[j]=false; for(int i=2;i<=n;i++) if(p[i]) cout<<i<<\\" \\"; }\\nint main() { sieve(30); return 0; }","explanation":{"approach":"Mark multiples of each prime as composite.","analogy":"Cross out multiples, remaining are prime.","steps":["Assume all prime","For each prime, mark multiples","Print unmarked"],"complexity":"Time: O(n log log n), Space: O(n)"}},{"id":"core31","title":"Euclidean GCD","description":"Greatest common divisor.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nint gcd(int a, int b) { return 0; }\\nint main() { cout<<gcd(48,18); return 0; }","expectedOutput":"6","solution":"#include <iostream>\\nusing namespace std;\\nint gcd(int a, int b) { while(b) { int t=b; b=a%b; a=t; } return a; }\\nint main() { cout<<gcd(48,18); return 0; }","explanation":{"approach":"gcd(a,b) = gcd(b, a mod b).","analogy":"Keep taking remainders until 0.","steps":["Replace larger with remainder","Repeat until one is 0"],"complexity":"Time: O(log min(a,b)), Space: O(1)"}},{"id":"core32","title":"Modular Exponentiation","description":"Calculate (x^n) mod m.","difficulty":"MEDIUM","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nlong long modPow(long long x, long long n, long long m) { return 0; }\\nint main() { cout<<modPow(2,10,1000); return 0; }","expectedOutput":"24","solution":"#include <iostream>\\nusing namespace std;\\nlong long modPow(long long x, long long n, long long m) { long long res=1; x%=m; while(n>0) { if(n&1) res=res*x%m; n>>=1; x=x*x%m; } return res; }\\nint main() { cout<<modPow(2,10,1000); return 0; }","explanation":{"approach":"Square-and-multiply algorithm.","analogy":"Use binary representation of exponent.","steps":["If bit is 1, multiply result","Square base each iteration"],"complexity":"Time: O(log n), Space: O(1)"}},{"id":"core33","title":"Extended Euclidean","description":"Find x, y for ax + by = gcd.","difficulty":"MEDIUM","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nint extGCD(int a, int b, int &x, int &y) { return 0; }\\nint main() { int x,y; cout<<extGCD(30,20,x,y)<<\\" \\"<<x<<\\" \\"<<y; return 0; }","expectedOutput":"10 1 -1","solution":"#include <iostream>\\nusing namespace std;\\nint extGCD(int a, int b, int &x, int &y) { if(b==0) { x=1; y=0; return a; } int x1,y1; int g=extGCD(b,a%b,x1,y1); x=y1; y=x1-(a/b)*y1; return g; }\\nint main() { int x,y; cout<<extGCD(30,20,x,y)<<\\" \\"<<x<<\\" \\"<<y; return 0; }","explanation":{"approach":"Work backwards from base case.","analogy":"Express gcd as linear combination.","steps":["Base: gcd(a,0), x=1, y=0","Work back: x=y1, y=x1-(a/b)*y1"],"complexity":"Time: O(log min(a,b)), Space: O(log min(a,b))"}},{"id":"core34","title":"Modular Inverse","description":"Find x where ax  1 (mod m).","difficulty":"MEDIUM","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nint modInverse(int a, int m) { return 0; }\\nint main() { cout<<modInverse(3,7); return 0; }","expectedOutput":"5","solution":"#include <iostream>\\nusing namespace std;\\nint extGCD(int a, int b, int &x, int &y) { if(b==0) { x=1; y=0; return a; } int x1,y1; int g=extGCD(b,a%b,x1,y1); x=y1; y=x1-(a/b)*y1; return g; }\\nint modInverse(int a, int m) { int x,y; extGCD(a,m,x,y); return (x%m+m)%m; }\\nint main() { cout<<modInverse(3,7); return 0; }","explanation":{"approach":"Use extended Euclidean algorithm.","analogy":"Find x such that ax gives remainder 1.","steps":["Use extGCD to find coefficients","Return x mod m"],"complexity":"Time: O(log m), Space: O(log m)"}},{"id":"core35","title":"Chinese Remainder Theorem","description":"Find x satisfying system.","difficulty":"HARD","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nint crt(int r[], int m[], int n) { return 0; }\\nint main() { int r[]={2,3,2}, m[]={3,5,7}; cout<<crt(r,m,3); return 0; }","expectedOutput":"23","solution":"#include <iostream>\\nusing namespace std;\\nint extGCD(int a, int b, int &x, int &y) { if(b==0) { x=1; y=0; return a; } int x1,y1; int g=extGCD(b,a%b,x1,y1); x=y1; y=x1-(a/b)*y1; return g; }\\nint crt(int r[], int m[], int n) { int M=1; for(int i=0;i<n;i++) M*=m[i]; int res=0; for(int i=0;i<n;i++) { int Mi=M/m[i], x, y; extGCD(Mi,m[i],x,y); res=(res+r[i]*Mi*x)%M; } return (res%M+M)%M; }\\nint main() { int r[]={2,3,2}, m[]={3,5,7}; cout<<crt(r,m,3); return 0; }","explanation":{"approach":"Combine remainders using modular inverses.","analogy":"Find x satisfying multiple mod conditions.","steps":["Compute product M","For each: x += r[i] * M/m[i] * inverse"],"complexity":"Time: O(n log M), Space: O(1)"}}]'),i5=JSON.parse(`[{"id":"core31","title":"Climbing Stairs","description":"You are climbing a staircase with n steps. Each time you can climb either 1 or 2 steps. In how many distinct ways can you climb to the top?","difficulty":"EASY","category":"Dynamic Programming","starterCode":"#include <iostream>\\nusing namespace std;\\nint climbStairs(int n) { return 0; }\\nint main() { cout << climbStairs(4); return 0; }","expectedOutput":"5","solution":"#include <iostream>\\nusing namespace std;\\nint climbStairs(int n) {\\n    if(n <= 2) return n;\\n    \\n    int prev2 = 1;  // Ways to reach step 1\\n    int prev1 = 2;  // Ways to reach step 2\\n    \\n    for(int i = 3; i <= n; i++) {\\n        int curr = prev1 + prev2;  // Can come from step i-1 or i-2\\n        prev2 = prev1;\\n        prev1 = curr;\\n    }\\n    return prev1;\\n}\\nint main() { cout << climbStairs(4); return 0; }","explanation":{"approach":"Dynamic programming (Fibonacci-like). To reach step n, you either came from step n-1 (took 1 step) or step n-2 (took 2 steps). So ways(n) = ways(n-1) + ways(n-2).","analogy":"Like the Fibonacci sequence! Each position is the sum of the two before it. You can reach step 4 from step 3 (1 jump) or step 2 (2 jumps).","steps":["Base cases: 1 way to reach step 1, 2 ways to reach step 2","For each step i from 3 to n:","  ways[i] = ways[i-1] + ways[i-2]","Optimize space: only keep last two values","Return ways to reach step n"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"core32","title":"Coin Change","description":"Given an array of coin denominations and a target amount, return the fewest number of coins needed to make that amount. Return -1 if it's impossible.","difficulty":"MEDIUM","category":"Dynamic Programming","starterCode":"#include <iostream>\\nusing namespace std;\\nint coinChange(int coins[], int n, int amount) { return -1; }\\nint main() { int c[] = {1, 2, 5}; cout << coinChange(c, 3, 11); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nint coinChange(int coins[], int n, int amount) {\\n    int dp[amount + 1];\\n    for(int i = 0; i <= amount; i++) dp[i] = amount + 1;  // Initialize to \\"impossible\\"\\n    dp[0] = 0;  // 0 coins needed for amount 0\\n    \\n    for(int a = 1; a <= amount; a++) {\\n        for(int i = 0; i < n; i++) {\\n            if(coins[i] <= a) {\\n                dp[a] = min(dp[a], dp[a - coins[i]] + 1);\\n            }\\n        }\\n    }\\n    \\n    return dp[amount] > amount ? -1 : dp[amount];\\n}\\nint main() { int c[] = {1, 2, 5}; cout << coinChange(c, 3, 11); return 0; }","explanation":{"approach":"Bottom-up DP. dp[a] = minimum coins to make amount a. For each amount, try using each coin and take the minimum.","analogy":"Like a cashier making change - for each dollar amount, figure out the best combination of coins. Use the solution for smaller amounts to build up.","steps":["dp[i] = minimum coins to make amount i","Initialize dp[0] = 0 (no coins for $0)","For each amount from 1 to target:","  For each coin denomination:","    If coin <= amount: dp[amount] = min(dp[amount], dp[amount - coin] + 1)","Return dp[target] or -1 if impossible"],"complexity":"Time: O(amount  n), Space: O(amount)"}},{"id":"core33","title":"Longest Common Subsequence","description":"Given two strings, find the length of their longest common subsequence (characters appearing in the same order, but not necessarily contiguous).","difficulty":"MEDIUM","category":"Dynamic Programming","starterCode":"#include <iostream>\\nusing namespace std;\\nint longestCommonSubsequence(char a[], char b[]) { return 0; }\\nint main() { cout << longestCommonSubsequence(\\"abcde\\", \\"ace\\"); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nint longestCommonSubsequence(char a[], char b[]) {\\n    int m = 0, n = 0;\\n    while(a[m]) m++;\\n    while(b[n]) n++;\\n    \\n    int dp[m + 1][n + 1];\\n    \\n    // Base cases: empty string has LCS 0\\n    for(int i = 0; i <= m; i++) dp[i][0] = 0;\\n    for(int j = 0; j <= n; j++) dp[0][j] = 0;\\n    \\n    for(int i = 1; i <= m; i++) {\\n        for(int j = 1; j <= n; j++) {\\n            if(a[i - 1] == b[j - 1]) {\\n                dp[i][j] = dp[i - 1][j - 1] + 1;\\n            } else {\\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\\n            }\\n        }\\n    }\\n    return dp[m][n];\\n}\\nint main() { cout << longestCommonSubsequence(\\"abcde\\", \\"ace\\"); return 0; }","explanation":{"approach":"2D DP. dp[i][j] = LCS of first i chars of a and first j chars of b. If current chars match, extend previous LCS. Otherwise, take max of excluding each char.","analogy":"Like finding common DNA between two species. If letters match, great - add 1. If not, try dropping a letter from either string and see which gives longer match.","steps":["dp[i][j] = LCS of a[0..i-1] and b[0..j-1]","If a[i-1] == b[j-1]: dp[i][j] = dp[i-1][j-1] + 1 (extend match)","Else: dp[i][j] = max(dp[i-1][j], dp[i][j-1]) (skip one char)","Answer is dp[m][n]"],"complexity":"Time: O(m  n), Space: O(m  n)"}},{"id":"core34","title":"Word Break","description":"Given a string and a dictionary of words, can you segment the string into a space-separated sequence of dictionary words?","difficulty":"MEDIUM","category":"Dynamic Programming","starterCode":"#include <iostream>\\nusing namespace std;\\nbool wordBreak(char s[], char* dict[], int n) { return false; }\\nint main() { char* d[] = {\\"leet\\", \\"code\\"}; cout << wordBreak(\\"leetcode\\", d, 2); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool match(char s[], int start, int end, char word[]) {\\n    int i = 0;\\n    for(int j = start; j < end; j++, i++) {\\n        if(word[i] == 0 || s[j] != word[i]) return false;\\n    }\\n    return word[i] == 0;\\n}\\n\\nbool wordBreak(char s[], char* dict[], int n) {\\n    int len = 0;\\n    while(s[len]) len++;\\n    \\n    bool dp[len + 1];\\n    for(int i = 0; i <= len; i++) dp[i] = false;\\n    dp[0] = true;  // Empty string can be segmented\\n    \\n    for(int i = 1; i <= len; i++) {\\n        for(int j = 0; j < i; j++) {\\n            if(dp[j]) {\\n                // Check if s[j..i-1] is in dictionary\\n                for(int w = 0; w < n; w++) {\\n                    if(match(s, j, i, dict[w])) {\\n                        dp[i] = true;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    return dp[len];\\n}\\nint main() { char* d[] = {\\"leet\\", \\"code\\"}; cout << wordBreak(\\"leetcode\\", d, 2); return 0; }","explanation":{"approach":"DP. dp[i] = can s[0..i-1] be segmented? For each position i, check if there's a j where dp[j] is true AND s[j..i-1] is a dictionary word.","analogy":"Like solving a puzzle - can you cover the whole string with dictionary word tiles without gaps or overlaps?","steps":["dp[i] = true if s[0..i-1] can be segmented","dp[0] = true (empty string)","For each position i:","  For each earlier position j where dp[j] is true:","    If s[j..i-1] is in dictionary, dp[i] = true","Return dp[length]"],"complexity":"Time: O(n  m  L), Space: O(n)"}},{"id":"core35","title":"House Robber","description":"You're a robber planning to rob houses along a street. Each house has money, but you can't rob two adjacent houses (alarms are connected). Find the maximum money you can rob.","difficulty":"MEDIUM","category":"Dynamic Programming","starterCode":"#include <iostream>\\nusing namespace std;\\nint rob(int nums[], int n) { return 0; }\\nint main() { int h[] = {2, 7, 9, 3, 1}; cout << rob(h, 5); return 0; }","expectedOutput":"12","solution":"#include <iostream>\\nusing namespace std;\\nint rob(int nums[], int n) {\\n    if(n == 0) return 0;\\n    if(n == 1) return nums[0];\\n    \\n    int prev2 = nums[0];  // Max if we only had first house\\n    int prev1 = max(nums[0], nums[1]);  // Max for first two houses\\n    \\n    for(int i = 2; i < n; i++) {\\n        int curr = max(prev1, prev2 + nums[i]);\\n        prev2 = prev1;\\n        prev1 = curr;\\n    }\\n    return prev1;\\n}\\nint main() { int h[] = {2, 7, 9, 3, 1}; cout << rob(h, 5); return 0; }","explanation":{"approach":"DP. For each house, you have two choices: skip it (take max from previous house) or rob it (add its value to max from two houses ago). Take the better option.","analogy":"Like choosing which pizzas to eat at a buffet where you must skip every other slice. At each slice: eat this one plus your best from 2 ago, or skip and keep your previous best.","steps":["dp[i] = max money from houses 0 to i","dp[0] = nums[0], dp[1] = max(nums[0], nums[1])","For each house i from 2:","  Option 1: Skip house i, take dp[i-1]","  Option 2: Rob house i, take nums[i] + dp[i-2]","  dp[i] = max of both options"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"core36","title":"Maximum Product Subarray","description":"Find the contiguous subarray within an array (containing at least one number) which has the largest product. Watch out for negative numbers!","difficulty":"MEDIUM","category":"Dynamic Programming","starterCode":"#include <iostream>\\nusing namespace std;\\nint maxProduct(int nums[], int n) { return 0; }\\nint main() { int a[] = {2, 3, -2, 4}; cout << maxProduct(a, 4); return 0; }","expectedOutput":"6","solution":"#include <iostream>\\nusing namespace std;\\nint maxProduct(int nums[], int n) {\\n    int maxProd = nums[0];\\n    int currMax = nums[0];\\n    int currMin = nums[0];  // Track minimum too (for negative  negative)\\n    \\n    for(int i = 1; i < n; i++) {\\n        if(nums[i] < 0) {\\n            // Negative number flips max and min\\n            int temp = currMax;\\n            currMax = currMin;\\n            currMin = temp;\\n        }\\n        \\n        currMax = max(nums[i], currMax * nums[i]);\\n        currMin = min(nums[i], currMin * nums[i]);\\n        \\n        maxProd = max(maxProd, currMax);\\n    }\\n    return maxProd;\\n}\\nint main() { int a[] = {2, 3, -2, 4}; cout << maxProduct(a, 4); return 0; }","explanation":{"approach":"Track both maximum AND minimum product ending at each position. Why minimum? Because a negative times a negative (minimum) can become maximum! When you hit a negative number, swap max and min.","analogy":"Like riding a roller coaster of multiplications - negative numbers flip your trajectory. What was lowest becomes highest when you hit another negative.","steps":["Track currMax and currMin at each position","When nums[i] is negative, swap max and min","currMax = max(nums[i], currMax  nums[i])","currMin = min(nums[i], currMin  nums[i])","Update global maximum","Why track min? -10  -2 = 20 (min becomes max)"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"core37","title":"Longest Increasing Subsequence","description":"Given an unsorted array of integers, find the length of the longest increasing subsequence (doesn't need to be contiguous, but must maintain relative order).","difficulty":"MEDIUM","category":"Dynamic Programming","starterCode":"#include <iostream>\\nusing namespace std;\\nint lengthOfLIS(int nums[], int n) { return 0; }\\nint main() { int a[] = {10, 9, 2, 5, 3, 7, 101, 18}; cout << lengthOfLIS(a, 8); return 0; }","expectedOutput":"4","solution":"#include <iostream>\\nusing namespace std;\\nint lengthOfLIS(int nums[], int n) {\\n    if(n == 0) return 0;\\n    \\n    int dp[n];\\n    for(int i = 0; i < n; i++) dp[i] = 1;  // Each element is a subsequence of length 1\\n    \\n    for(int i = 1; i < n; i++) {\\n        for(int j = 0; j < i; j++) {\\n            if(nums[j] < nums[i]) {\\n                dp[i] = max(dp[i], dp[j] + 1);\\n            }\\n        }\\n    }\\n    \\n    int maxLen = 0;\\n    for(int i = 0; i < n; i++) {\\n        maxLen = max(maxLen, dp[i]);\\n    }\\n    return maxLen;\\n}\\nint main() { int a[] = {10, 9, 2, 5, 3, 7, 101, 18}; cout << lengthOfLIS(a, 8); return 0; }","explanation":{"approach":"DP. dp[i] = length of LIS ending at index i. For each element, check all previous elements - if smaller, we can extend that subsequence.","analogy":"Like building the tallest tower by stacking blocks, but each block must be bigger than the one below. For each block, find the tallest tower you can build on.","steps":["dp[i] = LIS length ending at index i","Initialize all dp[i] = 1 (single element)","For each element i:","  For each earlier element j:","    If nums[j] < nums[i]: dp[i] = max(dp[i], dp[j] + 1)","Return max of all dp values"],"complexity":"Time: O(n), Space: O(n)"}},{"id":"core38","title":"0/1 Knapsack","description":"Given weights and values of n items, put items in a knapsack of capacity W to get the maximum total value. Each item can only be used once.","difficulty":"MEDIUM","category":"Dynamic Programming","starterCode":"#include <iostream>\\nusing namespace std;\\nint knapsack(int W, int wt[], int val[], int n) { return 0; }\\nint main() { int w[] = {1, 2, 3}; int v[] = {10, 15, 40}; cout << knapsack(5, w, v, 3); return 0; }","expectedOutput":"55","solution":"#include <iostream>\\nusing namespace std;\\nint knapsack(int W, int wt[], int val[], int n) {\\n    int dp[n + 1][W + 1];\\n    \\n    for(int i = 0; i <= n; i++) {\\n        for(int w = 0; w <= W; w++) {\\n            if(i == 0 || w == 0) {\\n                dp[i][w] = 0;\\n            } else if(wt[i - 1] <= w) {\\n                // Can include item i-1\\n                dp[i][w] = max(\\n                    val[i - 1] + dp[i - 1][w - wt[i - 1]],  // Include\\n                    dp[i - 1][w]                            // Exclude\\n                );\\n            } else {\\n                // Item too heavy, must exclude\\n                dp[i][w] = dp[i - 1][w];\\n            }\\n        }\\n    }\\n    return dp[n][W];\\n}\\nint main() { int w[] = {1, 2, 3}; int v[] = {10, 15, 40}; cout << knapsack(5, w, v, 3); return 0; }","explanation":{"approach":"2D DP. dp[i][w] = max value using first i items with capacity w. For each item, choose: include it (if it fits) or exclude it.","analogy":"Like packing for a trip with a weight limit. For each item: either pack it (add value, use weight) or leave it (keep previous best).","steps":["dp[i][w] = max value with first i items and capacity w","For each item i and capacity w:","  If item too heavy: dp[i][w] = dp[i-1][w]","  Else: dp[i][w] = max(","    dp[i-1][w],                        // Skip item","    val[i] + dp[i-1][w - weight[i]]    // Take item","  )"],"complexity":"Time: O(n  W), Space: O(n  W)"}},{"id":"core39","title":"Unique Paths","description":"A robot is at the top-left corner of an mn grid. It can only move right or down. How many unique paths are there to reach the bottom-right corner?","difficulty":"MEDIUM","category":"Dynamic Programming","starterCode":"#include <iostream>\\nusing namespace std;\\nint uniquePaths(int m, int n) { return 0; }\\nint main() { cout << uniquePaths(3, 7); return 0; }","expectedOutput":"28","solution":"#include <iostream>\\nusing namespace std;\\nint uniquePaths(int m, int n) {\\n    int dp[m][n];\\n    \\n    // First row: only one way (all right moves)\\n    for(int j = 0; j < n; j++) dp[0][j] = 1;\\n    \\n    // First column: only one way (all down moves)\\n    for(int i = 0; i < m; i++) dp[i][0] = 1;\\n    \\n    // Fill rest: paths from top + paths from left\\n    for(int i = 1; i < m; i++) {\\n        for(int j = 1; j < n; j++) {\\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\\n        }\\n    }\\n    \\n    return dp[m - 1][n - 1];\\n}\\nint main() { cout << uniquePaths(3, 7); return 0; }","explanation":{"approach":"DP. Each cell can be reached from above or from the left. So paths to cell (i,j) = paths to (i-1,j) + paths to (i,j-1).","analogy":"Like counting routes on a city grid where you can only go south or east. Each intersection's route count is the sum of routes from the two directions you could have come from.","steps":["dp[i][j] = number of paths to cell (i, j)","First row and column: only 1 path each (straight line)","For each other cell: dp[i][j] = dp[i-1][j] + dp[i][j-1]","Return dp[m-1][n-1]"],"complexity":"Time: O(m  n), Space: O(m  n)"}},{"id":"core40","title":"Jump Game","description":"Given an array of non-negative integers, you start at the first index. Each element represents your maximum jump length at that position. Determine if you can reach the last index.","difficulty":"MEDIUM","category":"Dynamic Programming","starterCode":"#include <iostream>\\nusing namespace std;\\nbool canJump(int nums[], int n) { return false; }\\nint main() { int a[] = {2, 3, 1, 1, 4}; cout << canJump(a, 5); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool canJump(int nums[], int n) {\\n    int maxReach = 0;  // Furthest index we can reach\\n    \\n    for(int i = 0; i < n; i++) {\\n        if(i > maxReach) return false;  // Can't reach this index\\n        maxReach = max(maxReach, i + nums[i]);  // Update furthest reach\\n        if(maxReach >= n - 1) return true;  // Can reach end\\n    }\\n    return true;\\n}\\nint main() { int a[] = {2, 3, 1, 1, 4}; cout << canJump(a, 5); return 0; }","explanation":{"approach":"Greedy. Track the furthest index you can reach. At each position, if you can reach it, update max reach. If max reach ever goes past the end, return true.","analogy":"Like a long jump competition - at each position, see how far you can jump. If you can jump past the finish line from anywhere you can reach, you win!","steps":["maxReach = 0 (furthest reachable index)","For each index i:","  If i > maxReach: can't reach this position, return false","  Update maxReach = max(maxReach, i + nums[i])","  If maxReach >= n-1: return true","Return true (reached the end)"],"complexity":"Time: O(n), Space: O(1)"}}]`),r5=JSON.parse(`[{"id":"core46","title":"N Queens Count","description":"Count N-Queens solutions.","difficulty":"HARD","category":"Backtracking","starterCode":"#include <iostream>\\nusing namespace std;\\nint solveNQueens(int n) { return 0; }\\nint main() { cout<<solveNQueens(4); return 0; }","expectedOutput":"2","solution":"#include <iostream>\\nusing namespace std;\\nint cnt; bool col[20],d1[40],d2[40];\\nvoid solve(int r, int n) { if(r==n){cnt++;return;} for(int c=0;c<n;c++) if(!col[c]&&!d1[r-c+n]&&!d2[r+c]) { col[c]=d1[r-c+n]=d2[r+c]=1; solve(r+1,n); col[c]=d1[r-c+n]=d2[r+c]=0; } }\\nint solveNQueens(int n) { cnt=0; solve(0,n); return cnt; }\\nint main() { cout<<solveNQueens(4); return 0; }","explanation":{"approach":"Backtracking with column and diagonal tracking.","analogy":"Try each column, backtrack if conflict.","steps":["Place queen in each valid column","Check column and diagonals","Backtrack if needed"],"complexity":"Time: O(n!), Space: O(n)"}},{"id":"core47","title":"Sudoku Solver","description":"Solve sudoku puzzle.","difficulty":"HARD","category":"Backtracking","starterCode":"#include <iostream>\\nusing namespace std;\\nbool solveSudoku(int b[][9]) { return false; }\\nint main() { int b[9][9]={{5,3,0,0,7,0,0,0,0},{6,0,0,1,9,5,0,0,0},{0,9,8,0,0,0,0,6,0},{8,0,0,0,6,0,0,0,3},{4,0,0,8,0,3,0,0,1},{7,0,0,0,2,0,0,0,6},{0,6,0,0,0,0,2,8,0},{0,0,0,4,1,9,0,0,5},{0,0,0,0,8,0,0,7,9}}; cout<<solveSudoku(b); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isValid(int b[][9], int r, int c, int n) { for(int i=0;i<9;i++) if(b[r][i]==n||b[i][c]==n) return false; int br=r-r%3, bc=c-c%3; for(int i=0;i<3;i++) for(int j=0;j<3;j++) if(b[br+i][bc+j]==n) return false; return true; }\\nbool solve(int b[][9]) { for(int r=0;r<9;r++) for(int c=0;c<9;c++) if(b[r][c]==0) { for(int n=1;n<=9;n++) if(isValid(b,r,c,n)) { b[r][c]=n; if(solve(b)) return true; b[r][c]=0; } return false; } return true; }\\nbool solveSudoku(int b[][9]) { return solve(b); }\\nint main() { int b[9][9]={{5,3,0,0,7,0,0,0,0},{6,0,0,1,9,5,0,0,0},{0,9,8,0,0,0,0,6,0},{8,0,0,0,6,0,0,0,3},{4,0,0,8,0,3,0,0,1},{7,0,0,0,2,0,0,0,6},{0,6,0,0,0,0,2,8,0},{0,0,0,4,1,9,0,0,5},{0,0,0,0,8,0,0,7,9}}; cout<<solveSudoku(b); return 0; }","explanation":{"approach":"Backtracking with constraint checking.","analogy":"Try digits 1-9, backtrack if invalid.","steps":["Find empty cell","Try 1-9","Check row, col, box","Backtrack if invalid"],"complexity":"Time: O(9^81), Space: O(81)"}},{"id":"core48","title":"Generate Parentheses","description":"All valid parentheses.","difficulty":"MEDIUM","category":"Backtracking","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid generate(int n) {}\\nint main() { generate(3); return 0; }","expectedOutput":"((()))(()())(())()(())()(())","solution":"#include <iostream>\\nusing namespace std;\\nvoid gen(char s[], int i, int o, int c, int n) { if(i==2*n) { s[i]=0; cout<<s; return; } if(o<n) { s[i]='('; gen(s,i+1,o+1,c,n); } if(c<o) { s[i]=')'; gen(s,i+1,o,c+1,n); } }\\nvoid generate(int n) { char s[20]; gen(s,0,0,0,n); }\\nint main() { generate(3); return 0; }","explanation":{"approach":"Track open and close counts.","analogy":"Add ( if can, add ) if more ( than ).","steps":["Add ( if open < n","Add ) if close < open","Base: full string"],"complexity":"Time: O(4^n/n), Space: O(n)"}},{"id":"core49","title":"Combination Sum","description":"Combinations summing to target.","difficulty":"MEDIUM","category":"Backtracking","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid combSum(int a[], int n, int t) {}\\nint main() { int a[]={2,3,6,7}; combSum(a,4,7); return 0; }","expectedOutput":"2 2 3 7","solution":"#include <iostream>\\nusing namespace std;\\nvoid solve(int a[], int n, int t, int i, int c[], int k) { if(t==0) { for(int j=0;j<k;j++) cout<<c[j]<<\\" \\"; return; } if(t<0||i>=n) return; c[k]=a[i]; solve(a,n,t-a[i],i,c,k+1); solve(a,n,t,i+1,c,k); }\\nvoid combSum(int a[], int n, int t) { int c[20]; solve(a,n,t,0,c,0); }\\nint main() { int a[]={2,3,6,7}; combSum(a,4,7); return 0; }","explanation":{"approach":"Include (possibly multiple) or skip.","analogy":"Try using each coin multiple times.","steps":["Include current, stay at index","Or skip to next"],"complexity":"Time: O(2^target), Space: O(target)"}},{"id":"core50","title":"Permutations","description":"Generate all permutations.","difficulty":"MEDIUM","category":"Backtracking","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid permute(int a[], int n) {}\\nint main() { int a[]={1,2,3}; permute(a,3); return 0; }","expectedOutput":"1 2 3 1 3 2 2 1 3 2 3 1 3 2 1 3 1 2","solution":"#include <iostream>\\nusing namespace std;\\nvoid perm(int a[], int l, int r) { if(l==r) { for(int i=0;i<=r;i++) cout<<a[i]<<\\" \\"; return; } for(int i=l;i<=r;i++) { swap(a[l],a[i]); perm(a,l+1,r); swap(a[l],a[i]); } }\\nvoid permute(int a[], int n) { perm(a,0,n-1); }\\nint main() { int a[]={1,2,3}; permute(a,3); return 0; }","explanation":{"approach":"Swap each element to front, permute rest.","analogy":"Try each as first, arrange rest.","steps":["Swap current with each position","Recurse on rest","Swap back"],"complexity":"Time: O(n!), Space: O(n)"}},{"id":"core51","title":"Word Search","description":"Find word in grid.","difficulty":"MEDIUM","category":"Backtracking","starterCode":"#include <iostream>\\nusing namespace std;\\nbool exist(char b[][4], int r, int c, char w[]) { return false; }\\nint main() { char b[][4]={{'A','B','C','E'},{'S','F','C','S'},{'A','D','E','E'}}; cout<<exist(b,3,4,\\"ABCCED\\"); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool dfs(char b[][4], int r, int c, int i, int j, char w[], int k) { if(!w[k]) return true; if(i<0||i>=r||j<0||j>=c||b[i][j]!=w[k]) return false; char t=b[i][j]; b[i][j]='#'; bool f=dfs(b,r,c,i+1,j,w,k+1)||dfs(b,r,c,i-1,j,w,k+1)||dfs(b,r,c,i,j+1,w,k+1)||dfs(b,r,c,i,j-1,w,k+1); b[i][j]=t; return f; }\\nbool exist(char b[][4], int r, int c, char w[]) { for(int i=0;i<r;i++) for(int j=0;j<c;j++) if(dfs(b,r,c,i,j,w,0)) return true; return false; }\\nint main() { char b[][4]={{'A','B','C','E'},{'S','F','C','S'},{'A','D','E','E'}}; cout<<exist(b,3,4,\\"ABCCED\\"); return 0; }","explanation":{"approach":"DFS from each cell, mark visited.","analogy":"Explore all paths like a maze.","steps":["Try each starting cell","DFS in 4 directions","Backtrack by restoring"],"complexity":"Time: O(rc4^L), Space: O(L)"}},{"id":"core52","title":"Palindrome Partitioning","description":"All palindrome partitions.","difficulty":"MEDIUM","category":"Backtracking","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid partition(char s[]) {}\\nint main() { partition(\\"aab\\"); return 0; }","expectedOutput":"a a b aa b","solution":"#include <iostream>\\nusing namespace std;\\nbool isPalin(char s[], int l, int r) { while(l<r) if(s[l++]!=s[r--]) return false; return true; }\\nvoid solve(char s[], int start, char cur[][10], int k, int n) { if(start>=n) { for(int i=0;i<k;i++) cout<<cur[i]<<\\" \\"; return; } for(int end=start;end<n;end++) if(isPalin(s,start,end)) { int len=0; for(int i=start;i<=end;i++) cur[k][len++]=s[i]; cur[k][len]=0; solve(s,end+1,cur,k+1,n); } }\\nvoid partition(char s[]) { int n=0; while(s[n]) n++; char cur[10][10]; solve(s,0,cur,0,n); }\\nint main() { partition(\\"aab\\"); return 0; }","explanation":{"approach":"Try all palindrome substrings.","analogy":"Cut string into palindrome pieces.","steps":["For each position, try all palindrome cuts","Recurse on remainder"],"complexity":"Time: O(n  2^n), Space: O(n)"}},{"id":"core53","title":"Letter Combinations","description":"Phone number letters.","difficulty":"MEDIUM","category":"Backtracking","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid letterCombos(char d[]) {}\\nint main() { letterCombos(\\"23\\"); return 0; }","expectedOutput":"ad ae af bd be bf cd ce cf","solution":"#include <iostream>\\nusing namespace std;\\nconst char* map[]={\\"abc\\",\\"def\\",\\"ghi\\",\\"jkl\\",\\"mno\\",\\"pqrs\\",\\"tuv\\",\\"wxyz\\"};\\nvoid solve(char d[], int i, char r[], int k, int n) { if(i==n) { r[k]=0; cout<<r<<\\" \\"; return; } const char* letters=map[d[i]-'2']; for(int j=0;letters[j];j++) { r[k]=letters[j]; solve(d,i+1,r,k+1,n); } }\\nvoid letterCombos(char d[]) { int n=0; while(d[n]) n++; if(n==0) return; char r[10]; solve(d,0,r,0,n); }\\nint main() { letterCombos(\\"23\\"); return 0; }","explanation":{"approach":"Map digits to letters, generate combos.","analogy":"Old phone keypad combinations.","steps":["Map each digit to letters","Try each letter, recurse"],"complexity":"Time: O(4^n), Space: O(n)"}},{"id":"core54","title":"Subsets II","description":"Subsets with duplicates.","difficulty":"MEDIUM","category":"Backtracking","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid subsetsWithDup(int a[], int n) {}\\nint main() { int a[]={1,2,2}; subsetsWithDup(a,3); return 0; }","expectedOutput":"{} {1} {1 2} {1 2 2} {2} {2 2}","solution":"#include <iostream>\\nusing namespace std;\\nvoid solve(int a[], int n, int i, int c[], int k) { cout<<\\"{\\"; for(int j=0;j<k;j++) cout<<(j?\\" \\":\\"\\")<<c[j]; cout<<\\"} \\"; for(int j=i;j<n;j++) { if(j>i && a[j]==a[j-1]) continue; c[k]=a[j]; solve(a,n,j+1,c,k+1); } }\\nvoid subsetsWithDup(int a[], int n) { for(int i=0;i<n-1;i++) for(int j=0;j<n-i-1;j++) if(a[j]>a[j+1]) swap(a[j],a[j+1]); int c[10]; solve(a,n,0,c,0); }\\nint main() { int a[]={1,2,2}; subsetsWithDup(a,3); return 0; }","explanation":{"approach":"Sort and skip consecutive duplicates.","analogy":"Like subsets but skip same elements.","steps":["Sort array","Skip if same as previous at same level"],"complexity":"Time: O(2^n), Space: O(n)"}},{"id":"core55","title":"Combination Sum III","description":"K numbers summing to n.","difficulty":"MEDIUM","category":"Backtracking","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid combSum3(int k, int n) {}\\nint main() { combSum3(3,9); return 0; }","expectedOutput":"1 2 6 1 3 5 2 3 4","solution":"#include <iostream>\\nusing namespace std;\\nvoid solve(int k, int n, int start, int c[], int cnt) { if(cnt==k && n==0) { for(int i=0;i<k;i++) cout<<c[i]<<\\" \\"; return; } if(cnt>=k||n<=0) return; for(int i=start;i<=9;i++) { c[cnt]=i; solve(k,n-i,i+1,c,cnt+1); } }\\nvoid combSum3(int k, int n) { int c[10]; solve(k,n,1,c,0); }\\nint main() { combSum3(3,9); return 0; }","explanation":{"approach":"Pick k numbers from 1-9.","analogy":"Choose k digits summing to target.","steps":["Try each number 1-9","Track count and sum","Base: k numbers, sum is n"],"complexity":"Time: O(C(9,k)), Space: O(k)"}}]`),a5=JSON.parse(`[{"id":"core51","title":"Valid Sudoku","description":"Determine if a 99 Sudoku board is valid. A valid Sudoku has each row, column, and 33 sub-box containing the digits 1-9 with no repeats.","difficulty":"MEDIUM","category":"Matrix","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isValidSudoku(char board[][9]) { return false; }\\nint main() { cout << \\"Check Sudoku\\"; return 0; }","expectedOutput":"Check Sudoku","solution":"#include <iostream>\\nusing namespace std;\\nbool isValidSudoku(char board[][9]) {\\n    // Check rows, columns, and 3x3 boxes\\n    for(int i = 0; i < 9; i++) {\\n        bool row[10] = {}, col[10] = {}, box[10] = {};\\n        for(int j = 0; j < 9; j++) {\\n            // Check row i\\n            if(board[i][j] != '.') {\\n                int d = board[i][j] - '0';\\n                if(row[d]) return false;\\n                row[d] = true;\\n            }\\n            // Check column i\\n            if(board[j][i] != '.') {\\n                int d = board[j][i] - '0';\\n                if(col[d]) return false;\\n                col[d] = true;\\n            }\\n            // Check box i\\n            int boxRow = 3 * (i / 3) + j / 3;\\n            int boxCol = 3 * (i % 3) + j % 3;\\n            if(board[boxRow][boxCol] != '.') {\\n                int d = board[boxRow][boxCol] - '0';\\n                if(box[d]) return false;\\n                box[d] = true;\\n            }\\n        }\\n    }\\n    return true;\\n}\\nint main() { cout << \\"Check Sudoku\\"; return 0; }","explanation":{"approach":"Check each row, column, and 33 box for duplicate digits. Use boolean arrays to track which digits have been seen.","analogy":"Like checking a Sudoku puzzle for rule violations - make sure no number repeats in any row, column, or small square.","steps":["For each row: track seen digits, fail if duplicate","For each column: track seen digits, fail if duplicate","For each 33 box: track seen digits, fail if duplicate","Can check all three in one pass with clever indexing","Return true if no violations found"],"complexity":"Time: O(81) = O(1), Space: O(1)"}},{"id":"core52","title":"Rotate Image","description":"Rotate a square nn 2D matrix by 90 degrees clockwise in-place. Do not allocate another 2D matrix.","difficulty":"MEDIUM","category":"Matrix","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid rotate(int m[][3], int n) {}\\nint main() { int m[][3] = {{1,2,3}, {4,5,6}, {7,8,9}}; rotate(m, 3); for(int i=0;i<3;i++) for(int j=0;j<3;j++) cout << m[i][j] << \\" \\"; return 0; }","expectedOutput":"7 4 1 8 5 2 9 6 3","solution":"#include <iostream>\\nusing namespace std;\\nvoid rotate(int m[][3], int n) {\\n    // Step 1: Transpose (swap rows and columns)\\n    for(int i = 0; i < n; i++) {\\n        for(int j = i; j < n; j++) {\\n            int temp = m[i][j];\\n            m[i][j] = m[j][i];\\n            m[j][i] = temp;\\n        }\\n    }\\n    \\n    // Step 2: Reverse each row\\n    for(int i = 0; i < n; i++) {\\n        int left = 0, right = n - 1;\\n        while(left < right) {\\n            int temp = m[i][left];\\n            m[i][left] = m[i][right];\\n            m[i][right] = temp;\\n            left++;\\n            right--;\\n        }\\n    }\\n}\\nint main() { int m[][3] = {{1,2,3}, {4,5,6}, {7,8,9}}; rotate(m, 3); for(int i=0;i<3;i++) for(int j=0;j<3;j++) cout << m[i][j] << \\" \\"; return 0; }","explanation":{"approach":"Two-step rotation: First transpose the matrix (swap rows with columns), then reverse each row. This gives 90 clockwise rotation.","analogy":"Like flipping a photo diagonally (transpose), then flipping it horizontally (reverse rows). Two flips = 90 rotation!","steps":["Transpose: swap matrix[i][j] with matrix[j][i]","Reverse each row: swap left and right elements","Why? Transpose + row reverse = 90 clockwise","Alternative: Transpose + column reverse = 90 counter-clockwise"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"core53","title":"Set Matrix Zeroes","description":"If an element in a matrix is 0, set its entire row and column to 0. Do it in-place using constant space.","difficulty":"MEDIUM","category":"Matrix","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid setZeroes(int m[][3], int rows, int cols) {}\\nint main() { int m[][3] = {{1,1,1}, {1,0,1}, {1,1,1}}; setZeroes(m, 3, 3); for(int i=0;i<3;i++) for(int j=0;j<3;j++) cout << m[i][j] << \\" \\"; return 0; }","expectedOutput":"1 0 1 0 0 0 1 0 1","solution":"#include <iostream>\\nusing namespace std;\\nvoid setZeroes(int m[][3], int rows, int cols) {\\n    bool firstRowZero = false, firstColZero = false;\\n    \\n    // Check if first row/col should be zero\\n    for(int j = 0; j < cols; j++) if(m[0][j] == 0) firstRowZero = true;\\n    for(int i = 0; i < rows; i++) if(m[i][0] == 0) firstColZero = true;\\n    \\n    // Use first row/col as markers\\n    for(int i = 1; i < rows; i++) {\\n        for(int j = 1; j < cols; j++) {\\n            if(m[i][j] == 0) {\\n                m[i][0] = 0;  // Mark row\\n                m[0][j] = 0;  // Mark column\\n            }\\n        }\\n    }\\n    \\n    // Set zeros based on markers\\n    for(int i = 1; i < rows; i++) {\\n        for(int j = 1; j < cols; j++) {\\n            if(m[i][0] == 0 || m[0][j] == 0) {\\n                m[i][j] = 0;\\n            }\\n        }\\n    }\\n    \\n    // Handle first row/col\\n    if(firstRowZero) for(int j = 0; j < cols; j++) m[0][j] = 0;\\n    if(firstColZero) for(int i = 0; i < rows; i++) m[i][0] = 0;\\n}\\nint main() { int m[][3] = {{1,1,1}, {1,0,1}, {1,1,1}}; setZeroes(m, 3, 3); for(int i=0;i<3;i++) for(int j=0;j<3;j++) cout << m[i][j] << \\" \\"; return 0; }","explanation":{"approach":"Use the first row and column as markers to remember which rows/columns need to be zeroed. First, record if first row/col itself needs zeroing. Then mark, then zero, then handle first row/col.","analogy":"Like using sticky notes on the edges of a grid to mark which rows and columns have zeros, then filling in based on the notes.","steps":["Check if first row/column contains any zeros (special case)","Scan matrix: if m[i][j]=0, mark m[i][0]=0 and m[0][j]=0","Scan again: if row or column marker is 0, set cell to 0","Finally, zero out first row/column if needed"],"complexity":"Time: O(m  n), Space: O(1)"}},{"id":"core54","title":"Search 2D Matrix","description":"Search for a value in an mn matrix where each row is sorted and the first integer of each row is greater than the last integer of the previous row.","difficulty":"MEDIUM","category":"Binary Search","starterCode":"#include <iostream>\\nusing namespace std;\\nbool searchMatrix(int m[][4], int rows, int cols, int target) { return false; }\\nint main() { int m[][4] = {{1,3,5,7}, {10,11,16,20}, {23,30,34,60}}; cout << searchMatrix(m, 3, 4, 3); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool searchMatrix(int m[][4], int rows, int cols, int target) {\\n    int left = 0, right = rows * cols - 1;\\n    \\n    while(left <= right) {\\n        int mid = (left + right) / 2;\\n        int row = mid / cols;\\n        int col = mid % cols;\\n        int val = m[row][col];\\n        \\n        if(val == target) return true;\\n        if(val < target) left = mid + 1;\\n        else right = mid - 1;\\n    }\\n    return false;\\n}\\nint main() { int m[][4] = {{1,3,5,7}, {10,11,16,20}, {23,30,34,60}}; cout << searchMatrix(m, 3, 4, 3); return 0; }","explanation":{"approach":"Treat the 2D matrix as a sorted 1D array and use binary search. Index i in 1D maps to (i/cols, i%cols) in 2D.","analogy":"Like a book with sorted chapters - you can treat all pages as one long sorted list and binary search directly.","steps":["Virtual 1D array: index 0 to rowscols-1","Binary search on this virtual array","Convert 1D index to 2D: row = index/cols, col = index%cols","Standard binary search comparison"],"complexity":"Time: O(log(m  n)), Space: O(1)"}},{"id":"core55","title":"Search 2D Matrix II","description":"Search for a value in an mn matrix where each row AND each column is sorted in ascending order. Different from Search 2D Matrix I - rows don't necessarily continue each other.","difficulty":"MEDIUM","category":"Binary Search","starterCode":"#include <iostream>\\nusing namespace std;\\nbool searchMatrix(int m[][5], int rows, int cols, int target) { return false; }\\nint main() { int mx[][5] = {{1,4,7,11,15}, {2,5,8,12,19}, {3,6,9,16,22}, {10,13,14,17,24}, {18,21,23,26,30}}; cout << searchMatrix(mx, 5, 5, 5); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool searchMatrix(int m[][5], int rows, int cols, int target) {\\n    // Start from top-right corner\\n    int row = 0, col = cols - 1;\\n    \\n    while(row < rows && col >= 0) {\\n        if(m[row][col] == target) return true;\\n        if(m[row][col] > target) {\\n            col--;  // Too big, go left\\n        } else {\\n            row++;  // Too small, go down\\n        }\\n    }\\n    return false;\\n}\\nint main() { int mx[][5] = {{1,4,7,11,15}, {2,5,8,12,19}, {3,6,9,16,22}, {10,13,14,17,24}, {18,21,23,26,30}}; cout << searchMatrix(mx, 5, 5, 5); return 0; }","explanation":{"approach":"Start from top-right (or bottom-left) corner. If current value is too large, go left (eliminating a column). If too small, go down (eliminating a row). Eliminate one row or column each step.","analogy":"Like playing 'hot and cold' - from the corner, you can always move in a direction that gets you closer. Going left makes it smaller, going down makes it bigger.","steps":["Start at top-right corner: m[0][cols-1]","If target found, return true","If current > target: move left (column--)","If current < target: move down (row++)","Continue until out of bounds"],"complexity":"Time: O(m + n), Space: O(1)"}},{"id":"core56","title":"Word Search","description":"Given a 2D board of letters and a word, find if the word exists in the grid. The word can be constructed from sequentially adjacent cells (horizontal or vertical), using each cell at most once.","difficulty":"MEDIUM","category":"Backtracking","starterCode":"#include <iostream>\\nusing namespace std;\\nbool exist(char board[][4], int m, int n, char word[]) { return false; }\\nint main() { char b[][4] = {{\\"ABCE\\"}, {\\"SFCS\\"}, {\\"ADEE\\"}}; cout << exist(b, 3, 4, \\"ABCCED\\"); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool dfs(char board[][4], int m, int n, char word[], int i, int j, int k) {\\n    if(word[k] == 0) return true;  // Found all characters\\n    if(i < 0 || i >= m || j < 0 || j >= n) return false;  // Out of bounds\\n    if(board[i][j] != word[k]) return false;  // Character doesn't match\\n    \\n    char temp = board[i][j];\\n    board[i][j] = '#';  // Mark as visited\\n    \\n    // Try all 4 directions\\n    bool found = dfs(board, m, n, word, i + 1, j, k + 1) ||\\n                 dfs(board, m, n, word, i - 1, j, k + 1) ||\\n                 dfs(board, m, n, word, i, j + 1, k + 1) ||\\n                 dfs(board, m, n, word, i, j - 1, k + 1);\\n    \\n    board[i][j] = temp;  // Restore for backtracking\\n    return found;\\n}\\n\\nbool exist(char board[][4], int m, int n, char word[]) {\\n    for(int i = 0; i < m; i++) {\\n        for(int j = 0; j < n; j++) {\\n            if(dfs(board, m, n, word, i, j, 0)) return true;\\n        }\\n    }\\n    return false;\\n}\\nint main() { char b[][4] = {{\\"ABCE\\"}, {\\"SFCS\\"}, {\\"ADEE\\"}}; cout << exist(b, 3, 4, \\"ABCCED\\"); return 0; }","explanation":{"approach":"DFS with backtracking. From each cell, try to match the word character by character. Mark visited cells, explore all 4 directions, and restore on backtrack.","analogy":"Like playing a word-finding game - start at each cell, try to spell the word by moving to adjacent cells, backtrack if stuck.","steps":["Try starting from each cell in the grid","DFS: if current cell matches current word character","  Mark cell as visited (prevent revisiting)","  Recursively try 4 directions for next character","  Restore cell on backtrack","Return true if word found from any starting position"],"complexity":"Time: O(m  n  4^L), Space: O(L) where L = word length"}},{"id":"core57","title":"N-Queens","description":"Place n queens on an nn chessboard so that no two queens attack each other. Queens attack horizontally, vertically, and diagonally. Return the number of solutions.","difficulty":"HARD","category":"Backtracking","starterCode":"#include <iostream>\\nusing namespace std;\\nint totalNQueens(int n) { return 0; }\\nint main() { cout << totalNQueens(4); return 0; }","expectedOutput":"2","solution":"#include <iostream>\\nusing namespace std;\\nint count;\\nbool col[10], diag1[20], diag2[20];  // Columns and diagonals\\n\\nvoid solve(int row, int n) {\\n    if(row == n) {\\n        count++;\\n        return;\\n    }\\n    \\n    for(int c = 0; c < n; c++) {\\n        // Check if position is safe\\n        if(!col[c] && !diag1[row - c + n] && !diag2[row + c]) {\\n            // Place queen\\n            col[c] = diag1[row - c + n] = diag2[row + c] = true;\\n            solve(row + 1, n);\\n            // Remove queen (backtrack)\\n            col[c] = diag1[row - c + n] = diag2[row + c] = false;\\n        }\\n    }\\n}\\n\\nint totalNQueens(int n) {\\n    count = 0;\\n    for(int i = 0; i < 10; i++) col[i] = false;\\n    for(int i = 0; i < 20; i++) diag1[i] = diag2[i] = false;\\n    solve(0, n);\\n    return count;\\n}\\nint main() { cout << totalNQueens(4); return 0; }","explanation":{"approach":"Backtracking. Place queens row by row. For each row, try each column. Check if column and both diagonals are free. Use arrays to track occupied columns and diagonals.","analogy":"Like a seating arrangement puzzle - place one queen per row, checking that no queen can 'see' another horizontally, vertically, or diagonally.","steps":["Place queens one row at a time","For each row, try each column position","Check safety: column free? both diagonals free?","Diag1 (): cells with same row-col have same diagonal","Diag2 (): cells with same row+col have same diagonal","Place queen, recurse to next row, then backtrack"],"complexity":"Time: O(n!), Space: O(n)"}},{"id":"core58","title":"Sudoku Solver","description":"Solve a Sudoku puzzle by filling the empty cells with digits 1-9 following Sudoku rules. Empty cells are represented by '.'.","difficulty":"HARD","category":"Backtracking","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid solveSudoku(char board[][9]) {}\\nint main() { cout << \\"Sudoku Solver\\"; return 0; }","expectedOutput":"Sudoku Solver","solution":"#include <iostream>\\nusing namespace std;\\nbool isValid(char board[][9], int row, int col, char c) {\\n    for(int i = 0; i < 9; i++) {\\n        if(board[row][i] == c) return false;  // Check row\\n        if(board[i][col] == c) return false;  // Check column\\n        // Check 3x3 box\\n        int boxRow = 3 * (row / 3) + i / 3;\\n        int boxCol = 3 * (col / 3) + i % 3;\\n        if(board[boxRow][boxCol] == c) return false;\\n    }\\n    return true;\\n}\\n\\nbool solve(char board[][9]) {\\n    for(int i = 0; i < 9; i++) {\\n        for(int j = 0; j < 9; j++) {\\n            if(board[i][j] == '.') {\\n                for(char c = '1'; c <= '9'; c++) {\\n                    if(isValid(board, i, j, c)) {\\n                        board[i][j] = c;\\n                        if(solve(board)) return true;\\n                        board[i][j] = '.';  // Backtrack\\n                    }\\n                }\\n                return false;  // No valid digit found\\n            }\\n        }\\n    }\\n    return true;  // All cells filled\\n}\\n\\nvoid solveSudoku(char board[][9]) {\\n    solve(board);\\n}\\nint main() { cout << \\"Sudoku Solver\\"; return 0; }","explanation":{"approach":"Backtracking. Find an empty cell, try digits 1-9. For each valid digit, place it and recursively solve. If stuck, backtrack and try next digit.","analogy":"Like solving a crossword with trial and error - try a number, see if it works with the constraints, backtrack if you get stuck.","steps":["Find next empty cell","Try digits 1-9:","  Check if digit is valid (no conflict in row, column, 33 box)","  If valid, place digit and recurse","  If recursion succeeds, puzzle solved!","  If fails, remove digit (backtrack) and try next","If no digit works, return false (need to backtrack further)"],"complexity":"Time: O(9^empty_cells), Space: O(81)"}},{"id":"core59","title":"Generate Parentheses","description":"Given n pairs of parentheses, generate all combinations of well-formed (valid) parentheses strings.","difficulty":"MEDIUM","category":"Backtracking","starterCode":"#include <iostream>\\nusing namespace std;\\nint count;\\nvoid generateParenthesis(int n) {}\\nint main() { generateParenthesis(3); return 0; }","expectedOutput":"5","solution":"#include <iostream>\\nusing namespace std;\\nint count;\\n\\nvoid generate(int open, int close, int n) {\\n    if(open == n && close == n) {\\n        count++;\\n        return;\\n    }\\n    \\n    // Can add open paren if we haven't used all\\n    if(open < n) {\\n        generate(open + 1, close, n);\\n    }\\n    \\n    // Can add close paren only if we have unmatched open parens\\n    if(close < open) {\\n        generate(open, close + 1, n);\\n    }\\n}\\n\\nvoid generateParenthesis(int n) {\\n    count = 0;\\n    generate(0, 0, n);\\n    cout << count;\\n}\\nint main() { generateParenthesis(3); return 0; }","explanation":{"approach":"Backtracking with two rules: (1) can add '(' if we haven't used all n, (2) can add ')' only if open count > close count (to keep it valid).","analogy":"Like building a mathematical expression - you can't close a parenthesis that was never opened, and you need to close all that you open.","steps":["Track count of open and close parens used","If open = close = n: valid combination found","Can add '(' if open < n","Can add ')' only if close < open (ensures validity)","By following these rules, all generated strings are valid"],"complexity":"Time: O(4^n / n), Space: O(n)"}},{"id":"core60","title":"Permutations","description":"Given an array of distinct integers, return all possible permutations. You can return them in any order.","difficulty":"MEDIUM","category":"Backtracking","starterCode":"#include <iostream>\\nusing namespace std;\\nint count;\\nvoid permute(int nums[], int n) {}\\nint main() { int a[] = {1, 2, 3}; permute(a, 3); return 0; }","expectedOutput":"6","solution":"#include <iostream>\\nusing namespace std;\\nint count;\\n\\nvoid backtrack(int nums[], int n, int start) {\\n    if(start == n) {\\n        count++;\\n        return;\\n    }\\n    \\n    for(int i = start; i < n; i++) {\\n        // Swap current position with each remaining element\\n        int temp = nums[start];\\n        nums[start] = nums[i];\\n        nums[i] = temp;\\n        \\n        backtrack(nums, n, start + 1);\\n        \\n        // Swap back (backtrack)\\n        temp = nums[start];\\n        nums[start] = nums[i];\\n        nums[i] = temp;\\n    }\\n}\\n\\nvoid permute(int nums[], int n) {\\n    count = 0;\\n    backtrack(nums, n, 0);\\n    cout << count;\\n}\\nint main() { int a[] = {1, 2, 3}; permute(a, 3); return 0; }","explanation":{"approach":"Backtracking by swapping. For position i, try placing each remaining element there by swapping, then recurse for position i+1, then swap back.","analogy":"Like choosing people for a line - for each position, let everyone not yet in line take a turn, then arrange the rest of the line recursively.","steps":["For each position from start to end:","  Swap element at 'start' with element at position i","  Recurse for start+1 (arrange rest of array)","  Swap back (restore for next iteration)","When start reaches end, we have a complete permutation"],"complexity":"Time: O(n  n!), Space: O(n)"}}]`),s5=JSON.parse(`[{"id":"core61","title":"Merge Intervals","description":"Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals and return an array of non-overlapping intervals.","difficulty":"MEDIUM","category":"Intervals","starterCode":"#include <iostream>\\nusing namespace std;\\nint merge(int intervals[][2], int n) { return 0; }\\nint main() { int in[][2] = {{1,3}, {2,6}, {8,10}, {15,18}}; cout << merge(in, 4); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nint merge(int intervals[][2], int n) {\\n    // Sort by start time\\n    for(int i = 0; i < n - 1; i++) {\\n        for(int j = 0; j < n - i - 1; j++) {\\n            if(intervals[j][0] > intervals[j+1][0]) {\\n                int t0 = intervals[j][0], t1 = intervals[j][1];\\n                intervals[j][0] = intervals[j+1][0];\\n                intervals[j][1] = intervals[j+1][1];\\n                intervals[j+1][0] = t0;\\n                intervals[j+1][1] = t1;\\n            }\\n        }\\n    }\\n    \\n    int merged = 1;\\n    int lastEnd = intervals[0][1];\\n    \\n    for(int i = 1; i < n; i++) {\\n        if(intervals[i][0] <= lastEnd) {\\n            // Overlapping - extend the end if needed\\n            lastEnd = max(lastEnd, intervals[i][1]);\\n        } else {\\n            // Non-overlapping - start new interval\\n            merged++;\\n            lastEnd = intervals[i][1];\\n        }\\n    }\\n    return merged;\\n}\\nint main() { int in[][2] = {{1,3}, {2,6}, {8,10}, {15,18}}; cout << merge(in, 4); return 0; }","explanation":{"approach":"Sort intervals by start time. Then iterate, merging overlapping intervals by extending the end time when intervals overlap.","analogy":"Like combining overlapping meeting times - if two meetings overlap, combine them into one longer block.","steps":["Sort intervals by start time","Initialize result with first interval","For each remaining interval:","  If start <= previous end: overlap! Extend end","  Else: no overlap, add as new interval"],"complexity":"Time: O(n log n), Space: O(1)"}},{"id":"core62","title":"Insert Interval","description":"Given a list of non-overlapping intervals sorted by start time, insert a new interval and merge if necessary. Return the resulting intervals.","difficulty":"MEDIUM","category":"Intervals","starterCode":"#include <iostream>\\nusing namespace std;\\nint insert(int intervals[][2], int n, int newI[]) { return 0; }\\nint main() { int in[][2] = {{1,2}, {3,5}, {6,7}, {8,10}, {12,16}}; int ni[] = {4, 8}; cout << insert(in, 5, ni); return 0; }","expectedOutput":"4","solution":"#include <iostream>\\nusing namespace std;\\nint insert(int intervals[][2], int n, int newI[]) {\\n    int result[20][2], k = 0;\\n    int i = 0;\\n    \\n    // Add all intervals that end before newInterval starts\\n    while(i < n && intervals[i][1] < newI[0]) {\\n        result[k][0] = intervals[i][0];\\n        result[k][1] = intervals[i][1];\\n        k++;\\n        i++;\\n    }\\n    \\n    // Merge overlapping intervals with newInterval\\n    while(i < n && intervals[i][0] <= newI[1]) {\\n        newI[0] = min(newI[0], intervals[i][0]);\\n        newI[1] = max(newI[1], intervals[i][1]);\\n        i++;\\n    }\\n    result[k][0] = newI[0];\\n    result[k][1] = newI[1];\\n    k++;\\n    \\n    // Add remaining intervals\\n    while(i < n) {\\n        result[k][0] = intervals[i][0];\\n        result[k][1] = intervals[i][1];\\n        k++;\\n        i++;\\n    }\\n    \\n    return k;\\n}\\nint main() { int in[][2] = {{1,2}, {3,5}, {6,7}, {8,10}, {12,16}}; int ni[] = {4, 8}; cout << insert(in, 5, ni); return 0; }","explanation":{"approach":"Three phases: (1) Add all intervals before new interval, (2) Merge all overlapping intervals with new interval, (3) Add all intervals after.","analogy":"Like inserting a block into a row of blocks - first pass all blocks that don't touch it, then merge with any overlapping blocks, then add remaining blocks.","steps":["Add intervals that end before newInterval starts","For overlapping intervals: merge by updating newInterval's start/end","Add the merged newInterval","Add intervals that start after newInterval ends"],"complexity":"Time: O(n), Space: O(n)"}},{"id":"core63","title":"Meeting Rooms II","description":"Given an array of meeting time intervals, find the minimum number of conference rooms required to host all meetings.","difficulty":"MEDIUM","category":"Intervals","starterCode":"#include <iostream>\\nusing namespace std;\\nint minMeetingRooms(int intervals[][2], int n) { return 0; }\\nint main() { int in[][2] = {{0,30}, {5,10}, {15,20}}; cout << minMeetingRooms(in, 3); return 0; }","expectedOutput":"2","solution":"#include <iostream>\\nusing namespace std;\\nint minMeetingRooms(int intervals[][2], int n) {\\n    int starts[n], ends[n];\\n    for(int i = 0; i < n; i++) {\\n        starts[i] = intervals[i][0];\\n        ends[i] = intervals[i][1];\\n    }\\n    \\n    // Sort starts and ends\\n    for(int i = 0; i < n - 1; i++) {\\n        for(int j = 0; j < n - i - 1; j++) {\\n            if(starts[j] > starts[j+1]) { int t = starts[j]; starts[j] = starts[j+1]; starts[j+1] = t; }\\n            if(ends[j] > ends[j+1]) { int t = ends[j]; ends[j] = ends[j+1]; ends[j+1] = t; }\\n        }\\n    }\\n    \\n    int rooms = 0, endPtr = 0;\\n    for(int i = 0; i < n; i++) {\\n        if(starts[i] < ends[endPtr]) {\\n            rooms++;  // Need new room\\n        } else {\\n            endPtr++;  // Reuse a room that freed up\\n        }\\n    }\\n    return rooms;\\n}\\nint main() { int in[][2] = {{0,30}, {5,10}, {15,20}}; cout << minMeetingRooms(in, 3); return 0; }","explanation":{"approach":"Separate start and end times, sort both. Use two pointers - for each meeting start, check if any room has freed up (meeting ended). If not, need new room.","analogy":"Like a busy office building - when a meeting starts, check if any room is free (a meeting ended). If no room is free, you need a new one.","steps":["Extract and sort all start times and end times separately","For each meeting (in start time order):","  If meeting starts before earliest ending: need new room","  Else: a room freed up, reuse it (move end pointer)","Count rooms needed"],"complexity":"Time: O(n log n), Space: O(n)"}},{"id":"core64","title":"Non-overlapping Intervals","description":"Given an array of intervals, find the minimum number of intervals you need to remove to make the rest non-overlapping.","difficulty":"MEDIUM","category":"Intervals","starterCode":"#include <iostream>\\nusing namespace std;\\nint eraseOverlapIntervals(int intervals[][2], int n) { return 0; }\\nint main() { int in[][2] = {{1,2}, {2,3}, {3,4}, {1,3}}; cout << eraseOverlapIntervals(in, 4); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nint eraseOverlapIntervals(int intervals[][2], int n) {\\n    if(n == 0) return 0;\\n    \\n    // Sort by end time\\n    for(int i = 0; i < n - 1; i++) {\\n        for(int j = 0; j < n - i - 1; j++) {\\n            if(intervals[j][1] > intervals[j+1][1]) {\\n                int t0 = intervals[j][0], t1 = intervals[j][1];\\n                intervals[j][0] = intervals[j+1][0];\\n                intervals[j][1] = intervals[j+1][1];\\n                intervals[j+1][0] = t0;\\n                intervals[j+1][1] = t1;\\n            }\\n        }\\n    }\\n    \\n    int keep = 1;\\n    int lastEnd = intervals[0][1];\\n    \\n    for(int i = 1; i < n; i++) {\\n        if(intervals[i][0] >= lastEnd) {\\n            keep++;\\n            lastEnd = intervals[i][1];\\n        }\\n    }\\n    \\n    return n - keep;\\n}\\nint main() { int in[][2] = {{1,2}, {2,3}, {3,4}, {1,3}}; cout << eraseOverlapIntervals(in, 4); return 0; }","explanation":{"approach":"Greedy - sort by end time. Always keep the interval that ends earliest, as it leaves more room for future intervals. Count how many we can keep, return n - kept.","analogy":"Like scheduling TV shows - always pick the show that ends earliest, so you can watch more shows total.","steps":["Sort intervals by end time","Keep first interval (ends earliest)","For each next interval:","  If starts after last kept ends: keep it","  Else: skip (overlaps)","Return n - number kept = number removed"],"complexity":"Time: O(n log n), Space: O(1)"}},{"id":"core65","title":"Linked List Cycle Detection","description":"Given the head of a linked list, determine if it has a cycle. A cycle exists if following the next pointers leads back to a previously visited node.","difficulty":"EASY","category":"Linked Lists","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int val; Node* next; Node(int x): val(x), next(0) {} };\\nbool hasCycle(Node* head) { return false; }\\nint main() { Node* h = new Node(1); h->next = new Node(2); h->next->next = h; cout << hasCycle(h); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int val; Node* next; Node(int x): val(x), next(0) {} };\\nbool hasCycle(Node* head) {\\n    if(!head || !head->next) return false;\\n    \\n    Node* slow = head;\\n    Node* fast = head;\\n    \\n    while(fast && fast->next) {\\n        slow = slow->next;         // Move 1 step\\n        fast = fast->next->next;   // Move 2 steps\\n        \\n        if(slow == fast) return true;  // They met = cycle!\\n    }\\n    return false;  // Fast reached end = no cycle\\n}\\nint main() { Node* h = new Node(1); h->next = new Node(2); h->next->next = h; cout << hasCycle(h); return 0; }","explanation":{"approach":"Floyd's Tortoise and Hare algorithm. Use two pointers - slow moves 1 step, fast moves 2 steps. If there's a cycle, they will eventually meet. If no cycle, fast will reach the end.","analogy":"Like two runners on a circular track - the faster one will eventually lap the slower one. If the track has an end (no cycle), the faster runner reaches it first.","steps":["Initialize slow and fast pointers at head","Move slow 1 step, fast 2 steps each iteration","If they ever meet: cycle detected!","If fast reaches null: no cycle"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"core66","title":"Reverse Linked List","description":"Reverse a singly linked list. Given the head of the list, return the new head of the reversed list.","difficulty":"EASY","category":"Linked Lists","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int val; Node* next; Node(int x): val(x), next(0) {} };\\nNode* reverseList(Node* head) { return nullptr; }\\nvoid print(Node* h) { while(h) { cout << h->val << \\" \\"; h = h->next; } }\\nint main() { Node* h = new Node(1); h->next = new Node(2); h->next->next = new Node(3); h = reverseList(h); print(h); return 0; }","expectedOutput":"3 2 1","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int val; Node* next; Node(int x): val(x), next(0) {} };\\nNode* reverseList(Node* head) {\\n    Node* prev = nullptr;\\n    Node* curr = head;\\n    \\n    while(curr) {\\n        Node* nextTemp = curr->next;  // Save next\\n        curr->next = prev;            // Reverse link\\n        prev = curr;                  // Move prev forward\\n        curr = nextTemp;              // Move curr forward\\n    }\\n    return prev;  // New head\\n}\\nvoid print(Node* h) { while(h) { cout << h->val << \\" \\"; h = h->next; } }\\nint main() { Node* h = new Node(1); h->next = new Node(2); h->next->next = new Node(3); h = reverseList(h); print(h); return 0; }","explanation":{"approach":"Iteratively reverse each link. Keep track of previous and current nodes. For each node, point its next to previous, then move both pointers forward.","analogy":"Like reversing a chain of people holding hands - each person turns around and grabs the person who was behind them.","steps":["Initialize prev = null, curr = head","While curr is not null:","  Save curr->next (we'll lose it after reversing)","  Reverse the link: curr->next = prev","  Move prev to curr","  Move curr to saved next","Return prev (new head)"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"core67","title":"Merge Two Sorted Lists","description":"Merge two sorted linked lists into one sorted linked list. Build the result by splicing together the nodes of the input lists.","difficulty":"EASY","category":"Linked Lists","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int val; Node* next; Node(int x): val(x), next(0) {} };\\nNode* mergeTwoLists(Node* l1, Node* l2) { return nullptr; }\\nvoid print(Node* h) { while(h) { cout << h->val << \\" \\"; h = h->next; } }\\nint main() { Node* a = new Node(1); a->next = new Node(3); Node* b = new Node(2); b->next = new Node(4); print(mergeTwoLists(a, b)); return 0; }","expectedOutput":"1 2 3 4","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int val; Node* next; Node(int x): val(x), next(0) {} };\\nNode* mergeTwoLists(Node* l1, Node* l2) {\\n    Node dummy(0);  // Dummy head for easier handling\\n    Node* tail = &dummy;\\n    \\n    while(l1 && l2) {\\n        if(l1->val <= l2->val) {\\n            tail->next = l1;\\n            l1 = l1->next;\\n        } else {\\n            tail->next = l2;\\n            l2 = l2->next;\\n        }\\n        tail = tail->next;\\n    }\\n    \\n    // Attach remaining nodes\\n    tail->next = l1 ? l1 : l2;\\n    \\n    return dummy.next;\\n}\\nvoid print(Node* h) { while(h) { cout << h->val << \\" \\"; h = h->next; } }\\nint main() { Node* a = new Node(1); a->next = new Node(3); Node* b = new Node(2); b->next = new Node(4); print(mergeTwoLists(a, b)); return 0; }","explanation":{"approach":"Use a dummy head node to simplify edge cases. Compare heads of both lists, take the smaller one and advance that list. Finally, attach any remaining nodes.","analogy":"Like merging two lines of people sorted by height into one line - always take the shorter person from the front of either line.","steps":["Create dummy node to avoid edge cases","While both lists have nodes:","  Compare heads, take smaller one","  Advance that list's pointer","Attach remaining list (one will be empty)","Return dummy.next"],"complexity":"Time: O(m + n), Space: O(1)"}},{"id":"core68","title":"Remove Nth Node From End","description":"Given a linked list, remove the nth node from the end and return the head. Do this in one pass through the list.","difficulty":"MEDIUM","category":"Linked Lists","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int val; Node* next; Node(int x): val(x), next(0) {} };\\nNode* removeNthFromEnd(Node* head, int n) { return nullptr; }\\nvoid print(Node* h) { while(h) { cout << h->val << \\" \\"; h = h->next; } }\\nint main() { Node* h = new Node(1); h->next = new Node(2); h->next->next = new Node(3); h->next->next->next = new Node(4); h = removeNthFromEnd(h, 2); print(h); return 0; }","expectedOutput":"1 2 4","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int val; Node* next; Node(int x): val(x), next(0) {} };\\nNode* removeNthFromEnd(Node* head, int n) {\\n    Node dummy(0);\\n    dummy.next = head;\\n    \\n    Node* first = &dummy;\\n    Node* second = &dummy;\\n    \\n    // Move first n+1 steps ahead\\n    for(int i = 0; i <= n; i++) {\\n        first = first->next;\\n    }\\n    \\n    // Move both until first reaches end\\n    while(first) {\\n        first = first->next;\\n        second = second->next;\\n    }\\n    \\n    // second is now at node BEFORE the one to remove\\n    second->next = second->next->next;\\n    \\n    return dummy.next;\\n}\\nvoid print(Node* h) { while(h) { cout << h->val << \\" \\"; h = h->next; } }\\nint main() { Node* h = new Node(1); h->next = new Node(2); h->next->next = new Node(3); h->next->next->next = new Node(4); h = removeNthFromEnd(h, 2); print(h); return 0; }","explanation":{"approach":"Two pointers with a gap of n nodes. When the first pointer reaches the end, the second pointer is at the node before the one to delete.","analogy":"Like two people walking with a fixed distance between them. When the first person reaches the end, the second person is exactly n steps from the end.","steps":["Use dummy node (handles removing first node)","Move first pointer n+1 steps ahead","Move both pointers together until first reaches end","Second is now pointing to node before the target","Remove target by skipping it: second->next = second->next->next"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"core69","title":"Flatten Binary Tree to Linked List","description":"Given the root of a binary tree, flatten it into a 'linked list' in-place. The list should use the right child pointer and follow pre-order traversal.","difficulty":"MEDIUM","category":"Trees","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct TreeNode { int val; TreeNode *left, *right; TreeNode(int x): val(x), left(0), right(0) {} };\\nvoid flatten(TreeNode* root) {}\\nvoid print(TreeNode* r) { while(r) { cout << r->val << \\" \\"; r = r->right; } }\\nint main() { TreeNode* r = new TreeNode(1); r->left = new TreeNode(2); r->right = new TreeNode(5); flatten(r); print(r); return 0; }","expectedOutput":"1 2 5","solution":"#include <iostream>\\nusing namespace std;\\nstruct TreeNode { int val; TreeNode *left, *right; TreeNode(int x): val(x), left(0), right(0) {} };\\nvoid flatten(TreeNode* root) {\\n    TreeNode* curr = root;\\n    \\n    while(curr) {\\n        if(curr->left) {\\n            // Find rightmost node of left subtree\\n            TreeNode* rightmost = curr->left;\\n            while(rightmost->right) {\\n                rightmost = rightmost->right;\\n            }\\n            \\n            // Connect rightmost to current's right subtree\\n            rightmost->right = curr->right;\\n            \\n            // Move left subtree to right\\n            curr->right = curr->left;\\n            curr->left = nullptr;\\n        }\\n        curr = curr->right;\\n    }\\n}\\nvoid print(TreeNode* r) { while(r) { cout << r->val << \\" \\"; r = r->right; } }\\nint main() { TreeNode* r = new TreeNode(1); r->left = new TreeNode(2); r->right = new TreeNode(5); flatten(r); print(r); return 0; }","explanation":{"approach":"For each node with a left child: find the rightmost node in left subtree, connect it to right subtree, then move left subtree to become the right child. Repeat.","analogy":"Like untangling a tree branch by branch - take the left branch, attach the right branch to its end, then make the left branch the new right.","steps":["For each node (curr):","  If it has left child:","    Find rightmost node in left subtree","    Connect rightmost to curr's right subtree","    Move left subtree to right","    Set left to null","  Move to right child"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"core70","title":"Lowest Common Ancestor","description":"Given a binary tree and two nodes p and q, find their lowest common ancestor (the deepest node that has both as descendants).","difficulty":"MEDIUM","category":"Trees","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct TreeNode { int val; TreeNode *left, *right; TreeNode(int x): val(x), left(0), right(0) {} };\\nTreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { return nullptr; }\\nint main() { TreeNode* r = new TreeNode(3); r->left = new TreeNode(5); r->right = new TreeNode(1); cout << lowestCommonAncestor(r, r->left, r->right)->val; return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nstruct TreeNode { int val; TreeNode *left, *right; TreeNode(int x): val(x), left(0), right(0) {} };\\nTreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n    if(!root || root == p || root == q) return root;\\n    \\n    TreeNode* left = lowestCommonAncestor(root->left, p, q);\\n    TreeNode* right = lowestCommonAncestor(root->right, p, q);\\n    \\n    if(left && right) return root;  // p and q are on different sides\\n    return left ? left : right;     // Both on same side\\n}\\nint main() { TreeNode* r = new TreeNode(3); r->left = new TreeNode(5); r->right = new TreeNode(1); cout << lowestCommonAncestor(r, r->left, r->right)->val; return 0; }","explanation":{"approach":"Recursive. If current node is p or q, return it. Recursively search left and right subtrees. If both return non-null, current node is the LCA. If only one returns non-null, return that.","analogy":"Like finding where two family branches meet - trace both people up the tree until you find their common ancestor.","steps":["Base: if root is null, p, or q, return root","Recursively find p/q in left subtree","Recursively find p/q in right subtree","If both found (left and right non-null): root is LCA","If only one found: return that one (both targets are in same subtree)"],"complexity":"Time: O(n), Space: O(h)"}}]`),o5=JSON.parse(`[{"id":"core71","title":"Level Order Traversal","description":"Given the root of a binary tree, return the level order traversal (visit nodes level by level, left to right).","difficulty":"MEDIUM","category":"Trees","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct TreeNode { int val; TreeNode *left, *right; TreeNode(int x): val(x), left(0), right(0) {} };\\nvoid levelOrder(TreeNode* root) {}\\nint main() { TreeNode* r = new TreeNode(3); r->left = new TreeNode(9); r->right = new TreeNode(20); levelOrder(r); return 0; }","expectedOutput":"3 9 20","solution":"#include <iostream>\\nusing namespace std;\\nstruct TreeNode { int val; TreeNode *left, *right; TreeNode(int x): val(x), left(0), right(0) {} };\\nvoid levelOrder(TreeNode* root) {\\n    if(!root) return;\\n    \\n    TreeNode* queue[100];\\n    int front = 0, back = 0;\\n    \\n    queue[back++] = root;\\n    \\n    while(front < back) {\\n        TreeNode* node = queue[front++];\\n        cout << node->val << \\" \\";\\n        \\n        if(node->left) queue[back++] = node->left;\\n        if(node->right) queue[back++] = node->right;\\n    }\\n}\\nint main() { TreeNode* r = new TreeNode(3); r->left = new TreeNode(9); r->right = new TreeNode(20); levelOrder(r); return 0; }","explanation":{"approach":"BFS using a queue. Process nodes level by level - dequeue a node, print it, enqueue its children. Repeat until queue is empty.","analogy":"Like reading a family tree generation by generation - meet all siblings before moving to the next generation.","steps":["Create a queue, add root","While queue not empty:","  Dequeue front node","  Process node (print value)","  Enqueue left child if exists","  Enqueue right child if exists"],"complexity":"Time: O(n), Space: O(n)"}},{"id":"core72","title":"Validate Binary Search Tree","description":"Determine if a binary tree is a valid BST. In a BST, all left descendants must be less than the node, and all right descendants must be greater.","difficulty":"MEDIUM","category":"Trees","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct TreeNode { int val; TreeNode *left, *right; TreeNode(int x): val(x), left(0), right(0) {} };\\nbool isValidBST(TreeNode* root) { return false; }\\nint main() { TreeNode* r = new TreeNode(2); r->left = new TreeNode(1); r->right = new TreeNode(3); cout << isValidBST(r); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nstruct TreeNode { int val; TreeNode *left, *right; TreeNode(int x): val(x), left(0), right(0) {} };\\nbool validate(TreeNode* node, long minVal, long maxVal) {\\n    if(!node) return true;\\n    \\n    if(node->val <= minVal || node->val >= maxVal) {\\n        return false;\\n    }\\n    \\n    return validate(node->left, minVal, node->val) &&\\n           validate(node->right, node->val, maxVal);\\n}\\n\\nbool isValidBST(TreeNode* root) {\\n    return validate(root, LONG_MIN, LONG_MAX);\\n}\\nint main() { TreeNode* r = new TreeNode(2); r->left = new TreeNode(1); r->right = new TreeNode(3); cout << isValidBST(r); return 0; }","explanation":{"approach":"Recursive validation with bounds. Each node must be within (min, max) range. When going left, update max. When going right, update min.","analogy":"Like checking an organization chart - everyone in your left team must earn less than you, everyone on your right must earn more. And these constraints flow down.","steps":["Start with range (-, +) for root","Each node must be strictly within its range","Left child: range becomes (min, parent_val)","Right child: range becomes (parent_val, max)","If any node violates its range, not a valid BST"],"complexity":"Time: O(n), Space: O(h)"}},{"id":"core73","title":"Construct Binary Tree from Preorder and Inorder","description":"Given preorder and inorder traversal arrays, construct and return the binary tree.","difficulty":"MEDIUM","category":"Trees","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct TreeNode { int val; TreeNode *left, *right; TreeNode(int x): val(x), left(0), right(0) {} };\\nTreeNode* buildTree(int pre[], int in[], int n) { return nullptr; }\\nint main() { int pre[] = {3, 9, 20}; int in[] = {9, 3, 20}; TreeNode* r = buildTree(pre, in, 3); cout << r->val; return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nstruct TreeNode { int val; TreeNode *left, *right; TreeNode(int x): val(x), left(0), right(0) {} };\\nint preIdx;\\n\\nTreeNode* build(int pre[], int in[], int inStart, int inEnd) {\\n    if(inStart > inEnd) return nullptr;\\n    \\n    int rootVal = pre[preIdx++];\\n    TreeNode* root = new TreeNode(rootVal);\\n    \\n    // Find root in inorder array\\n    int inIdx = inStart;\\n    for(int i = inStart; i <= inEnd; i++) {\\n        if(in[i] == rootVal) {\\n            inIdx = i;\\n            break;\\n        }\\n    }\\n    \\n    // Build left and right subtrees\\n    root->left = build(pre, in, inStart, inIdx - 1);\\n    root->right = build(pre, in, inIdx + 1, inEnd);\\n    \\n    return root;\\n}\\n\\nTreeNode* buildTree(int pre[], int in[], int n) {\\n    preIdx = 0;\\n    return build(pre, in, 0, n - 1);\\n}\\nint main() { int pre[] = {3, 9, 20}; int in[] = {9, 3, 20}; TreeNode* r = buildTree(pre, in, 3); cout << r->val; return 0; }","explanation":{"approach":"Preorder gives us the root first. Find this root in inorder - everything before it is left subtree, everything after is right subtree. Recursively build both.","analogy":"Like solving a puzzle - preorder tells you who's the boss, inorder tells you who's on the left team vs right team. Repeat for each team.","steps":["Preorder: first element is always the root","Find root in inorder array","Elements before root in inorder = left subtree","Elements after root in inorder = right subtree","Recursively build left, then right subtrees"],"complexity":"Time: O(n), Space: O(n)"}},{"id":"core74","title":"Kth Smallest in BST","description":"Given the root of a BST and an integer k, return the kth smallest value in the tree (1-indexed).","difficulty":"MEDIUM","category":"Trees","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct TreeNode { int val; TreeNode *left, *right; TreeNode(int x): val(x), left(0), right(0) {} };\\nint kthSmallest(TreeNode* root, int k) { return 0; }\\nint main() { TreeNode* r = new TreeNode(3); r->left = new TreeNode(1); r->right = new TreeNode(4); r->left->right = new TreeNode(2); cout << kthSmallest(r, 1); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nstruct TreeNode { int val; TreeNode *left, *right; TreeNode(int x): val(x), left(0), right(0) {} };\\nint count, result;\\n\\nvoid inorder(TreeNode* node, int k) {\\n    if(!node || count >= k) return;\\n    \\n    inorder(node->left, k);\\n    \\n    count++;\\n    if(count == k) {\\n        result = node->val;\\n        return;\\n    }\\n    \\n    inorder(node->right, k);\\n}\\n\\nint kthSmallest(TreeNode* root, int k) {\\n    count = 0;\\n    result = 0;\\n    inorder(root, k);\\n    return result;\\n}\\nint main() { TreeNode* r = new TreeNode(3); r->left = new TreeNode(1); r->right = new TreeNode(4); r->left->right = new TreeNode(2); cout << kthSmallest(r, 1); return 0; }","explanation":{"approach":"Inorder traversal of BST visits nodes in ascending order. Simply count during inorder traversal and stop at k.","analogy":"Inorder of BST is like reading a sorted list - the kth element in inorder is the kth smallest.","steps":["BST property: inorder gives sorted order","Do inorder traversal","Count each node visited","When count reaches k, that's our answer","Stop early once found"],"complexity":"Time: O(h + k), Space: O(h)"}},{"id":"core75","title":"Binary Tree Maximum Path Sum","description":"Find the maximum sum path in a binary tree. A path can start and end at any node (doesn't need to go through root). Each node is visited at most once.","difficulty":"HARD","category":"Trees","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct TreeNode { int val; TreeNode *left, *right; TreeNode(int x): val(x), left(0), right(0) {} };\\nint maxPathSum(TreeNode* root) { return 0; }\\nint main() { TreeNode* r = new TreeNode(-10); r->left = new TreeNode(9); r->right = new TreeNode(20); cout << maxPathSum(r); return 0; }","expectedOutput":"29","solution":"#include <iostream>\\nusing namespace std;\\nstruct TreeNode { int val; TreeNode *left, *right; TreeNode(int x): val(x), left(0), right(0) {} };\\nint maxSum;\\n\\nint maxGain(TreeNode* node) {\\n    if(!node) return 0;\\n    \\n    // Max gain from left/right (ignore negative paths)\\n    int leftGain = max(0, maxGain(node->left));\\n    int rightGain = max(0, maxGain(node->right));\\n    \\n    // Path through this node\\n    int pathSum = node->val + leftGain + rightGain;\\n    maxSum = max(maxSum, pathSum);\\n    \\n    // Return max single-side contribution to parent\\n    return node->val + max(leftGain, rightGain);\\n}\\n\\nint maxPathSum(TreeNode* root) {\\n    maxSum = -1000000000;\\n    maxGain(root);\\n    return maxSum;\\n}\\nint main() { TreeNode* r = new TreeNode(-10); r->left = new TreeNode(9); r->right = new TreeNode(20); cout << maxPathSum(r); return 0; }","explanation":{"approach":"For each node, calculate the best path passing through it (left + node + right). Track global maximum. Return to parent only the best single-side path (can't fork upward).","analogy":"Like finding the most scenic mountain trail - at each peak, check the best combined view left+right. But when reporting to a higher peak, you can only take one path up.","steps":["At each node, calculate left and right gains (0 if negative)","Path through this node = val + leftGain + rightGain","Update global max if this path is best","Return max single-side contribution: val + max(left, right)","Why single side? Can't branch when going to parent"],"complexity":"Time: O(n), Space: O(h)"}},{"id":"core76","title":"Serialize and Deserialize Binary Tree","description":"Design an algorithm to serialize a binary tree to a string and deserialize it back to a tree.","difficulty":"HARD","category":"Trees","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct TreeNode { int val; TreeNode *left, *right; TreeNode(int x): val(x), left(0), right(0) {} };\\nvoid serialize(TreeNode* root) {}\\nint main() { TreeNode* r = new TreeNode(1); r->left = new TreeNode(2); r->right = new TreeNode(3); serialize(r); return 0; }","expectedOutput":"1 2 # # 3 # #","solution":"#include <iostream>\\nusing namespace std;\\nstruct TreeNode { int val; TreeNode *left, *right; TreeNode(int x): val(x), left(0), right(0) {} };\\nvoid serialize(TreeNode* root) {\\n    if(!root) {\\n        cout << \\"# \\";\\n        return;\\n    }\\n    \\n    cout << root->val << \\" \\";\\n    serialize(root->left);\\n    serialize(root->right);\\n}\\nint main() { TreeNode* r = new TreeNode(1); r->left = new TreeNode(2); r->right = new TreeNode(3); serialize(r); return 0; }","explanation":{"approach":"Preorder traversal with null markers. Write each node's value, use '#' for null nodes. To deserialize, read in preorder and recursively build.","analogy":"Like writing directions to rebuild a Lego model - write each piece in order of assembly, with 'empty' markers for missing parts.","steps":["Serialize:","  If null, output '#'","  Else output value, then serialize left, then right (preorder)","Deserialize:","  Read next token","  If '#', return null","  Else create node, recursively build left and right"],"complexity":"Time: O(n), Space: O(n)"}},{"id":"core77","title":"Word Ladder","description":"Given two words and a dictionary, find the length of the shortest transformation sequence from beginWord to endWord, changing only one letter at a time. Each intermediate word must be in the dictionary.","difficulty":"HARD","category":"BFS","starterCode":"#include <iostream>\\nusing namespace std;\\nint ladderLength(char beginWord[], char endWord[], char* wordList[], int n) { return 0; }\\nint main() { char* words[] = {\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"}; cout << ladderLength(\\"hit\\", \\"cog\\", words, 6); return 0; }","expectedOutput":"5","solution":"#include <iostream>\\nusing namespace std;\\nbool differs(char a[], char b[]) {\\n    int diff = 0;\\n    for(int i = 0; a[i] && b[i]; i++) {\\n        if(a[i] != b[i]) diff++;\\n    }\\n    return diff == 1;\\n}\\n\\nbool equals(char a[], char b[]) {\\n    for(int i = 0; a[i] || b[i]; i++) {\\n        if(a[i] != b[i]) return false;\\n    }\\n    return true;\\n}\\n\\nint ladderLength(char beginWord[], char endWord[], char* wordList[], int n) {\\n    char* queue[100];\\n    int dist[100] = {};\\n    bool visited[100] = {};\\n    int front = 0, back = 0;\\n    \\n    queue[back] = beginWord;\\n    dist[back++] = 1;\\n    \\n    while(front < back) {\\n        char* curr = queue[front];\\n        int d = dist[front++];\\n        \\n        if(equals(curr, endWord)) return d;\\n        \\n        for(int i = 0; i < n; i++) {\\n            if(!visited[i] && differs(curr, wordList[i])) {\\n                visited[i] = true;\\n                queue[back] = wordList[i];\\n                dist[back++] = d + 1;\\n            }\\n        }\\n    }\\n    return 0;\\n}\\nint main() { char* words[] = {\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"}; cout << ladderLength(\\"hit\\", \\"cog\\", words, 6); return 0; }","explanation":{"approach":"BFS where each node is a word and edges connect words that differ by exactly one letter. BFS gives the shortest path.","analogy":"Like finding the shortest route through a word maze - from each word, you can step to any word that differs by one letter.","steps":["Start BFS from beginWord","Queue stores (word, distance)","For each word, find all neighbors (differ by 1 letter)","Add unvisited neighbors to queue","When endWord found, return distance","If queue empties, return 0 (no path)"],"complexity":"Time: O(n  L), Space: O(n)"}},{"id":"core78","title":"Number of Islands","description":"Given a 2D grid of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically.","difficulty":"MEDIUM","category":"DFS","starterCode":"#include <iostream>\\nusing namespace std;\\nint numIslands(char grid[][5], int m, int n) { return 0; }\\nint main() { char g[][5] = {{\\"11110\\"}, {\\"11010\\"}, {\\"11000\\"}, {\\"00000\\"}}; cout << numIslands(g, 4, 5); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nvoid dfs(char grid[][5], int m, int n, int i, int j) {\\n    if(i < 0 || i >= m || j < 0 || j >= n || grid[i][j] != '1') return;\\n    \\n    grid[i][j] = '0';  // Mark as visited\\n    \\n    dfs(grid, m, n, i + 1, j);  // Down\\n    dfs(grid, m, n, i - 1, j);  // Up\\n    dfs(grid, m, n, i, j + 1);  // Right\\n    dfs(grid, m, n, i, j - 1);  // Left\\n}\\n\\nint numIslands(char grid[][5], int m, int n) {\\n    int count = 0;\\n    \\n    for(int i = 0; i < m; i++) {\\n        for(int j = 0; j < n; j++) {\\n            if(grid[i][j] == '1') {\\n                count++;\\n                dfs(grid, m, n, i, j);  // Sink this island\\n            }\\n        }\\n    }\\n    return count;\\n}\\nint main() { char g[][5] = {{\\"11110\\"}, {\\"11010\\"}, {\\"11000\\"}, {\\"00000\\"}}; cout << numIslands(g, 4, 5); return 0; }","explanation":{"approach":"Scan the grid. When you find land ('1'), increment island count, then DFS to 'sink' the entire island (mark all connected land as visited).","analogy":"Like counting puddles - when you find water, count it and absorb the whole puddle. Each new puddle you find is a new count.","steps":["Scan grid cell by cell","When '1' found: found new island, count++","DFS from this cell to mark all connected '1's as visited ('0')","This ensures we don't count same island twice","Continue scanning for more islands"],"complexity":"Time: O(m  n), Space: O(m  n) for recursion"}},{"id":"core79","title":"Course Schedule","description":"There are n courses labeled 0 to n-1. Some courses have prerequisites. Given the total and a list of prerequisites, determine if it's possible to finish all courses (no circular dependencies).","difficulty":"MEDIUM","category":"Graph","starterCode":"#include <iostream>\\nusing namespace std;\\nbool canFinish(int numCourses, int prereq[][2], int n) { return false; }\\nint main() { int p[][2] = {{1, 0}}; cout << canFinish(2, p, 1); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nint adj[10][10], adjSize[10] = {};\\nint state[10];  // 0=unvisited, 1=visiting, 2=visited\\n\\nbool hasCycle(int node) {\\n    if(state[node] == 1) return true;   // Currently visiting = cycle!\\n    if(state[node] == 2) return false;  // Already processed\\n    \\n    state[node] = 1;  // Mark as visiting\\n    \\n    for(int i = 0; i < adjSize[node]; i++) {\\n        if(hasCycle(adj[node][i])) return true;\\n    }\\n    \\n    state[node] = 2;  // Done visiting\\n    return false;\\n}\\n\\nbool canFinish(int numCourses, int prereq[][2], int n) {\\n    // Build adjacency list\\n    for(int i = 0; i < numCourses; i++) adjSize[i] = 0;\\n    for(int i = 0; i < n; i++) {\\n        int a = prereq[i][0], b = prereq[i][1];  // b -> a\\n        adj[b][adjSize[b]++] = a;\\n    }\\n    \\n    for(int i = 0; i < numCourses; i++) state[i] = 0;\\n    \\n    for(int i = 0; i < numCourses; i++) {\\n        if(hasCycle(i)) return false;\\n    }\\n    return true;\\n}\\nint main() { int p[][2] = {{1, 0}}; cout << canFinish(2, p, 1); return 0; }","explanation":{"approach":"Detect cycle in directed graph using DFS. Use 3 states: unvisited, currently visiting, visited. If we visit a node that's currently being visited, we found a cycle.","analogy":"Like checking if a course catalog has impossible requirements - if taking Course A requires B, B requires C, and C requires A, it's impossible!","steps":["Build directed graph: prerequisite  course","DFS with 3 states for each node","0 = not visited, 1 = in current path, 2 = fully processed","If we encounter a node with state 1: cycle detected!","If no cycles found, can complete all courses"],"complexity":"Time: O(V + E), Space: O(V)"}},{"id":"core80","title":"Clone Graph","description":"Given a reference of a node in a connected undirected graph, return a deep copy (clone) of the graph. Each node contains a value and a list of neighbors.","difficulty":"MEDIUM","category":"Graph","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int val; Node* adj[10]; int n; Node(): val(0), n(0) {} Node(int v): val(v), n(0) {} };\\nNode* cloneGraph(Node* node) { return nullptr; }\\nint main() { Node* n = new Node(1); cout << \\"Clone Graph\\"; return 0; }","expectedOutput":"Clone Graph","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int val; Node* adj[10]; int n; Node(): val(0), n(0) {} Node(int v): val(v), n(0) {} };\\nNode* cloned[101] = {};  // Map original node value to cloned node\\n\\nNode* cloneGraph(Node* node) {\\n    if(!node) return nullptr;\\n    \\n    if(cloned[node->val]) {\\n        return cloned[node->val];  // Already cloned\\n    }\\n    \\n    // Create clone\\n    Node* copy = new Node(node->val);\\n    cloned[node->val] = copy;\\n    \\n    // Clone neighbors\\n    for(int i = 0; i < node->n; i++) {\\n        copy->adj[copy->n++] = cloneGraph(node->adj[i]);\\n    }\\n    \\n    return copy;\\n}\\nint main() { Node* n = new Node(1); cout << \\"Clone Graph\\"; return 0; }","explanation":{"approach":"DFS/BFS with a hash map to track originalclone mapping. When visiting a node, create its clone. Recursively clone neighbors, using map to avoid infinite loops.","analogy":"Like photocopying a social network - copy each person, and for their friends, either point to existing copies or create new ones.","steps":["Create a map: original node  cloned node","DFS from starting node","If already cloned (in map), return the clone","Create clone, add to map","Recursively clone each neighbor","Connect clone to cloned neighbors"],"complexity":"Time: O(V + E), Space: O(V)"}}]`),l5=JSON.parse(`[{"id":"rec1","title":"Tower of Hanoi","description":"Move n disks.","difficulty":"MEDIUM","category":"Recursion","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid hanoi(int n, char from, char to, char aux) {}\\nint main() { hanoi(3,'A','C','B'); return 0; }","expectedOutput":"A->C A->B C->B A->C B->A B->C A->C","solution":"#include <iostream>\\nusing namespace std;\\nvoid hanoi(int n, char from, char to, char aux) { if(n==1) { cout<<from<<\\"->\\"<<to<<\\" \\"; return; } hanoi(n-1,from,aux,to); cout<<from<<\\"->\\"<<to<<\\" \\"; hanoi(n-1,aux,to,from); }\\nint main() { hanoi(3,'A','C','B'); return 0; }","explanation":{"approach":"Move n-1 disks to aux, move biggest to target, move n-1 from aux to target.","analogy":"Move all but biggest aside, move biggest, put others back.","steps":["Move n-1 to auxiliary","Move largest to target","Move n-1 from aux to target"],"complexity":"Time: O(2^n), Space: O(n)"}},{"id":"rec2","title":"Subsets","description":"Generate all subsets.","difficulty":"MEDIUM","category":"Recursion","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid subsets(int a[], int n, int i, int sub[], int k) {}\\nint main() { int a[]={1,2,3}, s[10]; subsets(a,3,0,s,0); return 0; }","expectedOutput":"1 2 3 1 2 1 3 2 3 1 2 3","solution":"#include <iostream>\\nusing namespace std;\\nvoid subsets(int a[], int n, int i, int sub[], int k) { if(i==n) { for(int j=0;j<k;j++) cout<<sub[j]<<\\" \\"; return; } sub[k]=a[i]; subsets(a,n,i+1,sub,k+1); subsets(a,n,i+1,sub,k); }\\nint main() { int a[]={1,2,3}, s[10]; subsets(a,3,0,s,0); return 0; }","explanation":{"approach":"For each element: include or exclude.","analogy":"Binary choice for each item.","steps":["Include current, recurse","Exclude current, recurse"],"complexity":"Time: O(2^n), Space: O(n)"}},{"id":"rec3","title":"Permutations","description":"Generate all permutations.","difficulty":"MEDIUM","category":"Recursion","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid permute(int a[], int l, int r) {}\\nint main() { int a[]={1,2,3}; permute(a,0,2); return 0; }","expectedOutput":"1 2 3 1 3 2 2 1 3 2 3 1 3 2 1 3 1 2","solution":"#include <iostream>\\nusing namespace std;\\nvoid permute(int a[], int l, int r) { if(l==r) { for(int i=0;i<=r;i++) cout<<a[i]<<\\" \\"; return; } for(int i=l;i<=r;i++) { swap(a[l],a[i]); permute(a,l+1,r); swap(a[l],a[i]); } }\\nint main() { int a[]={1,2,3}; permute(a,0,2); return 0; }","explanation":{"approach":"Swap each element to first position, recurse on rest.","analogy":"Try each person as leader, arrange rest.","steps":["Swap current with each after","Recurse on remaining","Swap back"],"complexity":"Time: O(n!), Space: O(n)"}},{"id":"rec4","title":"Binary Search Recursive","description":"Binary search using recursion.","difficulty":"EASY","category":"Recursion","starterCode":"#include <iostream>\\nusing namespace std;\\nint bSearch(int a[], int l, int r, int x) { return -1; }\\nint main() { int a[]={1,3,5,7,9}; cout<<bSearch(a,0,4,5); return 0; }","expectedOutput":"2","solution":"#include <iostream>\\nusing namespace std;\\nint bSearch(int a[], int l, int r, int x) { if(l>r) return -1; int m=(l+r)/2; if(a[m]==x) return m; if(a[m]>x) return bSearch(a,l,m-1,x); return bSearch(a,m+1,r,x); }\\nint main() { int a[]={1,3,5,7,9}; cout<<bSearch(a,0,4,5); return 0; }","explanation":{"approach":"Check middle, recurse on appropriate half.","analogy":"Divide and conquer search.","steps":["Check middle","If less, go left half","If more, go right half"],"complexity":"Time: O(log n), Space: O(log n)"}},{"id":"rec5","title":"String Reversal Recursive","description":"Reverse string recursively.","difficulty":"EASY","category":"Recursion","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid reverse(char s[], int l, int r) {}\\nint main() { char s[]=\\"hello\\"; reverse(s,0,4); cout<<s; return 0; }","expectedOutput":"olleh","solution":"#include <iostream>\\nusing namespace std;\\nvoid reverse(char s[], int l, int r) { if(l>=r) return; swap(s[l],s[r]); reverse(s,l+1,r-1); }\\nint main() { char s[]=\\"hello\\"; reverse(s,0,4); cout<<s; return 0; }","explanation":{"approach":"Swap ends, recurse on middle.","analogy":"Mirror the outer, then inner.","steps":["Swap first and last","Recurse on middle portion"],"complexity":"Time: O(n), Space: O(n)"}},{"id":"rec6","title":"Combination Sum","description":"Find combinations summing to target.","difficulty":"MEDIUM","category":"Recursion","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid combSum(int a[], int n, int t, int i, int cur[], int k) {}\\nint main() { int a[]={2,3,6,7}, c[10]; combSum(a,4,7,0,c,0); return 0; }","expectedOutput":"2 2 3 7","solution":"#include <iostream>\\nusing namespace std;\\nvoid combSum(int a[], int n, int t, int i, int cur[], int k) { if(t==0) { for(int j=0;j<k;j++) cout<<cur[j]<<\\" \\"; return; } if(t<0||i>=n) return; cur[k]=a[i]; combSum(a,n,t-a[i],i,cur,k+1); combSum(a,n,t,i+1,cur,k); }\\nint main() { int a[]={2,3,6,7}, c[10]; combSum(a,4,7,0,c,0); return 0; }","explanation":{"approach":"Include current (possibly multiple times) or move to next.","analogy":"Try using each coin repeatedly.","steps":["Include current, stay at same index","Or skip to next index"],"complexity":"Time: O(2^n), Space: O(target)"}},{"id":"rec7","title":"N-th Catalan","description":"Calculate Catalan number.","difficulty":"MEDIUM","category":"Recursion","starterCode":"#include <iostream>\\nusing namespace std;\\nint catalan(int n) { return 0; }\\nint main() { cout<<catalan(5); return 0; }","expectedOutput":"42","solution":"#include <iostream>\\nusing namespace std;\\nint catalan(int n) { if(n<=1) return 1; int c=0; for(int i=0;i<n;i++) c+=catalan(i)*catalan(n-1-i); return c; }\\nint main() { cout<<catalan(5); return 0; }","explanation":{"approach":"C(n) = sum of C(i)  C(n-1-i) for all i.","analogy":"Count valid parentheses combinations.","steps":["Base: C(0)=C(1)=1","C(n) = sum over all splits"],"complexity":"Time: O(4^n), Space: O(n)"}},{"id":"rec8","title":"Josephus Problem","description":"Find survivor position.","difficulty":"MEDIUM","category":"Recursion","starterCode":"#include <iostream>\\nusing namespace std;\\nint josephus(int n, int k) { return 0; }\\nint main() { cout<<josephus(7,3); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nint josephus(int n, int k) { if(n==1) return 0; return (josephus(n-1,k)+k)%n; }\\nint main() { cout<<josephus(7,3); return 0; }","explanation":{"approach":"f(n,k) = (f(n-1,k)+k) mod n.","analogy":"After elimination, positions shift.","steps":["Base: 1 person, position 0","Add k and mod by n"],"complexity":"Time: O(n), Space: O(n)"}},{"id":"rec9","title":"Flood Fill","description":"Fill connected region.","difficulty":"MEDIUM","category":"Recursion","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid floodFill(int img[][5], int r, int c, int sr, int sc, int nc) {}\\nint main() { int img[][5]={{1,1,1},{1,1,0},{1,0,1}}; floodFill(img,3,3,1,1,2); cout<<img[1][1]; return 0; }","expectedOutput":"2","solution":"#include <iostream>\\nusing namespace std;\\nvoid fill(int img[][5], int r, int c, int i, int j, int oc, int nc) { if(i<0||i>=r||j<0||j>=c||img[i][j]!=oc) return; img[i][j]=nc; fill(img,r,c,i+1,j,oc,nc); fill(img,r,c,i-1,j,oc,nc); fill(img,r,c,i,j+1,oc,nc); fill(img,r,c,i,j-1,oc,nc); }\\nvoid floodFill(int img[][5], int r, int c, int sr, int sc, int nc) { int oc=img[sr][sc]; if(oc!=nc) fill(img,r,c,sr,sc,oc,nc); }\\nint main() { int img[][5]={{1,1,1},{1,1,0},{1,0,1}}; floodFill(img,3,3,1,1,2); cout<<img[1][1]; return 0; }","explanation":{"approach":"DFS to fill all connected same-color cells.","analogy":"Paint bucket tool in image editor.","steps":["Change current cell","Recurse to 4 neighbors"],"complexity":"Time: O(rc), Space: O(rc)"}},{"id":"rec10","title":"Rat in a Maze","description":"Find path through maze.","difficulty":"MEDIUM","category":"Recursion","starterCode":"#include <iostream>\\nusing namespace std;\\nbool solveMaze(int m[][4], int n) { return false; }\\nint main() { int m[][4]={{1,0,0,0},{1,1,0,1},{0,1,0,0},{1,1,1,1}}; cout<<solveMaze(m,4); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool solve(int m[][4], int n, int x, int y, int sol[][4]) { if(x==n-1&&y==n-1&&m[x][y]==1){sol[x][y]=1;return true;} if(x>=0&&x<n&&y>=0&&y<n&&m[x][y]==1&&sol[x][y]==0) { sol[x][y]=1; if(solve(m,n,x+1,y,sol)) return true; if(solve(m,n,x,y+1,sol)) return true; sol[x][y]=0; } return false; }\\nbool solveMaze(int m[][4], int n) { int sol[4][4]={}; return solve(m,n,0,0,sol); }\\nint main() { int m[][4]={{1,0,0,0},{1,1,0,1},{0,1,0,0},{1,1,1,1}}; cout<<solveMaze(m,4); return 0; }","explanation":{"approach":"Try down and right, backtrack if stuck.","analogy":"Try each path, undo and try another if blocked.","steps":["Mark current as part of path","Try down, then right","Backtrack if neither works"],"complexity":"Time: O(2^(n)), Space: O(n)"}}]`),c5=JSON.parse(`[{"id":"rec11","title":"N-th Tribonacci","description":"T(n) = T(n-1)+T(n-2)+T(n-3).","difficulty":"EASY","category":"Recursion","starterCode":"#include <iostream>\\nusing namespace std;\\nint tribonacci(int n) { return 0; }\\nint main() { cout<<tribonacci(7); return 0; }","expectedOutput":"13","solution":"#include <iostream>\\nusing namespace std;\\nint tribonacci(int n) { if(n==0) return 0; if(n<=2) return 1; return tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3); }\\nint main() { cout<<tribonacci(7); return 0; }","explanation":{"approach":"Like Fibonacci but with 3 terms.","analogy":"Sum of previous three.","steps":["Base: T(0)=0, T(1)=T(2)=1","T(n)=T(n-1)+T(n-2)+T(n-3)"],"complexity":"Time: O(3^n), Space: O(n)"}},{"id":"rec12","title":"Power Set Recursive","description":"Generate all subsets recursively.","difficulty":"MEDIUM","category":"Recursion","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid powerSet(int a[], int n) {}\\nint main() { int a[]={1,2}; powerSet(a,2); return 0; }","expectedOutput":"{} {1} {1 2} {2}","solution":"#include <iostream>\\nusing namespace std;\\nvoid gen(int a[], int n, int i, int cur[], int k) { if(i==n) { cout<<\\"{\\"; for(int j=0;j<k;j++) cout<<(j?\\" \\":\\"\\")<<cur[j]; cout<<\\"} \\"; return; } gen(a,n,i+1,cur,k); cur[k]=a[i]; gen(a,n,i+1,cur,k+1); }\\nvoid powerSet(int a[], int n) { int cur[10]; gen(a,n,0,cur,0); }\\nint main() { int a[]={1,2}; powerSet(a,2); return 0; }","explanation":{"approach":"Include or exclude each element.","analogy":"Binary choice for each.","steps":["For each element, choose include or not","Recurse to next element"],"complexity":"Time: O(2^n), Space: O(n)"}},{"id":"rec13","title":"String Permutations","description":"All permutations of string.","difficulty":"MEDIUM","category":"Recursion","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid permute(char s[]) {}\\nint main() { char s[]=\\"ABC\\"; permute(s); return 0; }","expectedOutput":"ABC ACB BAC BCA CBA CAB","solution":"#include <iostream>\\nusing namespace std;\\nvoid perm(char s[], int l, int r) { if(l==r) { cout<<s<<\\" \\"; return; } for(int i=l;i<=r;i++) { swap(s[l],s[i]); perm(s,l+1,r); swap(s[l],s[i]); } }\\nvoid permute(char s[]) { int n=0; while(s[n]) n++; perm(s,0,n-1); }\\nint main() { char s[]=\\"ABC\\"; permute(s); return 0; }","explanation":{"approach":"Swap each char to front, permute rest.","analogy":"Try each as first letter.","steps":["Swap current with each position","Recurse","Swap back"],"complexity":"Time: O(n!), Space: O(n)"}},{"id":"rec14","title":"Count Paths in Maze","description":"Paths from top-left to bottom-right.","difficulty":"MEDIUM","category":"Recursion","starterCode":"#include <iostream>\\nusing namespace std;\\nint countPaths(int r, int c) { return 0; }\\nint main() { cout<<countPaths(3,3); return 0; }","expectedOutput":"6","solution":"#include <iostream>\\nusing namespace std;\\nint countPaths(int r, int c) { if(r==1||c==1) return 1; return countPaths(r-1,c)+countPaths(r,c-1); }\\nint main() { cout<<countPaths(3,3); return 0; }","explanation":{"approach":"Sum of paths from left and above.","analogy":"Can only move right or down.","steps":["Base: edge has 1 path","paths(r,c) = paths(r-1,c) + paths(r,c-1)"],"complexity":"Time: O(2^(r+c)), Space: O(r+c)"}},{"id":"rec15","title":"Palindrome Partition Count","description":"Min cuts for palindrome partition.","difficulty":"HARD","category":"Recursion","starterCode":"#include <iostream>\\nusing namespace std;\\nint minCut(char s[]) { return 0; }\\nint main() { cout<<minCut(\\"aab\\"); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isPalin(char s[], int l, int r) { while(l<r) if(s[l++]!=s[r--]) return false; return true; }\\nint solve(char s[], int i, int n) { if(i>=n||isPalin(s,i,n-1)) return 0; int mn=1e9; for(int j=i;j<n-1;j++) if(isPalin(s,i,j)) mn=min(mn,1+solve(s,j+1,n)); return mn; }\\nint minCut(char s[]) { int n=0; while(s[n]) n++; return solve(s,0,n); }\\nint main() { cout<<minCut(\\"aab\\"); return 0; }","explanation":{"approach":"Try all palindrome prefixes.","analogy":"Cut after each palindrome prefix.","steps":["If rest is palindrome, no more cuts","Else try each palindrome prefix, cut, recurse"],"complexity":"Time: O(n  2^n), Space: O(n)"}},{"id":"rec16","title":"Word Break Recursive","description":"Can string be segmented.","difficulty":"MEDIUM","category":"Recursion","starterCode":"#include <iostream>\\nusing namespace std;\\nbool wordBreak(char s[], char dict[][10], int n) { return false; }\\nint main() { char dict[][10]={\\"apple\\",\\"pen\\"}; cout<<wordBreak(\\"applepenapple\\",dict,2); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool eq(char a[], char b[], int len) { for(int i=0;i<len;i++) if(a[i]!=b[i]) return false; return !b[len]; }\\nbool solve(char s[], int start, char dict[][10], int n, int slen) { if(start==slen) return true; for(int end=start+1;end<=slen;end++) for(int i=0;i<n;i++) if(eq(s+start,dict[i],end-start)) if(solve(s,end,dict,n,slen)) return true; return false; }\\nbool wordBreak(char s[], char dict[][10], int n) { int slen=0; while(s[slen]) slen++; return solve(s,0,dict,n,slen); }\\nint main() { char dict[][10]={\\"apple\\",\\"pen\\"}; cout<<wordBreak(\\"applepenapple\\",dict,2); return 0; }","explanation":{"approach":"Try matching each dictionary word.","analogy":"Spell out with dictionary words.","steps":["Try each word as prefix","If match, recurse on rest"],"complexity":"Time: O(2^n), Space: O(n)"}},{"id":"rec17","title":"Decode Ways Recursive","description":"Number of decodings.","difficulty":"MEDIUM","category":"Recursion","starterCode":"#include <iostream>\\nusing namespace std;\\nint numDecodings(char s[]) { return 0; }\\nint main() { cout<<numDecodings(\\"226\\"); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nint solve(char s[], int i, int n) { if(i==n) return 1; if(s[i]=='0') return 0; int ways=solve(s,i+1,n); if(i+1<n) { int two=(s[i]-'0')*10+(s[i+1]-'0'); if(two>=10 && two<=26) ways+=solve(s,i+2,n); } return ways; }\\nint numDecodings(char s[]) { int n=0; while(s[n]) n++; return solve(s,0,n); }\\nint main() { cout<<numDecodings(\\"226\\"); return 0; }","explanation":{"approach":"Take 1 or 2 digits.","analogy":"Decode as single or pair.","steps":["Take single digit (1-9)","Take two digits (10-26)"],"complexity":"Time: O(2^n), Space: O(n)"}},{"id":"rec18","title":"Unique BSTs Count","description":"Number of unique BSTs.","difficulty":"MEDIUM","category":"Recursion","starterCode":"#include <iostream>\\nusing namespace std;\\nint numTrees(int n) { return 0; }\\nint main() { cout<<numTrees(3); return 0; }","expectedOutput":"5","solution":"#include <iostream>\\nusing namespace std;\\nint numTrees(int n) { if(n<=1) return 1; int total=0; for(int i=1;i<=n;i++) total+=numTrees(i-1)*numTrees(n-i); return total; }\\nint main() { cout<<numTrees(3); return 0; }","explanation":{"approach":"Each node as root, count subtrees.","analogy":"Catalan number structure.","steps":["For each root i","Left has i-1 nodes, right has n-i"],"complexity":"Time: O(3^n), Space: O(n)"}},{"id":"rec19","title":"Kth Symbol in Grammar","description":"Find kth symbol in row n.","difficulty":"MEDIUM","category":"Recursion","starterCode":"#include <iostream>\\nusing namespace std;\\nint kthGrammar(int n, int k) { return 0; }\\nint main() { cout<<kthGrammar(4,5); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nint kthGrammar(int n, int k) { if(n==1) return 0; int parent=kthGrammar(n-1,(k+1)/2); return k%2==1 ? parent : 1-parent; }\\nint main() { cout<<kthGrammar(4,5); return 0; }","explanation":{"approach":"Find parent symbol, flip if needed.","analogy":"001, 110.","steps":["Find parent at position (k+1)/2","If k odd, same as parent; else flip"],"complexity":"Time: O(n), Space: O(n)"}},{"id":"rec20","title":"Different Ways to Add Parens","description":"All possible results.","difficulty":"MEDIUM","category":"Recursion","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid diffWays(char e[]) {}\\nint main() { diffWays(\\"2*3-4*5\\"); return 0; }","expectedOutput":"-34 -10 -14 -10 10","solution":"#include <iostream>\\nusing namespace std;\\nvoid solve(char e[], int l, int r, int res[], int *k) { bool hasOp=false; for(int i=l;i<=r;i++) { if(e[i]=='+'||e[i]=='-'||e[i]=='*') { hasOp=true; int left[100],right[100],lk=0,rk=0; solve(e,l,i-1,left,&lk); solve(e,i+1,r,right,&rk); for(int a=0;a<lk;a++) for(int b=0;b<rk;b++) { int v; if(e[i]=='+') v=left[a]+right[b]; else if(e[i]=='-') v=left[a]-right[b]; else v=left[a]*right[b]; res[(*k)++]=v; } } } if(!hasOp) { int v=0; for(int i=l;i<=r;i++) v=v*10+(e[i]-'0'); res[(*k)++]=v; } }\\nvoid diffWays(char e[]) { int n=0; while(e[n]) n++; int res[100], k=0; solve(e,0,n-1,res,&k); for(int i=0;i<k;i++) cout<<res[i]<<\\" \\"; }\\nint main() { diffWays(\\"2*3-4*5\\"); return 0; }","explanation":{"approach":"Split at each operator.","analogy":"Divide and conquer at operators.","steps":["For each operator, split","Combine results of subexpressions"],"complexity":"Time: O(4^n/n), Space: O(4^n/n)"}}]`),u5=JSON.parse(`[{"id":"bit1","title":"Check if Even","description":"Using bit operation.","difficulty":"EASY","category":"Bit Manipulation","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isEven(int n) { return false; }\\nint main() { cout<<isEven(10); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isEven(int n) { return (n & 1) == 0; }\\nint main() { cout<<isEven(10); return 0; }","explanation":{"approach":"Last bit is 0 for even numbers.","analogy":"In binary, even numbers always end in 0.","steps":["AND with 1","If result is 0, it's even"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"bit2","title":"Check if Odd","description":"Using bit operation.","difficulty":"EASY","category":"Bit Manipulation","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isOdd(int n) { return false; }\\nint main() { cout<<isOdd(7); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isOdd(int n) { return (n & 1) == 1; }\\nint main() { cout<<isOdd(7); return 0; }","explanation":{"approach":"Last bit is 1 for odd numbers.","analogy":"In binary, odd numbers end in 1.","steps":["AND with 1","If result is 1, it's odd"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"bit3","title":"Count Set Bits","description":"Count 1s in binary.","difficulty":"EASY","category":"Bit Manipulation","starterCode":"#include <iostream>\\nusing namespace std;\\nint countSetBits(int n) { return 0; }\\nint main() { cout<<countSetBits(13); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nint countSetBits(int n) { int c = 0; while(n) { c += n & 1; n >>= 1; } return c; }\\nint main() { cout<<countSetBits(13); return 0; }","explanation":{"approach":"Check last bit, shift right, repeat.","analogy":"13 = 1101 in binary, has three 1s.","steps":["Check last bit","Shift right","Count 1s"],"complexity":"Time: O(log n), Space: O(1)"}},{"id":"bit4","title":"Check Power of 2","description":"Is number power of 2.","difficulty":"EASY","category":"Bit Manipulation","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isPowerOf2(int n) { return false; }\\nint main() { cout<<isPowerOf2(16); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isPowerOf2(int n) { return n > 0 && (n & (n-1)) == 0; }\\nint main() { cout<<isPowerOf2(16); return 0; }","explanation":{"approach":"Power of 2 has exactly one 1 bit.","analogy":"16 = 10000, 16-1 = 01111, AND = 00000","steps":["n & (n-1) removes lowest set bit","If result is 0, only one bit was set"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"bit5","title":"Toggle Kth Bit","description":"Flip the kth bit.","difficulty":"EASY","category":"Bit Manipulation","starterCode":"#include <iostream>\\nusing namespace std;\\nint toggleBit(int n, int k) { return 0; }\\nint main() { cout<<toggleBit(13,1); return 0; }","expectedOutput":"15","solution":"#include <iostream>\\nusing namespace std;\\nint toggleBit(int n, int k) { return n ^ (1 << k); }\\nint main() { cout<<toggleBit(13,1); return 0; }","explanation":{"approach":"XOR with 1 at position k flips that bit.","analogy":"13=1101, toggle bit 1  1111=15","steps":["Create mask: 1 << k","XOR with n"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"bit6","title":"Set Kth Bit","description":"Set kth bit to 1.","difficulty":"EASY","category":"Bit Manipulation","starterCode":"#include <iostream>\\nusing namespace std;\\nint setBit(int n, int k) { return 0; }\\nint main() { cout<<setBit(10,0); return 0; }","expectedOutput":"11","solution":"#include <iostream>\\nusing namespace std;\\nint setBit(int n, int k) { return n | (1 << k); }\\nint main() { cout<<setBit(10,0); return 0; }","explanation":{"approach":"OR with 1 at position k sets that bit.","analogy":"10=1010, set bit 0  1011=11","steps":["Create mask: 1 << k","OR with n"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"bit7","title":"Clear Kth Bit","description":"Set kth bit to 0.","difficulty":"EASY","category":"Bit Manipulation","starterCode":"#include <iostream>\\nusing namespace std;\\nint clearBit(int n, int k) { return 0; }\\nint main() { cout<<clearBit(15,1); return 0; }","expectedOutput":"13","solution":"#include <iostream>\\nusing namespace std;\\nint clearBit(int n, int k) { return n & ~(1 << k); }\\nint main() { cout<<clearBit(15,1); return 0; }","explanation":{"approach":"AND with inverted mask clears that bit.","analogy":"15=1111, clear bit 1  1101=13","steps":["Create mask: ~(1 << k)","AND with n"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"bit8","title":"Check Kth Bit","description":"Is kth bit set.","difficulty":"EASY","category":"Bit Manipulation","starterCode":"#include <iostream>\\nusing namespace std;\\nbool checkBit(int n, int k) { return false; }\\nint main() { cout<<checkBit(13,2); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool checkBit(int n, int k) { return (n >> k) & 1; }\\nint main() { cout<<checkBit(13,2); return 0; }","explanation":{"approach":"Shift right k positions, check last bit.","analogy":"13=1101, bit 2 is 1","steps":["Shift n right by k","AND with 1"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"bit9","title":"Swap Two Numbers","description":"Swap without temp using XOR.","difficulty":"EASY","category":"Bit Manipulation","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid swap(int &a, int &b) {}\\nint main() { int a=5, b=10; swap(a,b); cout<<a<<\\" \\"<<b; return 0; }","expectedOutput":"10 5","solution":"#include <iostream>\\nusing namespace std;\\nvoid swap(int &a, int &b) { a = a ^ b; b = a ^ b; a = a ^ b; }\\nint main() { int a=5, b=10; swap(a,b); cout<<a<<\\" \\"<<b; return 0; }","explanation":{"approach":"XOR trick: a^=b, b^=a, a^=b","analogy":"Magic math swap without extra variable!","steps":["a = a XOR b","b = a XOR b (now b = original a)","a = a XOR b"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"bit10","title":"Find Single Number","description":"One appears once, others twice.","difficulty":"EASY","category":"Bit Manipulation","starterCode":"#include <iostream>\\nusing namespace std;\\nint singleNumber(int a[], int n) { return 0; }\\nint main() { int a[]={2,1,4,5,2,4,1}; cout<<singleNumber(a,7); return 0; }","expectedOutput":"5","solution":"#include <iostream>\\nusing namespace std;\\nint singleNumber(int a[], int n) { int r = 0; for(int i = 0; i < n; i++) r ^= a[i]; return r; }\\nint main() { int a[]={2,1,4,5,2,4,1}; cout<<singleNumber(a,7); return 0; }","explanation":{"approach":"XOR all: pairs cancel, single remains.","analogy":"a^a=0, so duplicates vanish, unique stays.","steps":["XOR all elements","Pairs cancel out","Unique number remains"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"bit11","title":"Rightmost Set Bit","description":"Position of rightmost 1.","difficulty":"EASY","category":"Bit Manipulation","starterCode":"#include <iostream>\\nusing namespace std;\\nint rightmostSetBit(int n) { return 0; }\\nint main() { cout<<rightmostSetBit(12); return 0; }","expectedOutput":"2","solution":"#include <iostream>\\nusing namespace std;\\nint rightmostSetBit(int n) { int pos = 0; while((n & 1) == 0) { n >>= 1; pos++; } return pos; }\\nint main() { cout<<rightmostSetBit(12); return 0; }","explanation":{"approach":"Shift right until last bit is 1.","analogy":"12=1100, first 1 from right is at position 2","steps":["Shift until bit is 1","Count shifts"],"complexity":"Time: O(log n), Space: O(1)"}},{"id":"bit12","title":"Turn Off Rightmost Bit","description":"Clear rightmost 1.","difficulty":"EASY","category":"Bit Manipulation","starterCode":"#include <iostream>\\nusing namespace std;\\nint turnOffRightmost(int n) { return 0; }\\nint main() { cout<<turnOffRightmost(12); return 0; }","expectedOutput":"8","solution":"#include <iostream>\\nusing namespace std;\\nint turnOffRightmost(int n) { return n & (n - 1); }\\nint main() { cout<<turnOffRightmost(12); return 0; }","explanation":{"approach":"n & (n-1) clears rightmost set bit.","analogy":"12=1100, 11=1011, AND = 1000=8","steps":["n-1 flips from rightmost 1","AND removes that bit"],"complexity":"Time: O(1), Space: O(1)"}}]`),d5=[{id:"logic1",title:"Josephus Problem",description:"Find last survivor.",difficulty:"MEDIUM",category:"Logic",starterCode:`#include <iostream>
using namespace std;
int josephus(int n, int k) { return 0; }
int main() { cout<<josephus(5,2); return 0; }`,expectedOutput:"2",solution:`#include <iostream>
using namespace std;
int josephus(int n, int k) { if(n==1) return 0; return (josephus(n-1,k)+k)%n; }
int main() { cout<<josephus(5,2); return 0; }`,explanation:{approach:"f(n,k) = (f(n-1,k)+k) mod n.",analogy:"Circle elimination game.",steps:["Base: 1 person at position 0","Recurse with shifted positions"],complexity:"Time: O(n), Space: O(n)"}},{id:"logic2",title:"Tower of Hanoi Steps",description:"Count minimum moves.",difficulty:"EASY",category:"Logic",starterCode:`#include <iostream>
using namespace std;
int hanoiMoves(int n) { return 0; }
int main() { cout<<hanoiMoves(3); return 0; }`,expectedOutput:"7",solution:`#include <iostream>
using namespace std;
int hanoiMoves(int n) { return (1<<n)-1; }
int main() { cout<<hanoiMoves(3); return 0; }`,explanation:{approach:"Formula: 2^n - 1 moves.",analogy:"Doubles with each disk added, minus 1.",steps:["2^n - 1"],complexity:"Time: O(1), Space: O(1)"}},{id:"logic3",title:"Egg Drop Problem",description:"Min tries with 2 eggs.",difficulty:"MEDIUM",category:"Logic",starterCode:`#include <iostream>
using namespace std;
int eggDrop(int n) { return 0; }
int main() { cout<<eggDrop(10); return 0; }`,expectedOutput:"4",solution:`#include <iostream>
using namespace std;
int eggDrop(int n) { int tries=1; while(tries*(tries+1)/2<n) tries++; return tries; }
int main() { cout<<eggDrop(10); return 0; }`,explanation:{approach:"Find k where k(k+1)/2 >= n.",analogy:"Triangular number covers n floors.",steps:["With k tries, can cover k(k+1)/2 floors"],complexity:"Time: O(n), Space: O(1)"}},{id:"logic4",title:"Water Jug Problem",description:"Can measure target liters.",difficulty:"MEDIUM",category:"Logic",starterCode:`#include <iostream>
using namespace std;
bool canMeasure(int x, int y, int z) { return false; }
int main() { cout<<canMeasure(3,5,4); return 0; }`,expectedOutput:"1",solution:`#include <iostream>
using namespace std;
int gcd(int a, int b) { return b==0?a:gcd(b,a%b); }
bool canMeasure(int x, int y, int z) { return z<=x+y && z%gcd(x,y)==0; }
int main() { cout<<canMeasure(3,5,4); return 0; }`,explanation:{approach:"Possible if z divides gcd(x,y) and z <= x+y.",analogy:"Can only measure multiples of GCD.",steps:["Check z <= x+y","Check z % gcd(x,y) == 0"],complexity:"Time: O(log min(x,y)), Space: O(1)"}},{id:"logic5",title:"Monty Hall",description:"Should you switch?",difficulty:"EASY",category:"Logic",starterCode:`#include <iostream>
using namespace std;
void montyHall() {}
int main() { montyHall(); return 0; }`,expectedOutput:"Switch",solution:`#include <iostream>
using namespace std;
void montyHall() { cout<<"Switch"; }
int main() { montyHall(); return 0; }`,explanation:{approach:"Switching wins 2/3 of the time.",analogy:"Initial choice is 1/3, other two are 2/3. Host reveals one, so switch gets 2/3.",steps:["Original choice: 1/3 chance","Other door: 2/3 chance","Always switch!"],complexity:"Time: O(1), Space: O(1)"}},{id:"logic6",title:"Birthday Paradox",description:"People needed for 50% same birthday.",difficulty:"EASY",category:"Logic",starterCode:`#include <iostream>
using namespace std;
int birthdayParadox() { return 0; }
int main() { cout<<birthdayParadox(); return 0; }`,expectedOutput:"23",solution:`#include <iostream>
using namespace std;
int birthdayParadox() { double p=1; int n=0; while(p>0.5) { n++; p*=(365.0-n+1)/365; } return n; }
int main() { cout<<birthdayParadox(); return 0; }`,explanation:{approach:"Calculate probability of all different birthdays.",analogy:"With 23 people, >50% chance of shared birthday.",steps:["P(all different) = 365/365  364/365  ...","Find when < 0.5"],complexity:"Time: O(1), Space: O(1)"}},{id:"logic7",title:"Prisoner Hat Problem",description:"Max saves with strategy.",difficulty:"EASY",category:"Logic",starterCode:`#include <iostream>
using namespace std;
int maxSaves(int n) { return 0; }
int main() { cout<<maxSaves(10); return 0; }`,expectedOutput:"9",solution:`#include <iostream>
using namespace std;
int maxSaves(int n) { return n-1; }
int main() { cout<<maxSaves(10); return 0; }`,explanation:{approach:"First person encodes parity, guarantees n-1 saves.",analogy:"First person says parity of black hats ahead.",steps:["First says odd/even count","Others deduce their color"],complexity:"Time: O(1), Space: O(1)"}},{id:"logic8",title:"Bridge Crossing",description:"Min time for 4 people.",difficulty:"MEDIUM",category:"Logic",starterCode:`#include <iostream>
using namespace std;
int bridgeCrossing(int a, int b, int c, int d) { return 0; }
int main() { cout<<bridgeCrossing(1,2,5,10); return 0; }`,expectedOutput:"17",solution:`#include <iostream>
using namespace std;
int bridgeCrossing(int a, int b, int c, int d) { int t[4]={a,b,c,d}; for(int i=0;i<4;i++) for(int j=i+1;j<4;j++) if(t[i]>t[j]) swap(t[i],t[j]); int opt1=t[0]+t[1]+t[0]+t[3]+t[0]+t[2]; int opt2=t[0]+t[3]+t[0]+t[2]+t[0]+t[1]; int opt3=t[1]+t[1]+t[0]+t[3]+t[1]+t[1]; return min({t[0]+t[1]+t[0]+t[3]+t[2], t[1]+t[0]+t[3]+t[1]+t[2], t[0]+t[3]+t[0]+t[2]+t[1]}); }
int main() { cout<<bridgeCrossing(1,2,5,10); return 0; }`,explanation:{approach:"Use fastest as shuttle or pair slowest.",analogy:"Balance between fast returning and slow pairing.",steps:["Option 1: fastest shuttles everyone","Option 2: pair slowest"],complexity:"Time: O(1), Space: O(1)"}},{id:"logic9",title:"Weighing Balls",description:"Min weighings for fake ball.",difficulty:"EASY",category:"Logic",starterCode:`#include <iostream>
using namespace std;
int minWeighings(int n) { return 0; }
int main() { cout<<minWeighings(9); return 0; }`,expectedOutput:"2",solution:`#include <iostream>
using namespace std;
int minWeighings(int n) { int w=0; while(n>1) { n=(n+2)/3; w++; } return w; }
int main() { cout<<minWeighings(9); return 0; }`,explanation:{approach:"Divide into 3 groups, one weighing eliminates 2/3.",analogy:"Like ternary search.",steps:["Each weighing divides by 3","log(n) weighings needed"],complexity:"Time: O(log n), Space: O(1)"}},{id:"logic10",title:"Chessboard Rice",description:"Grains on chessboard.",difficulty:"EASY",category:"Logic",starterCode:`#include <iostream>
using namespace std;
long long totalRice(int n) { return 0; }
int main() { cout<<totalRice(8); return 0; }`,expectedOutput:"255",solution:`#include <iostream>
using namespace std;
long long totalRice(int n) { return (1LL<<n)-1; }
int main() { cout<<totalRice(8); return 0; }`,explanation:{approach:"Sum of 2^0 + 2^1 + ... + 2^(n-1) = 2^n - 1.",analogy:"Geometric series with ratio 2.",steps:["Each square doubles previous","Total = 2^n - 1"],complexity:"Time: O(1), Space: O(1)"}}],p5=JSON.parse(`[{"id":"arr11","title":"Kadane's Algorithm","description":"Max subarray sum.","difficulty":"MEDIUM","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nint maxSubArray(int a[], int n) { return 0; }\\nint main() { int a[]={-2,1,-3,4,-1,2,1,-5,4}; cout<<maxSubArray(a,9); return 0; }","expectedOutput":"6","solution":"#include <iostream>\\nusing namespace std;\\nint maxSubArray(int a[], int n) { int mx=a[0],cur=a[0]; for(int i=1;i<n;i++) { cur=max(a[i],cur+a[i]); mx=max(mx,cur); } return mx; }\\nint main() { int a[]={-2,1,-3,4,-1,2,1,-5,4}; cout<<maxSubArray(a,9); return 0; }","explanation":{"approach":"Track current and max sum.","analogy":"Extend or restart at each position.","steps":["cur = max(a[i], cur + a[i])","mx = max(mx, cur)"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"arr12","title":"Merge Sorted Arrays","description":"Merge two sorted into one.","difficulty":"EASY","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid merge(int a[], int m, int b[], int n, int c[]) {}\\nint main() { int a[]={1,3,5}, b[]={2,4,6}, c[6]; merge(a,3,b,3,c); for(int i=0;i<6;i++) cout<<c[i]<<\\" \\"; return 0; }","expectedOutput":"1 2 3 4 5 6","solution":"#include <iostream>\\nusing namespace std;\\nvoid merge(int a[], int m, int b[], int n, int c[]) { int i=0,j=0,k=0; while(i<m && j<n) c[k++]=a[i]<b[j]?a[i++]:b[j++]; while(i<m) c[k++]=a[i++]; while(j<n) c[k++]=b[j++]; }\\nint main() { int a[]={1,3,5}, b[]={2,4,6}, c[6]; merge(a,3,b,3,c); for(int i=0;i<6;i++) cout<<c[i]<<\\" \\"; return 0; }","explanation":{"approach":"Two pointer merge.","analogy":"Pick smaller from each array.","steps":["Compare elements from both arrays","Pick smaller, advance that pointer"],"complexity":"Time: O(m+n), Space: O(m+n)"}},{"id":"arr13","title":"Intersection of Two Arrays","description":"Common elements.","difficulty":"EASY","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid intersection(int a[], int m, int b[], int n) {}\\nint main() { int a[]={1,2,2,1}, b[]={2,2}; intersection(a,4,b,2); return 0; }","expectedOutput":"2","solution":"#include <iostream>\\nusing namespace std;\\nvoid intersection(int a[], int m, int b[], int n) { bool seen[1001]={}; for(int i=0;i<m;i++) seen[a[i]]=true; bool printed[1001]={}; for(int i=0;i<n;i++) if(seen[b[i]] && !printed[b[i]]) { cout<<b[i]<<\\" \\"; printed[b[i]]=true; } }\\nint main() { int a[]={1,2,2,1}, b[]={2,2}; intersection(a,4,b,2); return 0; }","explanation":{"approach":"Hash set for first array.","analogy":"Mark present in first, find in second.","steps":["Mark all elements of a","Print elements of b that exist in a"],"complexity":"Time: O(m+n), Space: O(m)"}},{"id":"arr14","title":"Union of Two Arrays","description":"All unique elements.","difficulty":"EASY","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid unionArr(int a[], int m, int b[], int n) {}\\nint main() { int a[]={1,2,3}, b[]={2,3,4,5}; unionArr(a,3,b,4); return 0; }","expectedOutput":"1 2 3 4 5","solution":"#include <iostream>\\nusing namespace std;\\nvoid unionArr(int a[], int m, int b[], int n) { bool seen[1001]={}; for(int i=0;i<m;i++) if(!seen[a[i]]) { cout<<a[i]<<\\" \\"; seen[a[i]]=true; } for(int i=0;i<n;i++) if(!seen[b[i]]) { cout<<b[i]<<\\" \\"; seen[b[i]]=true; } }\\nint main() { int a[]={1,2,3}, b[]={2,3,4,5}; unionArr(a,3,b,4); return 0; }","explanation":{"approach":"Track all seen elements.","analogy":"Combine and deduplicate.","steps":["Print unseen from a","Print unseen from b"],"complexity":"Time: O(m+n), Space: O(m+n)"}},{"id":"arr15","title":"Leaders in Array","description":"Elements greater than all to right.","difficulty":"EASY","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid leaders(int a[], int n) {}\\nint main() { int a[]={16,17,4,3,5,2}; leaders(a,6); return 0; }","expectedOutput":"17 5 2","solution":"#include <iostream>\\nusing namespace std;\\nvoid leaders(int a[], int n) { int mx=a[n-1]; int res[n], k=0; res[k++]=mx; for(int i=n-2;i>=0;i--) if(a[i]>mx) { mx=a[i]; res[k++]=mx; } for(int i=k-1;i>=0;i--) cout<<res[i]<<\\" \\"; }\\nint main() { int a[]={16,17,4,3,5,2}; leaders(a,6); return 0; }","explanation":{"approach":"Scan from right tracking max.","analogy":"Leader = greater than all to right.","steps":["Track max from right","If current > max, it's a leader"],"complexity":"Time: O(n), Space: O(n)"}},{"id":"arr16","title":"Next Greater Element","description":"Next larger for each element.","difficulty":"MEDIUM","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid nextGreater(int a[], int n) {}\\nint main() { int a[]={4,5,2,25}; nextGreater(a,4); return 0; }","expectedOutput":"5 25 25 -1","solution":"#include <iostream>\\nusing namespace std;\\nvoid nextGreater(int a[], int n) { int stk[n],top=-1,res[n]; for(int i=n-1;i>=0;i--) { while(top>=0 && stk[top]<=a[i]) top--; res[i]=top<0?-1:stk[top]; stk[++top]=a[i]; } for(int i=0;i<n;i++) cout<<res[i]<<\\" \\"; }\\nint main() { int a[]={4,5,2,25}; nextGreater(a,4); return 0; }","explanation":{"approach":"Monotonic stack.","analogy":"Stack keeps larger elements.","steps":["Pop while stack top <= current","Top is next greater"],"complexity":"Time: O(n), Space: O(n)"}},{"id":"arr17","title":"Rotate Array by K","description":"Rotate array k positions.","difficulty":"MEDIUM","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid rotate(int a[], int n, int k) {}\\nint main() { int a[]={1,2,3,4,5,6,7}; rotate(a,7,3); for(int i=0;i<7;i++) cout<<a[i]<<\\" \\"; return 0; }","expectedOutput":"5 6 7 1 2 3 4","solution":"#include <iostream>\\nusing namespace std;\\nvoid rev(int a[], int l, int r) { while(l<r) swap(a[l++],a[r--]); }\\nvoid rotate(int a[], int n, int k) { k%=n; rev(a,0,n-1); rev(a,0,k-1); rev(a,k,n-1); }\\nint main() { int a[]={1,2,3,4,5,6,7}; rotate(a,7,3); for(int i=0;i<7;i++) cout<<a[i]<<\\" \\"; return 0; }","explanation":{"approach":"Three reversals.","analogy":"Reverse all, then parts.","steps":["Reverse entire array","Reverse first k","Reverse rest"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"arr18","title":"Move Zeros to End","description":"Move zeros to end, maintain order.","difficulty":"EASY","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid moveZeros(int a[], int n) {}\\nint main() { int a[]={0,1,0,3,12}; moveZeros(a,5); for(int i=0;i<5;i++) cout<<a[i]<<\\" \\"; return 0; }","expectedOutput":"1 3 12 0 0","solution":"#include <iostream>\\nusing namespace std;\\nvoid moveZeros(int a[], int n) { int j=0; for(int i=0;i<n;i++) if(a[i]!=0) swap(a[i],a[j++]); }\\nint main() { int a[]={0,1,0,3,12}; moveZeros(a,5); for(int i=0;i<5;i++) cout<<a[i]<<\\" \\"; return 0; }","explanation":{"approach":"Swap non-zeros to front.","analogy":"Partition with zero as pivot.","steps":["Move non-zeros to front","Zeros naturally end up at end"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"arr19","title":"Subarray with Given Sum","description":"Find subarray summing to target.","difficulty":"MEDIUM","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid subarraySum(int a[], int n, int target) {}\\nint main() { int a[]={1,4,20,3,10,5}; subarraySum(a,6,33); return 0; }","expectedOutput":"2 4","solution":"#include <iostream>\\nusing namespace std;\\nvoid subarraySum(int a[], int n, int target) { int s=0,start=0; for(int i=0;i<n;i++) { s+=a[i]; while(s>target && start<i) s-=a[start++]; if(s==target) { cout<<start<<\\" \\"<<i; return; } } }\\nint main() { int a[]={1,4,20,3,10,5}; subarraySum(a,6,33); return 0; }","explanation":{"approach":"Sliding window.","analogy":"Expand right, shrink left.","steps":["Add right element","Shrink left while too big"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"arr20","title":"Trapping Rain Water","description":"Water trapped between bars.","difficulty":"HARD","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nint trap(int h[], int n) { return 0; }\\nint main() { int h[]={0,1,0,2,1,0,1,3,2,1,2,1}; cout<<trap(h,12); return 0; }","expectedOutput":"6","solution":"#include <iostream>\\nusing namespace std;\\nint trap(int h[], int n) { int l=0,r=n-1,lm=0,rm=0,w=0; while(l<r) { if(h[l]<h[r]) { if(h[l]>=lm) lm=h[l]; else w+=lm-h[l]; l++; } else { if(h[r]>=rm) rm=h[r]; else w+=rm-h[r]; r--; } } return w; }\\nint main() { int h[]={0,1,0,2,1,0,1,3,2,1,2,1}; cout<<trap(h,12); return 0; }","explanation":{"approach":"Two pointers with max tracking.","analogy":"Water = min(leftMax, rightMax) - height.","steps":["Track left and right max","Move smaller side"],"complexity":"Time: O(n), Space: O(1)"}}]`),m5=JSON.parse(`[{"id":"str11","title":"Longest Substring Without Repeat","description":"Longest unique char substring.","difficulty":"MEDIUM","category":"Strings","starterCode":"#include <iostream>\\nusing namespace std;\\nint lengthOfLongestSubstring(char s[]) { return 0; }\\nint main() { cout<<lengthOfLongestSubstring(\\"abcabcbb\\"); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nint lengthOfLongestSubstring(char s[]) { int seen[256]={}; int mx=0,l=0; for(int r=0;s[r];r++) { while(seen[(int)s[r]]) { seen[(int)s[l]]=0; l++; } seen[(int)s[r]]=1; mx=max(mx,r-l+1); } return mx; }\\nint main() { cout<<lengthOfLongestSubstring(\\"abcabcbb\\"); return 0; }","explanation":{"approach":"Sliding window with char set.","analogy":"Shrink when duplicate found.","steps":["Expand right","Shrink left on duplicate"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"str12","title":"Valid Palindrome","description":"Check if palindrome ignoring non-alnum.","difficulty":"EASY","category":"Strings","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isPalindrome(char s[]) { return false; }\\nint main() { cout<<isPalindrome(\\"A man a plan a canal Panama\\"); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isAlnum(char c) { return (c>='a'&&c<='z')||(c>='A'&&c<='Z')||(c>='0'&&c<='9'); }\\nchar lower(char c) { return c>='A'&&c<='Z'?c+32:c; }\\nbool isPalindrome(char s[]) { int n=0; while(s[n]) n++; int l=0,r=n-1; while(l<r) { while(l<r && !isAlnum(s[l])) l++; while(l<r && !isAlnum(s[r])) r--; if(lower(s[l])!=lower(s[r])) return false; l++; r--; } return true; }\\nint main() { cout<<isPalindrome(\\"A man a plan a canal Panama\\"); return 0; }","explanation":{"approach":"Two pointers, skip non-alphanumeric.","analogy":"Compare letters only.","steps":["Skip non-alnum characters","Compare lowercase"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"str13","title":"String Compression","description":"Compress consecutive chars.","difficulty":"MEDIUM","category":"Strings","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid compress(char s[]) {}\\nint main() { char s[]=\\"aabcccccaaa\\"; compress(s); return 0; }","expectedOutput":"a2b1c5a3","solution":"#include <iostream>\\nusing namespace std;\\nvoid compress(char s[]) { int n=0; while(s[n]) n++; int i=0; while(i<n) { char c=s[i]; int cnt=0; while(i<n && s[i]==c) { cnt++; i++; } cout<<c<<cnt; } }\\nint main() { char s[]=\\"aabcccccaaa\\"; compress(s); return 0; }","explanation":{"approach":"Count consecutive characters.","analogy":"Run-length encoding.","steps":["Count same character runs","Print char and count"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"str14","title":"Multiply Strings","description":"Multiply two number strings.","difficulty":"MEDIUM","category":"Strings","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid multiply(char n1[], char n2[]) {}\\nint main() { multiply(\\"123\\",\\"456\\"); return 0; }","expectedOutput":"56088","solution":"#include <iostream>\\nusing namespace std;\\nvoid multiply(char n1[], char n2[]) { int l1=0,l2=0; while(n1[l1]) l1++; while(n2[l2]) l2++; int res[l1+l2]={}; for(int i=l1-1;i>=0;i--) for(int j=l2-1;j>=0;j--) { int mul=(n1[i]-'0')*(n2[j]-'0'); int p1=i+j,p2=i+j+1; int sum=mul+res[p2]; res[p2]=sum%10; res[p1]+=sum/10; } int i=0; while(i<l1+l2 && res[i]==0) i++; if(i==l1+l2) { cout<<0; return; } while(i<l1+l2) cout<<res[i++]; }\\nint main() { multiply(\\"123\\",\\"456\\"); return 0; }","explanation":{"approach":"Digit by digit multiplication.","analogy":"Grade school multiplication.","steps":["Multiply each pair of digits","Position result correctly","Handle carries"],"complexity":"Time: O(mn), Space: O(m+n)"}},{"id":"str15","title":"Add Binary","description":"Add two binary strings.","difficulty":"EASY","category":"Strings","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid addBinary(char a[], char b[]) {}\\nint main() { addBinary(\\"11\\",\\"1\\"); return 0; }","expectedOutput":"100","solution":"#include <iostream>\\nusing namespace std;\\nvoid addBinary(char a[], char b[]) { int la=0,lb=0; while(a[la]) la++; while(b[lb]) lb++; char res[la+lb+2]; int k=0,c=0; int i=la-1,j=lb-1; while(i>=0 || j>=0 || c) { int sum=c; if(i>=0) sum+=a[i--]-'0'; if(j>=0) sum+=b[j--]-'0'; res[k++]='0'+sum%2; c=sum/2; } for(int t=k-1;t>=0;t--) cout<<res[t]; }\\nint main() { addBinary(\\"11\\",\\"1\\"); return 0; }","explanation":{"approach":"Add with carry from right.","analogy":"Binary addition.","steps":["Add bits and carry","Store result in reverse"],"complexity":"Time: O(max(m,n)), Space: O(max(m,n))"}},{"id":"str16","title":"ZigZag Conversion","description":"Rearrange in zigzag pattern.","difficulty":"MEDIUM","category":"Strings","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid convert(char s[], int numRows) {}\\nint main() { convert(\\"PAYPALISHIRING\\",3); return 0; }","expectedOutput":"PAHNAPLSIIGYIR","solution":"#include <iostream>\\nusing namespace std;\\nvoid convert(char s[], int numRows) { if(numRows==1) { cout<<s; return; } char rows[numRows][100]; int len[numRows]={}; int row=0,dir=1; for(int i=0;s[i];i++) { rows[row][len[row]++]=s[i]; if(row==0) dir=1; else if(row==numRows-1) dir=-1; row+=dir; } for(int i=0;i<numRows;i++) for(int j=0;j<len[i];j++) cout<<rows[i][j]; }\\nint main() { convert(\\"PAYPALISHIRING\\",3); return 0; }","explanation":{"approach":"Simulate zigzag placement.","analogy":"Move down then up cyclically.","steps":["Place chars in rows","Change direction at boundaries"],"complexity":"Time: O(n), Space: O(n)"}},{"id":"str17","title":"Longest Common Prefix","description":"Find common prefix.","difficulty":"EASY","category":"Strings","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid longestCommonPrefix(char strs[][20], int n) {}\\nint main() { char strs[][20]={\\"flower\\",\\"flow\\",\\"flight\\"}; longestCommonPrefix(strs,3); return 0; }","expectedOutput":"fl","solution":"#include <iostream>\\nusing namespace std;\\nvoid longestCommonPrefix(char strs[][20], int n) { if(n==0) return; for(int i=0;strs[0][i];i++) { for(int j=1;j<n;j++) if(strs[j][i]!=strs[0][i]) { strs[0][i]=0; cout<<strs[0]; return; } } cout<<strs[0]; }\\nint main() { char strs[][20]={\\"flower\\",\\"flow\\",\\"flight\\"}; longestCommonPrefix(strs,3); return 0; }","explanation":{"approach":"Compare char by char.","analogy":"Stop at first mismatch.","steps":["For each position","Check if all strings match"],"complexity":"Time: O(S), Space: O(1)"}},{"id":"str18","title":"Find and Replace Pattern","description":"Words matching pattern.","difficulty":"MEDIUM","category":"Strings","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid findAndReplacePattern(char words[][10], int n, char pattern[]) {}\\nint main() { char words[][10]={\\"abc\\",\\"deq\\",\\"mee\\",\\"aqq\\",\\"dkd\\",\\"ccc\\"}; findAndReplacePattern(words,6,\\"abb\\"); return 0; }","expectedOutput":"mee aqq","solution":"#include <iostream>\\nusing namespace std;\\nbool match(char w[], char p[]) { int w2p[26]={},p2w[26]={}; for(int i=0;i<26;i++) { w2p[i]=-1; p2w[i]=-1; } for(int i=0;w[i];i++) { int wc=w[i]-'a',pc=p[i]-'a'; if(w2p[wc]==-1) w2p[wc]=pc; if(p2w[pc]==-1) p2w[pc]=wc; if(w2p[wc]!=pc || p2w[pc]!=wc) return false; } return true; }\\nvoid findAndReplacePattern(char words[][10], int n, char pattern[]) { for(int i=0;i<n;i++) if(match(words[i],pattern)) cout<<words[i]<<\\" \\"; }\\nint main() { char words[][10]={\\"abc\\",\\"deq\\",\\"mee\\",\\"aqq\\",\\"dkd\\",\\"ccc\\"}; findAndReplacePattern(words,6,\\"abb\\"); return 0; }","explanation":{"approach":"Bijection mapping check.","analogy":"One-to-one correspondence.","steps":["Map word chars to pattern chars","Check consistency both ways"],"complexity":"Time: O(nm), Space: O(26)"}},{"id":"str19","title":"Integer to Roman","description":"Convert int to roman numeral.","difficulty":"MEDIUM","category":"Strings","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid intToRoman(int num) {}\\nint main() { intToRoman(1994); return 0; }","expectedOutput":"MCMXCIV","solution":"#include <iostream>\\nusing namespace std;\\nvoid intToRoman(int num) { int vals[]={1000,900,500,400,100,90,50,40,10,9,5,4,1}; char* syms[]={\\"M\\",\\"CM\\",\\"D\\",\\"CD\\",\\"C\\",\\"XC\\",\\"L\\",\\"XL\\",\\"X\\",\\"IX\\",\\"V\\",\\"IV\\",\\"I\\"}; for(int i=0;i<13;i++) while(num>=vals[i]) { cout<<syms[i]; num-=vals[i]; } }\\nint main() { intToRoman(1994); return 0; }","explanation":{"approach":"Greedy from largest value.","analogy":"Subtract largest possible each time.","steps":["Match largest value","Append symbol, subtract"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"str20","title":"Roman to Integer","description":"Convert roman to int.","difficulty":"EASY","category":"Strings","starterCode":"#include <iostream>\\nusing namespace std;\\nint romanToInt(char s[]) { return 0; }\\nint main() { cout<<romanToInt(\\"MCMXCIV\\"); return 0; }","expectedOutput":"1994","solution":"#include <iostream>\\nusing namespace std;\\nint val(char c) { if(c=='M') return 1000; if(c=='D') return 500; if(c=='C') return 100; if(c=='L') return 50; if(c=='X') return 10; if(c=='V') return 5; if(c=='I') return 1; return 0; }\\nint romanToInt(char s[]) { int res=0; for(int i=0;s[i];i++) { if(s[i+1] && val(s[i])<val(s[i+1])) res-=val(s[i]); else res+=val(s[i]); } return res; }\\nint main() { cout<<romanToInt(\\"MCMXCIV\\"); return 0; }","explanation":{"approach":"Subtract if smaller before larger.","analogy":"IV = 5 - 1 = 4.","steps":["If current < next, subtract","Else add"],"complexity":"Time: O(n), Space: O(1)"}}]`),f5=JSON.parse('[{"id":"dp11","title":"Rod Cutting","description":"Max profit from rod pieces.","difficulty":"MEDIUM","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint cutRod(int prices[], int n) { return 0; }\\nint main() { int prices[]={1,5,8,9,10,17,17,20}; cout<<cutRod(prices,8); return 0; }","expectedOutput":"22","solution":"#include <iostream>\\nusing namespace std;\\nint cutRod(int prices[], int n) { int dp[n+1]={}; for(int i=1;i<=n;i++) for(int j=1;j<=i;j++) dp[i]=max(dp[i],prices[j-1]+dp[i-j]); return dp[n]; }\\nint main() { int prices[]={1,5,8,9,10,17,17,20}; cout<<cutRod(prices,8); return 0; }","explanation":{"approach":"DP - max value for each length.","analogy":"Try all first cut positions.","steps":["dp[i] = max profit for length i","Try cutting at each position"],"complexity":"Time: O(n), Space: O(n)"}},{"id":"dp12","title":"Matrix Chain Multiplication","description":"Min operations to multiply matrices.","difficulty":"HARD","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint matrixChain(int dims[], int n) { return 0; }\\nint main() { int dims[]={10,30,5,60}; cout<<matrixChain(dims,4); return 0; }","expectedOutput":"4500","solution":"#include <iostream>\\nusing namespace std;\\nint matrixChain(int dims[], int n) { int m=n-1; int dp[m][m]; for(int i=0;i<m;i++) dp[i][i]=0; for(int len=2;len<=m;len++) for(int i=0;i<=m-len;i++) { int j=i+len-1; dp[i][j]=1e9; for(int k=i;k<j;k++) dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+1][j]+dims[i]*dims[k+1]*dims[j+1]); } return dp[0][m-1]; }\\nint main() { int dims[]={10,30,5,60}; cout<<matrixChain(dims,4); return 0; }","explanation":{"approach":"DP on ranges.","analogy":"Find optimal split point.","steps":["dp[i][j] = min ops for i to j","Try all split points k"],"complexity":"Time: O(n), Space: O(n)"}},{"id":"dp13","title":"Egg Drop","description":"Min trials for k eggs, n floors.","difficulty":"HARD","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint eggDrop(int k, int n) { return 0; }\\nint main() { cout<<eggDrop(2,10); return 0; }","expectedOutput":"4","solution":"#include <iostream>\\nusing namespace std;\\nint eggDrop(int k, int n) { int dp[k+1][n+1]; for(int i=0;i<=k;i++) { dp[i][0]=0; dp[i][1]=1; } for(int j=0;j<=n;j++) dp[1][j]=j; for(int i=2;i<=k;i++) for(int j=2;j<=n;j++) { dp[i][j]=j; for(int x=1;x<=j;x++) dp[i][j]=min(dp[i][j],1+max(dp[i-1][x-1],dp[i][j-x])); } return dp[k][n]; }\\nint main() { cout<<eggDrop(2,10); return 0; }","explanation":{"approach":"DP - min trials for eggs and floors.","analogy":"Try dropping from each floor.","steps":["dp[k][n] = min trials for k eggs, n floors","Try dropping from each floor x"],"complexity":"Time: O(k  n), Space: O(kn)"}},{"id":"dp14","title":"Longest Bitonic Subseq","description":"Longest increasing then decreasing.","difficulty":"MEDIUM","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint longestBitonic(int a[], int n) { return 0; }\\nint main() { int a[]={1,11,2,10,4,5,2,1}; cout<<longestBitonic(a,8); return 0; }","expectedOutput":"6","solution":"#include <iostream>\\nusing namespace std;\\nint longestBitonic(int a[], int n) { int lis[n],lds[n]; for(int i=0;i<n;i++) { lis[i]=1; for(int j=0;j<i;j++) if(a[j]<a[i]) lis[i]=max(lis[i],lis[j]+1); } for(int i=n-1;i>=0;i--) { lds[i]=1; for(int j=n-1;j>i;j--) if(a[j]<a[i]) lds[i]=max(lds[i],lds[j]+1); } int mx=0; for(int i=0;i<n;i++) mx=max(mx,lis[i]+lds[i]-1); return mx; }\\nint main() { int a[]={1,11,2,10,4,5,2,1}; cout<<longestBitonic(a,8); return 0; }","explanation":{"approach":"LIS from left + LDS from right.","analogy":"Peak at each position.","steps":["Compute LIS ending at each i","Compute LDS starting at each i","Max of lis[i] + lds[i] - 1"],"complexity":"Time: O(n), Space: O(n)"}},{"id":"dp15","title":"Palindrome Partitioning","description":"Min cuts for palindrome partition.","difficulty":"HARD","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint minCut(char s[]) { return 0; }\\nint main() { cout<<minCut(\\"aab\\"); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nint minCut(char s[]) { int n=0; while(s[n]) n++; bool isPalin[n][n]={}; for(int i=0;i<n;i++) isPalin[i][i]=true; for(int len=2;len<=n;len++) for(int i=0;i<=n-len;i++) { int j=i+len-1; if(s[i]==s[j]) isPalin[i][j]=(len==2)|isPalin[i+1][j-1]; } int dp[n]; for(int i=0;i<n;i++) { if(isPalin[0][i]) dp[i]=0; else { dp[i]=i; for(int j=1;j<=i;j++) if(isPalin[j][i]) dp[i]=min(dp[i],dp[j-1]+1); } } return dp[n-1]; }\\nint main() { cout<<minCut(\\"aab\\"); return 0; }","explanation":{"approach":"DP with palindrome precomputation.","analogy":"Min cuts to make all parts palindromes.","steps":["Precompute all palindrome substrings","dp[i] = min cuts for s[0..i]"],"complexity":"Time: O(n), Space: O(n)"}},{"id":"dp16","title":"Longest Zigzag","description":"Longest alternating subsequence.","difficulty":"MEDIUM","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint longestZigzag(int a[], int n) { return 0; }\\nint main() { int a[]={1,7,4,9,2,5}; cout<<longestZigzag(a,6); return 0; }","expectedOutput":"6","solution":"#include <iostream>\\nusing namespace std;\\nint longestZigzag(int a[], int n) { int up[n],down[n]; up[0]=down[0]=1; for(int i=1;i<n;i++) { up[i]=down[i]=1; for(int j=0;j<i;j++) { if(a[i]>a[j]) up[i]=max(up[i],down[j]+1); if(a[i]<a[j]) down[i]=max(down[i],up[j]+1); } } int mx=1; for(int i=0;i<n;i++) mx=max(mx,max(up[i],down[i])); return mx; }\\nint main() { int a[]={1,7,4,9,2,5}; cout<<longestZigzag(a,6); return 0; }","explanation":{"approach":"Track up and down endings.","analogy":"Alternate up then down.","steps":["up[i] = zigzag ending up at i","down[i] = zigzag ending down at i"],"complexity":"Time: O(n), Space: O(n)"}},{"id":"dp17","title":"Count Palindromic Substrings","description":"Count all palindromic substrings.","difficulty":"MEDIUM","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint countSubstrings(char s[]) { return 0; }\\nint main() { cout<<countSubstrings(\\"aaa\\"); return 0; }","expectedOutput":"6","solution":"#include <iostream>\\nusing namespace std;\\nint countSubstrings(char s[]) { int n=0; while(s[n]) n++; int cnt=0; for(int i=0;i<n;i++) { int l=i,r=i; while(l>=0 && r<n && s[l]==s[r]) { cnt++; l--; r++; } l=i; r=i+1; while(l>=0 && r<n && s[l]==s[r]) { cnt++; l--; r++; } } return cnt; }\\nint main() { cout<<countSubstrings(\\"aaa\\"); return 0; }","explanation":{"approach":"Expand around each center.","analogy":"Try odd and even length palindromes.","steps":["For each center, expand","Count all palindromes found"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"dp18","title":"Optimal BST","description":"Min search cost BST.","difficulty":"HARD","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint optimalBST(int keys[], int freq[], int n) { return 0; }\\nint main() { int keys[]={10,12,20}; int freq[]={34,8,50}; cout<<optimalBST(keys,freq,3); return 0; }","expectedOutput":"142","solution":"#include <iostream>\\nusing namespace std;\\nint optimalBST(int keys[], int freq[], int n) { int dp[n][n], sum[n][n]; for(int i=0;i<n;i++) { dp[i][i]=freq[i]; sum[i][i]=freq[i]; } for(int len=2;len<=n;len++) for(int i=0;i<=n-len;i++) { int j=i+len-1; dp[i][j]=1e9; sum[i][j]=sum[i][j-1]+freq[j]; for(int r=i;r<=j;r++) { int c=sum[i][j]+(r>i?dp[i][r-1]:0)+(r<j?dp[r+1][j]:0); dp[i][j]=min(dp[i][j],c); } } return dp[0][n-1]; }\\nint main() { int keys[]={10,12,20}; int freq[]={34,8,50}; cout<<optimalBST(keys,freq,3); return 0; }","explanation":{"approach":"DP on ranges, try each as root.","analogy":"Min expected search cost.","steps":["dp[i][j] = min cost for keys i to j","Try each key as root"],"complexity":"Time: O(n), Space: O(n)"}},{"id":"dp19","title":"Maximum Product Subarray","description":"Max product contiguous.","difficulty":"MEDIUM","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint maxProduct(int a[], int n) { return 0; }\\nint main() { int a[]={2,3,-2,4}; cout<<maxProduct(a,4); return 0; }","expectedOutput":"6","solution":"#include <iostream>\\nusing namespace std;\\nint maxProduct(int a[], int n) { int mx=a[0],mn=a[0],res=a[0]; for(int i=1;i<n;i++) { if(a[i]<0) swap(mx,mn); mx=max(a[i],mx*a[i]); mn=min(a[i],mn*a[i]); res=max(res,mx); } return res; }\\nint main() { int a[]={2,3,-2,4}; cout<<maxProduct(a,4); return 0; }","explanation":{"approach":"Track max and min products.","analogy":"Negative  negative = positive.","steps":["Track both max and min at each position","Swap on negative"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"dp20","title":"Coin Change Count","description":"Number of ways to make amount.","difficulty":"MEDIUM","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint coinChangeWays(int coins[], int n, int amt) { return 0; }\\nint main() { int coins[]={1,2,5}; cout<<coinChangeWays(coins,3,5); return 0; }","expectedOutput":"4","solution":"#include <iostream>\\nusing namespace std;\\nint coinChangeWays(int coins[], int n, int amt) { int dp[amt+1]={}; dp[0]=1; for(int i=0;i<n;i++) for(int j=coins[i];j<=amt;j++) dp[j]+=dp[j-coins[i]]; return dp[amt]; }\\nint main() { int coins[]={1,2,5}; cout<<coinChangeWays(coins,3,5); return 0; }","explanation":{"approach":"DP - count ways for each amount.","analogy":"Unbounded knapsack variation.","steps":["Process each coin","Add ways using that coin"],"complexity":"Time: O(n  amt), Space: O(amt)"}}]'),h5=JSON.parse(`[{"id":"graph11","title":"Clone Graph","description":"Deep copy undirected graph.","difficulty":"MEDIUM","category":"Graph","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node* adj[10]; int sz; Node(int x):v(x),sz(0){} };\\nNode* cloneGraph(Node* n) { return nullptr; }\\nint main() { cout<<\\"Graph cloned\\"; return 0; }","expectedOutput":"Graph cloned","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node* adj[10]; int sz; Node(int x):v(x),sz(0){} };\\nNode* vis[101]={};\\nNode* cloneGraph(Node* n) { if(!n) return 0; if(vis[n->v]) return vis[n->v]; Node* c=new Node(n->v); vis[n->v]=c; for(int i=0;i<n->sz;i++) c->adj[c->sz++]=cloneGraph(n->adj[i]); return c; }\\nint main() { cout<<\\"Graph cloned\\"; return 0; }","explanation":{"approach":"DFS with visited map.","analogy":"Clone nodes, link cloned neighbors.","steps":["Clone node if not visited","Recurse on neighbors"],"complexity":"Time: O(V+E), Space: O(V)"}},{"id":"graph12","title":"Course Schedule II","description":"Return course order.","difficulty":"MEDIUM","category":"Graph","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid findOrder(int n, int pre[][2], int m) {}\\nint main() { int pre[][2]={{1,0},{2,0},{3,1},{3,2}}; findOrder(4,pre,4); return 0; }","expectedOutput":"0 1 2 3","solution":"#include <iostream>\\nusing namespace std;\\nint adj[100][100],deg[100],sz[100];\\nvoid findOrder(int n, int pre[][2], int m) { for(int i=0;i<n;i++) { sz[i]=0; deg[i]=0; } for(int i=0;i<m;i++) { adj[pre[i][1]][sz[pre[i][1]]++]=pre[i][0]; deg[pre[i][0]]++; } int q[100],f=0,r=0; for(int i=0;i<n;i++) if(deg[i]==0) q[r++]=i; while(f<r) { int u=q[f++]; cout<<u<<\\" \\"; for(int i=0;i<sz[u];i++) if(--deg[adj[u][i]]==0) q[r++]=adj[u][i]; } }\\nint main() { int pre[][2]={{1,0},{2,0},{3,1},{3,2}}; findOrder(4,pre,4); return 0; }","explanation":{"approach":"Topological sort.","analogy":"Process courses with satisfied prereqs.","steps":["Build graph and in-degrees","BFS from zero-degree nodes"],"complexity":"Time: O(V+E), Space: O(V+E)"}},{"id":"graph13","title":"Redundant Connection","description":"Remove edge to make tree.","difficulty":"MEDIUM","category":"Graph","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid findRedundant(int edges[][2], int n) {}\\nint main() { int edges[][2]={{1,2},{1,3},{2,3}}; findRedundant(edges,3); return 0; }","expectedOutput":"2 3","solution":"#include <iostream>\\nusing namespace std;\\nint parent[100];\\nint find(int x) { if(parent[x]!=x) parent[x]=find(parent[x]); return parent[x]; }\\nvoid findRedundant(int edges[][2], int n) { for(int i=0;i<=n;i++) parent[i]=i; for(int i=0;i<n;i++) { int u=edges[i][0],v=edges[i][1]; int pu=find(u),pv=find(v); if(pu==pv) { cout<<u<<\\" \\"<<v; return; } parent[pu]=pv; } }\\nint main() { int edges[][2]={{1,2},{1,3},{2,3}}; findRedundant(edges,3); return 0; }","explanation":{"approach":"Union-Find for cycle detection.","analogy":"Edge creating cycle is redundant.","steps":["Union edges","If same parent, cycle found"],"complexity":"Time: O(n (n)), Space: O(n)"}},{"id":"graph14","title":"Min Height Trees","description":"Find roots for min height.","difficulty":"MEDIUM","category":"Graph","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid findMinHeightTrees(int n, int edges[][2], int m) {}\\nint main() { int edges[][2]={{1,0},{1,2},{1,3}}; findMinHeightTrees(4,edges,3); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nvoid findMinHeightTrees(int n, int edges[][2], int m) { if(n==1) { cout<<0; return; } int adj[100][100],sz[100]={},deg[100]={}; for(int i=0;i<m;i++) { adj[edges[i][0]][sz[edges[i][0]]++]=edges[i][1]; adj[edges[i][1]][sz[edges[i][1]]++]=edges[i][0]; deg[edges[i][0]]++; deg[edges[i][1]]++; } int q[100],f=0,r=0; for(int i=0;i<n;i++) if(deg[i]==1) q[r++]=i; int rem=n; while(rem>2) { int size=r-f; rem-=size; for(int i=0;i<size;i++) { int u=q[f++]; for(int j=0;j<sz[u];j++) if(--deg[adj[u][j]]==1) q[r++]=adj[u][j]; } } while(f<r) cout<<q[f++]<<\\" \\"; }\\nint main() { int edges[][2]={{1,0},{1,2},{1,3}}; findMinHeightTrees(4,edges,3); return 0; }","explanation":{"approach":"Peel leaves layer by layer.","analogy":"Center nodes are min height roots.","steps":["Remove leaves iteratively","Remaining 1-2 nodes are roots"],"complexity":"Time: O(V+E), Space: O(V)"}},{"id":"graph15","title":"Graph Valid Tree","description":"Check if valid tree.","difficulty":"MEDIUM","category":"Graph","starterCode":"#include <iostream>\\nusing namespace std;\\nbool validTree(int n, int edges[][2], int m) { return false; }\\nint main() { int edges[][2]={{0,1},{0,2},{0,3},{1,4}}; cout<<validTree(5,edges,4); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nint parent[100];\\nint find(int x) { if(parent[x]!=x) parent[x]=find(parent[x]); return parent[x]; }\\nbool validTree(int n, int edges[][2], int m) { if(m!=n-1) return false; for(int i=0;i<n;i++) parent[i]=i; for(int i=0;i<m;i++) { int pu=find(edges[i][0]),pv=find(edges[i][1]); if(pu==pv) return false; parent[pu]=pv; } return true; }\\nint main() { int edges[][2]={{0,1},{0,2},{0,3},{1,4}}; cout<<validTree(5,edges,4); return 0; }","explanation":{"approach":"n-1 edges and no cycle.","analogy":"Tree = connected acyclic.","steps":["Must have n-1 edges","No cycle (Union-Find)"],"complexity":"Time: O(n (n)), Space: O(n)"}},{"id":"graph16","title":"Network Delay Time","description":"Time for all nodes to receive signal.","difficulty":"MEDIUM","category":"Graph","starterCode":"#include <iostream>\\nusing namespace std;\\nint networkDelay(int times[][3], int n, int m, int k) { return -1; }\\nint main() { int times[][3]={{2,1,1},{2,3,1},{3,4,1}}; cout<<networkDelay(times,4,3,2); return 0; }","expectedOutput":"2","solution":"#include <iostream>\\nusing namespace std;\\nint networkDelay(int times[][3], int n, int m, int k) { int dist[n+1]; for(int i=0;i<=n;i++) dist[i]=1e9; dist[k]=0; for(int i=0;i<n-1;i++) for(int j=0;j<m;j++) if(dist[times[j][0]]!=1e9) dist[times[j][1]]=min(dist[times[j][1]],dist[times[j][0]]+times[j][2]); int mx=0; for(int i=1;i<=n;i++) mx=max(mx,dist[i]); return mx>=1e9?-1:mx; }\\nint main() { int times[][3]={{2,1,1},{2,3,1},{3,4,1}}; cout<<networkDelay(times,4,3,2); return 0; }","explanation":{"approach":"Bellman-Ford shortest paths.","analogy":"Signal propagation time.","steps":["Relax all edges n-1 times","Return max distance"],"complexity":"Time: O(VE), Space: O(V)"}},{"id":"graph17","title":"Cheapest Flights K Stops","description":"Cheapest path with at most k stops.","difficulty":"MEDIUM","category":"Graph","starterCode":"#include <iostream>\\nusing namespace std;\\nint findCheapest(int n, int flights[][3], int m, int src, int dst, int k) { return -1; }\\nint main() { int flights[][3]={{0,1,100},{1,2,100},{0,2,500}}; cout<<findCheapest(3,flights,3,0,2,1); return 0; }","expectedOutput":"200","solution":"#include <iostream>\\nusing namespace std;\\nint findCheapest(int n, int flights[][3], int m, int src, int dst, int k) { int dist[n]; for(int i=0;i<n;i++) dist[i]=1e9; dist[src]=0; for(int i=0;i<=k;i++) { int temp[n]; for(int j=0;j<n;j++) temp[j]=dist[j]; for(int j=0;j<m;j++) if(dist[flights[j][0]]!=1e9) temp[flights[j][1]]=min(temp[flights[j][1]],dist[flights[j][0]]+flights[j][2]); for(int j=0;j<n;j++) dist[j]=temp[j]; } return dist[dst]>=1e9?-1:dist[dst]; }\\nint main() { int flights[][3]={{0,1,100},{1,2,100},{0,2,500}}; cout<<findCheapest(3,flights,3,0,2,1); return 0; }","explanation":{"approach":"Bellman-Ford with k+1 relaxations.","analogy":"At most k+1 edges allowed.","steps":["Relax k+1 times","Use temp array to avoid extra hops"],"complexity":"Time: O(kE), Space: O(V)"}},{"id":"graph18","title":"Reconstruct Itinerary","description":"Build itinerary from tickets.","difficulty":"HARD","category":"Graph","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid findItinerary(char tickets[][2][4], int n) {}\\nint main() { char tickets[][2][4]={{\\"MUC\\",\\"LHR\\"},{\\"JFK\\",\\"MUC\\"},{\\"SFO\\",\\"SJC\\"},{\\"LHR\\",\\"SFO\\"}}; findItinerary(tickets,4); return 0; }","expectedOutput":"JFK MUC LHR SFO SJC","solution":"#include <iostream>\\nusing namespace std;\\nchar result[10][4]; int ri=0;\\nvoid dfs(char cur[], char tickets[][2][4], bool used[], int n) { result[ri][0]=cur[0]; result[ri][1]=cur[1]; result[ri][2]=cur[2]; result[ri++][3]=0; for(int i=0;i<n;i++) if(!used[i] && tickets[i][0][0]==cur[0] && tickets[i][0][1]==cur[1] && tickets[i][0][2]==cur[2]) { used[i]=true; dfs(tickets[i][1],tickets,used,n); } }\\nvoid findItinerary(char tickets[][2][4], int n) { bool used[n]={}; ri=0; dfs(\\"JFK\\",tickets,used,n); for(int i=0;i<ri;i++) cout<<result[i]<<\\" \\"; }\\nint main() { char tickets[][2][4]={{\\"MUC\\",\\"LHR\\"},{\\"JFK\\",\\"MUC\\"},{\\"SFO\\",\\"SJC\\"},{\\"LHR\\",\\"SFO\\"}}; findItinerary(tickets,4); return 0; }","explanation":{"approach":"DFS from JFK.","analogy":"Use all tickets in order.","steps":["Start from JFK","DFS using each ticket once"],"complexity":"Time: O(E), Space: O(E)"}},{"id":"graph19","title":"Swim in Rising Water","description":"Min time to reach bottom-right.","difficulty":"HARD","category":"Graph","starterCode":"#include <iostream>\\nusing namespace std;\\nint swimInWater(int grid[][3], int n) { return 0; }\\nint main() { int grid[][3]={{0,2,1},{1,3,4},{2,5,0}}; cout<<swimInWater(grid,3); return 0; }","expectedOutput":"5","solution":"#include <iostream>\\nusing namespace std;\\nint swimInWater(int grid[][3], int n) { int dist[n][n]; bool vis[n][n]={}; for(int i=0;i<n;i++) for(int j=0;j<n;j++) dist[i][j]=1e9; dist[0][0]=grid[0][0]; int dx[]={1,-1,0,0},dy[]={0,0,1,-1}; while(!vis[n-1][n-1]) { int mi=-1,mj=-1,mn=1e9; for(int i=0;i<n;i++) for(int j=0;j<n;j++) if(!vis[i][j] && dist[i][j]<mn) { mn=dist[i][j]; mi=i; mj=j; } vis[mi][mj]=true; for(int d=0;d<4;d++) { int ni=mi+dx[d],nj=mj+dy[d]; if(ni>=0 && ni<n && nj>=0 && nj<n && !vis[ni][nj]) dist[ni][nj]=min(dist[ni][nj],max(dist[mi][mj],grid[ni][nj])); } } return dist[n-1][n-1]; }\\nint main() { int grid[][3]={{0,2,1},{1,3,4},{2,5,0}}; cout<<swimInWater(grid,3); return 0; }","explanation":{"approach":"Dijkstra with max along path.","analogy":"Wait for water to reach max cell.","steps":["Min of max heights on path","Dijkstra-like approach"],"complexity":"Time: O(n log n), Space: O(n)"}},{"id":"graph20","title":"Alien Dictionary","description":"Order of alien alphabet.","difficulty":"HARD","category":"Graph","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid alienOrder(char words[][10], int n) {}\\nint main() { char words[][10]={\\"wrt\\",\\"wrf\\",\\"er\\",\\"ett\\",\\"rftt\\"}; alienOrder(words,5); return 0; }","expectedOutput":"wertf","solution":"#include <iostream>\\nusing namespace std;\\nvoid alienOrder(char words[][10], int n) { int adj[26][26]={},deg[26]={},sz[26]={}; bool exists[26]={}; for(int i=0;i<n;i++) for(int j=0;words[i][j];j++) exists[words[i][j]-'a']=true; for(int i=0;i<n-1;i++) { int j=0; while(words[i][j] && words[i][j]==words[i+1][j]) j++; if(words[i][j] && words[i+1][j]) { int u=words[i][j]-'a',v=words[i+1][j]-'a'; adj[u][sz[u]++]=v; deg[v]++; } } int q[26],f=0,r=0; for(int i=0;i<26;i++) if(exists[i] && deg[i]==0) q[r++]=i; while(f<r) { int u=q[f++]; cout<<(char)('a'+u); for(int i=0;i<sz[u];i++) if(--deg[adj[u][i]]==0) q[r++]=adj[u][i]; } }\\nint main() { char words[][10]={\\"wrt\\",\\"wrf\\",\\"er\\",\\"ett\\",\\"rftt\\"}; alienOrder(words,5); return 0; }","explanation":{"approach":"Topological sort from comparisons.","analogy":"Letter order from word order.","steps":["Build graph from adjacent word differences","Topological sort"],"complexity":"Time: O(C), Space: O(1)"}}]`),g5=JSON.parse('[{"id":"tree11","title":"Same Tree","description":"Check if two trees are same.","difficulty":"EASY","category":"Trees","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nbool isSame(Node* p, Node* q) { return false; }\\nint main() { Node* p=new Node(1); p->l=new Node(2); p->r=new Node(3); Node* q=new Node(1); q->l=new Node(2); q->r=new Node(3); cout<<isSame(p,q); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nbool isSame(Node* p, Node* q) { if(!p && !q) return true; if(!p || !q) return false; return p->v==q->v && isSame(p->l,q->l) && isSame(p->r,q->r); }\\nint main() { Node* p=new Node(1); p->l=new Node(2); p->r=new Node(3); Node* q=new Node(1); q->l=new Node(2); q->r=new Node(3); cout<<isSame(p,q); return 0; }","explanation":{"approach":"Recursive comparison.","analogy":"Both null or both equal.","steps":["Base: both null = same","Check value and recurse on children"],"complexity":"Time: O(n), Space: O(h)"}},{"id":"tree12","title":"Subtree of Another","description":"Is t a subtree of s.","difficulty":"EASY","category":"Trees","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nbool isSubtree(Node* s, Node* t) { return false; }\\nint main() { Node* s=new Node(3); s->l=new Node(4); s->r=new Node(5); s->l->l=new Node(1); s->l->r=new Node(2); Node* t=new Node(4); t->l=new Node(1); t->r=new Node(2); cout<<isSubtree(s,t); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nbool same(Node* a, Node* b) { if(!a && !b) return true; if(!a || !b) return false; return a->v==b->v && same(a->l,b->l) && same(a->r,b->r); }\\nbool isSubtree(Node* s, Node* t) { if(!s) return false; if(same(s,t)) return true; return isSubtree(s->l,t) || isSubtree(s->r,t); }\\nint main() { Node* s=new Node(3); s->l=new Node(4); s->r=new Node(5); s->l->l=new Node(1); s->l->r=new Node(2); Node* t=new Node(4); t->l=new Node(1); t->r=new Node(2); cout<<isSubtree(s,t); return 0; }","explanation":{"approach":"Check each node as root.","analogy":"Find matching subtree.","steps":["If trees same, return true","Check left and right subtrees"],"complexity":"Time: O(mn), Space: O(h)"}},{"id":"tree13","title":"Invert Binary Tree","description":"Mirror the tree.","difficulty":"EASY","category":"Trees","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nNode* invertTree(Node* r) { return nullptr; }\\nvoid print(Node* r) { if(!r) return; cout<<r->v<<\\" \\"; print(r->l); print(r->r); }\\nint main() { Node* r=new Node(4); r->l=new Node(2); r->r=new Node(7); r->l->l=new Node(1); r->l->r=new Node(3); r=invertTree(r); print(r); return 0; }","expectedOutput":"4 7 2 3 1","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nNode* invertTree(Node* r) { if(!r) return 0; Node* t=r->l; r->l=invertTree(r->r); r->r=invertTree(t); return r; }\\nvoid print(Node* r) { if(!r) return; cout<<r->v<<\\" \\"; print(r->l); print(r->r); }\\nint main() { Node* r=new Node(4); r->l=new Node(2); r->r=new Node(7); r->l->l=new Node(1); r->l->r=new Node(3); r=invertTree(r); print(r); return 0; }","explanation":{"approach":"Swap children recursively.","analogy":"Mirror image.","steps":["Swap left and right","Recurse on children"],"complexity":"Time: O(n), Space: O(h)"}},{"id":"tree14","title":"Max Path Sum","description":"Maximum path sum in tree.","difficulty":"HARD","category":"Trees","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nint maxPathSum(Node* r) { return 0; }\\nint main() { Node* r=new Node(-10); r->l=new Node(9); r->r=new Node(20); r->r->l=new Node(15); r->r->r=new Node(7); cout<<maxPathSum(r); return 0; }","expectedOutput":"42","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nint maxSum;\\nint solve(Node* r) { if(!r) return 0; int l=max(0,solve(r->l)); int ri=max(0,solve(r->r)); maxSum=max(maxSum,l+ri+r->v); return r->v+max(l,ri); }\\nint maxPathSum(Node* r) { maxSum=-1e9; solve(r); return maxSum; }\\nint main() { Node* r=new Node(-10); r->l=new Node(9); r->r=new Node(20); r->r->l=new Node(15); r->r->r=new Node(7); cout<<maxPathSum(r); return 0; }","explanation":{"approach":"DFS returning max single path.","analogy":"Path through node as turning point.","steps":["Return max path going up","Update global with path through node"],"complexity":"Time: O(n), Space: O(h)"}},{"id":"tree15","title":"Build Tree from Preorder Inorder","description":"Construct tree from traversals.","difficulty":"MEDIUM","category":"Trees","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nNode* buildTree(int pre[], int in[], int n) { return nullptr; }\\nvoid post(Node* r) { if(!r) return; post(r->l); post(r->r); cout<<r->v<<\\" \\"; }\\nint main() { int pre[]={3,9,20,15,7}; int in[]={9,3,15,20,7}; Node* r=buildTree(pre,in,5); post(r); return 0; }","expectedOutput":"9 15 7 20 3","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nint idx=0;\\nNode* build(int pre[], int in[], int l, int r) { if(l>r) return 0; Node* root=new Node(pre[idx++]); int mid=l; while(in[mid]!=root->v) mid++; root->l=build(pre,in,l,mid-1); root->r=build(pre,in,mid+1,r); return root; }\\nNode* buildTree(int pre[], int in[], int n) { idx=0; return build(pre,in,0,n-1); }\\nvoid post(Node* r) { if(!r) return; post(r->l); post(r->r); cout<<r->v<<\\" \\"; }\\nint main() { int pre[]={3,9,20,15,7}; int in[]={9,3,15,20,7}; Node* r=buildTree(pre,in,5); post(r); return 0; }","explanation":{"approach":"Root from preorder, split inorder.","analogy":"Preorder gives root, inorder splits.","steps":["First preorder element is root","Find in inorder to get left and right subtrees"],"complexity":"Time: O(n), Space: O(n)"}},{"id":"tree16","title":"Populating Next Right","description":"Connect same level nodes.","difficulty":"MEDIUM","category":"Trees","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r,*next; Node(int x):v(x),l(0),r(0),next(0){} };\\nNode* connect(Node* root) { return nullptr; }\\nint main() { Node* r=new Node(1); r->l=new Node(2); r->r=new Node(3); r->l->l=new Node(4); r->l->r=new Node(5); r->r->r=new Node(7); connect(r); cout<<r->l->next->v<<\\" \\"<<r->l->r->next->v; return 0; }","expectedOutput":"3 7","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r,*next; Node(int x):v(x),l(0),r(0),next(0){} };\\nNode* connect(Node* root) { Node* cur=root; while(cur) { Node dummy(0), *tail=&dummy; while(cur) { if(cur->l) { tail->next=cur->l; tail=tail->next; } if(cur->r) { tail->next=cur->r; tail=tail->next; } cur=cur->next; } cur=dummy.next; } return root; }\\nint main() { Node* r=new Node(1); r->l=new Node(2); r->r=new Node(3); r->l->l=new Node(4); r->l->r=new Node(5); r->r->r=new Node(7); connect(r); cout<<r->l->next->v<<\\" \\"<<r->l->r->next->v; return 0; }","explanation":{"approach":"Level by level linking.","analogy":"Use next pointers for traversal.","steps":["Process each level using next","Link children as you go"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"tree17","title":"Count Good Nodes","description":"Nodes >= all ancestors.","difficulty":"MEDIUM","category":"Trees","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nint goodNodes(Node* r) { return 0; }\\nint main() { Node* r=new Node(3); r->l=new Node(1); r->r=new Node(4); r->l->l=new Node(3); r->r->l=new Node(1); r->r->r=new Node(5); cout<<goodNodes(r); return 0; }","expectedOutput":"4","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nint cnt=0;\\nvoid dfs(Node* r, int mx) { if(!r) return; if(r->v>=mx) cnt++; mx=max(mx,r->v); dfs(r->l,mx); dfs(r->r,mx); }\\nint goodNodes(Node* r) { cnt=0; dfs(r,-1e9); return cnt; }\\nint main() { Node* r=new Node(3); r->l=new Node(1); r->r=new Node(4); r->l->l=new Node(3); r->r->l=new Node(1); r->r->r=new Node(5); cout<<goodNodes(r); return 0; }","explanation":{"approach":"DFS tracking max ancestor.","analogy":"Good if >= all above.","steps":["Track max on path","Count if current >= max"],"complexity":"Time: O(n), Space: O(h)"}},{"id":"tree18","title":"Binary Tree Paths","description":"All root-to-leaf paths.","difficulty":"EASY","category":"Trees","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nvoid binaryTreePaths(Node* r) {}\\nint main() { Node* r=new Node(1); r->l=new Node(2); r->r=new Node(3); r->l->r=new Node(5); binaryTreePaths(r); return 0; }","expectedOutput":"1->2->5 1->3","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nvoid dfs(Node* r, int path[], int len) { if(!r) return; path[len++]=r->v; if(!r->l && !r->r) { for(int i=0;i<len;i++) cout<<(i?\\"->\\": \\"\\")<<path[i]; cout<<\\" \\"; } dfs(r->l,path,len); dfs(r->r,path,len); }\\nvoid binaryTreePaths(Node* r) { int path[100]; dfs(r,path,0); }\\nint main() { Node* r=new Node(1); r->l=new Node(2); r->r=new Node(3); r->l->r=new Node(5); binaryTreePaths(r); return 0; }","explanation":{"approach":"DFS building path.","analogy":"Collect nodes on path to leaf.","steps":["Add current to path","At leaf, print path","Recurse on children"],"complexity":"Time: O(n), Space: O(h)"}},{"id":"tree19","title":"Diameter of Binary Tree","description":"Longest path between nodes.","difficulty":"EASY","category":"Trees","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nint diameterOfBinaryTree(Node* r) { return 0; }\\nint main() { Node* r=new Node(1); r->l=new Node(2); r->r=new Node(3); r->l->l=new Node(4); r->l->r=new Node(5); cout<<diameterOfBinaryTree(r); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nint diam=0;\\nint height(Node* r) { if(!r) return 0; int l=height(r->l); int ri=height(r->r); diam=max(diam,l+ri); return 1+max(l,ri); }\\nint diameterOfBinaryTree(Node* r) { diam=0; height(r); return diam; }\\nint main() { Node* r=new Node(1); r->l=new Node(2); r->r=new Node(3); r->l->l=new Node(4); r->l->r=new Node(5); cout<<diameterOfBinaryTree(r); return 0; }","explanation":{"approach":"Diameter = left height + right height.","analogy":"Path through each node.","steps":["Compute height recursively","Track max left + right heights"],"complexity":"Time: O(n), Space: O(h)"}},{"id":"tree20","title":"Sum Root to Leaf","description":"Sum of all root-to-leaf numbers.","difficulty":"MEDIUM","category":"Trees","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nint sumNumbers(Node* r) { return 0; }\\nint main() { Node* r=new Node(1); r->l=new Node(2); r->r=new Node(3); cout<<sumNumbers(r); return 0; }","expectedOutput":"25","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nint dfs(Node* r, int num) { if(!r) return 0; num=num*10+r->v; if(!r->l && !r->r) return num; return dfs(r->l,num)+dfs(r->r,num); }\\nint sumNumbers(Node* r) { return dfs(r,0); }\\nint main() { Node* r=new Node(1); r->l=new Node(2); r->r=new Node(3); cout<<sumNumbers(r); return 0; }","explanation":{"approach":"Build number on path.","analogy":"Path 1->2 = number 12.","steps":["num = num  10 + node value","At leaf, return num","Sum all leaf numbers"],"complexity":"Time: O(n), Space: O(h)"}}]'),y5=JSON.parse(`[{"id":"fun1","title":"Two Sum","description":"Find indices summing to target.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid twoSum(int a[], int n, int t) {}\\nint main() { int a[]={2,7,11,15}; twoSum(a,4,9); return 0; }","expectedOutput":"0 1","solution":"#include <iostream>\\nusing namespace std;\\nvoid twoSum(int a[], int n, int t) {\\n    for(int i = 0; i < n; i++) {\\n        for(int j = i + 1; j < n; j++) {\\n            if(a[i] + a[j] == t) {\\n                cout << i << \\" \\" << j;\\n                return;\\n            }\\n        }\\n    }\\n}\\nint main() { int a[]={2,7,11,15}; twoSum(a,4,9); return 0; }","explanation":{"approach":"Check every pair of numbers. If two numbers add up to target, print their positions.","analogy":"Imagine you have coins and need to find two that add to exactly $1. You pick one coin, then check every other coin to see if they add up to $1.","steps":["Start with the first number","Compare it with every number after it","If they add to target, print both positions","If not found, try next starting number"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"fun2","title":"Reverse Array","description":"Reverse array in-place.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid reverse(int a[], int n) {}\\nint main() { int a[]={1,2,3,4,5}; reverse(a,5); for(int i=0;i<5;i++) cout<<a[i]<<\\" \\"; return 0; }","expectedOutput":"5 4 3 2 1","solution":"#include <iostream>\\nusing namespace std;\\nvoid reverse(int a[], int n) {\\n    int left = 0, right = n - 1;\\n    while(left < right) {\\n        int temp = a[left];\\n        a[left] = a[right];\\n        a[right] = temp;\\n        left++;\\n        right--;\\n    }\\n}\\nint main() { int a[]={1,2,3,4,5}; reverse(a,5); for(int i=0;i<5;i++) cout<<a[i]<<\\" \\"; return 0; }","explanation":{"approach":"Use two pointers - one at start, one at end. Swap them and move inward until they meet.","analogy":"Like reversing a line of people - person at front goes to back, person at back goes to front, then do the same for the next pair moving inward.","steps":["Put one pointer at start (left=0)","Put another at end (right=n-1)","Swap elements at both pointers","Move left forward, right backward","Repeat until they meet"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"fun3","title":"Find Maximum","description":"Find max element.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint findMax(int a[], int n) { return 0; }\\nint main() { int a[]={3,7,1,9,2}; cout<<findMax(a,5); return 0; }","expectedOutput":"9","solution":"#include <iostream>\\nusing namespace std;\\nint findMax(int a[], int n) {\\n    int maxVal = a[0];\\n    for(int i = 1; i < n; i++) {\\n        if(a[i] > maxVal) {\\n            maxVal = a[i];\\n        }\\n    }\\n    return maxVal;\\n}\\nint main() { int a[]={3,7,1,9,2}; cout<<findMax(a,5); return 0; }","explanation":{"approach":"Assume first element is maximum. Compare with each element - if we find bigger, update our maximum.","analogy":"Like finding the tallest person in a room. Assume first person is tallest, then walk around comparing heights.","steps":["Start assuming first element is max","Loop through remaining elements","If current element is bigger than max, update max","Return the maximum found"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"fun4","title":"Find Minimum","description":"Find min element.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint findMin(int a[], int n) { return 0; }\\nint main() { int a[]={3,7,1,9,2}; cout<<findMin(a,5); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nint findMin(int a[], int n) {\\n    int minVal = a[0];\\n    for(int i = 1; i < n; i++) {\\n        if(a[i] < minVal) {\\n            minVal = a[i];\\n        }\\n    }\\n    return minVal;\\n}\\nint main() { int a[]={3,7,1,9,2}; cout<<findMin(a,5); return 0; }","explanation":{"approach":"Same as finding max, but look for smaller values instead.","analogy":"Like finding the shortest person - assume first is shortest, then check everyone else.","steps":["Start assuming first element is min","Loop through remaining elements","If current element is smaller, update min","Return the minimum found"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"fun5","title":"Array Sum","description":"Sum all elements.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint sum(int a[], int n) { return 0; }\\nint main() { int a[]={1,2,3,4,5}; cout<<sum(a,5); return 0; }","expectedOutput":"15","solution":"#include <iostream>\\nusing namespace std;\\nint sum(int a[], int n) {\\n    int total = 0;\\n    for(int i = 0; i < n; i++) {\\n        total += a[i];\\n    }\\n    return total;\\n}\\nint main() { int a[]={1,2,3,4,5}; cout<<sum(a,5); return 0; }","explanation":{"approach":"Start with 0, add each element one by one.","analogy":"Like counting money - start with $0, add each bill you find to your total.","steps":["Initialize sum to 0","Loop through each element","Add each element to sum","Return total sum"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"fun6","title":"Array Average","description":"Calculate average.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\ndouble average(int a[], int n) { return 0; }\\nint main() { int a[]={10,20,30,40,50}; cout<<average(a,5); return 0; }","expectedOutput":"30","solution":"#include <iostream>\\nusing namespace std;\\ndouble average(int a[], int n) {\\n    int total = 0;\\n    for(int i = 0; i < n; i++) {\\n        total += a[i];\\n    }\\n    return (double)total / n;\\n}\\nint main() { int a[]={10,20,30,40,50}; cout<<average(a,5); return 0; }","explanation":{"approach":"First find sum, then divide by count of elements.","analogy":"Like finding average test score - add all scores, divide by number of students.","steps":["Calculate sum of all elements","Divide sum by number of elements","Return the result"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"fun7","title":"Count Even","description":"Count even numbers.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint countEven(int a[], int n) { return 0; }\\nint main() { int a[]={1,2,3,4,5,6}; cout<<countEven(a,6); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nint countEven(int a[], int n) {\\n    int count = 0;\\n    for(int i = 0; i < n; i++) {\\n        if(a[i] % 2 == 0) {\\n            count++;\\n        }\\n    }\\n    return count;\\n}\\nint main() { int a[]={1,2,3,4,5,6}; cout<<countEven(a,6); return 0; }","explanation":{"approach":"Check each number - if divisible by 2 with no remainder, it's even.","analogy":"Like sorting socks into pairs - if a number divides evenly by 2, it's 'even' like matching socks.","steps":["Start with count = 0","For each number, check if num % 2 == 0","If yes, increment count","Return final count"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"fun8","title":"Count Odd","description":"Count odd numbers.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint countOdd(int a[], int n) { return 0; }\\nint main() { int a[]={1,2,3,4,5,6}; cout<<countOdd(a,6); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nint countOdd(int a[], int n) {\\n    int count = 0;\\n    for(int i = 0; i < n; i++) {\\n        if(a[i] % 2 != 0) {\\n            count++;\\n        }\\n    }\\n    return count;\\n}\\nint main() { int a[]={1,2,3,4,5,6}; cout<<countOdd(a,6); return 0; }","explanation":{"approach":"Check each number - if dividing by 2 leaves remainder, it's odd.","analogy":"The leftover sock that doesn't have a pair is 'odd'.","steps":["Start with count = 0","For each number, check if num % 2 != 0","If yes, increment count","Return final count"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"fun9","title":"Swap Two Numbers","description":"Swap using temp.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint main() { int a=5, b=10; int t=a; a=b; b=t; cout<<a<<\\" \\"<<b; return 0; }","expectedOutput":"10 5","solution":"#include <iostream>\\nusing namespace std;\\nint main() {\\n    int a = 5, b = 10;\\n    int temp = a;  // Save a's value\\n    a = b;         // Put b's value in a\\n    b = temp;      // Put saved value in b\\n    cout << a << \\" \\" << b;\\n    return 0;\\n}","explanation":{"approach":"Save one value in a temporary box, then shuffle values around.","analogy":"Like swapping drinks between two glasses - you need a third empty glass to hold one drink temporarily.","steps":["Store a in temporary variable","Copy b into a","Copy temporary into b","Now a and b are swapped!"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"fun10","title":"Check Positive","description":"Is number positive.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isPositive(int n) { return false; }\\nint main() { cout<<isPositive(5); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isPositive(int n) {\\n    return n > 0;\\n}\\nint main() { cout<<isPositive(5); return 0; }","explanation":{"approach":"Simply check if the number is greater than zero.","analogy":"Like checking if you have money in your wallet - anything above $0 is positive!","steps":["Compare number with 0","If greater than 0, return true","Otherwise return false"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"fun11","title":"Check Negative","description":"Is number negative.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isNegative(int n) { return false; }\\nint main() { cout<<isNegative(-5); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isNegative(int n) {\\n    return n < 0;\\n}\\nint main() { cout<<isNegative(-5); return 0; }","explanation":{"approach":"Check if number is less than zero.","analogy":"Like being in debt - anything below $0 is negative.","steps":["Compare number with 0","If less than 0, return true","Otherwise return false"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"fun12","title":"Find Largest of Three","description":"Max of three numbers.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint largest(int a, int b, int c) { return 0; }\\nint main() { cout<<largest(5,9,3); return 0; }","expectedOutput":"9","solution":"#include <iostream>\\nusing namespace std;\\nint largest(int a, int b, int c) {\\n    if(a >= b && a >= c) return a;\\n    if(b >= a && b >= c) return b;\\n    return c;\\n}\\nint main() { cout<<largest(5,9,3); return 0; }","explanation":{"approach":"Compare each number with the other two. The one that beats both is the largest.","analogy":"Like a mini tournament - compare contestants until you find the champion.","steps":["Check if a is >= both b and c, if yes return a","Check if b is >= both a and c, if yes return b","Otherwise c is the largest"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"fun13","title":"Find Smallest of Three","description":"Min of three numbers.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint smallest(int a, int b, int c) { return 0; }\\nint main() { cout<<smallest(5,9,3); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nint smallest(int a, int b, int c) {\\n    if(a <= b && a <= c) return a;\\n    if(b <= a && b <= c) return b;\\n    return c;\\n}\\nint main() { cout<<smallest(5,9,3); return 0; }","explanation":{"approach":"Same as largest, but look for the one that's smaller than both others.","analogy":"Like finding who finishes last in a race - compare everyone's times.","steps":["Check if a is <= both b and c, if yes return a","Check if b is <= both a and c, if yes return b","Otherwise c is the smallest"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"fun14","title":"Check Divisible","description":"Check divisibility.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isDivisible(int a, int b) { return false; }\\nint main() { cout<<isDivisible(10,5); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isDivisible(int a, int b) {\\n    return a % b == 0;\\n}\\nint main() { cout<<isDivisible(10,5); return 0; }","explanation":{"approach":"Use modulo operator - if remainder is 0, it's divisible.","analogy":"Like dividing pizza slices equally - if everyone gets same amount with nothing left, it's divisible.","steps":["Calculate a % b (remainder)","If remainder is 0, return true","Otherwise return false"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"fun15","title":"Factorial Loop","description":"Factorial using loop.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint factorial(int n) { return 0; }\\nint main() { cout<<factorial(5); return 0; }","expectedOutput":"120","solution":"#include <iostream>\\nusing namespace std;\\nint factorial(int n) {\\n    int result = 1;\\n    for(int i = 1; i <= n; i++) {\\n        result *= i;\\n    }\\n    return result;\\n}\\nint main() { cout<<factorial(5); return 0; }","explanation":{"approach":"Multiply all numbers from 1 to n together. 5! = 12345 = 120","analogy":"Like a snowball rolling downhill - it keeps multiplying and getting bigger.","steps":["Start with result = 1","Multiply by 1, then 2, then 3...","Keep multiplying until we reach n","Return the product"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"fun16","title":"Sum of Digits","description":"Sum all digits.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint digitSum(int n) { return 0; }\\nint main() { cout<<digitSum(1234); return 0; }","expectedOutput":"10","solution":"#include <iostream>\\nusing namespace std;\\nint digitSum(int n) {\\n    int sum = 0;\\n    while(n > 0) {\\n        sum += n % 10;  // Get last digit\\n        n /= 10;        // Remove last digit\\n    }\\n    return sum;\\n}\\nint main() { cout<<digitSum(1234); return 0; }","explanation":{"approach":"Extract each digit using modulo 10 (gets last digit), add it to sum, then divide by 10 to remove that digit. Repeat.","analogy":"Like breaking apart a number into individual digits and adding them. 1234  1+2+3+4 = 10","steps":["Get last digit using n % 10","Add it to sum","Remove last digit using n / 10","Repeat until n becomes 0"],"complexity":"Time: O(log n), Space: O(1)"}},{"id":"fun17","title":"Count Digits","description":"Number of digits.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint countDigits(int n) { return 0; }\\nint main() { cout<<countDigits(12345); return 0; }","expectedOutput":"5","solution":"#include <iostream>\\nusing namespace std;\\nint countDigits(int n) {\\n    int count = 0;\\n    while(n > 0) {\\n        count++;\\n        n /= 10;\\n    }\\n    return count;\\n}\\nint main() { cout<<countDigits(12345); return 0; }","explanation":{"approach":"Keep dividing by 10 and count how many times until number becomes 0.","analogy":"Like counting how many times you can cut a number in half (by powers of 10).","steps":["Start with count = 0","Divide n by 10","Increment count","Repeat until n is 0","Return count"],"complexity":"Time: O(log n), Space: O(1)"}},{"id":"fun18","title":"Reverse Number","description":"Reverse digits.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint reverse(int n) { return 0; }\\nint main() { cout<<reverse(12345); return 0; }","expectedOutput":"54321","solution":"#include <iostream>\\nusing namespace std;\\nint reverse(int n) {\\n    int reversed = 0;\\n    while(n > 0) {\\n        reversed = reversed * 10 + n % 10;\\n        n /= 10;\\n    }\\n    return reversed;\\n}\\nint main() { cout<<reverse(12345); return 0; }","explanation":{"approach":"Build new number by taking digits from end and adding to result.","analogy":"Like reading a number backwards - take last digit, put it first in new number.","steps":["Get last digit (n % 10)","Multiply result by 10 and add this digit","Remove last digit from n (n / 10)","Repeat until n is 0"],"complexity":"Time: O(log n), Space: O(1)"}},{"id":"fun19","title":"Check Palindrome Number","description":"Is number palindrome.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isPalindrome(int n) { return false; }\\nint main() { cout<<isPalindrome(12321); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isPalindrome(int n) {\\n    int original = n, reversed = 0;\\n    while(n > 0) {\\n        reversed = reversed * 10 + n % 10;\\n        n /= 10;\\n    }\\n    return original == reversed;\\n}\\nint main() { cout<<isPalindrome(12321); return 0; }","explanation":{"approach":"Reverse the number and check if it's same as original.","analogy":"A palindrome reads the same forwards and backwards - like 'racecar' or 12321.","steps":["Save original number","Reverse the number","Compare reversed with original","If same, it's a palindrome"],"complexity":"Time: O(log n), Space: O(1)"}},{"id":"fun20","title":"Check Perfect Square","description":"Is perfect square.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isPerfectSquare(int n) { return false; }\\nint main() { cout<<isPerfectSquare(16); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isPerfectSquare(int n) {\\n    int root = 1;\\n    while(root * root < n) root++;\\n    return root * root == n;\\n}\\nint main() { cout<<isPerfectSquare(16); return 0; }","explanation":{"approach":"Find the integer that when squared equals n. If found, it's a perfect square.","analogy":"Like asking: can I arrange n squares into a perfect larger square? 16 = 44 ","steps":["Start with root = 1","Keep incrementing until root >= n","Check if root == n exactly"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"fun21","title":"Print Pattern Stars","description":"Right triangle of stars.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid pattern(int n) {}\\nint main() { pattern(4); return 0; }","expectedOutput":"* ** *** ****","solution":"#include <iostream>\\nusing namespace std;\\nvoid pattern(int n) {\\n    for(int i = 1; i <= n; i++) {\\n        for(int j = 1; j <= i; j++) {\\n            cout << \\"*\\";\\n        }\\n        if(i < n) cout << \\" \\";\\n    }\\n}\\nint main() { pattern(4); return 0; }","explanation":{"approach":"Use nested loops - outer loop for rows, inner loop prints stars equal to row number.","analogy":"Like building stairs - each step has one more block than the previous.","steps":["Row 1: print 1 star","Row 2: print 2 stars","Row 3: print 3 stars","Continue until row n"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"fun22","title":"Print Pattern Inverted","description":"Inverted triangle.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid pattern(int n) {}\\nint main() { pattern(4); return 0; }","expectedOutput":"**** *** ** *","solution":"#include <iostream>\\nusing namespace std;\\nvoid pattern(int n) {\\n    for(int i = n; i >= 1; i--) {\\n        for(int j = 1; j <= i; j++) {\\n            cout << \\"*\\";\\n        }\\n        if(i > 1) cout << \\" \\";\\n    }\\n}\\nint main() { pattern(4); return 0; }","explanation":{"approach":"Start from n stars and decrease by 1 each row.","analogy":"Like stairs going down - each step has one less block.","steps":["Row 1: print n stars","Row 2: print n-1 stars","Continue decreasing","Last row: print 1 star"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"fun23","title":"Print Number Pyramid","description":"Number pattern.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid pattern(int n) {}\\nint main() { pattern(4); return 0; }","expectedOutput":"1 12 123 1234","solution":"#include <iostream>\\nusing namespace std;\\nvoid pattern(int n) {\\n    for(int i = 1; i <= n; i++) {\\n        for(int j = 1; j <= i; j++) {\\n            cout << j;\\n        }\\n        if(i < n) cout << \\" \\";\\n    }\\n}\\nint main() { pattern(4); return 0; }","explanation":{"approach":"Each row prints numbers from 1 up to the row number.","analogy":"Like counting higher each row - 1, then 12, then 123...","steps":["Row 1: print 1","Row 2: print 12","Row 3: print 123","Row i: print 1 to i"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"fun24","title":"Sum of AP","description":"Sum of arithmetic progression.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint sumAP(int a, int d, int n) { return 0; }\\nint main() { cout<<sumAP(1,2,5); return 0; }","expectedOutput":"25","solution":"#include <iostream>\\nusing namespace std;\\nint sumAP(int a, int d, int n) {\\n    // Sum = n/2 * (2a + (n-1)d)\\n    return n * (2*a + (n-1)*d) / 2;\\n}\\nint main() { cout<<sumAP(1,2,5); return 0; }","explanation":{"approach":"Use the formula: Sum = n/2  (first term + last term) or n/2  (2a + (n-1)d)","analogy":"If you pair first and last terms, each pair has same sum. Multiply pairs by count/2.","steps":["First term a, difference d, n terms","Last term = a + (n-1)d","Sum = n  (first + last) / 2"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"fun25","title":"Sum of GP","description":"Sum of geometric progression.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint sumGP(int a, int r, int n) { return 0; }\\nint main() { cout<<sumGP(1,2,5); return 0; }","expectedOutput":"31","solution":"#include <iostream>\\nusing namespace std;\\nint sumGP(int a, int r, int n) {\\n    // Sum = a * (r^n - 1) / (r - 1)\\n    int rn = 1;\\n    for(int i = 0; i < n; i++) rn *= r;\\n    return a * (rn - 1) / (r - 1);\\n}\\nint main() { cout<<sumGP(1,2,5); return 0; }","explanation":{"approach":"Use formula: Sum = a  (r - 1) / (r - 1) where r is common ratio.","analogy":"Each term is multiplied by r. Like compound interest - grows exponentially.","steps":["Calculate r^n","Apply formula: a  (r^n - 1) / (r - 1)","Return result"],"complexity":"Time: O(n), Space: O(1)"}}]`),v5=JSON.parse(`[{"id":"fun26","title":"Nth Term AP","description":"Find nth term of AP.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint nthAP(int a, int d, int n) { return 0; }\\nint main() { cout<<nthAP(2,3,5); return 0; }","expectedOutput":"14","solution":"#include <iostream>\\nusing namespace std;\\nint nthAP(int a, int d, int n) {\\n    return a + (n-1) * d;\\n}\\nint main() { cout<<nthAP(2,3,5); return 0; }","explanation":{"approach":"Use formula: nth term = first term + (n-1)  common difference","analogy":"Like climbing stairs with equal steps - each step adds the same height.","steps":["First term is a","Each step adds d","After n-1 steps: a + (n-1)d"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"fun27","title":"Nth Term GP","description":"Find nth term of GP.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint nthGP(int a, int r, int n) { return 0; }\\nint main() { cout<<nthGP(2,3,4); return 0; }","expectedOutput":"54","solution":"#include <iostream>\\nusing namespace std;\\nint nthGP(int a, int r, int n) {\\n    int result = a;\\n    for(int i = 1; i < n; i++) result *= r;\\n    return result;\\n}\\nint main() { cout<<nthGP(2,3,4); return 0; }","explanation":{"approach":"Multiply first term by ratio (n-1) times.","analogy":"Like doubling money n times - it grows by multiplication.","steps":["Start with first term a","Multiply by r, (n-1) times","Result is a  r^(n-1)"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"fun28","title":"Power Function","description":"Calculate x^n.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint power(int x, int n) { return 0; }\\nint main() { cout<<power(2,10); return 0; }","expectedOutput":"1024","solution":"#include <iostream>\\nusing namespace std;\\nint power(int x, int n) {\\n    int result = 1;\\n    for(int i = 0; i < n; i++) result *= x;\\n    return result;\\n}\\nint main() { cout<<power(2,10); return 0; }","explanation":{"approach":"Multiply x by itself n times.","analogy":"2^10 means multiply 2 ten times: 2222222222 = 1024","steps":["Start with 1","Multiply by x, n times","Return result"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"fun29","title":"Cube of Number","description":"Calculate n^3.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint cube(int n) { return 0; }\\nint main() { cout<<cube(5); return 0; }","expectedOutput":"125","solution":"#include <iostream>\\nusing namespace std;\\nint cube(int n) {\\n    return n * n * n;\\n}\\nint main() { cout<<cube(5); return 0; }","explanation":{"approach":"Simply multiply n by itself 3 times.","analogy":"Like the volume of a cube with side n.","steps":["Return n  n  n"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"fun30","title":"Square Root Integer","description":"Floor of square root.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint mySqrt(int n) { return 0; }\\nint main() { cout<<mySqrt(26); return 0; }","expectedOutput":"5","solution":"#include <iostream>\\nusing namespace std;\\nint mySqrt(int n) {\\n    int i = 1;\\n    while(i * i <= n) i++;\\n    return i - 1;\\n}\\nint main() { cout<<mySqrt(26); return 0; }","explanation":{"approach":"Find largest i where i  n.","analogy":"What's the biggest number that when squared is still  n?","steps":["Start i=1","While i  n, increment i","Return i-1 (last valid i)"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"fun31","title":"Calculate Percentage","description":"Find percentage.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\ndouble percentage(int obtained, int total) { return 0; }\\nint main() { cout<<percentage(45,50); return 0; }","expectedOutput":"90","solution":"#include <iostream>\\nusing namespace std;\\ndouble percentage(int obtained, int total) {\\n    return (obtained * 100.0) / total;\\n}\\nint main() { cout<<percentage(45,50); return 0; }","explanation":{"approach":"(Obtained/Total)  100","analogy":"If you got 45 out of 50, that's 90%.","steps":["Divide obtained by total","Multiply by 100"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"fun32","title":"Simple Interest","description":"Calculate SI.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\ndouble simpleInterest(int p, int r, int t) { return 0; }\\nint main() { cout<<simpleInterest(1000,5,2); return 0; }","expectedOutput":"100","solution":"#include <iostream>\\nusing namespace std;\\ndouble simpleInterest(int p, int r, int t) {\\n    return (p * r * t) / 100.0;\\n}\\nint main() { cout<<simpleInterest(1000,5,2); return 0; }","explanation":{"approach":"SI = (Principal  Rate  Time) / 100","analogy":"Simple interest is like flat rent on your money.","steps":["Multiply P  R  T","Divide by 100"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"fun33","title":"Celsius to Fahrenheit","description":"Temperature conversion.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\ndouble toFahrenheit(double c) { return 0; }\\nint main() { cout<<toFahrenheit(0); return 0; }","expectedOutput":"32","solution":"#include <iostream>\\nusing namespace std;\\ndouble toFahrenheit(double c) {\\n    return c * 9.0/5.0 + 32;\\n}\\nint main() { cout<<toFahrenheit(0); return 0; }","explanation":{"approach":"F = C  (9/5) + 32","analogy":"0C = 32F (freezing point), 100C = 212F (boiling)","steps":["Multiply C by 9/5","Add 32"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"fun34","title":"Fahrenheit to Celsius","description":"Temperature conversion.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\ndouble toCelsius(double f) { return 0; }\\nint main() { cout<<toCelsius(32); return 0; }","expectedOutput":"0","solution":"#include <iostream>\\nusing namespace std;\\ndouble toCelsius(double f) {\\n    return (f - 32) * 5.0/9.0;\\n}\\nint main() { cout<<toCelsius(32); return 0; }","explanation":{"approach":"C = (F - 32)  (5/9)","analogy":"Reverse of Celsius to Fahrenheit.","steps":["Subtract 32 from F","Multiply by 5/9"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"fun35","title":"Area of Circle","description":"Calculate area.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\n#include <iomanip>\\nusing namespace std;\\ndouble areaCircle(double r) { return 0; }\\nint main() { cout<<fixed<<setprecision(2)<<areaCircle(7); return 0; }","expectedOutput":"153.94","solution":"#include <iostream>\\n#include <iomanip>\\nusing namespace std;\\ndouble areaCircle(double r) {\\n    return 3.14159 * r * r;\\n}\\nint main() { cout<<fixed<<setprecision(2)<<areaCircle(7); return 0; }","explanation":{"approach":"Area =   r","analogy":"How much space is inside a circle.","steps":["Square the radius","Multiply by  (3.14159)"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"fun36","title":"Area of Triangle","description":"Using base and height.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\ndouble areaTriangle(double b, double h) { return 0; }\\nint main() { cout<<areaTriangle(10,5); return 0; }","expectedOutput":"25","solution":"#include <iostream>\\nusing namespace std;\\ndouble areaTriangle(double b, double h) {\\n    return 0.5 * b * h;\\n}\\nint main() { cout<<areaTriangle(10,5); return 0; }","explanation":{"approach":"Area =   base  height","analogy":"A triangle is half of a rectangle.","steps":["Multiply base by height","Divide by 2"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"fun37","title":"Area of Rectangle","description":"Length times width.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint areaRect(int l, int w) { return 0; }\\nint main() { cout<<areaRect(10,5); return 0; }","expectedOutput":"50","solution":"#include <iostream>\\nusing namespace std;\\nint areaRect(int l, int w) {\\n    return l * w;\\n}\\nint main() { cout<<areaRect(10,5); return 0; }","explanation":{"approach":"Area = length  width","analogy":"Count tiles in a lw grid.","steps":["Multiply length by width"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"fun38","title":"Perimeter of Rectangle","description":"2*(l+w).","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint perimeter(int l, int w) { return 0; }\\nint main() { cout<<perimeter(10,5); return 0; }","expectedOutput":"30","solution":"#include <iostream>\\nusing namespace std;\\nint perimeter(int l, int w) {\\n    return 2 * (l + w);\\n}\\nint main() { cout<<perimeter(10,5); return 0; }","explanation":{"approach":"Perimeter = 2  (length + width)","analogy":"Walk around the rectangle - two lengths and two widths.","steps":["Add length and width","Multiply by 2"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"fun39","title":"Check Vowel","description":"Is character vowel.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isVowel(char c) { return false; }\\nint main() { cout<<isVowel('a'); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isVowel(char c) {\\n    c = tolower(c);\\n    return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u';\\n}\\nint main() { cout<<isVowel('a'); return 0; }","explanation":{"approach":"Check if character is a, e, i, o, or u.","analogy":"Vowels are the singing letters - A E I O U.","steps":["Convert to lowercase","Check against each vowel"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"fun40","title":"Check Consonant","description":"Is character consonant.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isConsonant(char c) { return false; }\\nint main() { cout<<isConsonant('b'); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isConsonant(char c) {\\n    c = tolower(c);\\n    return isalpha(c) && !(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u');\\n}\\nint main() { cout<<isConsonant('b'); return 0; }","explanation":{"approach":"Is a letter but NOT a vowel.","analogy":"Consonants are all letters except A E I O U.","steps":["Check if it's a letter","Check if it's not a vowel"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"fun41","title":"Check Uppercase","description":"Is character uppercase.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isUpper(char c) { return false; }\\nint main() { cout<<isUpper('A'); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isUpper(char c) {\\n    return c >= 'A' && c <= 'Z';\\n}\\nint main() { cout<<isUpper('A'); return 0; }","explanation":{"approach":"Check if between 'A' and 'Z' in ASCII.","analogy":"Capital letters live between A(65) and Z(90) in ASCII.","steps":["Compare with 'A' and 'Z'"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"fun42","title":"Check Lowercase","description":"Is character lowercase.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isLower(char c) { return false; }\\nint main() { cout<<isLower('a'); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isLower(char c) {\\n    return c >= 'a' && c <= 'z';\\n}\\nint main() { cout<<isLower('a'); return 0; }","explanation":{"approach":"Check if between 'a' and 'z'.","analogy":"Lowercase letters are a(97) to z(122).","steps":["Compare with 'a' and 'z'"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"fun43","title":"Check Alphabet","description":"Is character a letter.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isAlpha(char c) { return false; }\\nint main() { cout<<isAlpha('z'); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isAlpha(char c) {\\n    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');\\n}\\nint main() { cout<<isAlpha('z'); return 0; }","explanation":{"approach":"Either lowercase OR uppercase.","analogy":"Is it any letter from A-Z?","steps":["Check if lowercase","OR check if uppercase"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"fun44","title":"Check Digit","description":"Is character a digit.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isDigit(char c) { return false; }\\nint main() { cout<<isDigit('5'); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isDigit(char c) {\\n    return c >= '0' && c <= '9';\\n}\\nint main() { cout<<isDigit('5'); return 0; }","explanation":{"approach":"Check if between '0' and '9'.","analogy":"Digits are characters 0-9.","steps":["Compare with '0' and '9'"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"fun45","title":"ASCII Value","description":"Get ASCII value.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint getASCII(char c) { return 0; }\\nint main() { cout<<getASCII('A'); return 0; }","expectedOutput":"65","solution":"#include <iostream>\\nusing namespace std;\\nint getASCII(char c) {\\n    return (int)c;\\n}\\nint main() { cout<<getASCII('A'); return 0; }","explanation":{"approach":"Cast char to int to get ASCII value.","analogy":"Each character has a number code. A=65, a=97, 0=48.","steps":["Cast character to integer"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"fun46","title":"Character from ASCII","description":"Get character from ASCII.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nchar getChar(int n) { return 0; }\\nint main() { cout<<getChar(65); return 0; }","expectedOutput":"A","solution":"#include <iostream>\\nusing namespace std;\\nchar getChar(int n) {\\n    return (char)n;\\n}\\nint main() { cout<<getChar(65); return 0; }","explanation":{"approach":"Cast int to char.","analogy":"Convert number back to its character. 65  'A'.","steps":["Cast integer to character"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"fun47","title":"Toggle Case","description":"Swap case of character.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nchar toggleCase(char c) { return 0; }\\nint main() { cout<<toggleCase('a'); return 0; }","expectedOutput":"A","solution":"#include <iostream>\\nusing namespace std;\\nchar toggleCase(char c) {\\n    if(c >= 'a' && c <= 'z') return c - 32;\\n    if(c >= 'A' && c <= 'Z') return c + 32;\\n    return c;\\n}\\nint main() { cout<<toggleCase('a'); return 0; }","explanation":{"approach":"Lowercase and uppercase differ by 32 in ASCII.","analogy":"'a'(97) - 32 = 'A'(65). Add/subtract 32 to toggle.","steps":["If lowercase, subtract 32","If uppercase, add 32"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"fun48","title":"Days in Month","description":"Days given month.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint daysInMonth(int m, int y) { return 0; }\\nint main() { cout<<daysInMonth(2,2024); return 0; }","expectedOutput":"29","solution":"#include <iostream>\\nusing namespace std;\\nint daysInMonth(int m, int y) {\\n    int days[] = {31,28,31,30,31,30,31,31,30,31,30,31};\\n    if(m == 2 && ((y%4==0 && y%100!=0) || y%400==0)) return 29;\\n    return days[m-1];\\n}\\nint main() { cout<<daysInMonth(2,2024); return 0; }","explanation":{"approach":"Use array for days. Check leap year for February.","analogy":"30 days has September, April, June, November...","steps":["Store days in array","For Feb, check leap year","Return appropriate days"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"fun49","title":"Check Leap Year","description":"Is year leap.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isLeap(int y) { return false; }\\nint main() { cout<<isLeap(2024); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isLeap(int y) {\\n    return (y % 4 == 0 && y % 100 != 0) || (y % 400 == 0);\\n}\\nint main() { cout<<isLeap(2024); return 0; }","explanation":{"approach":"Divisible by 4 but not 100, OR divisible by 400.","analogy":"2024 is leap (4, not 100). 2000 is leap (400). 1900 is not (100 but not 400).","steps":["Check if divisible by 4 but not 100","OR divisible by 400"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"fun50","title":"Sum 1 to N Formula","description":"Using n*(n+1)/2.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint sum1ToN(int n) { return 0; }\\nint main() { cout<<sum1ToN(100); return 0; }","expectedOutput":"5050","solution":"#include <iostream>\\nusing namespace std;\\nint sum1ToN(int n) {\\n    return n * (n + 1) / 2;\\n}\\nint main() { cout<<sum1ToN(100); return 0; }","explanation":{"approach":"Gauss formula: n(n+1)/2","analogy":"Pair first and last: 1+100=101, 2+99=101... 50 pairs  101 = 5050.","steps":["Apply formula n(n+1)/2"],"complexity":"Time: O(1), Space: O(1)"}}]`),x5=JSON.parse(`[{"id":"fun51","title":"Sum of Squares 1 to N","description":"Formula: n(n+1)(2n+1)/6.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint sumSquares(int n) { return 0; }\\nint main() { cout<<sumSquares(5); return 0; }","expectedOutput":"55","solution":"#include <iostream>\\nusing namespace std;\\nint sumSquares(int n) {\\n    return n * (n + 1) * (2 * n + 1) / 6;\\n}\\nint main() { cout<<sumSquares(5); return 0; }","explanation":{"approach":"Formula: n(n+1)(2n+1)/6 gives 1 + 2 + 3 + ... + n","analogy":"Like stacking squares - there's a magic formula for the total.","steps":["Apply formula: n(n+1)(2n+1)/6"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"fun52","title":"Sum of Cubes 1 to N","description":"Formula: (n(n+1)/2).","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint sumCubes(int n) { return 0; }\\nint main() { cout<<sumCubes(5); return 0; }","expectedOutput":"225","solution":"#include <iostream>\\nusing namespace std;\\nint sumCubes(int n) {\\n    int sum = n * (n + 1) / 2;\\n    return sum * sum;\\n}\\nint main() { cout<<sumCubes(5); return 0; }","explanation":{"approach":"Formula: (n(n+1)/2) = (sum of 1 to n)","analogy":"Amazing: 1+2+3+...+n = (1+2+3+...+n)","steps":["Calculate sum 1 to n","Square it"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"fun53","title":"Print Odd Numbers","description":"Print odd 1 to N.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid printOdd(int n) {}\\nint main() { printOdd(10); return 0; }","expectedOutput":"1 3 5 7 9","solution":"#include <iostream>\\nusing namespace std;\\nvoid printOdd(int n) {\\n    for(int i = 1; i <= n; i += 2)\\n        cout << i << (i + 2 <= n ? \\" \\" : \\"\\");\\n}\\nint main() { printOdd(10); return 0; }","explanation":{"approach":"Start from 1, increment by 2 each time.","analogy":"Skip every other number starting from 1.","steps":["Start at 1","Add 2 each step","Stop when > n"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"fun54","title":"Print Even Numbers","description":"Print even 1 to N.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid printEven(int n) {}\\nint main() { printEven(10); return 0; }","expectedOutput":"2 4 6 8 10","solution":"#include <iostream>\\nusing namespace std;\\nvoid printEven(int n) {\\n    for(int i = 2; i <= n; i += 2)\\n        cout << i << (i + 2 <= n ? \\" \\" : \\"\\");\\n}\\nint main() { printEven(10); return 0; }","explanation":{"approach":"Start from 2, increment by 2.","analogy":"Skip every other number starting from 2.","steps":["Start at 2","Add 2 each step","Stop when > n"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"fun55","title":"Sum of Even 1 to N","description":"Sum of even numbers.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint sumEven(int n) { return 0; }\\nint main() { cout<<sumEven(10); return 0; }","expectedOutput":"30","solution":"#include <iostream>\\nusing namespace std;\\nint sumEven(int n) {\\n    int sum = 0;\\n    for(int i = 2; i <= n; i += 2) sum += i;\\n    return sum;\\n}\\nint main() { cout<<sumEven(10); return 0; }","explanation":{"approach":"Add all even numbers from 2 to n.","analogy":"2+4+6+8+10 = 30","steps":["Loop through even numbers","Add each to sum"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"fun56","title":"Sum of Odd 1 to N","description":"Sum of odd numbers.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint sumOdd(int n) { return 0; }\\nint main() { cout<<sumOdd(10); return 0; }","expectedOutput":"25","solution":"#include <iostream>\\nusing namespace std;\\nint sumOdd(int n) {\\n    int sum = 0;\\n    for(int i = 1; i <= n; i += 2) sum += i;\\n    return sum;\\n}\\nint main() { cout<<sumOdd(10); return 0; }","explanation":{"approach":"Add all odd numbers from 1 to n.","analogy":"1+3+5+7+9 = 25","steps":["Loop through odd numbers","Add each to sum"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"fun57","title":"Product of Digits","description":"Multiply all digits.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint productDigits(int n) { return 0; }\\nint main() { cout<<productDigits(234); return 0; }","expectedOutput":"24","solution":"#include <iostream>\\nusing namespace std;\\nint productDigits(int n) {\\n    int prod = 1;\\n    while(n > 0) {\\n        prod *= n % 10;\\n        n /= 10;\\n    }\\n    return prod;\\n}\\nint main() { cout<<productDigits(234); return 0; }","explanation":{"approach":"Extract each digit and multiply together.","analogy":"234  234 = 24","steps":["Get last digit","Multiply to product","Remove last digit","Repeat"],"complexity":"Time: O(log n), Space: O(1)"}},{"id":"fun58","title":"First Digit","description":"Get first digit.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint firstDigit(int n) { return 0; }\\nint main() { cout<<firstDigit(12345); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nint firstDigit(int n) {\\n    while(n >= 10) n /= 10;\\n    return n;\\n}\\nint main() { cout<<firstDigit(12345); return 0; }","explanation":{"approach":"Keep dividing by 10 until single digit.","analogy":"12345  1234  123  12  1","steps":["Divide by 10 repeatedly","Until n < 10"],"complexity":"Time: O(log n), Space: O(1)"}},{"id":"fun59","title":"Last Digit","description":"Get last digit.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint lastDigit(int n) { return 0; }\\nint main() { cout<<lastDigit(12345); return 0; }","expectedOutput":"5","solution":"#include <iostream>\\nusing namespace std;\\nint lastDigit(int n) {\\n    return n % 10;\\n}\\nint main() { cout<<lastDigit(12345); return 0; }","explanation":{"approach":"Modulo 10 gives last digit.","analogy":"12345 % 10 = 5","steps":["Return n % 10"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"fun60","title":"Sum First and Last","description":"Sum of first and last digit.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint sumFirstLast(int n) { return 0; }\\nint main() { cout<<sumFirstLast(12345); return 0; }","expectedOutput":"6","solution":"#include <iostream>\\nusing namespace std;\\nint sumFirstLast(int n) {\\n    int last = n % 10;\\n    while(n >= 10) n /= 10;\\n    return n + last;\\n}\\nint main() { cout<<sumFirstLast(12345); return 0; }","explanation":{"approach":"Get last digit, then find first digit, add them.","analogy":"12345  1 + 5 = 6","steps":["Get last digit (n%10)","Find first digit","Add them"],"complexity":"Time: O(log n), Space: O(1)"}},{"id":"fun61","title":"Swap First and Last Digit","description":"Swap first and last.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint swapFirstLast(int n) { return 0; }\\nint main() { cout<<swapFirstLast(12345); return 0; }","expectedOutput":"52341","solution":"#include <iostream>\\nusing namespace std;\\nint swapFirstLast(int n) {\\n    int digits = 0, temp = n;\\n    while(temp > 0) { digits++; temp /= 10; }\\n    int first = n, mult = 1;\\n    while(first >= 10) { first /= 10; mult *= 10; }\\n    int last = n % 10;\\n    return n - first * mult - last + last * mult + first;\\n}\\nint main() { cout<<swapFirstLast(12345); return 0; }","explanation":{"approach":"Calculate positions, swap mathematically.","analogy":"12345  swap 1 and 5  52341","steps":["Find first and last digits","Calculate their positions","Swap using math"],"complexity":"Time: O(log n), Space: O(1)"}},{"id":"fun62","title":"Remove First Digit","description":"Number without first digit.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint removeFirst(int n) { return 0; }\\nint main() { cout<<removeFirst(12345); return 0; }","expectedOutput":"2345","solution":"#include <iostream>\\nusing namespace std;\\nint removeFirst(int n) {\\n    int mult = 1, temp = n;\\n    while(temp >= 10) { mult *= 10; temp /= 10; }\\n    return n % mult;\\n}\\nint main() { cout<<removeFirst(12345); return 0; }","explanation":{"approach":"Use modulo to remove first digit.","analogy":"12345 % 10000 = 2345","steps":["Find power of 10 equal to first digit position","Modulo by that"],"complexity":"Time: O(log n), Space: O(1)"}},{"id":"fun63","title":"Remove Last Digit","description":"Number without last digit.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint removeLast(int n) { return 0; }\\nint main() { cout<<removeLast(12345); return 0; }","expectedOutput":"1234","solution":"#include <iostream>\\nusing namespace std;\\nint removeLast(int n) {\\n    return n / 10;\\n}\\nint main() { cout<<removeLast(12345); return 0; }","explanation":{"approach":"Integer division by 10.","analogy":"12345 / 10 = 1234","steps":["Divide by 10"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"fun64","title":"Rotate Left Once","description":"Move first digit to end.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint rotateLeft(int n) { return 0; }\\nint main() { cout<<rotateLeft(12345); return 0; }","expectedOutput":"23451","solution":"#include <iostream>\\nusing namespace std;\\nint rotateLeft(int n) {\\n    int mult = 1, temp = n;\\n    while(temp >= 10) { mult *= 10; temp /= 10; }\\n    return (n % mult) * 10 + temp;\\n}\\nint main() { cout<<rotateLeft(12345); return 0; }","explanation":{"approach":"Remove first digit, append it at end.","analogy":"12345  2345  10 + 1 = 23451","steps":["Find first digit","Remove it","Append to end"],"complexity":"Time: O(log n), Space: O(1)"}},{"id":"fun65","title":"Rotate Right Once","description":"Move last digit to start.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint rotateRight(int n) { return 0; }\\nint main() { cout<<rotateRight(12345); return 0; }","expectedOutput":"51234","solution":"#include <iostream>\\nusing namespace std;\\nint rotateRight(int n) {\\n    int last = n % 10;\\n    int mult = 1, temp = n;\\n    while(temp >= 10) { mult *= 10; temp /= 10; }\\n    return last * mult + n / 10;\\n}\\nint main() { cout<<rotateRight(12345); return 0; }","explanation":{"approach":"Remove last digit, prepend it at start.","analogy":"12345  5  10000 + 1234 = 51234","steps":["Get last digit","Remove it","Prepend at start"],"complexity":"Time: O(log n), Space: O(1)"}},{"id":"fun66","title":"Neon Number","description":"Sum of digits of square = n.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isNeon(int n) { return false; }\\nint main() { cout<<isNeon(9); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isNeon(int n) {\\n    int sq = n * n, sum = 0;\\n    while(sq > 0) { sum += sq % 10; sq /= 10; }\\n    return sum == n;\\n}\\nint main() { cout<<isNeon(9); return 0; }","explanation":{"approach":"Square n, sum its digits, check if equals n.","analogy":"9 = 81, 8+1 = 9 ","steps":["Calculate n","Sum digits of square","Check if equals n"],"complexity":"Time: O(log n), Space: O(1)"}},{"id":"fun67","title":"Spy Number","description":"Sum of digits = product.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isSpy(int n) { return false; }\\nint main() { cout<<isSpy(1124); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isSpy(int n) {\\n    int sum = 0, prod = 1;\\n    while(n > 0) {\\n        int d = n % 10;\\n        sum += d; prod *= d;\\n        n /= 10;\\n    }\\n    return sum == prod;\\n}\\nint main() { cout<<isSpy(1124); return 0; }","explanation":{"approach":"Calculate sum and product of digits, compare.","analogy":"1124: sum=1+1+2+4=8, prod=1124=8 ","steps":["Calculate sum of digits","Calculate product of digits","Check if equal"],"complexity":"Time: O(log n), Space: O(1)"}},{"id":"fun68","title":"Automorphic Number","description":"Square ends with n.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isAutomorphic(int n) { return false; }\\nint main() { cout<<isAutomorphic(25); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isAutomorphic(int n) {\\n    int sq = n * n, mult = 1;\\n    int temp = n;\\n    while(temp > 0) { mult *= 10; temp /= 10; }\\n    return sq % mult == n;\\n}\\nint main() { cout<<isAutomorphic(25); return 0; }","explanation":{"approach":"Check if n ends with n.","analogy":"25 = 625, ends with 25 ","steps":["Calculate n","Check if last digits equal n"],"complexity":"Time: O(log n), Space: O(1)"}},{"id":"fun69","title":"Duck Number","description":"Has zero but not at start.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isDuck(int n) { return false; }\\nint main() { cout<<isDuck(1023); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isDuck(int n) {\\n    while(n > 0) {\\n        if(n % 10 == 0 && n >= 10) return true;\\n        n /= 10;\\n    }\\n    return false;\\n}\\nint main() { cout<<isDuck(1023); return 0; }","explanation":{"approach":"Check if 0 appears (not at start).","analogy":"1023 has 0 not at start ","steps":["Check each digit","If 0 found (not first), it's duck"],"complexity":"Time: O(log n), Space: O(1)"}},{"id":"fun70","title":"Buzz Number","description":"Ends in 7 or divisible by 7.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isBuzz(int n) { return false; }\\nint main() { cout<<isBuzz(14); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isBuzz(int n) {\\n    return n % 10 == 7 || n % 7 == 0;\\n}\\nint main() { cout<<isBuzz(14); return 0; }","explanation":{"approach":"Check if ends in 7 OR divisible by 7.","analogy":"14 is divisible by 7 , 27 ends in 7 ","steps":["Check if n % 10 == 7","OR check if n % 7 == 0"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"fun71","title":"Harshad Number","description":"Divisible by sum of digits.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isHarshad(int n) { return false; }\\nint main() { cout<<isHarshad(18); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isHarshad(int n) {\\n    int sum = 0, temp = n;\\n    while(temp > 0) { sum += temp % 10; temp /= 10; }\\n    return n % sum == 0;\\n}\\nint main() { cout<<isHarshad(18); return 0; }","explanation":{"approach":"Find digit sum, check if n divisible by it.","analogy":"18: sum=1+8=9, 189=2 ","steps":["Calculate digit sum","Check if n % sum == 0"],"complexity":"Time: O(log n), Space: O(1)"}},{"id":"fun72","title":"Pronic Number","description":"Product of consecutive ints.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isPronic(int n) { return false; }\\nint main() { cout<<isPronic(12); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isPronic(int n) {\\n    for(int i = 0; i * i <= n; i++)\\n        if(i * (i + 1) == n) return true;\\n    return false;\\n}\\nint main() { cout<<isPronic(12); return 0; }","explanation":{"approach":"Check if n = k  (k+1) for some k.","analogy":"12 = 3  4 ","steps":["Try each k","Check if k  (k+1) = n"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"fun73","title":"Happy Number","description":"Sum of digit squares reaches 1.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isHappy(int n) { return false; }\\nint main() { cout<<isHappy(19); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nint sumSq(int n) { int s=0; while(n>0){int d=n%10; s+=d*d; n/=10;} return s; }\\nbool isHappy(int n) {\\n    int slow = n, fast = n;\\n    do { slow = sumSq(slow); fast = sumSq(sumSq(fast)); } while(slow != fast);\\n    return slow == 1;\\n}\\nint main() { cout<<isHappy(19); return 0; }","explanation":{"approach":"Keep replacing n with sum of digit squares. If reaches 1, it's happy.","analogy":"1982681001  Happy!","steps":["Replace n with sum of digit","Repeat until 1 or cycle","1 means happy"],"complexity":"Time: O(log n), Space: O(1)"}},{"id":"fun74","title":"Sad Number","description":"Not a happy number.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isSad(int n) { return false; }\\nint main() { cout<<isSad(4); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nint sumSq(int n) { int s=0; while(n>0){int d=n%10; s+=d*d; n/=10;} return s; }\\nbool isSad(int n) {\\n    int slow = n, fast = n;\\n    do { slow = sumSq(slow); fast = sumSq(sumSq(fast)); } while(slow != fast);\\n    return slow != 1;\\n}\\nint main() { cout<<isSad(4); return 0; }","explanation":{"approach":"Not a happy number - gets stuck in a cycle.","analogy":"41637588914542204 (cycle, never reaches 1)","steps":["Same as happy","But return true if NOT 1"],"complexity":"Time: O(log n), Space: O(1)"}},{"id":"fun75","title":"Abundant Number","description":"Sum of divisors > n.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isAbundant(int n) { return false; }\\nint main() { cout<<isAbundant(12); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isAbundant(int n) {\\n    int sum = 0;\\n    for(int i = 1; i < n; i++)\\n        if(n % i == 0) sum += i;\\n    return sum > n;\\n}\\nint main() { cout<<isAbundant(12); return 0; }","explanation":{"approach":"Sum proper divisors, check if > n.","analogy":"12: divisors 1+2+3+4+6=16 > 12 ","steps":["Find all divisors except n","Sum them","Check if sum > n"],"complexity":"Time: O(n), Space: O(1)"}}]`),b5=JSON.parse(`[{"id":"fun76","title":"Deficient Number","description":"Sum of divisors < n.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isDeficient(int n) { return false; }\\nint main() { cout<<isDeficient(8); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isDeficient(int n) {\\n    int sum = 0;\\n    for(int i = 1; i < n; i++)\\n        if(n % i == 0) sum += i;\\n    return sum < n;\\n}\\nint main() { cout<<isDeficient(8); return 0; }","explanation":{"approach":"Sum proper divisors, check if < n.","analogy":"8: divisors 1+2+4=7 < 8","steps":["Find all divisors","Sum them","Check if sum < n"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"fun77","title":"Perfect Number","description":"Sum of divisors = n.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isPerfect(int n) { return false; }\\nint main() { cout<<isPerfect(28); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isPerfect(int n) {\\n    int sum = 0;\\n    for(int i = 1; i < n; i++)\\n        if(n % i == 0) sum += i;\\n    return sum == n;\\n}\\nint main() { cout<<isPerfect(28); return 0; }","explanation":{"approach":"Sum proper divisors, check if = n.","analogy":"28: 1+2+4+7+14=28","steps":["Find all divisors","Sum them"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"fun78","title":"Amicable Numbers","description":"Check amicable pair.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nbool areAmicable(int a, int b) { return false; }\\nint main() { cout<<areAmicable(220,284); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nint sumDiv(int n) { int s=0; for(int i=1;i<n;i++) if(n%i==0) s+=i; return s; }\\nbool areAmicable(int a, int b) { return sumDiv(a)==b && sumDiv(b)==a; }\\nint main() { cout<<areAmicable(220,284); return 0; }","explanation":{"approach":"Sum of a's divisors = b AND vice versa.","analogy":"220's divisors sum to 284","steps":["Calculate divisor sums"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"fun79","title":"Twin Primes","description":"Check twin primes.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nbool areTwinPrimes(int a, int b) { return false; }\\nint main() { cout<<areTwinPrimes(11,13); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isPrime(int n) { if(n<2) return false; for(int i=2;i*i<=n;i++) if(n%i==0) return false; return true; }\\nbool areTwinPrimes(int a, int b) { return isPrime(a) && isPrime(b) && abs(b-a)==2; }\\nint main() { cout<<areTwinPrimes(11,13); return 0; }","explanation":{"approach":"Both prime and differ by 2.","analogy":"11 and 13 are both prime","steps":["Check if both prime","Differ by 2"],"complexity":"Time: O(sqrt n), Space: O(1)"}},{"id":"fun80","title":"Co-Prime Numbers","description":"GCD is 1.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nbool areCoPrime(int a, int b) { return false; }\\nint main() { cout<<areCoPrime(14,15); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nint gcd(int a, int b) { return b==0 ? a : gcd(b,a%b); }\\nbool areCoPrime(int a, int b) { return gcd(a,b)==1; }\\nint main() { cout<<areCoPrime(14,15); return 0; }","explanation":{"approach":"GCD = 1 means no common factors.","analogy":"14 and 15 share no factor","steps":["Calculate GCD"],"complexity":"Time: O(log n), Space: O(1)"}},{"id":"fun81","title":"Kaprekar Number","description":"Parts of square sum to n.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isKaprekar(int n) { return false; }\\nint main() { cout<<isKaprekar(45); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isKaprekar(int n) {\\n    long sq = (long)n * n; int d = 0, t = n;\\n    while(t > 0) { d++; t /= 10; }\\n    int div = 1; for(int i=0;i<d;i++) div *= 10;\\n    return (sq%div + sq/div) == n && sq%div > 0;\\n}\\nint main() { cout<<isKaprekar(45); return 0; }","explanation":{"approach":"Split n^2, parts sum to n.","analogy":"45^2=2025, 20+25=45","steps":["Square n","Split","Sum parts"],"complexity":"Time: O(log n), Space: O(1)"}},{"id":"fun82","title":"Tech Number","description":"Even digits, halves sum^2 = n.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isTech(int n) { return false; }\\nint main() { cout<<isTech(2025); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isTech(int n) {\\n    int d = 0, t = n; while(t > 0) { d++; t /= 10; }\\n    if(d % 2 != 0) return false;\\n    int div = 1; for(int i=0;i<d/2;i++) div *= 10;\\n    int l = n/div, r = n%div;\\n    return (l+r)*(l+r) == n;\\n}\\nint main() { cout<<isTech(2025); return 0; }","explanation":{"approach":"(half1 + half2)^2 = n.","analogy":"(20+25)^2 = 2025","steps":["Split in half","Sum and square"],"complexity":"Time: O(log n), Space: O(1)"}},{"id":"fun83","title":"Strontio Number","description":"n*4 has same middle digits.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isStrontio(int n) { return false; }\\nint main() { cout<<isStrontio(1111); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isStrontio(int n) {\\n    if(n < 1000 || n > 9999) return false;\\n    int r = n * 4;\\n    return (r/100%10) == (r/10%10);\\n}\\nint main() { cout<<isStrontio(1111); return 0; }","explanation":{"approach":"4-digit, n*4 has same middle digits.","analogy":"1111*4=4444","steps":["Multiply by 4","Check middle"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"fun84","title":"Xylem Phloem","description":"Sum edge = sum middle.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isXylemPhloem(int n) { return false; }\\nint main() { cout<<isXylemPhloem(1234); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isXylemPhloem(int n) {\\n    int f = n; while(f >= 10) f /= 10;\\n    int l = n % 10, d2 = (n/100)%10, d3 = (n/10)%10;\\n    return f + l == d2 + d3;\\n}\\nint main() { cout<<isXylemPhloem(1234); return 0; }","explanation":{"approach":"Edge digits sum = middle digits sum.","analogy":"1234: 1+4 = 2+3","steps":["Get edges","Get middle","Compare"],"complexity":"Time: O(log n), Space: O(1)"}},{"id":"fun85","title":"Trimorphic Number","description":"Cube ends with n.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isTrimorphic(int n) { return false; }\\nint main() { cout<<isTrimorphic(4); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isTrimorphic(int n) {\\n    long cube = (long)n*n*n;\\n    int m = 1, t = n; while(t > 0) { m *= 10; t /= 10; }\\n    return cube % m == n;\\n}\\nint main() { cout<<isTrimorphic(4); return 0; }","explanation":{"approach":"n^3 ends with n.","analogy":"4^3 = 64 ends with 4","steps":["Cube n","Check ending"],"complexity":"Time: O(log n), Space: O(1)"}},{"id":"fun86","title":"Peterson Number","description":"Sum of digit factorials = n.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isPeterson(int n) { return false; }\\nint main() { cout<<isPeterson(145); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nint fact(int x) { int f=1; for(int i=2;i<=x;i++) f*=i; return f; }\\nbool isPeterson(int n) { int s=0, t=n; while(t>0){s+=fact(t%10); t/=10;} return s==n; }\\nint main() { cout<<isPeterson(145); return 0; }","explanation":{"approach":"Sum of digit! = n.","analogy":"145: 1!+4!+5! = 145","steps":["Factorial each digit","Sum"],"complexity":"Time: O(log n), Space: O(1)"}},{"id":"fun87","title":"Sunny Number","description":"n+1 is perfect square.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isSunny(int n) { return false; }\\nint main() { cout<<isSunny(24); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isSunny(int n) { int r=1; while(r*r<n+1) r++; return r*r==n+1; }\\nint main() { cout<<isSunny(24); return 0; }","explanation":{"approach":"n+1 is perfect square.","analogy":"24+1 = 25 = 5^2","steps":["Check if n+1 is square"],"complexity":"Time: O(sqrt n), Space: O(1)"}}]`),w5=[{id:"prac1",title:"Hello Name",description:"Print greeting with name.",difficulty:"EASY",category:"Practice",starterCode:`#include <iostream>
using namespace std;
void greet(char name[]) {}
int main() { greet("Alice"); return 0; }`,expectedOutput:"Hello Alice!",solution:`#include <iostream>
using namespace std;
void greet(char name[]) { cout<<"Hello "<<name<<"!"; }
int main() { greet("Alice"); return 0; }`,explanation:{approach:"Concatenate greeting with name.",analogy:"Simple string output.",steps:["Print Hello, name, then !"],complexity:"Time: O(n), Space: O(1)"}},{id:"prac2",title:"Rectangle Area",description:"Calculate rectangle area.",difficulty:"EASY",category:"Practice",starterCode:`#include <iostream>
using namespace std;
int area(int l, int w) { return 0; }
int main() { cout<<area(5,3); return 0; }`,expectedOutput:"15",solution:`#include <iostream>
using namespace std;
int area(int l, int w) { return l*w; }
int main() { cout<<area(5,3); return 0; }`,explanation:{approach:"Area = length  width.",analogy:"Count tiles in grid.",steps:["Multiply length by width"],complexity:"Time: O(1), Space: O(1)"}},{id:"prac3",title:"Circle Circumference",description:"Calculate circumference.",difficulty:"EASY",category:"Practice",starterCode:`#include <iostream>
#include <iomanip>
using namespace std;
double circumference(double r) { return 0; }
int main() { cout<<fixed<<setprecision(2)<<circumference(5); return 0; }`,expectedOutput:"31.42",solution:`#include <iostream>
#include <iomanip>
using namespace std;
double circumference(double r) { return 2*3.14159*r; }
int main() { cout<<fixed<<setprecision(2)<<circumference(5); return 0; }`,explanation:{approach:"C = 2r.",analogy:"Distance around the circle.",steps:["Multiply 2    radius"],complexity:"Time: O(1), Space: O(1)"}},{id:"prac4",title:"Grade Calculator",description:"Assign letter grade.",difficulty:"EASY",category:"Practice",starterCode:`#include <iostream>
using namespace std;
char grade(int score) { return 'F'; }
int main() { cout<<grade(85); return 0; }`,expectedOutput:"B",solution:`#include <iostream>
using namespace std;
char grade(int score) { if(score>=90) return 'A'; if(score>=80) return 'B'; if(score>=70) return 'C'; if(score>=60) return 'D'; return 'F'; }
int main() { cout<<grade(85); return 0; }`,explanation:{approach:"Check score ranges.",analogy:"Grading scale conversion.",steps:["Check each threshold","Return corresponding grade"],complexity:"Time: O(1), Space: O(1)"}},{id:"prac5",title:"Age in Days",description:"Convert years to days.",difficulty:"EASY",category:"Practice",starterCode:`#include <iostream>
using namespace std;
int ageDays(int years) { return 0; }
int main() { cout<<ageDays(10); return 0; }`,expectedOutput:"3650",solution:`#include <iostream>
using namespace std;
int ageDays(int years) { return years*365; }
int main() { cout<<ageDays(10); return 0; }`,explanation:{approach:"Days = years  365.",analogy:"Convert units.",steps:["Multiply by 365"],complexity:"Time: O(1), Space: O(1)"}},{id:"prac6",title:"Tip Calculator",description:"Calculate tip amount.",difficulty:"EASY",category:"Practice",starterCode:`#include <iostream>
using namespace std;
double tip(double bill, int percent) { return 0; }
int main() { cout<<tip(50,20); return 0; }`,expectedOutput:"10",solution:`#include <iostream>
using namespace std;
double tip(double bill, int percent) { return bill*percent/100; }
int main() { cout<<tip(50,20); return 0; }`,explanation:{approach:"Tip = bill  percent / 100.",analogy:"Percentage of bill.",steps:["Multiply bill by percentage","Divide by 100"],complexity:"Time: O(1), Space: O(1)"}},{id:"prac7",title:"BMI Calculator",description:"Calculate BMI.",difficulty:"EASY",category:"Practice",starterCode:`#include <iostream>
#include <iomanip>
using namespace std;
double bmi(double w, double h) { return 0; }
int main() { cout<<fixed<<setprecision(1)<<bmi(70,1.75); return 0; }`,expectedOutput:"22.9",solution:`#include <iostream>
#include <iomanip>
using namespace std;
double bmi(double w, double h) { return w/(h*h); }
int main() { cout<<fixed<<setprecision(1)<<bmi(70,1.75); return 0; }`,explanation:{approach:"BMI = weight / height.",analogy:"Body mass index formula.",steps:["Divide weight by height squared"],complexity:"Time: O(1), Space: O(1)"}},{id:"prac8",title:"Distance Formula",description:"Distance between two points.",difficulty:"EASY",category:"Practice",starterCode:`#include <iostream>
#include <cmath>
using namespace std;
double distance(int x1, int y1, int x2, int y2) { return 0; }
int main() { cout<<distance(0,0,3,4); return 0; }`,expectedOutput:"5",solution:`#include <iostream>
#include <cmath>
using namespace std;
double distance(int x1, int y1, int x2, int y2) { return sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1)); }
int main() { cout<<distance(0,0,3,4); return 0; }`,explanation:{approach:"d = ((x2-x1) + (y2-y1)).",analogy:"Pythagorean theorem.",steps:["Calculate differences","Square and sum","Take square root"],complexity:"Time: O(1), Space: O(1)"}},{id:"prac9",title:"Quadratic Roots",description:"Find roots of ax+bx+c=0.",difficulty:"EASY",category:"Practice",starterCode:`#include <iostream>
#include <cmath>
using namespace std;
void roots(int a, int b, int c) {}
int main() { roots(1,-5,6); return 0; }`,expectedOutput:"3 2",solution:`#include <iostream>
#include <cmath>
using namespace std;
void roots(int a, int b, int c) { double d=b*b-4*a*c; double r1=(-b+sqrt(d))/(2*a), r2=(-b-sqrt(d))/(2*a); cout<<(int)r1<<" "<<(int)r2; }
int main() { roots(1,-5,6); return 0; }`,explanation:{approach:"Quadratic formula: (-b  (b-4ac)) / 2a.",analogy:"Standard formula from algebra.",steps:["Calculate discriminant","Apply quadratic formula"],complexity:"Time: O(1), Space: O(1)"}},{id:"prac10",title:"Check Triangle",description:"Can sides form triangle.",difficulty:"EASY",category:"Practice",starterCode:`#include <iostream>
using namespace std;
bool isTriangle(int a, int b, int c) { return false; }
int main() { cout<<isTriangle(3,4,5); return 0; }`,expectedOutput:"1",solution:`#include <iostream>
using namespace std;
bool isTriangle(int a, int b, int c) { return a+b>c && b+c>a && a+c>b; }
int main() { cout<<isTriangle(3,4,5); return 0; }`,explanation:{approach:"Sum of any two sides must exceed third.",analogy:"Triangle inequality theorem.",steps:["Check all three combinations"],complexity:"Time: O(1), Space: O(1)"}}],S5=[{id:"prac11",title:"Fahrenheit to Celsius",description:"Convert temperature.",difficulty:"EASY",category:"Practice",starterCode:`#include <iostream>
using namespace std;
double fToC(double f) { return 0; }
int main() { cout<<fToC(98.6); return 0; }`,expectedOutput:"37",solution:`#include <iostream>
using namespace std;
double fToC(double f) { return (f-32)*5/9; }
int main() { cout<<(int)fToC(98.6); return 0; }`,explanation:{approach:"C = (F-32)  5/9.",analogy:"Temperature conversion formula.",steps:["Subtract 32","Multiply by 5/9"],complexity:"Time: O(1), Space: O(1)"}},{id:"prac12",title:"Celsius to Fahrenheit",description:"Convert temperature.",difficulty:"EASY",category:"Practice",starterCode:`#include <iostream>
using namespace std;
double cToF(double c) { return 0; }
int main() { cout<<cToF(37); return 0; }`,expectedOutput:"98.6",solution:`#include <iostream>
using namespace std;
double cToF(double c) { return c*9/5+32; }
int main() { cout<<cToF(37); return 0; }`,explanation:{approach:"F = C  9/5 + 32.",analogy:"Temperature conversion formula.",steps:["Multiply by 9/5","Add 32"],complexity:"Time: O(1), Space: O(1)"}},{id:"prac13",title:"Simple Interest",description:"Calculate simple interest.",difficulty:"EASY",category:"Practice",starterCode:`#include <iostream>
using namespace std;
double simpleInterest(double p, double r, double t) { return 0; }
int main() { cout<<simpleInterest(1000,5,2); return 0; }`,expectedOutput:"100",solution:`#include <iostream>
using namespace std;
double simpleInterest(double p, double r, double t) { return p*r*t/100; }
int main() { cout<<simpleInterest(1000,5,2); return 0; }`,explanation:{approach:"SI = P  R  T / 100.",analogy:"Interest on principal.",steps:["Multiply principal, rate, time","Divide by 100"],complexity:"Time: O(1), Space: O(1)"}},{id:"prac14",title:"Compound Interest",description:"Calculate compound interest.",difficulty:"EASY",category:"Practice",starterCode:`#include <iostream>
#include <cmath>
using namespace std;
double compoundInterest(double p, double r, int t) { return 0; }
int main() { cout<<(int)compoundInterest(1000,10,2); return 0; }`,expectedOutput:"210",solution:`#include <iostream>
#include <cmath>
using namespace std;
double compoundInterest(double p, double r, int t) { return p*pow(1+r/100,t)-p; }
int main() { cout<<(int)compoundInterest(1000,10,2); return 0; }`,explanation:{approach:"CI = P  (1+r/100)^t - P.",analogy:"Interest on interest.",steps:["Calculate amount with compound","Subtract principal"],complexity:"Time: O(1), Space: O(1)"}},{id:"prac15",title:"Area of Triangle",description:"Calculate triangle area.",difficulty:"EASY",category:"Practice",starterCode:`#include <iostream>
using namespace std;
double triangleArea(double b, double h) { return 0; }
int main() { cout<<triangleArea(10,5); return 0; }`,expectedOutput:"25",solution:`#include <iostream>
using namespace std;
double triangleArea(double b, double h) { return 0.5*b*h; }
int main() { cout<<triangleArea(10,5); return 0; }`,explanation:{approach:"A = 0.5  base  height.",analogy:"Half of rectangle.",steps:["Multiply base and height","Divide by 2"],complexity:"Time: O(1), Space: O(1)"}},{id:"prac16",title:"Volume of Cube",description:"Calculate cube volume.",difficulty:"EASY",category:"Practice",starterCode:`#include <iostream>
using namespace std;
int cubeVolume(int a) { return 0; }
int main() { cout<<cubeVolume(3); return 0; }`,expectedOutput:"27",solution:`#include <iostream>
using namespace std;
int cubeVolume(int a) { return a*a*a; }
int main() { cout<<cubeVolume(3); return 0; }`,explanation:{approach:"V = a.",analogy:"Side cubed.",steps:["Multiply side by itself 3 times"],complexity:"Time: O(1), Space: O(1)"}},{id:"prac17",title:"Volume of Sphere",description:"Calculate sphere volume.",difficulty:"EASY",category:"Practice",starterCode:`#include <iostream>
#include <iomanip>
using namespace std;
double sphereVolume(double r) { return 0; }
int main() { cout<<fixed<<setprecision(2)<<sphereVolume(3); return 0; }`,expectedOutput:"113.10",solution:`#include <iostream>
#include <iomanip>
using namespace std;
double sphereVolume(double r) { return 4.0/3.0*3.14159*r*r*r; }
int main() { cout<<fixed<<setprecision(2)<<sphereVolume(3); return 0; }`,explanation:{approach:"V = 4/3    r.",analogy:"Sphere volume formula.",steps:["Multiply 4/3, , and r"],complexity:"Time: O(1), Space: O(1)"}},{id:"prac18",title:"Perimeter of Rectangle",description:"Calculate rectangle perimeter.",difficulty:"EASY",category:"Practice",starterCode:`#include <iostream>
using namespace std;
int rectPerimeter(int l, int w) { return 0; }
int main() { cout<<rectPerimeter(5,3); return 0; }`,expectedOutput:"16",solution:`#include <iostream>
using namespace std;
int rectPerimeter(int l, int w) { return 2*(l+w); }
int main() { cout<<rectPerimeter(5,3); return 0; }`,explanation:{approach:"P = 2  (length + width).",analogy:"Sum of all sides.",steps:["Add length and width","Multiply by 2"],complexity:"Time: O(1), Space: O(1)"}},{id:"prac19",title:"Hypotenuse",description:"Calculate hypotenuse.",difficulty:"EASY",category:"Practice",starterCode:`#include <iostream>
#include <cmath>
using namespace std;
double hypotenuse(double a, double b) { return 0; }
int main() { cout<<hypotenuse(3,4); return 0; }`,expectedOutput:"5",solution:`#include <iostream>
#include <cmath>
using namespace std;
double hypotenuse(double a, double b) { return sqrt(a*a+b*b); }
int main() { cout<<hypotenuse(3,4); return 0; }`,explanation:{approach:"c = (a + b).",analogy:"Pythagorean theorem.",steps:["Square both sides","Sum and sqrt"],complexity:"Time: O(1), Space: O(1)"}},{id:"prac20",title:"Print Multiplication Table",description:"Print table of n.",difficulty:"EASY",category:"Practice",starterCode:`#include <iostream>
using namespace std;
void multiTable(int n) {}
int main() { multiTable(5); return 0; }`,expectedOutput:"5 10 15 20 25 30 35 40 45 50",solution:`#include <iostream>
using namespace std;
void multiTable(int n) { for(int i=1;i<=10;i++) cout<<n*i<<" "; }
int main() { multiTable(5); return 0; }`,explanation:{approach:"Print ni for i=1 to 10.",analogy:"Multiplication table.",steps:["Loop 1 to 10","Print n  i"],complexity:"Time: O(1), Space: O(1)"}}],C5=JSON.parse('[{"id":"prac21","title":"Pointers Swap","description":"Swap using pointers.","difficulty":"EASY","category":"Pointers","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid swapPtr(int *a, int *b) {}\\nint main() { int x=5,y=10; swapPtr(&x,&y); cout<<x<<\\" \\"<<y; return 0; }","expectedOutput":"10 5","solution":"#include <iostream>\\nusing namespace std;\\nvoid swapPtr(int *a, int *b) { int t=*a; *a=*b; *b=t; }\\nint main() { int x=5,y=10; swapPtr(&x,&y); cout<<x<<\\" \\"<<y; return 0; }","explanation":{"approach":"Use pointers to swap values.","analogy":"Dereference to access values.","steps":["Save *a","Assign *b to *a","Assign saved to *b"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"prac22","title":"Pointer Arithmetic","description":"Traverse array with pointer.","difficulty":"EASY","category":"Pointers","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid printArr(int *a, int n) {}\\nint main() { int a[]={1,2,3,4,5}; printArr(a,5); return 0; }","expectedOutput":"1 2 3 4 5","solution":"#include <iostream>\\nusing namespace std;\\nvoid printArr(int *a, int n) { for(int i=0;i<n;i++) cout<<*(a+i)<<\\" \\"; }\\nint main() { int a[]={1,2,3,4,5}; printArr(a,5); return 0; }","explanation":{"approach":"Use pointer arithmetic to traverse.","analogy":"a+i points to ith element.","steps":["*(a+i) gives value at index i"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"prac23","title":"Function Overloading","description":"Overload add function.","difficulty":"EASY","category":"OOP","starterCode":"#include <iostream>\\nusing namespace std;\\nint add2(int a, int b) { return 0; }\\nint add3(int a, int b, int c) { return 0; }\\nint main() { cout<<add2(1,2)<<\\" \\"<<add3(1,2,3); return 0; }","expectedOutput":"3 6","solution":"#include <iostream>\\nusing namespace std;\\nint add2(int a, int b) { return a+b; }\\nint add3(int a, int b, int c) { return a+b+c; }\\nint main() { cout<<add2(1,2)<<\\" \\"<<add3(1,2,3); return 0; }","explanation":{"approach":"Same function name, different parameters.","analogy":"Choose version based on arguments.","steps":["2-param version adds 2","3-param adds 3"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"prac24","title":"Constructor Example","description":"Class with constructor.","difficulty":"EASY","category":"OOP","starterCode":"#include <iostream>\\nusing namespace std;\\nclass Box { int w,h; public: Box(int w, int h) : w(0), h(0) {} int area() { return 0; } };\\nint main() { Box b(5,3); cout<<b.area(); return 0; }","expectedOutput":"15","solution":"#include <iostream>\\nusing namespace std;\\nclass Box { int w,h; public: Box(int w, int h) : w(w), h(h) {} int area() { return w*h; } };\\nint main() { Box b(5,3); cout<<b.area(); return 0; }","explanation":{"approach":"Initialize members in constructor.","analogy":"Constructor sets up object.","steps":["Constructor initializes w and h","area() returns wh"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"prac25","title":"Inheritance Example","description":"Basic inheritance.","difficulty":"EASY","category":"OOP","starterCode":"#include <iostream>\\nusing namespace std;\\nclass Animal { public: void speak() {} };\\nclass Dog : public Animal { public: void speak() {} };\\nint main() { Dog d; d.speak(); return 0; }","expectedOutput":"Woof","solution":"#include <iostream>\\nusing namespace std;\\nclass Animal { public: virtual void speak() { cout<<\\"Sound\\"; } };\\nclass Dog : public Animal { public: void speak() override { cout<<\\"Woof\\"; } };\\nint main() { Dog d; d.speak(); return 0; }","explanation":{"approach":"Child overrides parent method.","analogy":"Dog is-a Animal.","steps":["Dog inherits from Animal","Dog overrides speak()"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"extra11","title":"Minimum Difference BST","description":"Min difference between nodes.","difficulty":"MEDIUM","category":"Trees","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nint minDiff(Node* r) { return 0; }\\nint main() { Node* r=new Node(4); r->l=new Node(2); r->r=new Node(6); r->l->l=new Node(1); r->l->r=new Node(3); cout<<minDiff(r); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nint prev_val=-1,minD=1e9;\\nvoid inorder(Node* r) { if(!r) return; inorder(r->l); if(prev_val>=0) minD=min(minD,r->v-prev_val); prev_val=r->v; inorder(r->r); }\\nint minDiff(Node* r) { prev_val=-1; minD=1e9; inorder(r); return minD; }\\nint main() { Node* r=new Node(4); r->l=new Node(2); r->r=new Node(6); r->l->l=new Node(1); r->l->r=new Node(3); cout<<minDiff(r); return 0; }","explanation":{"approach":"Inorder gives sorted, check consecutive.","analogy":"Adjacent in sorted order.","steps":["Inorder traversal","Track previous and diff"],"complexity":"Time: O(n), Space: O(h)"}},{"id":"extra12","title":"Serialize Binary Tree","description":"Encode tree to string.","difficulty":"HARD","category":"Trees","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nvoid serialize(Node* r) {}\\nint main() { Node* r=new Node(1); r->l=new Node(2); r->r=new Node(3); r->r->l=new Node(4); r->r->r=new Node(5); serialize(r); return 0; }","expectedOutput":"1 2 # # 3 4 # # 5 # #","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nvoid serialize(Node* r) { if(!r) { cout<<\\"# \\"; return; } cout<<r->v<<\\" \\"; serialize(r->l); serialize(r->r); }\\nint main() { Node* r=new Node(1); r->l=new Node(2); r->r=new Node(3); r->r->l=new Node(4); r->r->r=new Node(5); serialize(r); return 0; }","explanation":{"approach":"Preorder with null markers.","analogy":"Encode structure with placeholders.","steps":["Print value or # for null","Recurse left then right"],"complexity":"Time: O(n), Space: O(n)"}},{"id":"extra13","title":"Sliding Window Max","description":"Maximum in each window.","difficulty":"HARD","category":"Sliding Window","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid maxSliding(int a[], int n, int k) {}\\nint main() { int a[]={1,3,-1,-3,5,3,6,7}; maxSliding(a,8,3); return 0; }","expectedOutput":"3 3 5 5 6 7","solution":"#include <iostream>\\nusing namespace std;\\nvoid maxSliding(int a[], int n, int k) { int dq[n],f=0,r=0; for(int i=0;i<n;i++) { while(f<r && dq[f]<=i-k) f++; while(f<r && a[dq[r-1]]<=a[i]) r--; dq[r++]=i; if(i>=k-1) cout<<a[dq[f]]<<\\" \\"; } }\\nint main() { int a[]={1,3,-1,-3,5,3,6,7}; maxSliding(a,8,3); return 0; }","explanation":{"approach":"Monotonic deque.","analogy":"Keep only useful candidates.","steps":["Remove out of window","Remove smaller from back","Front is max"],"complexity":"Time: O(n), Space: O(k)"}},{"id":"extra14","title":"Subarray Sum K","description":"Count subarrays with sum k.","difficulty":"MEDIUM","category":"Hashing","starterCode":"#include <iostream>\\nusing namespace std;\\nint subarraySum(int a[], int n, int k) { return 0; }\\nint main() { int a[]={1,1,1}; cout<<subarraySum(a,3,2); return 0; }","expectedOutput":"2","solution":"#include <iostream>\\nusing namespace std;\\nint subarraySum(int a[], int n, int k) { int c=0; for(int i=0;i<n;i++) { int s=0; for(int j=i;j<n;j++) { s+=a[j]; if(s==k) c++; } } return c; }\\nint main() { int a[]={1,1,1}; cout<<subarraySum(a,3,2); return 0; }","explanation":{"approach":"Check all subarrays.","analogy":"Count matching sums.","steps":["For each start, sum to each end"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"extra15","title":"Longest Substring No Repeat","description":"Longest unique char substring.","difficulty":"MEDIUM","category":"Sliding Window","starterCode":"#include <iostream>\\nusing namespace std;\\nint lengthOfLongest(char s[]) { return 0; }\\nint main() { cout<<lengthOfLongest(\\"abcabcbb\\"); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nint lengthOfLongest(char s[]) { int seen[256]={}; int mx=0,l=0; for(int r=0;s[r];r++) { while(seen[(int)s[r]]) { seen[(int)s[l]]=0; l++; } seen[(int)s[r]]=1; mx=max(mx,r-l+1); } return mx; }\\nint main() { cout<<lengthOfLongest(\\"abcabcbb\\"); return 0; }","explanation":{"approach":"Sliding window with set.","analogy":"Shrink when duplicate found.","steps":["Expand right","Shrink left until unique"],"complexity":"Time: O(n), Space: O(1)"}}]'),O5=JSON.parse('[{"id":"extra1","title":"Binary Search Left Bound","description":"First occurrence of target.","difficulty":"MEDIUM","category":"Binary Search","starterCode":"#include <iostream>\\nusing namespace std;\\nint leftBound(int a[], int n, int t) { return -1; }\\nint main() { int a[]={1,2,2,2,3}; cout<<leftBound(a,5,2); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nint leftBound(int a[], int n, int t) { int l=0, r=n; while(l<r) { int m=(l+r)/2; if(a[m]<t) l=m+1; else r=m; } return l<n && a[l]==t ? l : -1; }\\nint main() { int a[]={1,2,2,2,3}; cout<<leftBound(a,5,2); return 0; }","explanation":{"approach":"Binary search, keep going left when found.","analogy":"Find leftmost boundary.","steps":["If a[m] < t, search right","Else search left (including m)"],"complexity":"Time: O(log n), Space: O(1)"}},{"id":"extra2","title":"Binary Search Right Bound","description":"Last occurrence of target.","difficulty":"MEDIUM","category":"Binary Search","starterCode":"#include <iostream>\\nusing namespace std;\\nint rightBound(int a[], int n, int t) { return -1; }\\nint main() { int a[]={1,2,2,2,3}; cout<<rightBound(a,5,2); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nint rightBound(int a[], int n, int t) { int l=0, r=n; while(l<r) { int m=(l+r)/2; if(a[m]<=t) l=m+1; else r=m; } return l-1>=0 && a[l-1]==t ? l-1 : -1; }\\nint main() { int a[]={1,2,2,2,3}; cout<<rightBound(a,5,2); return 0; }","explanation":{"approach":"Binary search, keep going right when found.","analogy":"Find rightmost boundary.","steps":["If a[m] <= t, search right","Else search left"],"complexity":"Time: O(log n), Space: O(1)"}},{"id":"extra3","title":"Peak Element","description":"Find local maximum.","difficulty":"MEDIUM","category":"Binary Search","starterCode":"#include <iostream>\\nusing namespace std;\\nint findPeak(int a[], int n) { return -1; }\\nint main() { int a[]={1,2,3,1}; cout<<findPeak(a,4); return 0; }","expectedOutput":"2","solution":"#include <iostream>\\nusing namespace std;\\nint findPeak(int a[], int n) { int l=0, r=n-1; while(l<r) { int m=(l+r)/2; if(a[m]>a[m+1]) r=m; else l=m+1; } return l; }\\nint main() { int a[]={1,2,3,1}; cout<<findPeak(a,4); return 0; }","explanation":{"approach":"Go towards larger neighbor.","analogy":"Climb the hill, peak is where you stop.","steps":["If a[m] > a[m+1], go left","Else go right"],"complexity":"Time: O(log n), Space: O(1)"}},{"id":"extra4","title":"Search in Rotated Array","description":"Search sorted rotated array.","difficulty":"MEDIUM","category":"Binary Search","starterCode":"#include <iostream>\\nusing namespace std;\\nint search(int a[], int n, int t) { return -1; }\\nint main() { int a[]={4,5,6,7,0,1,2}; cout<<search(a,7,0); return 0; }","expectedOutput":"4","solution":"#include <iostream>\\nusing namespace std;\\nint search(int a[], int n, int t) { int l=0, r=n-1; while(l<=r) { int m=(l+r)/2; if(a[m]==t) return m; if(a[l]<=a[m]) { if(a[l]<=t && t<a[m]) r=m-1; else l=m+1; } else { if(a[m]<t && t<=a[r]) l=m+1; else r=m-1; } } return -1; }\\nint main() { int a[]={4,5,6,7,0,1,2}; cout<<search(a,7,0); return 0; }","explanation":{"approach":"Determine which half is sorted, search there.","analogy":"One half is always sorted.","steps":["Check which half is sorted","If target in sorted half, search there","Else search other half"],"complexity":"Time: O(log n), Space: O(1)"}},{"id":"extra5","title":"Find Minimum in Rotated","description":"Min in rotated sorted array.","difficulty":"MEDIUM","category":"Binary Search","starterCode":"#include <iostream>\\nusing namespace std;\\nint findMin(int a[], int n) { return 0; }\\nint main() { int a[]={3,4,5,1,2}; cout<<findMin(a,5); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nint findMin(int a[], int n) { int l=0, r=n-1; while(l<r) { int m=(l+r)/2; if(a[m]>a[r]) l=m+1; else r=m; } return a[l]; }\\nint main() { int a[]={3,4,5,1,2}; cout<<findMin(a,5); return 0; }","explanation":{"approach":"Binary search for rotation point.","analogy":"Find where the break is.","steps":["If a[m] > a[r], min is right","Else min is left or at m"],"complexity":"Time: O(log n), Space: O(1)"}},{"id":"extra6","title":"Square Root Binary Search","description":"Integer square root.","difficulty":"EASY","category":"Binary Search","starterCode":"#include <iostream>\\nusing namespace std;\\nint mySqrt(int n) { return 0; }\\nint main() { cout<<mySqrt(8); return 0; }","expectedOutput":"2","solution":"#include <iostream>\\nusing namespace std;\\nint mySqrt(int n) { if(n==0) return 0; int l=1, r=n, ans=0; while(l<=r) { int m=l+(r-l)/2; if(m<=n/m) { ans=m; l=m+1; } else r=m-1; } return ans; }\\nint main() { cout<<mySqrt(8); return 0; }","explanation":{"approach":"Binary search for largest x where x*x <= n.","analogy":"Find the floor of square root.","steps":["Check if m*m <= n","If yes, try larger","If no, try smaller"],"complexity":"Time: O(log n), Space: O(1)"}},{"id":"extra7","title":"Search 2D Matrix","description":"Search in sorted matrix.","difficulty":"MEDIUM","category":"Binary Search","starterCode":"#include <iostream>\\nusing namespace std;\\nbool searchMatrix(int m[][4], int r, int c, int t) { return false; }\\nint main() { int m[3][4]={{1,3,5,7},{10,11,16,20},{23,30,34,60}}; cout<<searchMatrix(m,3,4,3); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool searchMatrix(int m[][4], int r, int c, int t) { int lo=0, hi=r*c-1; while(lo<=hi) { int mid=(lo+hi)/2; int val=m[mid/c][mid%c]; if(val==t) return true; if(val<t) lo=mid+1; else hi=mid-1; } return false; }\\nint main() { int m[3][4]={{1,3,5,7},{10,11,16,20},{23,30,34,60}}; cout<<searchMatrix(m,3,4,3); return 0; }","explanation":{"approach":"Treat matrix as 1D array.","analogy":"Row and column from single index.","steps":["Binary search on virtual 1D","Index: row = mid/c, col = mid%c"],"complexity":"Time: O(log(rc)), Space: O(1)"}},{"id":"extra8","title":"Kth Smallest in Matrix","description":"Find kth smallest element.","difficulty":"MEDIUM","category":"Binary Search","starterCode":"#include <iostream>\\nusing namespace std;\\nint kthSmallest(int m[][3], int n, int k) { return 0; }\\nint main() { int m[3][3]={{1,5,9},{10,11,13},{12,13,15}}; cout<<kthSmallest(m,3,5); return 0; }","expectedOutput":"11","solution":"#include <iostream>\\nusing namespace std;\\nint countLE(int m[][3], int n, int mid) { int c=0, col=n-1; for(int row=0;row<n;row++) { while(col>=0 && m[row][col]>mid) col--; c+=col+1; } return c; }\\nint kthSmallest(int m[][3], int n, int k) { int lo=m[0][0], hi=m[n-1][n-1]; while(lo<hi) { int mid=lo+(hi-lo)/2; if(countLE(m,n,mid)>=k) hi=mid; else lo=mid+1; } return lo; }\\nint main() { int m[3][3]={{1,5,9},{10,11,13},{12,13,15}}; cout<<kthSmallest(m,3,5); return 0; }","explanation":{"approach":"Binary search on value, count elements <= mid.","analogy":"Find value where exactly k elements are smaller.","steps":["Binary search on value range","Count elements <= mid","Adjust search based on count"],"complexity":"Time: O(n log(max-min)), Space: O(1)"}},{"id":"extra9","title":"Allocate Minimum Pages","description":"Min max pages per student.","difficulty":"HARD","category":"Binary Search","starterCode":"#include <iostream>\\nusing namespace std;\\nint allocateBooks(int a[], int n, int k) { return 0; }\\nint main() { int a[]={12,34,67,90}; cout<<allocateBooks(a,4,2); return 0; }","expectedOutput":"113","solution":"#include <iostream>\\nusing namespace std;\\nbool canAllocate(int a[], int n, int k, int mid) { int s=1, pages=0; for(int i=0;i<n;i++) { if(a[i]>mid) return false; if(pages+a[i]>mid) { s++; pages=a[i]; } else pages+=a[i]; } return s<=k; }\\nint allocateBooks(int a[], int n, int k) { int lo=0, hi=0; for(int i=0;i<n;i++) { lo=max(lo,a[i]); hi+=a[i]; } while(lo<hi) { int mid=(lo+hi)/2; if(canAllocate(a,n,k,mid)) hi=mid; else lo=mid+1; } return lo; }\\nint main() { int a[]={12,34,67,90}; cout<<allocateBooks(a,4,2); return 0; }","explanation":{"approach":"Binary search on answer (max pages).","analogy":"Find minimum possible maximum pages.","steps":["Binary search on max pages","Check if allocation possible","Minimize the maximum"],"complexity":"Time: O(n log sum), Space: O(1)"}},{"id":"extra10","title":"Aggressive Cows","description":"Max minimum distance.","difficulty":"HARD","category":"Binary Search","starterCode":"#include <iostream>\\nusing namespace std;\\nint aggressiveCows(int pos[], int n, int c) { return 0; }\\nint main() { int pos[]={1,2,4,8,9}; cout<<aggressiveCows(pos,5,3); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nbool canPlace(int pos[], int n, int c, int d) { int cows=1, last=pos[0]; for(int i=1;i<n;i++) if(pos[i]-last>=d) { cows++; last=pos[i]; } return cows>=c; }\\nint aggressiveCows(int pos[], int n, int c) { for(int i=0;i<n-1;i++) for(int j=0;j<n-i-1;j++) if(pos[j]>pos[j+1]) swap(pos[j],pos[j+1]); int lo=1, hi=pos[n-1]-pos[0], ans=0; while(lo<=hi) { int mid=(lo+hi)/2; if(canPlace(pos,n,c,mid)) { ans=mid; lo=mid+1; } else hi=mid-1; } return ans; }\\nint main() { int pos[]={1,2,4,8,9}; cout<<aggressiveCows(pos,5,3); return 0; }","explanation":{"approach":"Binary search on answer (min distance).","analogy":"Maximize the minimum gap between cows.","steps":["Sort positions","Binary search on minimum distance","Check if placement possible"],"complexity":"Time: O(n log(max-min)), Space: O(1)"}}]'),_5=JSON.parse(`[{"id":"ext21","title":"Jump Game II","description":"Min jumps to end.","difficulty":"MEDIUM","category":"Greedy","starterCode":"#include <iostream>\\nusing namespace std;\\nint jump(int nums[], int n) { return 0; }\\nint main() { int a[]={2,3,1,1,4}; cout<<jump(a,5); return 0; }","expectedOutput":"2","solution":"#include <iostream>\\nusing namespace std;\\nint jump(int nums[], int n) { int jumps=0,cur=0,far=0; for(int i=0;i<n-1;i++) { far=max(far,i+nums[i]); if(i==cur) { jumps++; cur=far; } } return jumps; }\\nint main() { int a[]={2,3,1,1,4}; cout<<jump(a,5); return 0; }","explanation":{"approach":"Greedy BFS.","steps":["Track current level end","Jump when reaching current end"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"ext22","title":"Gas Station","description":"Starting station to complete circuit.","difficulty":"MEDIUM","category":"Greedy","starterCode":"#include <iostream>\\nusing namespace std;\\nint canCompleteCircuit(int gas[], int cost[], int n) { return -1; }\\nint main() { int g[]={1,2,3,4,5}; int c[]={3,4,5,1,2}; cout<<canCompleteCircuit(g,c,5); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nint canCompleteCircuit(int gas[], int cost[], int n) { int total=0,tank=0,start=0; for(int i=0;i<n;i++) { total+=gas[i]-cost[i]; tank+=gas[i]-cost[i]; if(tank<0) { tank=0; start=i+1; } } return total>=0?start:-1; }\\nint main() { int g[]={1,2,3,4,5}; int c[]={3,4,5,1,2}; cout<<canCompleteCircuit(g,c,5); return 0; }","explanation":{"approach":"Track tank and restart point.","steps":["If tank goes negative, restart from next","Check if total is non-negative"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"ext23","title":"Candy","description":"Min candies for ratings.","difficulty":"HARD","category":"Greedy","starterCode":"#include <iostream>\\nusing namespace std;\\nint candy(int ratings[], int n) { return 0; }\\nint main() { int r[]={1,0,2}; cout<<candy(r,3); return 0; }","expectedOutput":"5","solution":"#include <iostream>\\nusing namespace std;\\nint candy(int ratings[], int n) { int c[n]; for(int i=0;i<n;i++) c[i]=1; for(int i=1;i<n;i++) if(ratings[i]>ratings[i-1]) c[i]=c[i-1]+1; for(int i=n-2;i>=0;i--) if(ratings[i]>ratings[i+1]) c[i]=max(c[i],c[i+1]+1); int sum=0; for(int i=0;i<n;i++) sum+=c[i]; return sum; }\\nint main() { int r[]={1,0,2}; cout<<candy(r,3); return 0; }","explanation":{"approach":"Two pass greedy.","steps":["Left to right pass","Right to left pass"],"complexity":"Time: O(n), Space: O(n)"}},{"id":"ext24","title":"Partition Labels","description":"Max partitions where each char appears once.","difficulty":"MEDIUM","category":"Greedy","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid partitionLabels(char s[]) {}\\nint main() { partitionLabels(\\"ababcbacadefegdehijhklij\\"); return 0; }","expectedOutput":"9 7 8","solution":"#include <iostream>\\nusing namespace std;\\nvoid partitionLabels(char s[]) { int last[26]={}; int n=0; while(s[n]) { last[s[n]-'a']=n; n++; } int start=0,end=0; for(int i=0;i<n;i++) { end=max(end,last[s[i]-'a']); if(i==end) { cout<<end-start+1<<\\" \\"; start=i+1; } } }\\nint main() { partitionLabels(\\"ababcbacadefegdehijhklij\\"); return 0; }","explanation":{"approach":"Track last occurrence.","steps":["Find last occurrence of each char","Extend partition to include all"],"complexity":"Time: O(n), Space: O(26)"}},{"id":"ext25","title":"Task Scheduler","description":"Min time for tasks with cooldown.","difficulty":"MEDIUM","category":"Greedy","starterCode":"#include <iostream>\\nusing namespace std;\\nint leastInterval(char tasks[], int n, int k) { return 0; }\\nint main() { char t[]={'A','A','A','B','B','B'}; cout<<leastInterval(t,6,2); return 0; }","expectedOutput":"8","solution":"#include <iostream>\\nusing namespace std;\\nint leastInterval(char tasks[], int n, int k) { int cnt[26]={}; for(int i=0;i<n;i++) cnt[tasks[i]-'A']++; int mx=0,mxCnt=0; for(int i=0;i<26;i++) { if(cnt[i]>mx) { mx=cnt[i]; mxCnt=1; } else if(cnt[i]==mx) mxCnt++; } return max(n,(mx-1)*(k+1)+mxCnt); }\\nint main() { char t[]={'A','A','A','B','B','B'}; cout<<leastInterval(t,6,2); return 0; }","explanation":{"approach":"Calculate based on max frequency.","steps":["Find most frequent task","Fill slots or use all tasks"],"complexity":"Time: O(n), Space: O(26)"}},{"id":"ext26","title":"Two Sum Hashing","description":"Two sum with hashing.","difficulty":"EASY","category":"Hashing","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid twoSum(int nums[], int n, int target) {}\\nint main() { int a[]={2,7,11,15}; twoSum(a,4,9); return 0; }","expectedOutput":"0 1","solution":"#include <iostream>\\nusing namespace std;\\nvoid twoSum(int nums[], int n, int target) { for(int i=0;i<n;i++) for(int j=i+1;j<n;j++) if(nums[i]+nums[j]==target) { cout<<i<<\\" \\"<<j; return; } }\\nint main() { int a[]={2,7,11,15}; twoSum(a,4,9); return 0; }","explanation":{"approach":"Check all pairs.","steps":["For each pair","Check if sum equals target"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"ext27","title":"Group Anagrams","description":"Group anagrams together.","difficulty":"MEDIUM","category":"Hashing","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid groupAnagrams(char* strs[], int n) {}\\nint main() { char* s[]={\\"eat\\",\\"tea\\",\\"tan\\",\\"ate\\",\\"nat\\",\\"bat\\"}; groupAnagrams(s,6); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nvoid groupAnagrams(char* strs[], int n) { int groups=0; bool used[100]={}; for(int i=0;i<n;i++) { if(used[i]) continue; groups++; used[i]=true; int cnt1[26]={}; for(int k=0;strs[i][k];k++) cnt1[strs[i][k]-'a']++; for(int j=i+1;j<n;j++) { if(used[j]) continue; int cnt2[26]={}; for(int k=0;strs[j][k];k++) cnt2[strs[j][k]-'a']++; bool eq=true; for(int k=0;k<26;k++) if(cnt1[k]!=cnt2[k]) { eq=false; break; } if(eq) used[j]=true; } } cout<<groups; }\\nint main() { char* s[]={\\"eat\\",\\"tea\\",\\"tan\\",\\"ate\\",\\"nat\\",\\"bat\\"}; groupAnagrams(s,6); return 0; }","explanation":{"approach":"Sort or count chars.","steps":["For each string, create signature","Group by signature"],"complexity":"Time: O(n  k), Space: O(n  k)"}},{"id":"ext28","title":"Valid Anagram","description":"Check if anagram.","difficulty":"EASY","category":"Hashing","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isAnagram(char s[], char t[]) { return false; }\\nint main() { cout<<isAnagram(\\"anagram\\",\\"nagaram\\"); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isAnagram(char s[], char t[]) { int cnt[26]={}; int ls=0,lt=0; while(s[ls]) { cnt[s[ls]-'a']++; ls++; } while(t[lt]) { cnt[t[lt]-'a']--; lt++; } if(ls!=lt) return false; for(int i=0;i<26;i++) if(cnt[i]) return false; return true; }\\nint main() { cout<<isAnagram(\\"anagram\\",\\"nagaram\\"); return 0; }","explanation":{"approach":"Count chars.","steps":["Count in s, decrement in t","All counts should be 0"],"complexity":"Time: O(n), Space: O(26)"}},{"id":"ext29","title":"Contains Duplicate II","description":"Duplicate within k distance.","difficulty":"EASY","category":"Hashing","starterCode":"#include <iostream>\\nusing namespace std;\\nbool containsNearbyDuplicate(int nums[], int n, int k) { return false; }\\nint main() { int a[]={1,2,3,1}; cout<<containsNearbyDuplicate(a,4,3); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool containsNearbyDuplicate(int nums[], int n, int k) { for(int i=0;i<n;i++) for(int j=i+1;j<n&&j<=i+k;j++) if(nums[i]==nums[j]) return true; return false; }\\nint main() { int a[]={1,2,3,1}; cout<<containsNearbyDuplicate(a,4,3); return 0; }","explanation":{"approach":"Check pairs within k.","steps":["For each i, check i+1 to i+k","Return true if duplicate found"],"complexity":"Time: O(nk), Space: O(1)"}},{"id":"ext30","title":"Longest Consecutive","description":"Longest consecutive sequence.","difficulty":"MEDIUM","category":"Hashing","starterCode":"#include <iostream>\\nusing namespace std;\\nint longestConsecutive(int nums[], int n) { return 0; }\\nint main() { int a[]={100,4,200,1,3,2}; cout<<longestConsecutive(a,6); return 0; }","expectedOutput":"4","solution":"#include <iostream>\\nusing namespace std;\\nint longestConsecutive(int nums[], int n) { if(n==0) return 0; for(int i=0;i<n-1;i++) for(int j=0;j<n-i-1;j++) if(nums[j]>nums[j+1]) swap(nums[j],nums[j+1]); int mx=1,cur=1; for(int i=1;i<n;i++) { if(nums[i]==nums[i-1]) continue; if(nums[i]==nums[i-1]+1) cur++; else cur=1; mx=max(mx,cur); } return mx; }\\nint main() { int a[]={100,4,200,1,3,2}; cout<<longestConsecutive(a,6); return 0; }","explanation":{"approach":"Sort and count.","steps":["Sort array","Count consecutive runs"],"complexity":"Time: O(n log n), Space: O(1)"}}]`),T5=JSON.parse('[{"id":"ext31","title":"Kth Largest","description":"Kth largest in stream.","difficulty":"EASY","category":"Heap","starterCode":"#include <iostream>\\nusing namespace std;\\nclass KthLargest {\\npublic:\\n    KthLargest(int k, int nums[], int n) {}\\n    int add(int val) { return 0; }\\n};\\nint main() { int a[]={4,5,8,2}; KthLargest kl(3,a,4); cout<<kl.add(3); return 0; }","expectedOutput":"4","solution":"#include <iostream>\\nusing namespace std;\\nclass KthLargest { int arr[100],n,k; public: KthLargest(int k, int nums[], int sz):k(k),n(0) { for(int i=0;i<sz;i++) add(nums[i]); } int add(int val) { arr[n++]=val; for(int i=0;i<n-1;i++) for(int j=0;j<n-i-1;j++) if(arr[j]<arr[j+1]) swap(arr[j],arr[j+1]); return arr[k-1]; } };\\nint main() { int a[]={4,5,8,2}; KthLargest kl(3,a,4); cout<<kl.add(3); return 0; }","explanation":{"approach":"Sort and return kth.","steps":["Maintain sorted array","Return kth largest"],"complexity":"Time: O(n log n), Space: O(n)"}},{"id":"ext32","title":"Top K Frequent","description":"K most frequent elements.","difficulty":"MEDIUM","category":"Heap","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid topKFrequent(int nums[], int n, int k) {}\\nint main() { int a[]={1,1,1,2,2,3}; topKFrequent(a,6,2); return 0; }","expectedOutput":"1 2","solution":"#include <iostream>\\nusing namespace std;\\nvoid topKFrequent(int nums[], int n, int k) { int vals[100],cnt[100],m=0; for(int i=0;i<n;i++) { int j=0; while(j<m&&vals[j]!=nums[i]) j++; if(j<m) cnt[j]++; else { vals[m]=nums[i]; cnt[m++]=1; } } for(int i=0;i<k;i++) { int mx=0; for(int j=1;j<m;j++) if(cnt[j]>cnt[mx]) mx=j; cout<<vals[mx]<<\\" \\"; cnt[mx]=-1; } }\\nint main() { int a[]={1,1,1,2,2,3}; topKFrequent(a,6,2); return 0; }","explanation":{"approach":"Count and pick top k.","steps":["Count frequencies","Select k highest"],"complexity":"Time: O(n  k), Space: O(n)"}},{"id":"ext33","title":"Find Kth Smallest","description":"Kth smallest in sorted matrix.","difficulty":"MEDIUM","category":"Heap","starterCode":"#include <iostream>\\nusing namespace std;\\nint kthSmallest(int m[][3], int n, int k) { return 0; }\\nint main() { int m[][3]={{1,5,9},{10,11,13},{12,13,15}}; cout<<kthSmallest(m,3,8); return 0; }","expectedOutput":"13","solution":"#include <iostream>\\nusing namespace std;\\nint kthSmallest(int m[][3], int n, int k) { int arr[100],c=0; for(int i=0;i<n;i++) for(int j=0;j<n;j++) arr[c++]=m[i][j]; for(int i=0;i<c-1;i++) for(int j=0;j<c-i-1;j++) if(arr[j]>arr[j+1]) swap(arr[j],arr[j+1]); return arr[k-1]; }\\nint main() { int m[][3]={{1,5,9},{10,11,13},{12,13,15}}; cout<<kthSmallest(m,3,8); return 0; }","explanation":{"approach":"Flatten and sort.","steps":["Put all elements in array","Sort and return kth"],"complexity":"Time: O(n log n), Space: O(n)"}},{"id":"ext34","title":"Minimum Meeting Rooms","description":"Min rooms needed.","difficulty":"MEDIUM","category":"Heap","starterCode":"#include <iostream>\\nusing namespace std;\\nint minMeetingRooms(int start[], int end[], int n) { return 0; }\\nint main() { int s[]={0,5,15}; int e[]={30,10,20}; cout<<minMeetingRooms(s,e,3); return 0; }","expectedOutput":"2","solution":"#include <iostream>\\nusing namespace std;\\nint minMeetingRooms(int start[], int end[], int n) { for(int i=0;i<n-1;i++) for(int j=0;j<n-i-1;j++) if(start[j]>start[j+1]) { swap(start[j],start[j+1]); swap(end[j],end[j+1]); } int rooms[100],m=0; for(int i=0;i<n;i++) { int j=0; while(j<m&&rooms[j]>start[i]) j++; if(j<m) rooms[j]=end[i]; else rooms[m++]=end[i]; } return m; }\\nint main() { int s[]={0,5,15}; int e[]={30,10,20}; cout<<minMeetingRooms(s,e,3); return 0; }","explanation":{"approach":"Sort and assign rooms.","steps":["Sort by start time","Reuse room if available, else add new"],"complexity":"Time: O(n log n), Space: O(n)"}},{"id":"ext35","title":"Sliding Window Max","description":"Max in each window.","difficulty":"HARD","category":"Sliding Window","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid maxSlidingWindow(int nums[], int n, int k) {}\\nint main() { int a[]={1,3,-1,-3,5,3,6,7}; maxSlidingWindow(a,8,3); return 0; }","expectedOutput":"3 3 5 5 6 7","solution":"#include <iostream>\\nusing namespace std;\\nvoid maxSlidingWindow(int nums[], int n, int k) { for(int i=0;i<=n-k;i++) { int mx=nums[i]; for(int j=i;j<i+k;j++) mx=max(mx,nums[j]); cout<<mx<<\\" \\"; } }\\nint main() { int a[]={1,3,-1,-3,5,3,6,7}; maxSlidingWindow(a,8,3); return 0; }","explanation":{"approach":"Check each window.","steps":["For each window","Find maximum"],"complexity":"Time: O(nk), Space: O(1)"}},{"id":"ext36","title":"Implement Trie","description":"Prefix tree implementation.","difficulty":"MEDIUM","category":"Trie","starterCode":"#include <iostream>\\nusing namespace std;\\nclass Trie {\\npublic:\\n    void insert(char word[]) {}\\n    bool search(char word[]) { return false; }\\n    bool startsWith(char prefix[]) { return false; }\\n};\\nint main() { Trie t; t.insert(\\"apple\\"); cout<<t.search(\\"apple\\"); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nclass Trie { char words[100][50]; int n; public: Trie():n(0){} void insert(char word[]) { int i=0; while(word[i]) { words[n][i]=word[i]; i++; } words[n++][i]=0; } bool search(char word[]) { for(int i=0;i<n;i++) { bool eq=true; for(int j=0;word[j]||words[i][j];j++) if(word[j]!=words[i][j]) { eq=false; break; } if(eq) return true; } return false; } bool startsWith(char pre[]) { for(int i=0;i<n;i++) { bool m=true; for(int j=0;pre[j];j++) if(words[i][j]!=pre[j]) { m=false; break; } if(m) return true; } return false; } };\\nint main() { Trie t; t.insert(\\"apple\\"); cout<<t.search(\\"apple\\"); return 0; }","explanation":{"approach":"Store words array.","steps":["Insert adds to array","Search checks exact match","StartsWith checks prefix"],"complexity":"Time: O(n  L), Space: O(n  L)"}},{"id":"ext37","title":"Word Break","description":"Can segment into words.","difficulty":"MEDIUM","category":"Trie","starterCode":"#include <iostream>\\nusing namespace std;\\nbool wordBreak(char s[], char* dict[], int n) { return false; }\\nint main() { char* d[]={\\"leet\\",\\"code\\"}; cout<<wordBreak(\\"leetcode\\",d,2); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool wordBreak(char s[], char* dict[], int n) { int len=0; while(s[len]) len++; bool dp[len+1]={}; dp[0]=true; for(int i=1;i<=len;i++) for(int j=0;j<n;j++) { int wl=0; while(dict[j][wl]) wl++; if(i>=wl&&dp[i-wl]) { bool m=true; for(int k=0;k<wl;k++) if(s[i-wl+k]!=dict[j][k]) { m=false; break; } if(m) dp[i]=true; } } return dp[len]; }\\nint main() { char* d[]={\\"leet\\",\\"code\\"}; cout<<wordBreak(\\"leetcode\\",d,2); return 0; }","explanation":{"approach":"DP with word matching.","steps":["dp[i] = can form s[0..i-1]","Try each word ending at i"],"complexity":"Time: O(n  m  L), Space: O(n)"}},{"id":"ext38","title":"Range Sum Query","description":"Sum of range [i,j].","difficulty":"EASY","category":"Segment Tree","starterCode":"#include <iostream>\\nusing namespace std;\\nclass NumArray {\\n    int a[100],n;\\npublic:\\n    NumArray(int nums[], int sz) { n=sz; for(int i=0;i<n;i++) a[i]=nums[i]; }\\n    int sumRange(int i, int j) { int s=0; for(int k=i;k<=j;k++) s+=a[k]; return s; }\\n};\\nint main() { int a[]={-2,0,3,-5,2,-1}; NumArray na(a,6); cout<<na.sumRange(0,2); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nclass NumArray { int pre[101],n; public: NumArray(int nums[], int sz) { n=sz; pre[0]=0; for(int i=0;i<n;i++) pre[i+1]=pre[i]+nums[i]; } int sumRange(int i, int j) { return pre[j+1]-pre[i]; } };\\nint main() { int a[]={-2,0,3,-5,2,-1}; NumArray na(a,6); cout<<na.sumRange(0,2); return 0; }","explanation":{"approach":"Prefix sum.","steps":["Precompute prefix sums","Return pre[j+1] - pre[i]"],"complexity":"Time: O(1) query, Space: O(n)"}},{"id":"ext39","title":"Range Sum 2D","description":"Sum of rectangle.","difficulty":"MEDIUM","category":"Segment Tree","starterCode":"#include <iostream>\\nusing namespace std;\\nclass NumMatrix {\\n    int m[10][10],r,c;\\npublic:\\n    NumMatrix(int mat[][5], int rows, int cols) { r=rows; c=cols; for(int i=0;i<r;i++) for(int j=0;j<c;j++) m[i][j]=mat[i][j]; }\\n    int sumRegion(int r1, int c1, int r2, int c2) { int s=0; for(int i=r1;i<=r2;i++) for(int j=c1;j<=c2;j++) s+=m[i][j]; return s; }\\n};\\nint main() { int m[][5]={{3,0,1,4,2},{5,6,3,2,1},{1,2,0,1,5},{4,1,0,1,7},{1,0,3,0,5}}; NumMatrix nm(m,5,5); cout<<nm.sumRegion(2,1,4,3); return 0; }","expectedOutput":"8","solution":"#include <iostream>\\nusing namespace std;\\nclass NumMatrix { int pre[11][11],r,c; public: NumMatrix(int mat[][5], int rows, int cols) { r=rows; c=cols; for(int i=0;i<=r;i++) pre[i][0]=0; for(int j=0;j<=c;j++) pre[0][j]=0; for(int i=1;i<=r;i++) for(int j=1;j<=c;j++) pre[i][j]=mat[i-1][j-1]+pre[i-1][j]+pre[i][j-1]-pre[i-1][j-1]; } int sumRegion(int r1, int c1, int r2, int c2) { return pre[r2+1][c2+1]-pre[r1][c2+1]-pre[r2+1][c1]+pre[r1][c1]; } };\\nint main() { int m[][5]={{3,0,1,4,2},{5,6,3,2,1},{1,2,0,1,5},{4,1,0,1,7},{1,0,3,0,5}}; NumMatrix nm(m,5,5); cout<<nm.sumRegion(2,1,4,3); return 0; }","explanation":{"approach":"2D prefix sum.","steps":["Precompute 2D prefix sums","Use inclusion-exclusion"],"complexity":"Time: O(1) query, Space: O(mn)"}},{"id":"ext40","title":"Count of Smaller","description":"Count smaller elements to right.","difficulty":"HARD","category":"Segment Tree","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid countSmaller(int nums[], int n) {}\\nint main() { int a[]={5,2,6,1}; countSmaller(a,4); return 0; }","expectedOutput":"2 1 1 0","solution":"#include <iostream>\\nusing namespace std;\\nvoid countSmaller(int nums[], int n) { for(int i=0;i<n;i++) { int cnt=0; for(int j=i+1;j<n;j++) if(nums[j]<nums[i]) cnt++; cout<<cnt<<\\" \\"; } }\\nint main() { int a[]={5,2,6,1}; countSmaller(a,4); return 0; }","explanation":{"approach":"Check all pairs.","steps":["For each element","Count smaller elements to right"],"complexity":"Time: O(n), Space: O(1)"}}]'),k5=[{id:"math1",title:"Fibonacci Series",description:"Print first n Fibonacci numbers.",difficulty:"EASY",category:"Math",starterCode:`#include <iostream>
using namespace std;
void fibonacci(int n) {}
int main() { fibonacci(10); return 0; }`,expectedOutput:"0 1 1 2 3 5 8 13 21 34",solution:`#include <iostream>
using namespace std;
void fibonacci(int n) { int a=0, b=1; for(int i=0;i<n;i++) { cout<<a<<" "; int c=a+b; a=b; b=c; } }
int main() { fibonacci(10); return 0; }`,explanation:{approach:"Each number is sum of previous two.",analogy:"Rabbit breeding pattern.",steps:["Start with 0, 1","Each next = sum of previous two"],complexity:"Time: O(n), Space: O(1)"}},{id:"math2",title:"Pascal's Triangle Row",description:"Print nth row.",difficulty:"EASY",category:"Math",starterCode:`#include <iostream>
using namespace std;
void pascalRow(int n) {}
int main() { pascalRow(5); return 0; }`,expectedOutput:"1 4 6 4 1",solution:`#include <iostream>
using namespace std;
void pascalRow(int n) { int c=1; for(int i=0;i<n;i++) { cout<<c<<" "; c=c*(n-1-i)/(i+1); } }
int main() { pascalRow(5); return 0; }`,explanation:{approach:"Use nCr formula iteratively.",analogy:"Each row is binomial coefficients.",steps:["Start with 1","Multiply by (n-1-i)/(i+1)"],complexity:"Time: O(n), Space: O(1)"}},{id:"math3",title:"Catalan Number",description:"Nth Catalan number.",difficulty:"MEDIUM",category:"Math",starterCode:`#include <iostream>
using namespace std;
long long catalan(int n) { return 0; }
int main() { cout<<catalan(5); return 0; }`,expectedOutput:"42",solution:`#include <iostream>
using namespace std;
long long catalan(int n) { long long dp[n+1]={}; dp[0]=dp[1]=1; for(int i=2;i<=n;i++) for(int j=0;j<i;j++) dp[i]+=dp[j]*dp[i-1-j]; return dp[n]; }
int main() { cout<<catalan(5); return 0; }`,explanation:{approach:"C(n) = sum of C(i) * C(n-1-i).",analogy:"Count valid parentheses, BST shapes.",steps:["Use DP to avoid recomputation","Sum all splits"],complexity:"Time: O(n), Space: O(n)"}},{id:"math4",title:"NCR Calculation",description:"Binomial coefficient.",difficulty:"EASY",category:"Math",starterCode:`#include <iostream>
using namespace std;
long long nCr(int n, int r) { return 0; }
int main() { cout<<nCr(10,3); return 0; }`,expectedOutput:"120",solution:`#include <iostream>
using namespace std;
long long nCr(int n, int r) { if(r>n-r) r=n-r; long long res=1; for(int i=0;i<r;i++) { res*=(n-i); res/=(i+1); } return res; }
int main() { cout<<nCr(10,3); return 0; }`,explanation:{approach:"nCr = n!/(r!(n-r)!), computed iteratively.",analogy:"Ways to choose r items from n.",steps:["Use smaller r","Multiply/divide progressively"],complexity:"Time: O(r), Space: O(1)"}},{id:"math5",title:"Power Set Size",description:"Number of subsets.",difficulty:"EASY",category:"Math",starterCode:`#include <iostream>
using namespace std;
int powerSetSize(int n) { return 0; }
int main() { cout<<powerSetSize(4); return 0; }`,expectedOutput:"16",solution:`#include <iostream>
using namespace std;
int powerSetSize(int n) { return 1<<n; }
int main() { cout<<powerSetSize(4); return 0; }`,explanation:{approach:"2^n subsets for n elements.",analogy:"Each element: include or exclude.",steps:["Return 2^n"],complexity:"Time: O(1), Space: O(1)"}},{id:"math6",title:"Count Set Bits 1 to N",description:"Total set bits from 1 to n.",difficulty:"MEDIUM",category:"Math",starterCode:`#include <iostream>
using namespace std;
int countSetBits(int n) { return 0; }
int main() { cout<<countSetBits(7); return 0; }`,expectedOutput:"12",solution:`#include <iostream>
using namespace std;
int countSetBits(int n) { int total=0; for(int i=1;i<=n;i++) { int x=i; while(x) { total+=x&1; x>>=1; } } return total; }
int main() { cout<<countSetBits(7); return 0; }`,explanation:{approach:"Count bits in each number.",analogy:"Sum all 1-bits from 1 to n.",steps:["For each number 1 to n","Count its set bits","Sum all"],complexity:"Time: O(n log n), Space: O(1)"}},{id:"math7",title:"Sum of Multiples",description:"Sum of multiples of 3 or 5.",difficulty:"EASY",category:"Math",starterCode:`#include <iostream>
using namespace std;
int sumMultiples(int n) { return 0; }
int main() { cout<<sumMultiples(10); return 0; }`,expectedOutput:"23",solution:`#include <iostream>
using namespace std;
int sumMultiples(int n) { int sum=0; for(int i=1;i<n;i++) if(i%3==0||i%5==0) sum+=i; return sum; }
int main() { cout<<sumMultiples(10); return 0; }`,explanation:{approach:"Check each number for divisibility.",analogy:"FizzBuzz sum.",steps:["For each i < n","If divisible by 3 or 5, add"],complexity:"Time: O(n), Space: O(1)"}},{id:"math8",title:"Digital Root",description:"Single digit recursive sum.",difficulty:"EASY",category:"Math",starterCode:`#include <iostream>
using namespace std;
int digitalRoot(int n) { return 0; }
int main() { cout<<digitalRoot(12345); return 0; }`,expectedOutput:"6",solution:`#include <iostream>
using namespace std;
int digitalRoot(int n) { if(n==0) return 0; return 1+(n-1)%9; }
int main() { cout<<digitalRoot(12345); return 0; }`,explanation:{approach:"Formula: 1 + (n-1) mod 9.",analogy:"Keep summing digits until single digit.",steps:["Use modulo 9 trick"],complexity:"Time: O(1), Space: O(1)"}},{id:"math9",title:"Trailing Zeros in Factorial",description:"Count trailing zeros.",difficulty:"EASY",category:"Math",starterCode:`#include <iostream>
using namespace std;
int trailingZeros(int n) { return 0; }
int main() { cout<<trailingZeros(25); return 0; }`,expectedOutput:"6",solution:`#include <iostream>
using namespace std;
int trailingZeros(int n) { int c=0; while(n>=5) { n/=5; c+=n; } return c; }
int main() { cout<<trailingZeros(25); return 0; }`,explanation:{approach:"Count factors of 5 (pairs with 2s).",analogy:"Each 5 with a 2 makes 10.",steps:["Count n/5 + n/25 + n/125 + ..."],complexity:"Time: O(log n), Space: O(1)"}},{id:"math10",title:"Smallest Prime Factor",description:"SPF for each 1 to n.",difficulty:"MEDIUM",category:"Math",starterCode:`#include <iostream>
using namespace std;
void smallestPrimeFactor(int n) {}
int main() { smallestPrimeFactor(10); return 0; }`,expectedOutput:"0 1 2 3 2 5 2 7 2 3 2",solution:`#include <iostream>
using namespace std;
void smallestPrimeFactor(int n) { int spf[n+1]; for(int i=0;i<=n;i++) spf[i]=i; for(int i=2;i*i<=n;i++) if(spf[i]==i) for(int j=i*i;j<=n;j+=i) if(spf[j]==j) spf[j]=i; for(int i=0;i<=n;i++) cout<<spf[i]<<" "; }
int main() { smallestPrimeFactor(10); return 0; }`,explanation:{approach:"Sieve-like approach.",analogy:"For composites, smallest prime that divides.",steps:["Initialize spf[i] = i","For each prime, mark multiples"],complexity:"Time: O(n log log n), Space: O(n)"}}],N5=JSON.parse(`[{"id":"ds1","title":"Stack using Array","description":"Implement stack operations.","difficulty":"EASY","category":"Data Structures","starterCode":"#include <iostream>\\nusing namespace std;\\nclass Stack { int a[100], t; public: Stack():t(-1){} void push(int x){} int pop(){return -1;} int top(){return -1;} bool empty(){return true;} };\\nint main() { Stack s; s.push(1); s.push(2); cout<<s.top()<<\\" \\"; s.pop(); cout<<s.top(); return 0; }","expectedOutput":"2 1","solution":"#include <iostream>\\nusing namespace std;\\nclass Stack { int a[100], t; public: Stack():t(-1){} void push(int x){a[++t]=x;} int pop(){return a[t--];} int top(){return a[t];} bool empty(){return t==-1;} };\\nint main() { Stack s; s.push(1); s.push(2); cout<<s.top()<<\\" \\"; s.pop(); cout<<s.top(); return 0; }","explanation":{"approach":"Array with top pointer.","analogy":"Stack of plates - add/remove from top.","steps":["push: increment top, store","pop: return and decrement top"],"complexity":"Time: O(1) all ops, Space: O(n)"}},{"id":"ds2","title":"Queue using Array","description":"Implement queue operations.","difficulty":"EASY","category":"Data Structures","starterCode":"#include <iostream>\\nusing namespace std;\\nclass Queue { int a[100], f, r; public: Queue():f(0),r(-1){} void enqueue(int x){} int dequeue(){return -1;} int front(){return -1;} bool empty(){return true;} };\\nint main() { Queue q; q.enqueue(1); q.enqueue(2); cout<<q.front()<<\\" \\"; q.dequeue(); cout<<q.front(); return 0; }","expectedOutput":"1 2","solution":"#include <iostream>\\nusing namespace std;\\nclass Queue { int a[100], f, r; public: Queue():f(0),r(-1){} void enqueue(int x){a[++r]=x;} int dequeue(){return a[f++];} int front(){return a[f];} bool empty(){return f>r;} };\\nint main() { Queue q; q.enqueue(1); q.enqueue(2); cout<<q.front()<<\\" \\"; q.dequeue(); cout<<q.front(); return 0; }","explanation":{"approach":"Array with front and rear pointers.","analogy":"Line at a store - join at back, leave from front.","steps":["enqueue: add at rear","dequeue: remove from front"],"complexity":"Time: O(1) all ops, Space: O(n)"}},{"id":"ds3","title":"Linked List Insert","description":"Insert at end of list.","difficulty":"EASY","category":"Data Structures","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int val; Node* next; Node(int x):val(x),next(0){} };\\nNode* insert(Node* head, int x) { return nullptr; }\\nint main() { Node* h=nullptr; h=insert(h,1); h=insert(h,2); h=insert(h,3); Node* t=h; while(t) { cout<<t->val<<\\" \\"; t=t->next; } return 0; }","expectedOutput":"1 2 3","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int val; Node* next; Node(int x):val(x),next(0){} };\\nNode* insert(Node* head, int x) { Node* n=new Node(x); if(!head) return n; Node* t=head; while(t->next) t=t->next; t->next=n; return head; }\\nint main() { Node* h=nullptr; h=insert(h,1); h=insert(h,2); h=insert(h,3); Node* t=h; while(t) { cout<<t->val<<\\" \\"; t=t->next; } return 0; }","explanation":{"approach":"Traverse to end, link new node.","analogy":"Add to end of chain.","steps":["Create new node","Find last node","Link new node"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"ds4","title":"Linked List Delete","description":"Delete node with value.","difficulty":"EASY","category":"Data Structures","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int val; Node* next; Node(int x):val(x),next(0){} };\\nNode* deleteNode(Node* head, int x) { return nullptr; }\\nint main() { Node* h=new Node(1); h->next=new Node(2); h->next->next=new Node(3); h=deleteNode(h,2); Node* t=h; while(t) { cout<<t->val<<\\" \\"; t=t->next; } return 0; }","expectedOutput":"1 3","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int val; Node* next; Node(int x):val(x),next(0){} };\\nNode* deleteNode(Node* head, int x) { if(!head) return nullptr; if(head->val==x) return head->next; Node* t=head; while(t->next && t->next->val!=x) t=t->next; if(t->next) t->next=t->next->next; return head; }\\nint main() { Node* h=new Node(1); h->next=new Node(2); h->next->next=new Node(3); h=deleteNode(h,2); Node* t=h; while(t) { cout<<t->val<<\\" \\"; t=t->next; } return 0; }","explanation":{"approach":"Find node before target, skip over.","analogy":"Remove link from chain.","steps":["Find predecessor","Skip target node"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"ds5","title":"Reverse Linked List","description":"Reverse list in-place.","difficulty":"EASY","category":"Data Structures","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int val; Node* next; Node(int x):val(x),next(0){} };\\nNode* reverse(Node* head) { return nullptr; }\\nint main() { Node* h=new Node(1); h->next=new Node(2); h->next->next=new Node(3); h=reverse(h); Node* t=h; while(t) { cout<<t->val<<\\" \\"; t=t->next; } return 0; }","expectedOutput":"3 2 1","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int val; Node* next; Node(int x):val(x),next(0){} };\\nNode* reverse(Node* head) { Node* prev=nullptr, *cur=head; while(cur) { Node* next=cur->next; cur->next=prev; prev=cur; cur=next; } return prev; }\\nint main() { Node* h=new Node(1); h->next=new Node(2); h->next->next=new Node(3); h=reverse(h); Node* t=h; while(t) { cout<<t->val<<\\" \\"; t=t->next; } return 0; }","explanation":{"approach":"Reverse pointers one by one.","analogy":"Turn each arrow backwards.","steps":["Track previous","Reverse current's next","Move forward"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"ds6","title":"Detect Cycle in List","description":"Check for cycle.","difficulty":"MEDIUM","category":"Data Structures","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int val; Node* next; Node(int x):val(x),next(0){} };\\nbool hasCycle(Node* head) { return false; }\\nint main() { Node* h=new Node(1); h->next=new Node(2); h->next->next=new Node(3); h->next->next->next=h->next; cout<<hasCycle(h); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int val; Node* next; Node(int x):val(x),next(0){} };\\nbool hasCycle(Node* head) { Node* s=head, *f=head; while(f && f->next) { s=s->next; f=f->next->next; if(s==f) return true; } return false; }\\nint main() { Node* h=new Node(1); h->next=new Node(2); h->next->next=new Node(3); h->next->next->next=h->next; cout<<hasCycle(h); return 0; }","explanation":{"approach":"Floyd's cycle detection - slow and fast pointers.","analogy":"If runners on track, they'll meet if there's a loop.","steps":["Slow moves 1 step","Fast moves 2 steps","If they meet, cycle exists"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"ds7","title":"Valid Parentheses","description":"Check balanced brackets.","difficulty":"EASY","category":"Data Structures","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isValid(char s[]) { return false; }\\nint main() { cout<<isValid(\\"([{}])\\"); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isValid(char s[]) { char stk[100]; int t=-1; for(int i=0;s[i];i++) { if(s[i]=='('||s[i]=='['||s[i]=='{') stk[++t]=s[i]; else { if(t<0) return false; if(s[i]==')' && stk[t]!='(') return false; if(s[i]==']' && stk[t]!='[') return false; if(s[i]=='}' && stk[t]!='{') return false; t--; } } return t==-1; }\\nint main() { cout<<isValid(\\"([{}])\\"); return 0; }","explanation":{"approach":"Stack to match brackets.","analogy":"Each opener waits for its closer.","steps":["Push opening brackets","Pop and match closing","Stack should be empty at end"],"complexity":"Time: O(n), Space: O(n)"}},{"id":"ds8","title":"Min Stack","description":"Stack with getMin in O(1).","difficulty":"MEDIUM","category":"Data Structures","starterCode":"#include <iostream>\\nusing namespace std;\\nclass MinStack { public: void push(int x){} void pop(){} int top(){return 0;} int getMin(){return 0;} };\\nint main() { MinStack s; s.push(5); s.push(2); s.push(3); cout<<s.getMin(); return 0; }","expectedOutput":"2","solution":"#include <iostream>\\nusing namespace std;\\nclass MinStack { int a[100], m[100], t; public: MinStack():t(-1){} void push(int x){a[++t]=x; m[t]=t==0?x:min(x,m[t-1]);} void pop(){t--;} int top(){return a[t];} int getMin(){return m[t];} };\\nint main() { MinStack s; s.push(5); s.push(2); s.push(3); cout<<s.getMin(); return 0; }","explanation":{"approach":"Auxiliary stack tracking min at each level.","analogy":"Remember minimum as you build up.","steps":["Track min at each push","Pop updates automatically"],"complexity":"Time: O(1) all ops, Space: O(n)"}},{"id":"ds9","title":"Implement Queue using Stacks","description":"Queue with two stacks.","difficulty":"MEDIUM","category":"Data Structures","starterCode":"#include <iostream>\\nusing namespace std;\\nclass MyQueue { int s1[100], s2[100], t1, t2; public: MyQueue():t1(-1),t2(-1){} void push(int x){} int pop(){return 0;} };\\nint main() { MyQueue q; q.push(1); q.push(2); cout<<q.pop()<<\\" \\"<<q.pop(); return 0; }","expectedOutput":"1 2","solution":"#include <iostream>\\nusing namespace std;\\nclass MyQueue { int s1[100], s2[100], t1, t2; public: MyQueue():t1(-1),t2(-1){} void push(int x){s1[++t1]=x;} int pop(){ if(t2<0) while(t1>=0) s2[++t2]=s1[t1--]; return s2[t2--]; } };\\nint main() { MyQueue q; q.push(1); q.push(2); cout<<q.pop()<<\\" \\"<<q.pop(); return 0; }","explanation":{"approach":"Push to s1, pop from s2 (transfer when empty).","analogy":"Two stacks simulate queue via reversal.","steps":["Push always to s1","Pop from s2, refill from s1 if empty"],"complexity":"Time: O(1) amortized, Space: O(n)"}},{"id":"ds10","title":"Implement Stack using Queues","description":"Stack with two queues.","difficulty":"MEDIUM","category":"Data Structures","starterCode":"#include <iostream>\\nusing namespace std;\\n#include <queue>\\nclass MyStack { queue<int> q; public: void push(int x){} int pop(){return 0;} };\\nint main() { MyStack s; s.push(1); s.push(2); cout<<s.pop()<<\\" \\"<<s.pop(); return 0; }","expectedOutput":"2 1","solution":"#include <iostream>\\nusing namespace std;\\n#include <queue>\\nclass MyStack { queue<int> q; public: void push(int x){ q.push(x); for(int i=0;i<q.size()-1;i++){q.push(q.front());q.pop();} } int pop(){ int t=q.front(); q.pop(); return t; } };\\nint main() { MyStack s; s.push(1); s.push(2); cout<<s.pop()<<\\" \\"<<s.pop(); return 0; }","explanation":{"approach":"After push, rotate to put new at front.","analogy":"Reorganize queue so last is first.","steps":["Push to queue","Rotate n-1 elements to back"],"complexity":"Time: O(n) push, O(1) pop, Space: O(n)"}}]`),E5=JSON.parse(`[{"id":"final1","title":"Rotate Matrix 90","description":"Rotate matrix clockwise.","difficulty":"MEDIUM","category":"Matrix","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid rotate(int m[][3], int n) {}\\nint main() { int m[3][3]={{1,2,3},{4,5,6},{7,8,9}}; rotate(m,3); for(int i=0;i<3;i++) { for(int j=0;j<3;j++) cout<<m[i][j]<<\\" \\"; } return 0; }","expectedOutput":"7 4 1 8 5 2 9 6 3","solution":"#include <iostream>\\nusing namespace std;\\nvoid rotate(int m[][3], int n) { for(int i=0;i<n;i++) for(int j=i;j<n;j++) swap(m[i][j],m[j][i]); for(int i=0;i<n;i++) for(int j=0;j<n/2;j++) swap(m[i][j],m[i][n-1-j]); }\\nint main() { int m[3][3]={{1,2,3},{4,5,6},{7,8,9}}; rotate(m,3); for(int i=0;i<3;i++) { for(int j=0;j<3;j++) cout<<m[i][j]<<\\" \\"; } return 0; }","explanation":{"approach":"Transpose then reverse each row.","analogy":"Flip diagonally, then mirror horizontally.","steps":["Transpose matrix","Reverse each row"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"final2","title":"Spiral Matrix","description":"Print matrix in spiral.","difficulty":"MEDIUM","category":"Matrix","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid spiral(int m[][4], int r, int c) {}\\nint main() { int m[3][4]={{1,2,3,4},{5,6,7,8},{9,10,11,12}}; spiral(m,3,4); return 0; }","expectedOutput":"1 2 3 4 8 12 11 10 9 5 6 7","solution":"#include <iostream>\\nusing namespace std;\\nvoid spiral(int m[][4], int r, int c) { int t=0,b=r-1,l=0,ri=c-1; while(t<=b && l<=ri) { for(int i=l;i<=ri;i++) cout<<m[t][i]<<\\" \\"; t++; for(int i=t;i<=b;i++) cout<<m[i][ri]<<\\" \\"; ri--; if(t<=b) { for(int i=ri;i>=l;i--) cout<<m[b][i]<<\\" \\"; b--; } if(l<=ri) { for(int i=b;i>=t;i--) cout<<m[i][l]<<\\" \\"; l++; } } }\\nint main() { int m[3][4]={{1,2,3,4},{5,6,7,8},{9,10,11,12}}; spiral(m,3,4); return 0; }","explanation":{"approach":"Track boundaries, shrink after each layer.","analogy":"Peel the onion layer by layer.","steps":["Go right, down, left, up","Shrink boundaries","Repeat"],"complexity":"Time: O(rc), Space: O(1)"}},{"id":"final3","title":"Set Matrix Zeros","description":"Set row and col to 0.","difficulty":"MEDIUM","category":"Matrix","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid setZeroes(int m[][3], int r, int c) {}\\nint main() { int m[3][3]={{1,1,1},{1,0,1},{1,1,1}}; setZeroes(m,3,3); for(int i=0;i<3;i++) for(int j=0;j<3;j++) cout<<m[i][j]<<\\" \\"; return 0; }","expectedOutput":"1 0 1 0 0 0 1 0 1","solution":"#include <iostream>\\nusing namespace std;\\nvoid setZeroes(int m[][3], int r, int c) { bool r0=false, c0=false; for(int i=0;i<r;i++) if(m[i][0]==0) c0=true; for(int j=0;j<c;j++) if(m[0][j]==0) r0=true; for(int i=1;i<r;i++) for(int j=1;j<c;j++) if(m[i][j]==0) { m[i][0]=0; m[0][j]=0; } for(int i=1;i<r;i++) for(int j=1;j<c;j++) if(m[i][0]==0||m[0][j]==0) m[i][j]=0; if(c0) for(int i=0;i<r;i++) m[i][0]=0; if(r0) for(int j=0;j<c;j++) m[0][j]=0; }\\nint main() { int m[3][3]={{1,1,1},{1,0,1},{1,1,1}}; setZeroes(m,3,3); for(int i=0;i<3;i++) for(int j=0;j<3;j++) cout<<m[i][j]<<\\" \\"; return 0; }","explanation":{"approach":"Use first row/col as markers.","analogy":"Mark rows and cols to zero later.","steps":["Mark first row/col","Use them as flags","Set zeros based on flags"],"complexity":"Time: O(rc), Space: O(1)"}},{"id":"final4","title":"Sudoku Validator","description":"Check valid sudoku.","difficulty":"MEDIUM","category":"Matrix","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isValidSudoku(int b[][9]) { return false; }\\nint main() { int b[9][9]={{5,3,0,0,7,0,0,0,0},{6,0,0,1,9,5,0,0,0},{0,9,8,0,0,0,0,6,0},{8,0,0,0,6,0,0,0,3},{4,0,0,8,0,3,0,0,1},{7,0,0,0,2,0,0,0,6},{0,6,0,0,0,0,2,8,0},{0,0,0,4,1,9,0,0,5},{0,0,0,0,8,0,0,7,9}}; cout<<isValidSudoku(b); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isValidSudoku(int b[][9]) { for(int i=0;i<9;i++) { int r[10]={}, c[10]={}; for(int j=0;j<9;j++) { if(b[i][j] && r[b[i][j]]++) return false; if(b[j][i] && c[b[j][i]]++) return false; } } for(int bi=0;bi<3;bi++) for(int bj=0;bj<3;bj++) { int s[10]={}; for(int i=0;i<3;i++) for(int j=0;j<3;j++) if(b[bi*3+i][bj*3+j] && s[b[bi*3+i][bj*3+j]]++) return false; } return true; }\\nint main() { int b[9][9]={{5,3,0,0,7,0,0,0,0},{6,0,0,1,9,5,0,0,0},{0,9,8,0,0,0,0,6,0},{8,0,0,0,6,0,0,0,3},{4,0,0,8,0,3,0,0,1},{7,0,0,0,2,0,0,0,6},{0,6,0,0,0,0,2,8,0},{0,0,0,4,1,9,0,0,5},{0,0,0,0,8,0,0,7,9}}; cout<<isValidSudoku(b); return 0; }","explanation":{"approach":"Check rows, cols, and 33 boxes.","analogy":"No repeats in any row, col, or box.","steps":["Check each row","Check each column","Check each 33 box"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"final5","title":"Word Break","description":"Can string be segmented.","difficulty":"MEDIUM","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nbool wordBreak(char s[], char dict[][10], int n) { return false; }\\nint main() { char dict[][10]={\\"leet\\",\\"code\\"}; cout<<wordBreak(\\"leetcode\\",dict,2); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool wordBreak(char s[], char dict[][10], int n) { int len=0; while(s[len]) len++; bool dp[len+1]={}; dp[0]=true; for(int i=1;i<=len;i++) for(int j=0;j<i;j++) if(dp[j]) { bool match=false; for(int k=0;k<n;k++) { int wl=0; while(dict[k][wl]) wl++; if(wl==i-j) { bool ok=true; for(int m=0;m<wl;m++) if(s[j+m]!=dict[k][m]) ok=false; if(ok) match=true; } } if(match) dp[i]=true; } return dp[len]; }\\nint main() { char dict[][10]={\\"leet\\",\\"code\\"}; cout<<wordBreak(\\"leetcode\\",dict,2); return 0; }","explanation":{"approach":"dp[i] = can we form s[0..i-1] from dictionary.","analogy":"Build string word by word.","steps":["dp[0] = true (empty string)","For each position, check all words"],"complexity":"Time: O(n  m), Space: O(n)"}},{"id":"final6","title":"House Robber","description":"Max money without adjacent.","difficulty":"MEDIUM","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint rob(int a[], int n) { return 0; }\\nint main() { int a[]={2,7,9,3,1}; cout<<rob(a,5); return 0; }","expectedOutput":"12","solution":"#include <iostream>\\nusing namespace std;\\nint rob(int a[], int n) { if(n==0) return 0; if(n==1) return a[0]; int prev2=a[0], prev1=max(a[0],a[1]); for(int i=2;i<n;i++) { int cur=max(prev1, prev2+a[i]); prev2=prev1; prev1=cur; } return prev1; }\\nint main() { int a[]={2,7,9,3,1}; cout<<rob(a,5); return 0; }","explanation":{"approach":"Rob current + prev2 OR skip current.","analogy":"Can't rob neighbors.","steps":["Either rob house i + profit from i-2","Or skip house i, keep profit from i-1"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"final7","title":"Unique Paths","description":"Paths in grid.","difficulty":"MEDIUM","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint uniquePaths(int m, int n) { return 0; }\\nint main() { cout<<uniquePaths(3,7); return 0; }","expectedOutput":"28","solution":"#include <iostream>\\nusing namespace std;\\nint uniquePaths(int m, int n) { int dp[m][n]; for(int i=0;i<m;i++) for(int j=0;j<n;j++) dp[i][j]=(i==0||j==0)?1:dp[i-1][j]+dp[i][j-1]; return dp[m-1][n-1]; }\\nint main() { cout<<uniquePaths(3,7); return 0; }","explanation":{"approach":"dp[i][j] = paths from top or left.","analogy":"Can only come from above or left.","steps":["First row and col have 1 path each","Others = sum of top + left"],"complexity":"Time: O(mn), Space: O(mn)"}},{"id":"final8","title":"Decode Ways","description":"Ways to decode number string.","difficulty":"MEDIUM","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint numDecodings(char s[]) { return 0; }\\nint main() { cout<<numDecodings(\\"226\\"); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nint numDecodings(char s[]) { int n=0; while(s[n]) n++; if(n==0||s[0]=='0') return 0; int dp[n+1]={}; dp[0]=1; dp[1]=1; for(int i=2;i<=n;i++) { if(s[i-1]!='0') dp[i]=dp[i-1]; int two=(s[i-2]-'0')*10+(s[i-1]-'0'); if(two>=10&&two<=26) dp[i]+=dp[i-2]; } return dp[n]; }\\nint main() { cout<<numDecodings(\\"226\\"); return 0; }","explanation":{"approach":"1 digit or 2 digit decode.","analogy":"Like Fibonacci with constraints.","steps":["Single digit: 1-9 valid","Two digits: 10-26 valid"],"complexity":"Time: O(n), Space: O(n)"}},{"id":"final9","title":"Jump Game","description":"Can reach last index.","difficulty":"MEDIUM","category":"Greedy","starterCode":"#include <iostream>\\nusing namespace std;\\nbool canJump(int a[], int n) { return false; }\\nint main() { int a[]={2,3,1,1,4}; cout<<canJump(a,5); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool canJump(int a[], int n) { int reach=0; for(int i=0;i<n;i++) { if(i>reach) return false; reach=max(reach, i+a[i]); } return true; }\\nint main() { int a[]={2,3,1,1,4}; cout<<canJump(a,5); return 0; }","explanation":{"approach":"Track farthest reachable position.","analogy":"Greedy - always update max reach.","steps":["Update max reachable","If current > max reach, impossible"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"final10","title":"Product Except Self","description":"Product of all except current.","difficulty":"MEDIUM","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid productExceptSelf(int a[], int n) {}\\nint main() { int a[]={1,2,3,4}; productExceptSelf(a,4); return 0; }","expectedOutput":"24 12 8 6","solution":"#include <iostream>\\nusing namespace std;\\nvoid productExceptSelf(int a[], int n) { int res[n]; res[0]=1; for(int i=1;i<n;i++) res[i]=res[i-1]*a[i-1]; int right=1; for(int i=n-1;i>=0;i--) { res[i]*=right; right*=a[i]; } for(int i=0;i<n;i++) cout<<res[i]<<\\" \\"; }\\nint main() { int a[]={1,2,3,4}; productExceptSelf(a,4); return 0; }","explanation":{"approach":"Left products  right products.","analogy":"Prefix and suffix products.","steps":["Calculate prefix products","Multiply by suffix products"],"complexity":"Time: O(n), Space: O(n)"}}]`),j5=JSON.parse(`[{"id":"fin11","title":"Longest Common Prefix","description":"Find common prefix.","difficulty":"EASY","category":"Strings","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid longestCommonPrefix(char strs[][20], int n) {}\\nint main() { char strs[][20]={\\"flower\\",\\"flow\\",\\"flight\\"}; longestCommonPrefix(strs,3); return 0; }","expectedOutput":"fl","solution":"#include <iostream>\\nusing namespace std;\\nvoid longestCommonPrefix(char strs[][20], int n) { if(n==0) return; for(int i=0;strs[0][i];i++) { for(int j=1;j<n;j++) if(strs[j][i]!=strs[0][i]) { strs[0][i]=0; cout<<strs[0]; return; } } cout<<strs[0]; }\\nint main() { char strs[][20]={\\"flower\\",\\"flow\\",\\"flight\\"}; longestCommonPrefix(strs,3); return 0; }","explanation":{"approach":"Compare char by char.","analogy":"Stop at first mismatch.","steps":["For each position","Check all strings match"],"complexity":"Time: O(S), Space: O(1)"}},{"id":"fin12","title":"Valid Anagram","description":"Check if anagram.","difficulty":"EASY","category":"Strings","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isAnagram(char s[], char t[]) { return false; }\\nint main() { cout<<isAnagram(\\"anagram\\",\\"nagaram\\"); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isAnagram(char s[], char t[]) { int c[26]={}; for(int i=0;s[i];i++) c[s[i]-'a']++; for(int i=0;t[i];i++) c[t[i]-'a']--; for(int i=0;i<26;i++) if(c[i]!=0) return false; return true; }\\nint main() { cout<<isAnagram(\\"anagram\\",\\"nagaram\\"); return 0; }","explanation":{"approach":"Count characters.","analogy":"Same letters, same counts.","steps":["Count s, subtract t","All counts should be 0"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"fin13","title":"Remove Duplicates II","description":"Allow at most 2 duplicates.","difficulty":"MEDIUM","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nint removeDuplicates(int a[], int n) { return 0; }\\nint main() { int a[]={1,1,1,2,2,3}; int k=removeDuplicates(a,6); for(int i=0;i<k;i++) cout<<a[i]<<\\" \\"; return 0; }","expectedOutput":"1 1 2 2 3","solution":"#include <iostream>\\nusing namespace std;\\nint removeDuplicates(int a[], int n) { if(n<=2) return n; int j=2; for(int i=2;i<n;i++) if(a[i]!=a[j-2]) a[j++]=a[i]; return j; }\\nint main() { int a[]={1,1,1,2,2,3}; int k=removeDuplicates(a,6); for(int i=0;i<k;i++) cout<<a[i]<<\\" \\"; return 0; }","explanation":{"approach":"Two pointers, check 2 back.","analogy":"Allow 2 of same.","steps":["Compare with element 2 positions back","Copy if different"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"fin14","title":"Search in Rotated","description":"Binary search in rotated array.","difficulty":"MEDIUM","category":"Binary Search","starterCode":"#include <iostream>\\nusing namespace std;\\nint search(int a[], int n, int t) { return -1; }\\nint main() { int a[]={4,5,6,7,0,1,2}; cout<<search(a,7,0); return 0; }","expectedOutput":"4","solution":"#include <iostream>\\nusing namespace std;\\nint search(int a[], int n, int t) { int l=0,r=n-1; while(l<=r) { int m=(l+r)/2; if(a[m]==t) return m; if(a[l]<=a[m]) { if(t>=a[l]&&t<a[m]) r=m-1; else l=m+1; } else { if(t>a[m]&&t<=a[r]) l=m+1; else r=m-1; } } return -1; }\\nint main() { int a[]={4,5,6,7,0,1,2}; cout<<search(a,7,0); return 0; }","explanation":{"approach":"Check which half is sorted.","analogy":"One half is always sorted.","steps":["Find which half is sorted","Check if target is in that half"],"complexity":"Time: O(log n), Space: O(1)"}},{"id":"fin15","title":"Find Minimum Rotated","description":"Min in rotated sorted array.","difficulty":"MEDIUM","category":"Binary Search","starterCode":"#include <iostream>\\nusing namespace std;\\nint findMin(int a[], int n) { return 0; }\\nint main() { int a[]={3,4,5,1,2}; cout<<findMin(a,5); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nint findMin(int a[], int n) { int l=0,r=n-1; while(l<r) { int m=(l+r)/2; if(a[m]>a[r]) l=m+1; else r=m; } return a[l]; }\\nint main() { int a[]={3,4,5,1,2}; cout<<findMin(a,5); return 0; }","explanation":{"approach":"Binary search for pivot.","analogy":"Min is at rotation point.","steps":["If mid > right, min is in right half","Else min is in left half (including mid)"],"complexity":"Time: O(log n), Space: O(1)"}},{"id":"fin16","title":"Product Except Self","description":"Product of all except self.","difficulty":"MEDIUM","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid productExceptSelf(int a[], int n) {}\\nint main() { int a[]={1,2,3,4}; productExceptSelf(a,4); return 0; }","expectedOutput":"24 12 8 6","solution":"#include <iostream>\\nusing namespace std;\\nvoid productExceptSelf(int a[], int n) { int res[n]; res[0]=1; for(int i=1;i<n;i++) res[i]=res[i-1]*a[i-1]; int right=1; for(int i=n-1;i>=0;i--) { res[i]*=right; right*=a[i]; } for(int i=0;i<n;i++) cout<<res[i]<<\\" \\"; }\\nint main() { int a[]={1,2,3,4}; productExceptSelf(a,4); return 0; }","explanation":{"approach":"Left and right products.","analogy":"Prefix  suffix products.","steps":["Build left products","Multiply by right products"],"complexity":"Time: O(n), Space: O(n)"}},{"id":"fin17","title":"Maximum Subarray","description":"Max contiguous sum.","difficulty":"MEDIUM","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint maxSubArray(int a[], int n) { return 0; }\\nint main() { int a[]={-2,1,-3,4,-1,2,1,-5,4}; cout<<maxSubArray(a,9); return 0; }","expectedOutput":"6","solution":"#include <iostream>\\nusing namespace std;\\nint maxSubArray(int a[], int n) { int mx=a[0],cur=a[0]; for(int i=1;i<n;i++) { cur=max(a[i],cur+a[i]); mx=max(mx,cur); } return mx; }\\nint main() { int a[]={-2,1,-3,4,-1,2,1,-5,4}; cout<<maxSubArray(a,9); return 0; }","explanation":{"approach":"Kadane's algorithm.","analogy":"Extend or start fresh.","steps":["cur = max(a[i], cur+a[i])","Track overall max"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"fin18","title":"Container With Water","description":"Max water between lines.","difficulty":"MEDIUM","category":"Two Pointers","starterCode":"#include <iostream>\\nusing namespace std;\\nint maxArea(int h[], int n) { return 0; }\\nint main() { int h[]={1,8,6,2,5,4,8,3,7}; cout<<maxArea(h,9); return 0; }","expectedOutput":"49","solution":"#include <iostream>\\nusing namespace std;\\nint maxArea(int h[], int n) { int l=0,r=n-1,mx=0; while(l<r) { mx=max(mx,min(h[l],h[r])*(r-l)); if(h[l]<h[r]) l++; else r--; } return mx; }\\nint main() { int h[]={1,8,6,2,5,4,8,3,7}; cout<<maxArea(h,9); return 0; }","explanation":{"approach":"Two pointers, move shorter.","analogy":"Move smaller wall inward.","steps":["Calculate area","Move smaller side"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"fin19","title":"Merge Intervals","description":"Merge overlapping intervals.","difficulty":"MEDIUM","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid mergeIntervals(int a[][2], int n) {}\\nint main() { int a[][2]={{1,3},{2,6},{8,10},{15,18}}; mergeIntervals(a,4); return 0; }","expectedOutput":"1-6 8-10 15-18","solution":"#include <iostream>\\nusing namespace std;\\nvoid mergeIntervals(int a[][2], int n) { for(int i=0;i<n-1;i++) for(int j=0;j<n-i-1;j++) if(a[j][0]>a[j+1][0]) { swap(a[j][0],a[j+1][0]); swap(a[j][1],a[j+1][1]); } int res[n][2], k=0; res[0][0]=a[0][0]; res[0][1]=a[0][1]; for(int i=1;i<n;i++) { if(a[i][0]<=res[k][1]) res[k][1]=max(res[k][1],a[i][1]); else { k++; res[k][0]=a[i][0]; res[k][1]=a[i][1]; } } for(int i=0;i<=k;i++) cout<<res[i][0]<<\\"-\\"<<res[i][1]<<\\" \\"; }\\nint main() { int a[][2]={{1,3},{2,6},{8,10},{15,18}}; mergeIntervals(a,4); return 0; }","explanation":{"approach":"Sort and merge overlapping.","analogy":"Combine overlapping ranges.","steps":["Sort by start","Merge if overlap"],"complexity":"Time: O(n log n), Space: O(n)"}},{"id":"fin20","title":"Insert Interval","description":"Insert and merge interval.","difficulty":"MEDIUM","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid insertInterval(int a[][2], int n, int newI[]) {}\\nint main() { int a[][2]={{1,3},{6,9}}; int newI[]={2,5}; insertInterval(a,2,newI); return 0; }","expectedOutput":"1-5 6-9","solution":"#include <iostream>\\nusing namespace std;\\nvoid insertInterval(int a[][2], int n, int newI[]) { int res[n+1][2], k=0, i=0; while(i<n && a[i][1]<newI[0]) { res[k][0]=a[i][0]; res[k++][1]=a[i++][1]; } while(i<n && a[i][0]<=newI[1]) { newI[0]=min(newI[0],a[i][0]); newI[1]=max(newI[1],a[i++][1]); } res[k][0]=newI[0]; res[k++][1]=newI[1]; while(i<n) { res[k][0]=a[i][0]; res[k++][1]=a[i++][1]; } for(int j=0;j<k;j++) cout<<res[j][0]<<\\"-\\"<<res[j][1]<<\\" \\"; }\\nint main() { int a[][2]={{1,3},{6,9}}; int newI[]={2,5}; insertInterval(a,2,newI); return 0; }","explanation":{"approach":"Three phases: before, merge, after.","analogy":"Insert at right spot, merge overlaps.","steps":["Copy non-overlapping before","Merge overlapping","Copy non-overlapping after"],"complexity":"Time: O(n), Space: O(n)"}}]`),A5=JSON.parse(`[{"id":"fin21","title":"Climbing Stairs Memoized","description":"Ways to climb n stairs with memo.","difficulty":"EASY","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint climbStairs(int n) { return 0; }\\nint main() { cout<<climbStairs(10); return 0; }","expectedOutput":"89","solution":"#include <iostream>\\nusing namespace std;\\nint dp[100];\\nint solve(int n) { if(n<=1) return 1; if(dp[n]) return dp[n]; return dp[n]=solve(n-1)+solve(n-2); }\\nint climbStairs(int n) { for(int i=0;i<100;i++) dp[i]=0; return solve(n); }\\nint main() { cout<<climbStairs(10); return 0; }","explanation":{"approach":"DP with memoization.","analogy":"Cache computed results.","steps":["If computed, return cached","Else compute and cache"],"complexity":"Time: O(n), Space: O(n)"}},{"id":"fin22","title":"Min Cost Climbing Stairs","description":"Min cost to reach top.","difficulty":"EASY","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint minCostClimbing(int cost[], int n) { return 0; }\\nint main() { int cost[]={10,15,20}; cout<<minCostClimbing(cost,3); return 0; }","expectedOutput":"15","solution":"#include <iostream>\\nusing namespace std;\\nint minCostClimbing(int cost[], int n) { int dp[n+1]={}; for(int i=2;i<=n;i++) dp[i]=min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2]); return dp[n]; }\\nint main() { int cost[]={10,15,20}; cout<<minCostClimbing(cost,3); return 0; }","explanation":{"approach":"DP - min cost at each step.","analogy":"From step i-1 or i-2.","steps":["dp[i] = min cost to reach step i"],"complexity":"Time: O(n), Space: O(n)"}},{"id":"fin23","title":"Number of 1 Bits","description":"Count set bits.","difficulty":"EASY","category":"Bits","starterCode":"#include <iostream>\\nusing namespace std;\\nint hammingWeight(unsigned int n) { return 0; }\\nint main() { cout<<hammingWeight(11); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nint hammingWeight(unsigned int n) { int c=0; while(n) { c+=n&1; n>>=1; } return c; }\\nint main() { cout<<hammingWeight(11); return 0; }","explanation":{"approach":"Count LSB, shift right.","analogy":"Pop off bits one by one.","steps":["Add n&1 to count","Shift right"],"complexity":"Time: O(log n), Space: O(1)"}},{"id":"fin24","title":"Counting Bits","description":"Count bits for 0 to n.","difficulty":"EASY","category":"Bits","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid countBits(int n) {}\\nint main() { countBits(5); return 0; }","expectedOutput":"0 1 1 2 1 2","solution":"#include <iostream>\\nusing namespace std;\\nvoid countBits(int n) { int dp[n+1]; dp[0]=0; for(int i=1;i<=n;i++) dp[i]=dp[i>>1]+(i&1); for(int i=0;i<=n;i++) cout<<dp[i]<<\\" \\"; }\\nint main() { countBits(5); return 0; }","explanation":{"approach":"DP using i/2.","analogy":"bits(i) = bits(i/2) + last bit.","steps":["dp[i] = dp[i>>1] + (i&1)"],"complexity":"Time: O(n), Space: O(n)"}},{"id":"fin25","title":"Reverse Bits","description":"Reverse 32-bit integer.","difficulty":"EASY","category":"Bits","starterCode":"#include <iostream>\\nusing namespace std;\\nunsigned int reverseBits(unsigned int n) { return 0; }\\nint main() { cout<<reverseBits(43261596); return 0; }","expectedOutput":"964176192","solution":"#include <iostream>\\nusing namespace std;\\nunsigned int reverseBits(unsigned int n) { unsigned int r=0; for(int i=0;i<32;i++) { r=(r<<1)|(n&1); n>>=1; } return r; }\\nint main() { cout<<reverseBits(43261596); return 0; }","explanation":{"approach":"Build reversed bit by bit.","analogy":"Take LSB, put in result MSB position.","steps":["Get LSB of n","Put in result","Shift both"],"complexity":"Time: O(32), Space: O(1)"}},{"id":"fin26","title":"Missing Number","description":"Find missing in 0 to n.","difficulty":"EASY","category":"Bits","starterCode":"#include <iostream>\\nusing namespace std;\\nint missingNumber(int a[], int n) { return 0; }\\nint main() { int a[]={3,0,1}; cout<<missingNumber(a,3); return 0; }","expectedOutput":"2","solution":"#include <iostream>\\nusing namespace std;\\nint missingNumber(int a[], int n) { int x=n; for(int i=0;i<n;i++) x^=i^a[i]; return x; }\\nint main() { int a[]={3,0,1}; cout<<missingNumber(a,3); return 0; }","explanation":{"approach":"XOR all indices and values.","analogy":"Pairs cancel out.","steps":["XOR n and all i and a[i]","Missing number remains"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"fin27","title":"Sum of Two Integers","description":"Add without + or -.","difficulty":"MEDIUM","category":"Bits","starterCode":"#include <iostream>\\nusing namespace std;\\nint getSum(int a, int b) { return 0; }\\nint main() { cout<<getSum(5,3); return 0; }","expectedOutput":"8","solution":"#include <iostream>\\nusing namespace std;\\nint getSum(int a, int b) { while(b) { int c=(unsigned)(a&b)<<1; a=a^b; b=c; } return a; }\\nint main() { cout<<getSum(5,3); return 0; }","explanation":{"approach":"XOR for sum, AND for carry.","analogy":"Binary addition manually.","steps":["XOR = sum without carry","AND<<1 = carry","Repeat until no carry"],"complexity":"Time: O(32), Space: O(1)"}},{"id":"fin28","title":"House Robber II","description":"Circular house robber.","difficulty":"MEDIUM","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint rob(int a[], int n) { return 0; }\\nint main() { int a[]={2,3,2}; cout<<rob(a,3); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nint robRange(int a[], int l, int r) { int p=0,c=0; for(int i=l;i<=r;i++) { int t=max(c,p+a[i]); p=c; c=t; } return c; }\\nint rob(int a[], int n) { if(n==1) return a[0]; return max(robRange(a,0,n-2),robRange(a,1,n-1)); }\\nint main() { int a[]={2,3,2}; cout<<rob(a,3); return 0; }","explanation":{"approach":"Two cases: skip first or last.","analogy":"Circle means first and last are adjacent.","steps":["Rob houses 0 to n-2","Or rob houses 1 to n-1","Return max"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"fin29","title":"Palindrome Linked List","description":"Check if list is palindrome.","difficulty":"EASY","category":"Linked List","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node* n; Node(int x):v(x),n(0){} };\\nbool isPalindrome(Node* h) { return false; }\\nint main() { Node* h=new Node(1); h->n=new Node(2); h->n->n=new Node(2); h->n->n->n=new Node(1); cout<<isPalindrome(h); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node* n; Node(int x):v(x),n(0){} };\\nNode* rev(Node* h) { Node* p=0; while(h) { Node* t=h->n; h->n=p; p=h; h=t; } return p; }\\nbool isPalindrome(Node* h) { Node* s=h,*f=h; while(f&&f->n) { s=s->n; f=f->n->n; } s=rev(s); while(s) { if(h->v!=s->v) return false; h=h->n; s=s->n; } return true; }\\nint main() { Node* h=new Node(1); h->n=new Node(2); h->n->n=new Node(2); h->n->n->n=new Node(1); cout<<isPalindrome(h); return 0; }","explanation":{"approach":"Reverse second half, compare.","analogy":"Compare first half with reversed second.","steps":["Find middle","Reverse second half","Compare"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"fin30","title":"Linked List Cycle","description":"Detect cycle in list.","difficulty":"EASY","category":"Linked List","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node* n; Node(int x):v(x),n(0){} };\\nbool hasCycle(Node* h) { return false; }\\nint main() { Node* h=new Node(3); h->n=new Node(2); h->n->n=new Node(0); h->n->n->n=new Node(-4); h->n->n->n->n=h->n; cout<<hasCycle(h); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node* n; Node(int x):v(x),n(0){} };\\nbool hasCycle(Node* h) { Node* s=h,*f=h; while(f&&f->n) { s=s->n; f=f->n->n; if(s==f) return true; } return false; }\\nint main() { Node* h=new Node(3); h->n=new Node(2); h->n->n=new Node(0); h->n->n->n=new Node(-4); h->n->n->n->n=h->n; cout<<hasCycle(h); return 0; }","explanation":{"approach":"Floyd's tortoise and hare.","analogy":"Fast catches slow if cycle exists.","steps":["Slow moves 1, fast moves 2","If they meet, cycle exists"],"complexity":"Time: O(n), Space: O(1)"}}]`),M5=JSON.parse(`[{"id":"fin31","title":"Cycle Start Node","description":"Find where cycle begins.","difficulty":"MEDIUM","category":"Linked List","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node* n; Node(int x):v(x),n(0){} };\\nNode* detectCycle(Node* h) { return nullptr; }\\nint main() { Node* h=new Node(3); h->n=new Node(2); h->n->n=new Node(0); h->n->n->n=new Node(-4); h->n->n->n->n=h->n; Node* r=detectCycle(h); cout<<(r?r->v:-1); return 0; }","expectedOutput":"2","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node* n; Node(int x):v(x),n(0){} };\\nNode* detectCycle(Node* h) { Node* s=h,*f=h; while(f&&f->n) { s=s->n; f=f->n->n; if(s==f) { s=h; while(s!=f) { s=s->n; f=f->n; } return s; } } return 0; }\\nint main() { Node* h=new Node(3); h->n=new Node(2); h->n->n=new Node(0); h->n->n->n=new Node(-4); h->n->n->n->n=h->n; Node* r=detectCycle(h); cout<<(r?r->v:-1); return 0; }","explanation":{"approach":"Floyd's detect, then find start.","analogy":"Reset one pointer to head.","steps":["Detect cycle with fast/slow","Move one to head","Move both by 1, meet at start"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"fin32","title":"Reverse Linked List","description":"Reverse entire list.","difficulty":"EASY","category":"Linked List","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node* n; Node(int x):v(x),n(0){} };\\nNode* reverseList(Node* h) { return nullptr; }\\nint main() { Node* h=new Node(1); h->n=new Node(2); h->n->n=new Node(3); h->n->n->n=new Node(4); h->n->n->n->n=new Node(5); h=reverseList(h); while(h) { cout<<h->v<<\\" \\"; h=h->n; } return 0; }","expectedOutput":"5 4 3 2 1","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node* n; Node(int x):v(x),n(0){} };\\nNode* reverseList(Node* h) { Node* p=0; while(h) { Node* t=h->n; h->n=p; p=h; h=t; } return p; }\\nint main() { Node* h=new Node(1); h->n=new Node(2); h->n->n=new Node(3); h->n->n->n=new Node(4); h->n->n->n->n=new Node(5); h=reverseList(h); while(h) { cout<<h->v<<\\" \\"; h=h->n; } return 0; }","explanation":{"approach":"Iterative pointer reversal.","analogy":"Flip each arrow.","steps":["Save next","Point current to prev","Move pointers forward"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"fin33","title":"Best Time Buy Sell","description":"Max profit one transaction.","difficulty":"EASY","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nint maxProfit(int p[], int n) { return 0; }\\nint main() { int p[]={7,1,5,3,6,4}; cout<<maxProfit(p,6); return 0; }","expectedOutput":"5","solution":"#include <iostream>\\nusing namespace std;\\nint maxProfit(int p[], int n) { int mn=1e9,mx=0; for(int i=0;i<n;i++) { mn=min(mn,p[i]); mx=max(mx,p[i]-mn); } return mx; }\\nint main() { int p[]={7,1,5,3,6,4}; cout<<maxProfit(p,6); return 0; }","explanation":{"approach":"Track min and max profit.","analogy":"Buy low, sell high.","steps":["Track minimum seen","Track max profit so far"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"fin34","title":"Best Time Buy Sell II","description":"Max profit unlimited transactions.","difficulty":"MEDIUM","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nint maxProfit(int p[], int n) { return 0; }\\nint main() { int p[]={7,1,5,3,6,4}; cout<<maxProfit(p,6); return 0; }","expectedOutput":"7","solution":"#include <iostream>\\nusing namespace std;\\nint maxProfit(int p[], int n) { int profit=0; for(int i=1;i<n;i++) if(p[i]>p[i-1]) profit+=p[i]-p[i-1]; return profit; }\\nint main() { int p[]={7,1,5,3,6,4}; cout<<maxProfit(p,6); return 0; }","explanation":{"approach":"Add all positive differences.","analogy":"Capture every upswing.","steps":["If tomorrow higher, buy today sell tomorrow"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"fin35","title":"Contains Duplicate","description":"Check if array has duplicates.","difficulty":"EASY","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nbool containsDuplicate(int a[], int n) { return false; }\\nint main() { int a[]={1,2,3,1}; cout<<containsDuplicate(a,4); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool containsDuplicate(int a[], int n) { for(int i=0;i<n;i++) for(int j=i+1;j<n;j++) if(a[i]==a[j]) return true; return false; }\\nint main() { int a[]={1,2,3,1}; cout<<containsDuplicate(a,4); return 0; }","explanation":{"approach":"Check all pairs.","analogy":"Find any match.","steps":["Compare each pair"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"fin36","title":"Single Number","description":"Find element appearing once.","difficulty":"EASY","category":"Bits","starterCode":"#include <iostream>\\nusing namespace std;\\nint singleNumber(int a[], int n) { return 0; }\\nint main() { int a[]={4,1,2,1,2}; cout<<singleNumber(a,5); return 0; }","expectedOutput":"4","solution":"#include <iostream>\\nusing namespace std;\\nint singleNumber(int a[], int n) { int x=0; for(int i=0;i<n;i++) x^=a[i]; return x; }\\nint main() { int a[]={4,1,2,1,2}; cout<<singleNumber(a,5); return 0; }","explanation":{"approach":"XOR all elements.","analogy":"Pairs cancel out.","steps":["XOR cancels duplicates","Single remains"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"fin37","title":"Majority Element","description":"Element appearing > n/2 times.","difficulty":"EASY","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nint majorityElement(int a[], int n) { return 0; }\\nint main() { int a[]={3,2,3}; cout<<majorityElement(a,3); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nint majorityElement(int a[], int n) { int c=0,m=0; for(int i=0;i<n;i++) { if(c==0) m=a[i]; c+=(a[i]==m)?1:-1; } return m; }\\nint main() { int a[]={3,2,3}; cout<<majorityElement(a,3); return 0; }","explanation":{"approach":"Boyer-Moore voting.","analogy":"Cancel different elements.","steps":["If count 0, pick new candidate","Inc if same, dec if different"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"fin38","title":"Valid Parentheses","description":"Check balanced brackets.","difficulty":"EASY","category":"Stack","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isValid(char s[]) { return false; }\\nint main() { cout<<isValid(\\"()[]{}\\"); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isValid(char s[]) { char stk[100]; int top=-1; for(int i=0;s[i];i++) { if(s[i]=='('||s[i]=='['||s[i]=='{') stk[++top]=s[i]; else { if(top<0) return false; char p=stk[top--]; if((s[i]==')' && p!='(') || (s[i]==']' && p!='[') || (s[i]=='}' && p!='{')) return false; } } return top==-1; }\\nint main() { cout<<isValid(\\"()[]{}\\"); return 0; }","explanation":{"approach":"Stack for matching.","analogy":"Push opens, pop and match closes.","steps":["Push open brackets","Pop and match on close","Stack empty at end"],"complexity":"Time: O(n), Space: O(n)"}},{"id":"fin39","title":"Min Stack","description":"Stack with getMin O(1).","difficulty":"MEDIUM","category":"Stack","starterCode":"#include <iostream>\\nusing namespace std;\\nclass MinStack { public: void push(int x) {} void pop() {} int top() { return 0; } int getMin() { return 0; } };\\nint main() { MinStack s; s.push(-2); s.push(0); s.push(-3); cout<<s.getMin()<<\\" \\"; s.pop(); cout<<s.top()<<\\" \\"<<s.getMin(); return 0; }","expectedOutput":"-3 0 -2","solution":"#include <iostream>\\nusing namespace std;\\nclass MinStack { int stk[100],minStk[100],t,mt; public: MinStack():t(-1),mt(-1){} void push(int x) { stk[++t]=x; if(mt<0||x<=minStk[mt]) minStk[++mt]=x; } void pop() { if(stk[t]==minStk[mt]) mt--; t--; } int top() { return stk[t]; } int getMin() { return minStk[mt]; } };\\nint main() { MinStack s; s.push(-2); s.push(0); s.push(-3); cout<<s.getMin()<<\\" \\"; s.pop(); cout<<s.top()<<\\" \\"<<s.getMin(); return 0; }","explanation":{"approach":"Auxiliary min stack.","analogy":"Track min at each level.","steps":["Push to min stack if <= current min","Pop from min stack if popping min"],"complexity":"Time: O(1), Space: O(n)"}},{"id":"fin40","title":"Evaluate RPN","description":"Evaluate reverse polish notation.","difficulty":"MEDIUM","category":"Stack","starterCode":"#include <iostream>\\nusing namespace std;\\nint evalRPN(char tokens[][10], int n) { return 0; }\\nint main() { char t[][10]={\\"2\\",\\"1\\",\\"+\\",\\"3\\",\\"*\\"}; cout<<evalRPN(t,5); return 0; }","expectedOutput":"9","solution":"#include <iostream>\\nusing namespace std;\\nbool isOp(char c) { return c=='+'||c=='-'||c=='*'||c=='/'; }\\nint evalRPN(char tokens[][10], int n) { int stk[100],top=-1; for(int i=0;i<n;i++) { if(isOp(tokens[i][0]) && !tokens[i][1]) { int b=stk[top--],a=stk[top--]; if(tokens[i][0]=='+') stk[++top]=a+b; else if(tokens[i][0]=='-') stk[++top]=a-b; else if(tokens[i][0]=='*') stk[++top]=a*b; else stk[++top]=a/b; } else { int v=0,neg=0,j=0; if(tokens[i][0]=='-') { neg=1; j=1; } for(;tokens[i][j];j++) v=v*10+(tokens[i][j]-'0'); stk[++top]=neg?-v:v; } } return stk[0]; }\\nint main() { char t[][10]={\\"2\\",\\"1\\",\\"+\\",\\"3\\",\\"*\\"}; cout<<evalRPN(t,5); return 0; }","explanation":{"approach":"Stack for operands.","analogy":"Push numbers, apply operators.","steps":["Push numbers","On operator, pop 2, compute, push result"],"complexity":"Time: O(n), Space: O(n)"}}]`),R5=JSON.parse(`[{"id":"fin41","title":"Daily Temperatures","description":"Days until warmer temp.","difficulty":"MEDIUM","category":"Stack","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid dailyTemps(int t[], int n) {}\\nint main() { int t[]={73,74,75,71,69,72,76,73}; dailyTemps(t,8); return 0; }","expectedOutput":"1 1 4 2 1 1 0 0","solution":"#include <iostream>\\nusing namespace std;\\nvoid dailyTemps(int t[], int n) { int res[n]={}, stk[n], top=-1; for(int i=n-1;i>=0;i--) { while(top>=0 && t[stk[top]]<=t[i]) top--; res[i]=top<0?0:stk[top]-i; stk[++top]=i; } for(int i=0;i<n;i++) cout<<res[i]<<\\" \\"; }\\nint main() { int t[]={73,74,75,71,69,72,76,73}; dailyTemps(t,8); return 0; }","explanation":{"approach":"Monotonic decreasing stack.","analogy":"Find next greater element.","steps":["Pop while current >= stack top","Difference is days to wait"],"complexity":"Time: O(n), Space: O(n)"}},{"id":"fin42","title":"Next Greater Element","description":"Next larger element.","difficulty":"MEDIUM","category":"Stack","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid nextGreater(int a[], int n) {}\\nint main() { int a[]={4,5,2,25}; nextGreater(a,4); return 0; }","expectedOutput":"5 25 25 -1","solution":"#include <iostream>\\nusing namespace std;\\nvoid nextGreater(int a[], int n) { int res[n], stk[n], top=-1; for(int i=n-1;i>=0;i--) { while(top>=0 && stk[top]<=a[i]) top--; res[i]=top<0?-1:stk[top]; stk[++top]=a[i]; } for(int i=0;i<n;i++) cout<<res[i]<<\\" \\"; }\\nint main() { int a[]={4,5,2,25}; nextGreater(a,4); return 0; }","explanation":{"approach":"Monotonic stack from right.","analogy":"Stack holds candidates.","steps":["Pop while current >= stack top","Top is next greater"],"complexity":"Time: O(n), Space: O(n)"}},{"id":"fin43","title":"Car Fleet","description":"Count car fleets.","difficulty":"MEDIUM","category":"Stack","starterCode":"#include <iostream>\\nusing namespace std;\\nint carFleet(int target, int pos[], int speed[], int n) { return 0; }\\nint main() { int pos[]={10,8,0,5,3}, speed[]={2,4,1,1,3}; cout<<carFleet(12,pos,speed,5); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nint carFleet(int target, int pos[], int speed[], int n) { double time[n]; int idx[n]; for(int i=0;i<n;i++) { idx[i]=i; time[i]=(double)(target-pos[i])/speed[i]; } for(int i=0;i<n-1;i++) for(int j=0;j<n-i-1;j++) if(pos[idx[j]]<pos[idx[j+1]]) { int t=idx[j]; idx[j]=idx[j+1]; idx[j+1]=t; } int fleets=0; double maxTime=-1; for(int i=0;i<n;i++) { if(time[idx[i]]>maxTime) { fleets++; maxTime=time[idx[i]]; } } return fleets; }\\nint main() { int pos[]={10,8,0,5,3}, speed[]={2,4,1,1,3}; cout<<carFleet(12,pos,speed,5); return 0; }","explanation":{"approach":"Sort by position, count fleets.","analogy":"Cars reaching target form fleets.","steps":["Sort by position descending","Count cars with higher arrival time"],"complexity":"Time: O(n log n), Space: O(n)"}},{"id":"fin44","title":"Search 2D Matrix II","description":"Search in row/col sorted matrix.","difficulty":"MEDIUM","category":"Matrix","starterCode":"#include <iostream>\\nusing namespace std;\\nbool searchMatrix(int m[][5], int r, int c, int t) { return false; }\\nint main() { int m[][5]={{1,4,7,11,15},{2,5,8,12,19},{3,6,9,16,22},{10,13,14,17,24},{18,21,23,26,30}}; cout<<searchMatrix(m,5,5,5); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool searchMatrix(int m[][5], int r, int c, int t) { int i=0,j=c-1; while(i<r && j>=0) { if(m[i][j]==t) return true; if(m[i][j]>t) j--; else i++; } return false; }\\nint main() { int m[][5]={{1,4,7,11,15},{2,5,8,12,19},{3,6,9,16,22},{10,13,14,17,24},{18,21,23,26,30}}; cout<<searchMatrix(m,5,5,5); return 0; }","explanation":{"approach":"Start from top-right corner.","analogy":"Eliminate row or column each step.","steps":["If target < current, go left","If target > current, go down"],"complexity":"Time: O(r+c), Space: O(1)"}},{"id":"fin45","title":"Median of Two Sorted","description":"Find median of merged arrays.","difficulty":"HARD","category":"Binary Search","starterCode":"#include <iostream>\\nusing namespace std;\\ndouble findMedian(int a[], int m, int b[], int n) { return 0; }\\nint main() { int a[]={1,3}, b[]={2}; cout<<findMedian(a,2,b,1); return 0; }","expectedOutput":"2","solution":"#include <iostream>\\nusing namespace std;\\ndouble findMedian(int a[], int m, int b[], int n) { if(m>n) return findMedian(b,n,a,m); int lo=0,hi=m,half=(m+n+1)/2; while(lo<=hi) { int i=(lo+hi)/2, j=half-i; int left1=i>0?a[i-1]:-1e9; int right1=i<m?a[i]:1e9; int left2=j>0?b[j-1]:-1e9; int right2=j<n?b[j]:1e9; if(left1<=right2 && left2<=right1) { if((m+n)%2) return max(left1,left2); return (max(left1,left2)+min(right1,right2))/2.0; } if(left1>right2) hi=i-1; else lo=i+1; } return 0; }\\nint main() { int a[]={1,3}, b[]={2}; cout<<findMedian(a,2,b,1); return 0; }","explanation":{"approach":"Binary search on smaller array.","analogy":"Find correct partition.","steps":["Binary search partition in smaller","Derive partition in larger","Check if valid partition"],"complexity":"Time: O(log(min(m,n))), Space: O(1)"}},{"id":"fin46","title":"Kth Largest in Stream","description":"Maintain kth largest.","difficulty":"EASY","category":"Heap","starterCode":"#include <iostream>\\nusing namespace std;\\nclass KthLargest { public: KthLargest(int k, int nums[], int n) {} int add(int val) { return 0; } };\\nint main() { int nums[]={4,5,8,2}; KthLargest kl(3,nums,4); cout<<kl.add(3)<<\\" \\"<<kl.add(5); return 0; }","expectedOutput":"4 5","solution":"#include <iostream>\\nusing namespace std;\\nclass KthLargest { int heap[10000],sz,K; void up(int i) { while(i>0 && heap[(i-1)/2]>heap[i]) { swap(heap[(i-1)/2],heap[i]); i=(i-1)/2; } } void down(int i) { while(2*i+1<sz) { int s=2*i+1; if(s+1<sz && heap[s+1]<heap[s]) s++; if(heap[i]<=heap[s]) break; swap(heap[i],heap[s]); i=s; } } public: KthLargest(int k, int nums[], int n) { K=k; sz=0; for(int i=0;i<n;i++) add(nums[i]); } int add(int val) { if(sz<K) { heap[sz++]=val; up(sz-1); } else if(val>heap[0]) { heap[0]=val; down(0); } return heap[0]; } };\\nint main() { int nums[]={4,5,8,2}; KthLargest kl(3,nums,4); cout<<kl.add(3)<<\\" \\"<<kl.add(5); return 0; }","explanation":{"approach":"Min-heap of size k.","analogy":"Keep k largest, return smallest of them.","steps":["Maintain min-heap of k elements","If new > root, replace and heapify"],"complexity":"Time: O(log k), Space: O(k)"}},{"id":"fin47","title":"Last Stone Weight","description":"Smash stones until one left.","difficulty":"EASY","category":"Heap","starterCode":"#include <iostream>\\nusing namespace std;\\nint lastStoneWeight(int stones[], int n) { return 0; }\\nint main() { int stones[]={2,7,4,1,8,1}; cout<<lastStoneWeight(stones,6); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nint lastStoneWeight(int stones[], int n) { while(n>1) { int m1=0,m2=1; if(stones[m1]<stones[m2]) swap(m1,m2); for(int i=2;i<n;i++) { if(stones[i]>stones[m1]) { m2=m1; m1=i; } else if(stones[i]>stones[m2]) m2=i; } int diff=stones[m1]-stones[m2]; if(m1>m2) { stones[m1]=stones[--n]; stones[m2]=stones[--n]; } else { stones[m2]=stones[--n]; stones[m1]=stones[--n]; } if(diff>0) stones[n++]=diff; } return n?stones[0]:0; }\\nint main() { int stones[]={2,7,4,1,8,1}; cout<<lastStoneWeight(stones,6); return 0; }","explanation":{"approach":"Find two largest, smash.","analogy":"Repeat until one or none left.","steps":["Find two largest","Replace with difference or remove"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"fin48","title":"K Closest Points","description":"K closest points to origin.","difficulty":"MEDIUM","category":"Heap","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid kClosest(int p[][2], int n, int k) {}\\nint main() { int p[][2]={{1,3},{-2,2},{5,8},{0,1}}; kClosest(p,4,2); return 0; }","expectedOutput":"0,1 -2,2","solution":"#include <iostream>\\nusing namespace std;\\nvoid kClosest(int p[][2], int n, int k) { int dist[n]; for(int i=0;i<n;i++) dist[i]=p[i][0]*p[i][0]+p[i][1]*p[i][1]; for(int i=0;i<k;i++) { int mn=i; for(int j=i+1;j<n;j++) if(dist[j]<dist[mn]) mn=j; swap(dist[i],dist[mn]); swap(p[i][0],p[mn][0]); swap(p[i][1],p[mn][1]); } for(int i=0;i<k;i++) cout<<p[i][0]<<\\",\\"<<p[i][1]<<\\" \\"; }\\nint main() { int p[][2]={{1,3},{-2,2},{5,8},{0,1}}; kClosest(p,4,2); return 0; }","explanation":{"approach":"Partial selection sort.","analogy":"Find k smallest distances.","steps":["Calculate distances","Select k smallest"],"complexity":"Time: O(nk), Space: O(n)"}},{"id":"fin49","title":"Task Scheduler","description":"Min intervals to complete tasks.","difficulty":"MEDIUM","category":"Greedy","starterCode":"#include <iostream>\\nusing namespace std;\\nint leastInterval(char tasks[], int n, int k) { return 0; }\\nint main() { char tasks[]=\\"AAABBB\\"; cout<<leastInterval(tasks,6,2); return 0; }","expectedOutput":"8","solution":"#include <iostream>\\nusing namespace std;\\nint leastInterval(char tasks[], int n, int k) { int freq[26]={}; for(int i=0;i<n;i++) freq[tasks[i]-'A']++; int maxF=0,maxC=0; for(int i=0;i<26;i++) maxF=max(maxF,freq[i]); for(int i=0;i<26;i++) if(freq[i]==maxF) maxC++; int slots=(maxF-1)*(k+1)+maxC; return max(n,slots); }\\nint main() { char tasks[]=\\"AAABBB\\"; cout<<leastInterval(tasks,6,2); return 0; }","explanation":{"approach":"Calculate idle slots needed.","analogy":"Fill gaps between max frequency task.","steps":["Find max frequency","Calculate slots needed","Return max of n and slots"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"fin50","title":"Design Twitter","description":"Simplified Twitter feed.","difficulty":"MEDIUM","category":"Design","starterCode":"#include <iostream>\\nusing namespace std;\\nclass Twitter { public: void postTweet(int u, int t) {} void getNewsFeed(int u) {} };\\nint main() { Twitter tw; tw.postTweet(1,5); tw.getNewsFeed(1); return 0; }","expectedOutput":"5","solution":"#include <iostream>\\nusing namespace std;\\nclass Twitter { int tweets[100][2], sz; public: Twitter():sz(0){} void postTweet(int u, int t) { tweets[sz][0]=u; tweets[sz++][1]=t; } void getNewsFeed(int u) { int c=0; for(int i=sz-1;i>=0 && c<10;i--) if(tweets[i][0]==u) { cout<<tweets[i][1]<<\\" \\"; c++; } } };\\nint main() { Twitter tw; tw.postTweet(1,5); tw.getNewsFeed(1); return 0; }","explanation":{"approach":"Store tweets with user and timestamp.","analogy":"Simple chronological feed.","steps":["Store (user, tweet) pairs","Return recent 10 from user"],"complexity":"Time: O(n), Space: O(n)"}}]`),lh=[...CR,...OR,..._R,...TR,...kR,...NR,...ER,...jR,...AR,...MR,...RR,...DR,...IR],ch=[...PR,...LR,...UR,...BR,...zR,...FR,...qR,...HR,...YR,...GR],uh=[...VR,...WR,...KR,...QR,...XR,...$R,...ZR,...JR],dh=[...e5,...t5,...n5,...i5,...r5,...a5,...s5,...o5,...l5,...c5,...u5,...d5,...y5,...v5,...x5,...b5],ph=[...p5,...m5,...f5,...h5,...g5,...w5,...S5,...C5,...O5,..._5,...T5,...k5,...N5,...E5,...j5,...A5,...M5,...R5],Gr=[...lh,...ch,...uh,...dh,...ph];console.log(`

              VALKRY Problem Bank - Loaded                

  EASY    : ${String(lh.length).padStart(4)} questions                           
  MEDIUM  : ${String(ch.length).padStart(4)} questions                           
  HARD    : ${String(uh.length).padStart(4)} questions                           
  CORE    : ${String(dh.length).padStart(4)} questions (Recursion, Bits, etc)    
  TOPIC   : ${String(ph.length).padStart(4)} questions (Arrays, DP, Graphs, etc) 

  TOTAL   : ${String(Gr.length).padStart(4)} questions                           

`);function Fc(){return Gr[Math.floor(Math.random()*Gr.length)]}function Kw(){return[...new Set(Gr.map(n=>n.category))]}function Pu(){return{EASY:lh.length,MEDIUM:ch.length,HARD:uh.length,CORE:dh.length,TOPIC:ph.length,total:Gr.length}}const D5=Object.freeze(Object.defineProperty({__proto__:null,getAllCategories:Kw,getCountByDifficulty:Pu,getRandomProblem:Fc,problems:Gr},Symbol.toStringTag,{value:"Module"})),Yv=()=>{const{user:n}=$r(),[e,i]=S.useState({totalPlayers:0,totalBattles:0}),a=Pu();return S.useEffect(()=>{oh().then(i)},[]),y.jsxs("div",{className:"page",children:[y.jsxs("section",{style:{display:"flex",flexDirection:"column",alignItems:"center",justifyContent:"center",minHeight:"calc(100vh - 52px)",textAlign:"center",padding:"0 22px"},children:[y.jsx("p",{className:"caption",style:{marginBottom:"16px",color:"var(--accent)"},children:"Introducing Valkry"}),y.jsx("h1",{className:"headline-super",style:{maxWidth:"800px",marginBottom:"16px"},children:"Code. Battle. Dominate."}),y.jsx("p",{className:"body-large",style:{maxWidth:"500px",marginBottom:"32px"},children:"Solve. Debug. Compete. Climb the global leaderboard."}),y.jsxs("div",{style:{display:"flex",alignItems:"center",gap:"24px"},children:[y.jsx(Tt,{to:n?"/arena":"/signin",children:y.jsx("button",{className:"btn btn-primary",children:n?"Enter Arena":"Get started"})}),y.jsxs(Tt,{to:"/leaderboard",className:"btn btn-secondary",children:["View rankings ",y.jsx(fu,{size:14})]})]})]}),y.jsx("section",{style:{padding:"88px 22px",background:"var(--bg-secondary)"},children:y.jsxs("div",{className:"container",children:[y.jsx("h2",{className:"headline",style:{textAlign:"center",marginBottom:"12px"},children:"How it works."}),y.jsx("p",{className:"body-large",style:{textAlign:"center",marginBottom:"56px"},children:"Three steps to start competing."}),y.jsx("div",{className:"grid grid-3",style:{gap:"30px"},children:[{num:"01",title:"Match",desc:"Join the queue and get paired with a similar skill player."},{num:"02",title:"Code",desc:"Solve the problem or fix the bug before your opponent."},{num:"03",title:"Rise",desc:"Win battles to earn points and climb the leaderboard."}].map((o,c)=>y.jsxs("div",{style:{textAlign:"center"},children:[y.jsx("div",{style:{fontSize:"48px",fontWeight:"600",color:"var(--text-tertiary)",marginBottom:"16px"},children:o.num}),y.jsx("h3",{className:"headline-small",style:{marginBottom:"8px"},children:o.title}),y.jsx("p",{style:{color:"var(--text-secondary)",fontSize:"15px",lineHeight:1.5},children:o.desc})]},c))})]})}),y.jsx("section",{style:{padding:"88px 22px"},children:y.jsx("div",{className:"container",children:y.jsxs("div",{className:"grid grid-3",style:{textAlign:"center"},children:[y.jsxs("div",{children:[y.jsx("div",{style:{fontSize:"56px",fontWeight:"600",letterSpacing:"-0.02em"},children:e.totalPlayers||0}),y.jsx("div",{style:{color:"var(--text-secondary)",marginTop:"4px"},children:"Players worldwide"})]}),y.jsxs("div",{children:[y.jsx("div",{style:{fontSize:"56px",fontWeight:"600",letterSpacing:"-0.02em"},children:e.totalBattles||0}),y.jsx("div",{style:{color:"var(--text-secondary)",marginTop:"4px"},children:"Battles completed"})]}),y.jsxs("div",{children:[y.jsxs("div",{style:{fontSize:"56px",fontWeight:"600",letterSpacing:"-0.02em"},children:[a.total,"+"]}),y.jsx("div",{style:{color:"var(--text-secondary)",marginTop:"4px"},children:"Problems available"})]})]})})}),y.jsxs("section",{style:{padding:"88px 22px",background:"var(--bg-secondary)",textAlign:"center"},children:[y.jsx("h2",{className:"headline",style:{marginBottom:"12px"},children:"Ready to compete?"}),y.jsx("p",{className:"body-large",style:{marginBottom:"32px"},children:"Join the arena. It's free."}),y.jsx(Tt,{to:n?"/arena":"/signin",children:y.jsxs("button",{className:"btn btn-primary",children:["Start now ",y.jsx(fu,{size:14})]})})]}),y.jsx("footer",{style:{padding:"24px 22px",textAlign:"center",borderTop:"1px solid var(--border)"},children:y.jsx("span",{className:"caption",children:"Valkry  2024"})})]})},I5=()=>{const[n,e]=S.useState(!1),[i,a]=S.useState(""),[o,c]=S.useState(""),[d,m]=S.useState(""),[f,h]=S.useState(""),[x,v]=S.useState(!1),{loginWithEmail:b,signUpWithEmail:_,loginGoogle:N}=$r(),D=yu(),q=async I=>{I.preventDefault(),h(""),v(!0);try{n?await _(i,o,d):await b(i,o),D("/dashboard")}catch(H){h(H.message)}finally{v(!1)}},F=async()=>{h(""),v(!0);try{await N(),D("/dashboard")}catch(I){h(I.message)}finally{v(!1)}};return y.jsx("div",{className:"page",style:{display:"flex",alignItems:"center",justifyContent:"center",minHeight:"100vh",background:"var(--bg-secondary)"},children:y.jsxs("div",{style:{width:"100%",maxWidth:"360px",padding:"40px",background:"var(--bg-elevated)",borderRadius:"18px",border:"1px solid var(--border)"},children:[y.jsx("div",{style:{textAlign:"center",marginBottom:"32px"},children:y.jsx(Ww,{size:"large"})}),y.jsx("h1",{className:"headline-small",style:{textAlign:"center",marginBottom:"24px"},children:n?"Create your account":"Sign in"}),f&&y.jsx("div",{style:{padding:"12px 16px",background:"rgba(255, 69, 58, 0.1)",borderRadius:"12px",color:"var(--red)",fontSize:"14px",marginBottom:"20px",textAlign:"center"},children:f}),y.jsxs("button",{onClick:F,disabled:x,style:{width:"100%",padding:"12px",background:"white",border:"none",borderRadius:"12px",fontSize:"15px",fontWeight:"500",color:"#1D1D1F",cursor:"pointer",display:"flex",alignItems:"center",justifyContent:"center",gap:"8px",marginBottom:"20px"},children:[y.jsxs("svg",{width:"18",height:"18",viewBox:"0 0 24 24",children:[y.jsx("path",{fill:"#4285F4",d:"M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"}),y.jsx("path",{fill:"#34A853",d:"M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"}),y.jsx("path",{fill:"#FBBC05",d:"M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"}),y.jsx("path",{fill:"#EA4335",d:"M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"})]}),"Continue with Google"]}),y.jsxs("div",{style:{display:"flex",alignItems:"center",gap:"12px",marginBottom:"20px"},children:[y.jsx("div",{style:{flex:1,height:"1px",background:"var(--border)"}}),y.jsx("span",{className:"caption",children:"or"}),y.jsx("div",{style:{flex:1,height:"1px",background:"var(--border)"}})]}),y.jsxs("form",{onSubmit:q,children:[n&&y.jsx("div",{style:{marginBottom:"16px"},children:y.jsxs("div",{style:{position:"relative"},children:[y.jsx(Gw,{size:16,style:{position:"absolute",left:"14px",top:"50%",transform:"translateY(-50%)",color:"var(--text-tertiary)"}}),y.jsx("input",{type:"text",className:"input",placeholder:"Name",value:d,onChange:I=>m(I.target.value),style:{paddingLeft:"42px",fontSize:"15px"},required:!0})]})}),y.jsx("div",{style:{marginBottom:"16px"},children:y.jsxs("div",{style:{position:"relative"},children:[y.jsx(zw,{size:16,style:{position:"absolute",left:"14px",top:"50%",transform:"translateY(-50%)",color:"var(--text-tertiary)"}}),y.jsx("input",{type:"email",className:"input",placeholder:"Email",value:i,onChange:I=>a(I.target.value),style:{paddingLeft:"42px",fontSize:"15px"},required:!0})]})}),y.jsx("div",{style:{marginBottom:"24px"},children:y.jsxs("div",{style:{position:"relative"},children:[y.jsx($M,{size:16,style:{position:"absolute",left:"14px",top:"50%",transform:"translateY(-50%)",color:"var(--text-tertiary)"}}),y.jsx("input",{type:"password",className:"input",placeholder:"Password",value:o,onChange:I=>c(I.target.value),style:{paddingLeft:"42px",fontSize:"15px"},required:!0})]})}),y.jsxs("button",{type:"submit",disabled:x,className:"btn btn-primary",style:{width:"100%",padding:"12px"},children:[x&&y.jsx("div",{className:"spinner"}),n?"Create account":"Sign in"]})]}),y.jsxs("p",{style:{textAlign:"center",marginTop:"24px",fontSize:"14px",color:"var(--text-secondary)"},children:[n?"Already have an account?":"Don't have an account?"," ",y.jsx("button",{onClick:()=>e(!n),style:{background:"none",border:"none",color:"var(--accent)",cursor:"pointer",fontSize:"14px"},children:n?"Sign in":"Sign up"})]})]})})},P5=()=>{const{user:n,loading:e}=$r();if(!e&&!n)return y.jsx(yx,{to:"/signin",replace:!0});const i=n?.name?.split(" ")[0]||"there",[a,o]=S.useState(null),[c,d]=S.useState({}),[m,f]=S.useState([]),[h,x]=S.useState(!0);S.useEffect(()=>{if(!n)return;const b=ZA(n.id,_=>{o(_),x(!1)});return rM(n.id).then(d),nM(3).then(f),()=>b()},[n]);const v=Object.keys(c).length;return y.jsx("div",{className:"page",children:y.jsxs("div",{className:"container",style:{paddingTop:"56px",paddingBottom:"56px"},children:[y.jsxs("div",{style:{marginBottom:"48px"},children:[y.jsx("p",{className:"caption",style:{marginBottom:"8px"},children:"Dashboard"}),y.jsxs("h1",{className:"headline",children:["Welcome back, ",i,"."]})]}),y.jsxs("div",{className:"card",style:{padding:"40px",marginBottom:"32px",textAlign:"center",background:"linear-gradient(180deg, var(--bg-elevated) 0%, var(--bg-secondary) 100%)"},children:[y.jsx("h2",{className:"headline-small",style:{marginBottom:"8px"},children:"Ready for a battle?"}),y.jsx("p",{style:{color:"var(--text-secondary)",marginBottom:"24px"},children:"Find an opponent and start competing."}),y.jsx(Tt,{to:"/arena",children:y.jsxs("button",{className:"btn btn-primary",style:{padding:"14px 28px"},children:[y.jsx(Fw,{size:16}),"Start playing"]})})]}),y.jsx("div",{className:"grid grid-4",style:{marginBottom:"32px"},children:[{label:"Battles",value:a?.battles||0,icon:Xm},{label:"Wins",value:a?.wins||0,icon:Hv},{label:"Win rate",value:`${a?.winRate||0}%`,icon:Yw},{label:"Rating",value:a?.rating||1e3,icon:Hw}].map((b,_)=>y.jsxs("div",{className:"card",style:{padding:"20px"},children:[y.jsxs("div",{style:{display:"flex",alignItems:"center",gap:"8px",marginBottom:"12px"},children:[y.jsx(b.icon,{size:16,style:{color:"var(--text-tertiary)"}}),y.jsx("span",{className:"caption",children:b.label})]}),y.jsx("div",{style:{fontSize:"32px",fontWeight:"600",letterSpacing:"-0.02em"},children:h?"":b.value})]},_))}),y.jsxs("div",{className:"grid grid-2",children:[y.jsxs("div",{className:"card",children:[y.jsxs("div",{style:{display:"flex",justifyContent:"space-between",alignItems:"center",marginBottom:"20px"},children:[y.jsx("span",{style:{fontWeight:"600"},children:"Top players"}),y.jsxs(Tt,{to:"/leaderboard",className:"btn btn-secondary",style:{padding:0,fontSize:"14px"},children:["See all ",y.jsx(fu,{size:12})]})]}),m.length>0?m.map(b=>y.jsxs("div",{style:{display:"flex",alignItems:"center",gap:"12px",padding:"12px 0",borderTop:"1px solid var(--border)"},children:[y.jsx("span",{style:{width:"24px",fontSize:"14px",color:b.rank===1?"#FFD700":"var(--text-tertiary)"},children:b.rank}),b.avatar?y.jsx("img",{src:b.avatar,alt:b.name,style:{width:"32px",height:"32px",borderRadius:"50%",objectFit:"cover"}}):y.jsx("div",{className:"avatar",style:{width:"32px",height:"32px",fontSize:"13px"},children:b.name?.charAt(0).toUpperCase()||"?"}),y.jsx("span",{style:{flex:1,fontWeight:"500",fontSize:"15px"},children:b.name}),y.jsx("span",{className:"mono",style:{color:"var(--text-secondary)",fontSize:"14px"},children:b.rating?.toLocaleString()})]},b.rank)):y.jsx("div",{style:{padding:"24px 0",textAlign:"center",color:"var(--text-tertiary)"},children:"No players yet"})]}),y.jsxs("div",{className:"card",children:[y.jsx("span",{style:{fontWeight:"600"},children:"Your progress"}),y.jsxs("div",{style:{marginTop:"20px"},children:[y.jsxs("div",{style:{display:"flex",justifyContent:"space-between",alignItems:"center",padding:"12px 0",borderBottom:"1px solid var(--border)"},children:[y.jsx("span",{style:{color:"var(--text-secondary)"},children:"Rank"}),y.jsx("span",{style:{fontWeight:"600",color:"var(--accent)"},children:a?.rank||"Bronze"})]}),y.jsxs("div",{style:{display:"flex",justifyContent:"space-between",alignItems:"center",padding:"12px 0",borderBottom:"1px solid var(--border)"},children:[y.jsx("span",{style:{color:"var(--text-secondary)"},children:"Current streak"}),y.jsxs("span",{style:{fontWeight:"600",display:"flex",alignItems:"center",gap:"4px"},children:[y.jsx(Bw,{size:14,style:{color:"var(--orange)"}}),a?.currentStreak||0]})]}),y.jsxs("div",{style:{display:"flex",justifyContent:"space-between",alignItems:"center",padding:"12px 0",borderBottom:"1px solid var(--border)"},children:[y.jsx("span",{style:{color:"var(--text-secondary)"},children:"Best streak"}),y.jsx("span",{style:{fontWeight:"600"},children:a?.bestStreak||0})]}),y.jsxs("div",{style:{display:"flex",justifyContent:"space-between",alignItems:"center",padding:"12px 0"},children:[y.jsx("span",{style:{color:"var(--text-secondary)"},children:"Achievements"}),y.jsxs("span",{style:{fontWeight:"600",display:"flex",alignItems:"center",gap:"4px"},children:[y.jsx(Uw,{size:14,style:{color:"var(--green)"}}),v,"/12"]})]})]})]})]}),v>0&&y.jsxs("div",{className:"card",style:{marginTop:"24px"},children:[y.jsx("span",{style:{fontWeight:"600"},children:"Recent achievements"}),y.jsx("div",{style:{display:"flex",gap:"12px",marginTop:"16px",flexWrap:"wrap"},children:Object.entries(c).slice(0,6).map(([b,_])=>y.jsxs("div",{style:{padding:"12px 16px",background:"var(--bg-secondary)",borderRadius:"12px",display:"flex",alignItems:"center",gap:"8px"},children:[y.jsx(Hv,{size:16,style:{color:"var(--green)"}}),y.jsx("span",{style:{fontSize:"14px",fontWeight:"500"},children:_.name})]},b))})]})]})})},L5=()=>{const{user:n}=$r(),[e,i]=S.useState(""),[a,o]=S.useState([]),[c,d]=S.useState({totalPlayers:0,battlesToday:0,totalBattles:0}),[m,f]=S.useState(!0);S.useEffect(()=>{const b=iM(_=>{o(_),f(!1)},50);return oh().then(d),()=>b()},[]);const h=a.filter(b=>b.name?.toLowerCase().includes(e.toLowerCase())),x=a.findIndex(b=>b.id===n?.id)+1,v=b=>b===1?"#FFD700":b===2?"#C0C0C0":b===3?"#CD7F32":"var(--text-tertiary)";return y.jsx("div",{className:"page",children:y.jsxs("div",{className:"container",style:{paddingTop:"56px",paddingBottom:"56px"},children:[y.jsxs("div",{style:{marginBottom:"48px"},children:[y.jsx("p",{className:"caption",style:{marginBottom:"8px"},children:"Rankings"}),y.jsx("h1",{className:"headline",children:"Leaderboard"})]}),y.jsxs("div",{className:`grid ${n?"grid-3":"grid-2"}`,style:{marginBottom:"40px"},children:[y.jsxs("div",{className:"card",style:{textAlign:"center",padding:"28px"},children:[y.jsx(Vw,{size:20,style:{color:"var(--text-tertiary)",marginBottom:"8px"}}),y.jsx("div",{style:{fontSize:"32px",fontWeight:"600",marginBottom:"4px"},children:a.length||c.totalPlayers||""}),y.jsx("div",{className:"caption",children:"Total players"})]}),y.jsxs("div",{className:"card",style:{textAlign:"center",padding:"28px"},children:[y.jsx(Yw,{size:20,style:{color:"var(--text-tertiary)",marginBottom:"8px"}}),y.jsx("div",{style:{fontSize:"32px",fontWeight:"600",marginBottom:"4px"},children:c.battlesToday||0}),y.jsx("div",{className:"caption",children:"Battles today"})]}),n&&y.jsxs("div",{className:"card",style:{textAlign:"center",padding:"28px"},children:[y.jsx(Uw,{size:20,style:{color:"var(--text-tertiary)",marginBottom:"8px"}}),y.jsx("div",{style:{fontSize:"32px",fontWeight:"600",marginBottom:"4px",color:x>0?"var(--accent)":"var(--text)"},children:x>0?`#${x}`:""}),y.jsx("div",{className:"caption",children:"Your rank"})]})]}),y.jsxs("div",{style:{position:"relative",marginBottom:"24px"},children:[y.jsx(qw,{size:16,style:{position:"absolute",left:"16px",top:"50%",transform:"translateY(-50%)",color:"var(--text-tertiary)"}}),y.jsx("input",{type:"text",className:"input",placeholder:"Search players...",value:e,onChange:b=>i(b.target.value),style:{paddingLeft:"44px",fontSize:"15px"}})]}),y.jsx("div",{className:"card",style:{padding:0,overflow:"hidden"},children:m?y.jsxs("div",{style:{padding:"60px",textAlign:"center"},children:[y.jsx("div",{className:"spinner",style:{margin:"0 auto 16px"}}),y.jsx("p",{style:{color:"var(--text-tertiary)"},children:"Loading leaderboard..."})]}):h.length>0?y.jsxs("table",{className:"table",children:[y.jsx("thead",{children:y.jsxs("tr",{children:[y.jsx("th",{style:{width:"60px"},children:"Rank"}),y.jsx("th",{children:"Player"}),y.jsx("th",{style:{textAlign:"right"},children:"Rating"}),y.jsx("th",{style:{textAlign:"right"},children:"Wins"}),y.jsx("th",{style:{textAlign:"right"},children:"Streak"})]})}),y.jsx("tbody",{children:h.map(b=>y.jsxs("tr",{style:{background:b.id===n?.id?"rgba(0, 113, 227, 0.05)":"transparent"},children:[y.jsx("td",{children:b.rank<=3?y.jsx(UM,{size:16,style:{color:v(b.rank)}}):y.jsx("span",{style:{color:"var(--text-tertiary)"},children:b.rank})}),y.jsx("td",{children:y.jsxs("div",{style:{display:"flex",alignItems:"center",gap:"12px"},children:[b.avatar?y.jsx("img",{src:b.avatar,alt:b.name,style:{width:"32px",height:"32px",borderRadius:"50%",objectFit:"cover"}}):y.jsx("div",{className:"avatar",style:{width:"32px",height:"32px",fontSize:"13px"},children:b.name?.charAt(0).toUpperCase()||"?"}),y.jsxs("span",{style:{fontWeight:"500"},children:[b.name,b.id===n?.id&&y.jsx("span",{style:{marginLeft:"8px",fontSize:"12px",color:"var(--accent)"},children:"(you)"})]})]})}),y.jsx("td",{style:{textAlign:"right"},children:y.jsx("span",{className:"mono",children:b.rating?.toLocaleString()})}),y.jsx("td",{style:{textAlign:"right",color:"var(--text-secondary)"},children:b.wins||0}),y.jsx("td",{style:{textAlign:"right"},children:b.streak>0?y.jsxs("span",{style:{display:"inline-flex",alignItems:"center",gap:"4px",color:"var(--orange)"},children:[y.jsx(Bw,{size:14}),b.streak]}):y.jsx("span",{style:{color:"var(--text-tertiary)"},children:"0"})})]},b.id))})]}):y.jsx("div",{style:{padding:"60px",textAlign:"center"},children:y.jsx("p",{style:{color:"var(--text-tertiary)"},children:e?"No players found":"No players yet. Be the first!"})})})]})})};function Gv(n,e){(e==null||e>n.length)&&(e=n.length);for(var i=0,a=Array(e);i<e;i++)a[i]=n[i];return a}function U5(n){if(Array.isArray(n))return n}function B5(n,e,i){return(e=V5(e))in n?Object.defineProperty(n,e,{value:i,enumerable:!0,configurable:!0,writable:!0}):n[e]=i,n}function z5(n,e){var i=n==null?null:typeof Symbol<"u"&&n[Symbol.iterator]||n["@@iterator"];if(i!=null){var a,o,c,d,m=[],f=!0,h=!1;try{if(c=(i=i.call(n)).next,e!==0)for(;!(f=(a=c.call(i)).done)&&(m.push(a.value),m.length!==e);f=!0);}catch(x){h=!0,o=x}finally{try{if(!f&&i.return!=null&&(d=i.return(),Object(d)!==d))return}finally{if(h)throw o}}return m}}function F5(){throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)}function Vv(n,e){var i=Object.keys(n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(n);e&&(a=a.filter(function(o){return Object.getOwnPropertyDescriptor(n,o).enumerable})),i.push.apply(i,a)}return i}function Wv(n){for(var e=1;e<arguments.length;e++){var i=arguments[e]!=null?arguments[e]:{};e%2?Vv(Object(i),!0).forEach(function(a){B5(n,a,i[a])}):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(i)):Vv(Object(i)).forEach(function(a){Object.defineProperty(n,a,Object.getOwnPropertyDescriptor(i,a))})}return n}function q5(n,e){if(n==null)return{};var i,a,o=H5(n,e);if(Object.getOwnPropertySymbols){var c=Object.getOwnPropertySymbols(n);for(a=0;a<c.length;a++)i=c[a],e.indexOf(i)===-1&&{}.propertyIsEnumerable.call(n,i)&&(o[i]=n[i])}return o}function H5(n,e){if(n==null)return{};var i={};for(var a in n)if({}.hasOwnProperty.call(n,a)){if(e.indexOf(a)!==-1)continue;i[a]=n[a]}return i}function Y5(n,e){return U5(n)||z5(n,e)||W5(n,e)||F5()}function G5(n,e){if(typeof n!="object"||!n)return n;var i=n[Symbol.toPrimitive];if(i!==void 0){var a=i.call(n,e);if(typeof a!="object")return a;throw new TypeError("@@toPrimitive must return a primitive value.")}return(e==="string"?String:Number)(n)}function V5(n){var e=G5(n,"string");return typeof e=="symbol"?e:e+""}function W5(n,e){if(n){if(typeof n=="string")return Gv(n,e);var i={}.toString.call(n).slice(8,-1);return i==="Object"&&n.constructor&&(i=n.constructor.name),i==="Map"||i==="Set"?Array.from(n):i==="Arguments"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i)?Gv(n,e):void 0}}function K5(n,e,i){return e in n?Object.defineProperty(n,e,{value:i,enumerable:!0,configurable:!0,writable:!0}):n[e]=i,n}function Kv(n,e){var i=Object.keys(n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(n);e&&(a=a.filter(function(o){return Object.getOwnPropertyDescriptor(n,o).enumerable})),i.push.apply(i,a)}return i}function Qv(n){for(var e=1;e<arguments.length;e++){var i=arguments[e]!=null?arguments[e]:{};e%2?Kv(Object(i),!0).forEach(function(a){K5(n,a,i[a])}):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(i)):Kv(Object(i)).forEach(function(a){Object.defineProperty(n,a,Object.getOwnPropertyDescriptor(i,a))})}return n}function Q5(){for(var n=arguments.length,e=new Array(n),i=0;i<n;i++)e[i]=arguments[i];return function(a){return e.reduceRight(function(o,c){return c(o)},a)}}function So(n){return function e(){for(var i=this,a=arguments.length,o=new Array(a),c=0;c<a;c++)o[c]=arguments[c];return o.length>=n.length?n.apply(this,o):function(){for(var d=arguments.length,m=new Array(d),f=0;f<d;f++)m[f]=arguments[f];return e.apply(i,[].concat(o,m))}}}function hu(n){return{}.toString.call(n).includes("Object")}function X5(n){return!Object.keys(n).length}function Go(n){return typeof n=="function"}function $5(n,e){return Object.prototype.hasOwnProperty.call(n,e)}function Z5(n,e){return hu(e)||nr("changeType"),Object.keys(e).some(function(i){return!$5(n,i)})&&nr("changeField"),e}function J5(n){Go(n)||nr("selectorType")}function eD(n){Go(n)||hu(n)||nr("handlerType"),hu(n)&&Object.values(n).some(function(e){return!Go(e)})&&nr("handlersType")}function tD(n){n||nr("initialIsRequired"),hu(n)||nr("initialType"),X5(n)&&nr("initialContent")}function nD(n,e){throw new Error(n[e]||n.default)}var iD={initialIsRequired:"initial state is required",initialType:"initial state should be an object",initialContent:"initial state shouldn't be an empty object",handlerType:"handler should be an object or a function",handlersType:"all handlers should be a functions",selectorType:"selector should be a function",changeType:"provided value of changes should be an object",changeField:'it seams you want to change a field in the state which is not specified in the "initial" state',default:"an unknown error accured in `state-local` package"},nr=So(nD)(iD),Ec={changes:Z5,selector:J5,handler:eD,initial:tD};function rD(n){var e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};Ec.initial(n),Ec.handler(e);var i={current:n},a=So(oD)(i,e),o=So(sD)(i),c=So(Ec.changes)(n),d=So(aD)(i);function m(){var h=arguments.length>0&&arguments[0]!==void 0?arguments[0]:function(x){return x};return Ec.selector(h),h(i.current)}function f(h){Q5(a,o,c,d)(h)}return[m,f]}function aD(n,e){return Go(e)?e(n.current):e}function sD(n,e){return n.current=Qv(Qv({},n.current),e),e}function oD(n,e,i){return Go(e)?e(n.current):Object.keys(i).forEach(function(a){var o;return(o=e[a])===null||o===void 0?void 0:o.call(e,n.current[a])}),i}var lD={create:rD},cD={paths:{vs:"https://cdn.jsdelivr.net/npm/monaco-editor@0.55.1/min/vs"}};function uD(n){return function e(){for(var i=this,a=arguments.length,o=new Array(a),c=0;c<a;c++)o[c]=arguments[c];return o.length>=n.length?n.apply(this,o):function(){for(var d=arguments.length,m=new Array(d),f=0;f<d;f++)m[f]=arguments[f];return e.apply(i,[].concat(o,m))}}}function dD(n){return{}.toString.call(n).includes("Object")}function pD(n){return n||Xv("configIsRequired"),dD(n)||Xv("configType"),n.urls?(mD(),{paths:{vs:n.urls.monacoBase}}):n}function mD(){console.warn(Qw.deprecation)}function fD(n,e){throw new Error(n[e]||n.default)}var Qw={configIsRequired:"the configuration object is required",configType:"the configuration object should be an object",default:"an unknown error accured in `@monaco-editor/loader` package",deprecation:`Deprecation warning!
    You are using deprecated way of configuration.

    Instead of using
      monaco.config({ urls: { monacoBase: '...' } })
    use
      monaco.config({ paths: { vs: '...' } })

    For more please check the link https://github.com/suren-atoyan/monaco-loader#config
  `},Xv=uD(fD)(Qw),hD={config:pD},gD=function(){for(var e=arguments.length,i=new Array(e),a=0;a<e;a++)i[a]=arguments[a];return function(o){return i.reduceRight(function(c,d){return d(c)},o)}};function Xw(n,e){return Object.keys(e).forEach(function(i){e[i]instanceof Object&&n[i]&&Object.assign(e[i],Xw(n[i],e[i]))}),Wv(Wv({},n),e)}var yD={type:"cancelation",msg:"operation is manually canceled"};function wm(n){var e=!1,i=new Promise(function(a,o){n.then(function(c){return e?o(yD):a(c)}),n.catch(o)});return i.cancel=function(){return e=!0},i}var vD=["monaco"],xD=lD.create({config:cD,isInitialized:!1,resolve:null,reject:null,monaco:null}),$w=Y5(xD,2),al=$w[0],Lu=$w[1];function bD(n){var e=hD.config(n),i=e.monaco,a=q5(e,vD);Lu(function(o){return{config:Xw(o.config,a),monaco:i}})}function wD(){var n=al(function(e){var i=e.monaco,a=e.isInitialized,o=e.resolve;return{monaco:i,isInitialized:a,resolve:o}});if(!n.isInitialized){if(Lu({isInitialized:!0}),n.monaco)return n.resolve(n.monaco),wm(Sm);if(window.monaco&&window.monaco.editor)return Zw(window.monaco),n.resolve(window.monaco),wm(Sm);gD(SD,OD)(_D)}return wm(Sm)}function SD(n){return document.body.appendChild(n)}function CD(n){var e=document.createElement("script");return n&&(e.src=n),e}function OD(n){var e=al(function(a){var o=a.config,c=a.reject;return{config:o,reject:c}}),i=CD("".concat(e.config.paths.vs,"/loader.js"));return i.onload=function(){return n()},i.onerror=e.reject,i}function _D(){var n=al(function(i){var a=i.config,o=i.resolve,c=i.reject;return{config:a,resolve:o,reject:c}}),e=window.require;e.config(n.config),e(["vs/editor/editor.main"],function(i){var a=i.m||i;Zw(a),n.resolve(a)},function(i){n.reject(i)})}function Zw(n){al().monaco||Lu({monaco:n})}function TD(){return al(function(n){var e=n.monaco;return e})}var Sm=new Promise(function(n,e){return Lu({resolve:n,reject:e})}),Jw={config:bD,init:wD,__getMonacoInstance:TD},kD={wrapper:{display:"flex",position:"relative",textAlign:"initial"},fullWidth:{width:"100%"},hide:{display:"none"}},Cm=kD,ND={container:{display:"flex",height:"100%",width:"100%",justifyContent:"center",alignItems:"center"}},ED=ND;function jD({children:n}){return Pr.createElement("div",{style:ED.container},n)}var AD=jD,MD=AD;function RD({width:n,height:e,isEditorReady:i,loading:a,_ref:o,className:c,wrapperProps:d}){return Pr.createElement("section",{style:{...Cm.wrapper,width:n,height:e},...d},!i&&Pr.createElement(MD,null,a),Pr.createElement("div",{ref:o,style:{...Cm.fullWidth,...!i&&Cm.hide},className:c}))}var DD=RD,eS=S.memo(DD);function ID(n){S.useEffect(n,[])}var tS=ID;function PD(n,e,i=!0){let a=S.useRef(!0);S.useEffect(a.current||!i?()=>{a.current=!1}:n,e)}var en=PD;function jo(){}function qa(n,e,i,a){return LD(n,a)||UD(n,e,i,a)}function LD(n,e){return n.editor.getModel(nS(n,e))}function UD(n,e,i,a){return n.editor.createModel(e,i,a?nS(n,a):void 0)}function nS(n,e){return n.Uri.parse(e)}function BD({original:n,modified:e,language:i,originalLanguage:a,modifiedLanguage:o,originalModelPath:c,modifiedModelPath:d,keepCurrentOriginalModel:m=!1,keepCurrentModifiedModel:f=!1,theme:h="light",loading:x="Loading...",options:v={},height:b="100%",width:_="100%",className:N,wrapperProps:D={},beforeMount:q=jo,onMount:F=jo}){let[I,H]=S.useState(!1),[z,X]=S.useState(!0),Z=S.useRef(null),K=S.useRef(null),fe=S.useRef(null),se=S.useRef(F),te=S.useRef(q),Me=S.useRef(!1);tS(()=>{let he=Jw.init();return he.then(M=>(K.current=M)&&X(!1)).catch(M=>M?.type!=="cancelation"&&console.error("Monaco initialization: error:",M)),()=>Z.current?st():he.cancel()}),en(()=>{if(Z.current&&K.current){let he=Z.current.getOriginalEditor(),M=qa(K.current,n||"",a||i||"text",c||"");M!==he.getModel()&&he.setModel(M)}},[c],I),en(()=>{if(Z.current&&K.current){let he=Z.current.getModifiedEditor(),M=qa(K.current,e||"",o||i||"text",d||"");M!==he.getModel()&&he.setModel(M)}},[d],I),en(()=>{let he=Z.current.getModifiedEditor();he.getOption(K.current.editor.EditorOption.readOnly)?he.setValue(e||""):e!==he.getValue()&&(he.executeEdits("",[{range:he.getModel().getFullModelRange(),text:e||"",forceMoveMarkers:!0}]),he.pushUndoStop())},[e],I),en(()=>{Z.current?.getModel()?.original.setValue(n||"")},[n],I),en(()=>{let{original:he,modified:M}=Z.current.getModel();K.current.editor.setModelLanguage(he,a||i||"text"),K.current.editor.setModelLanguage(M,o||i||"text")},[i,a,o],I),en(()=>{K.current?.editor.setTheme(h)},[h],I),en(()=>{Z.current?.updateOptions(v)},[v],I);let qe=S.useCallback(()=>{if(!K.current)return;te.current(K.current);let he=qa(K.current,n||"",a||i||"text",c||""),M=qa(K.current,e||"",o||i||"text",d||"");Z.current?.setModel({original:he,modified:M})},[i,e,o,n,a,c,d]),Dt=S.useCallback(()=>{!Me.current&&fe.current&&(Z.current=K.current.editor.createDiffEditor(fe.current,{automaticLayout:!0,...v}),qe(),K.current?.editor.setTheme(h),H(!0),Me.current=!0)},[v,h,qe]);S.useEffect(()=>{I&&se.current(Z.current,K.current)},[I]),S.useEffect(()=>{!z&&!I&&Dt()},[z,I,Dt]);function st(){let he=Z.current?.getModel();m||he?.original?.dispose(),f||he?.modified?.dispose(),Z.current?.dispose()}return Pr.createElement(eS,{width:_,height:b,isEditorReady:I,loading:x,_ref:fe,className:N,wrapperProps:D})}var zD=BD;S.memo(zD);function FD(n){let e=S.useRef();return S.useEffect(()=>{e.current=n},[n]),e.current}var qD=FD,jc=new Map;function HD({defaultValue:n,defaultLanguage:e,defaultPath:i,value:a,language:o,path:c,theme:d="light",line:m,loading:f="Loading...",options:h={},overrideServices:x={},saveViewState:v=!0,keepCurrentModel:b=!1,width:_="100%",height:N="100%",className:D,wrapperProps:q={},beforeMount:F=jo,onMount:I=jo,onChange:H,onValidate:z=jo}){let[X,Z]=S.useState(!1),[K,fe]=S.useState(!0),se=S.useRef(null),te=S.useRef(null),Me=S.useRef(null),qe=S.useRef(I),Dt=S.useRef(F),st=S.useRef(),he=S.useRef(a),M=qD(c),V=S.useRef(!1),J=S.useRef(!1);tS(()=>{let O=Jw.init();return O.then(L=>(se.current=L)&&fe(!1)).catch(L=>L?.type!=="cancelation"&&console.error("Monaco initialization: error:",L)),()=>te.current?Ce():O.cancel()}),en(()=>{let O=qa(se.current,n||a||"",e||o||"",c||i||"");O!==te.current?.getModel()&&(v&&jc.set(M,te.current?.saveViewState()),te.current?.setModel(O),v&&te.current?.restoreViewState(jc.get(c)))},[c],X),en(()=>{te.current?.updateOptions(h)},[h],X),en(()=>{!te.current||a===void 0||(te.current.getOption(se.current.editor.EditorOption.readOnly)?te.current.setValue(a):a!==te.current.getValue()&&(J.current=!0,te.current.executeEdits("",[{range:te.current.getModel().getFullModelRange(),text:a,forceMoveMarkers:!0}]),te.current.pushUndoStop(),J.current=!1))},[a],X),en(()=>{let O=te.current?.getModel();O&&o&&se.current?.editor.setModelLanguage(O,o)},[o],X),en(()=>{m!==void 0&&te.current?.revealLine(m)},[m],X),en(()=>{se.current?.editor.setTheme(d)},[d],X);let ve=S.useCallback(()=>{if(!(!Me.current||!se.current)&&!V.current){Dt.current(se.current);let O=c||i,L=qa(se.current,a||n||"",e||o||"",O||"");te.current=se.current?.editor.create(Me.current,{model:L,automaticLayout:!0,...h},x),v&&te.current.restoreViewState(jc.get(O)),se.current.editor.setTheme(d),m!==void 0&&te.current.revealLine(m),Z(!0),V.current=!0}},[n,e,i,a,o,c,h,x,v,d,m]);S.useEffect(()=>{X&&qe.current(te.current,se.current)},[X]),S.useEffect(()=>{!K&&!X&&ve()},[K,X,ve]),he.current=a,S.useEffect(()=>{X&&H&&(st.current?.dispose(),st.current=te.current?.onDidChangeModelContent(O=>{J.current||H(te.current.getValue(),O)}))},[X,H]),S.useEffect(()=>{if(X){let O=se.current.editor.onDidChangeMarkers(L=>{let Y=te.current.getModel()?.uri;if(Y&&L.find(W=>W.path===Y.path)){let W=se.current.editor.getModelMarkers({resource:Y});z?.(W)}});return()=>{O?.dispose()}}return()=>{}},[X,z]);function Ce(){st.current?.dispose(),b?v&&jc.set(c,te.current.saveViewState()):te.current.getModel()?.dispose(),te.current.dispose()}return Pr.createElement(eS,{width:_,height:N,isEditorReady:X,loading:f,_ref:Me,className:D,wrapperProps:q})}var YD=HD,GD=S.memo(YD),Zm=GD;const iS="https://ce.judge0.com",VD=54;async function WD(n,e=""){const i=await fetch(`${iS}/submissions?base64_encoded=false&wait=false`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({source_code:n,language_id:VD,stdin:e})});if(!i.ok){const a=await i.text();throw new Error(`Submission failed: ${i.status} - ${a}`)}return await i.json()}async function KD(n){const e=await fetch(`${iS}/submissions/${n}?base64_encoded=false&fields=stdout,stderr,compile_output,status,time,memory`,{method:"GET",headers:{"Content-Type":"application/json"}});if(!e.ok)throw new Error(`Failed to get result: ${e.statusText}`);return await e.json()}async function QD(n,e=""){const{token:i}=await WD(n,e),a=15,o=2e3;for(let c=0;c<a;c++){await new Promise(m=>setTimeout(m,o));const d=await KD(i);if(d.status&&d.status.id>=3)return{success:d.status.id===3,status:d.status.description,stdout:d.stdout||"",stderr:d.stderr||"",compile_output:d.compile_output||"",time:d.time,memory:d.memory}}throw new Error("Execution timed out")}const XD="modulepreload",$D=function(n){return"/"+n},$v={},rS=function(e,i,a){let o=Promise.resolve();if(i&&i.length>0){let h=function(x){return Promise.all(x.map(v=>Promise.resolve(v).then(b=>({status:"fulfilled",value:b}),b=>({status:"rejected",reason:b}))))};var d=h;document.getElementsByTagName("link");const m=document.querySelector("meta[property=csp-nonce]"),f=m?.nonce||m?.getAttribute("nonce");o=h(i.map(x=>{if(x=$D(x),x in $v)return;$v[x]=!0;const v=x.endsWith(".css"),b=v?'[rel="stylesheet"]':"";if(document.querySelector(`link[href="${x}"]${b}`))return;const _=document.createElement("link");if(_.rel=v?"stylesheet":XD,v||(_.as="script"),_.crossOrigin="",_.href=x,f&&_.setAttribute("nonce",f),document.head.appendChild(_),v)return new Promise((N,D)=>{_.addEventListener("load",N),_.addEventListener("error",()=>D(new Error(`Unable to preload CSS for ${x}`)))})}))}function c(m){const f=new Event("vite:preloadError",{cancelable:!0});if(f.payload=m,window.dispatchEvent(f),!f.defaultPrevented)throw m}return o.then(m=>{for(const f of m||[])f.status==="rejected"&&c(f.reason);return e().catch(c)})};async function aS(n){const e=_e(Te,"matchmaking/queue"),i=Mw(e);return await Pn(i,{odplayerId:n.id,playerName:n.name,joinedAt:Date.now(),status:"waiting",battleId:null}),console.log("Joined queue with key:",i.key,"player:",n.name),i.key}async function Jm(n){if(n)try{const e=_e(Te,`matchmaking/queue/${n}`);await ps(e),console.log("Left queue:",n)}catch(e){console.error("Error leaving queue:",e)}}async function sS(n,e,i){const a=_e(Te,"battles"),o=Mw(a);return await Pn(o,{player1:{id:n.id,name:n.name,code:i.starterCode,testsPassed:0,finished:!1},player2:{id:e.id,name:e.name,code:i.starterCode,testsPassed:0,finished:!1},problem:{id:i.id,title:i.title,description:i.description,difficulty:i.difficulty,category:i.category,starterCode:i.starterCode,expectedOutput:i.expectedOutput},status:"active",startedAt:QA(),winner:null}),console.log("Created battle:",o.key),o.key}function oS(n,e){const i=_e(Te,`battles/${n}`);return lr(i,a=>{a.exists()&&e(a.val())}),()=>Xr(i)}async function lS(n,e,i,a){const o=_e(Te,`battles/${n}`),c=await Tn(o);if(!c.exists())return;const f=c.val().player1.id===e?"player1":"player2",h=_e(Te,`battles/${n}/${f}`);await Rt(h,{testsPassed:i,finished:a}),await Rt(o,{status:"finished",winner:f,finishedAt:Date.now()})}async function cS(n,e){const i=_e(Te,`battles/${n}`),a=await Tn(i);if(!a.exists())return;const c=a.val().player1.id===e,d=c?"player1":"player2",m=c?"player2":"player1";await Rt(_e(Te,`battles/${n}/${d}`),{forfeited:!0}),await Rt(i,{status:"finished",winner:m,finishedAt:Date.now(),endReason:"forfeit"})}function uS(n,e,i,a){const o=_e(Te,"matchmaking/queue"),c=_e(Te,`matchmaking/queue/${e}`),d=lr(c,async m=>{if(!m.exists())return;const f=m.val();if(console.log("My entry updated:",f),f.battleId&&f.status==="matched"){console.log("I was matched! Battle:",f.battleId);const h=_e(Te,`battles/${f.battleId}`),x=await Tn(h);if(x.exists()){const v=x.val(),b=v.player1.id===n,_=b?v.player2:v.player1;i({battleId:f.battleId,problem:v.problem,opponent:_,isPlayer1:b})}await ps(c)}});return lr(o,async m=>{if(!m.exists())return;const f=m.val(),x=Object.entries(f).filter(([v,b])=>b.status==="waiting").sort((v,b)=>v[1].joinedAt-b[1].joinedAt);if(console.log("Waiting players:",x.length),x.length>=2){const[v,b]=x[0],[_,N]=x[1];if(v===e){console.log("I am first player, creating battle...");try{const{getRandomProblem:D}=await rS(async()=>{const{getRandomProblem:I}=await Promise.resolve().then(()=>D5);return{getRandomProblem:I}},[]),q=D(),F=await sS({id:b.odplayerId,name:b.playerName},{id:N.odplayerId,name:N.playerName},q);await Rt(_e(Te,`matchmaking/queue/${v}`),{status:"matched",battleId:F}),await Rt(_e(Te,`matchmaking/queue/${_}`),{status:"matched",battleId:F}),console.log("Battle created and players matched!")}catch(D){console.error("Error creating battle:",D),a(D)}}else console.log("Waiting for first player to create battle...")}}),()=>{d(),Xr(o)}}const ZD=Object.freeze(Object.defineProperty({__proto__:null,createBattle:sS,forfeitBattle:cS,joinQueue:aS,leaveQueue:Jm,subscribeToBattle:oS,subscribeToMatchmaking:uS,updatePlayerProgress:lS},Symbol.toStringTag,{value:"Module"}));function JD(n){const e=_e(Te,`online_players/${n.id}`);return Pn(e,{name:n.name,avatar:n.avatar||null,status:"available",onlineSince:Date.now()}),PA(e).remove(),()=>ps(e)}async function vo(n,e){const i=_e(Te,`online_players/${n}`);await Rt(i,{status:e})}function e4(n,e){const i=_e(Te,"online_players");return lr(i,a=>{if(!a.exists()){e([]);return}const o=[];a.forEach(c=>{c.key!==n&&o.push({id:c.key,...c.val()})}),e(o)}),()=>Xr(i)}async function t4(n,e,i){const a=_e(Te,`challenges/${e}`);return await Pn(a,{from:{id:n.id,name:n.name,avatar:n.avatar||null},problem:{id:i.id,title:i.title,description:i.description,difficulty:i.difficulty,category:i.category||"General",starterCode:i.starterCode,expectedOutput:i.expectedOutput,testCases:i.testCases||[]},createdAt:Date.now(),status:"pending",battleId:null}),a}function n4(n,e,i,a){const o=_e(Te,`challenges/${n}`);let c=!1;const d=setTimeout(async()=>{if(c)return;const m=await Tn(o);m.exists()&&m.val().status==="pending"&&(await Rt(o,{status:"expired"}),setTimeout(()=>ps(o),1e3))},3e4);return lr(o,m=>{if(!c)if(m.exists()){const f=m.val();f.status==="accepted"&&f.battleId?(c=!0,clearTimeout(d),e(f)):f.status==="declined"?(c=!0,clearTimeout(d),i()):f.status==="expired"&&(c=!0,clearTimeout(d),a())}else c||(c=!0,clearTimeout(d),a())}),()=>{clearTimeout(d),Xr(o)}}function i4(n,e){const i=_e(Te,`challenges/${n}`);return lr(i,a=>{if(a.exists()){const o=a.val();o.status==="pending"?e(o):e(null)}else e(null)}),()=>Xr(i)}async function r4(n,e,i){const{createBattle:a}=await rS(async()=>{const{createBattle:d}=await Promise.resolve().then(()=>ZD);return{createBattle:d}},void 0),o=await a({id:i.from.id,name:i.from.name},{id:n,name:e},i.problem),c=_e(Te,`challenges/${n}`);return await Rt(c,{status:"accepted",battleId:o}),setTimeout(()=>ps(c),5e3),o}async function a4(n){const e=_e(Te,`challenges/${n}`);await Rt(e,{status:"declined"}),setTimeout(()=>ps(e),2e3)}const s4=3e4,o4=()=>{const{user:n}=$r(),[e,i]=S.useState("lobby"),[a,o]=S.useState(!1),[c,d]=S.useState({type:"info",content:'Click "Run" to execute your code'}),[m,f]=S.useState(null),[h,x]=S.useState(null),[v,b]=S.useState(null),[_,N]=S.useState(null),[D,q]=S.useState(Fc()),[F,I]=S.useState(0),[H,z]=S.useState(0),[X,Z]=S.useState(null),[K,fe]=S.useState([]),[se,te]=S.useState(null),[Me,qe]=S.useState(null),[Dt,st]=S.useState(!1),[he,M]=S.useState(!1),[V,J]=S.useState([]),ve=S.useRef(null),Ce=S.useRef(null),O=S.useRef(null),L=S.useRef(null),Y=S.useRef(null),W=S.useRef(null),[oe,ce]=S.useState(D.starterCode);S.useEffect(()=>{n&&Dw(n.id,n.name,n.avatar)},[n]),S.useEffect(()=>{if(n){const ne=JD({id:n.id,name:n.name,avatar:n.avatar});return O.current=e4(n.id,He=>{fe(He.filter(It=>It.status==="available"))}),L.current=i4(n.id,te),()=>{ne(),O.current&&O.current(),L.current&&L.current()}}},[n]),S.useEffect(()=>{let ne;if(e==="playing"){const He=v||Date.now();ne=setInterval(()=>{I(Math.floor((Date.now()-He)/1e3))},1e3)}return()=>clearInterval(ne)},[e,v]);const ke=ne=>`${Math.floor(ne/60).toString().padStart(2,"0")}:${(ne%60).toString().padStart(2,"0")}`,dt=async(ne,He,It,Jr)=>{Y.current&&clearTimeout(Y.current),W.current&&clearInterval(W.current),x(ne),N(He),q(It),ce(It.starterCode),i("playing"),Z(null),b(Date.now()),qe(null),z(0),n&&vo(n.id,"in_battle"),Iw("battle");const kt=oS(ne,async bi=>{if(bi.startedAt&&b(bi.startedAt),bi.status==="finished"){const ll=bi.player1.id===n.id,gs=bi.winner===(ll?"player1":"player2");if(i("finished"),Z(gs?"win":"lose"),n&&vo(n.id,"available"),Ce.current&&Ce.current(),n){const ea=Math.floor((Date.now()-(bi.startedAt||Date.now()))/1e3),Bu=await eM(n.id,gs,ea),ys=await aM(n.id,Bu);ys.new.length>0&&J(ys.new)}}});Ce.current=kt},We=async()=>{if(!n)return;i("searching"),z(0);const ne=Date.now();W.current=setInterval(()=>{z(Math.floor((Date.now()-ne)/1e3))},1e3);try{const He=await aS({id:n.id,name:n.name});f(He),Y.current=setTimeout(async()=>{ve.current&&ve.current(),He&&await Jm(He),W.current&&clearInterval(W.current),f(null),i("timeout"),n&&vo(n.id,"available")},s4);const It=uS(n.id,He,Jr=>{dt(Jr.battleId,Jr.opponent,Jr.problem,null),It()},()=>{Y.current&&clearTimeout(Y.current),W.current&&clearInterval(W.current),i("lobby")});ve.current=It}catch{Y.current&&clearTimeout(Y.current),W.current&&clearInterval(W.current),i("lobby")}},pr=async()=>{Y.current&&clearTimeout(Y.current),W.current&&clearInterval(W.current),ve.current&&ve.current(),m&&await Jm(m),f(null),i("lobby"),z(0),n&&vo(n.id,"available")},Zr=async ne=>{const He=Fc();await t4({id:n.id,name:n.name,avatar:n.avatar},ne.id,He),qe({target:ne,problem:He}),st(!1),n4(ne.id,It=>dt(It.battleId,ne,It.problem),()=>qe(null),()=>qe(null))},ms=async()=>{const ne=await r4(n.id,n.name,se);dt(ne,se.from,se.problem),te(null)},sl=async()=>{await a4(n.id),te(null)},Bn=async()=>{h&&n&&await cS(h,n.id)},fs=async()=>{o(!0),d({type:"info",content:"Compiling..."});try{const ne=await QD(oe);if(ne.compile_output)d({type:"error",content:`Compile Error:
${ne.compile_output}`});else if(ne.stderr)d({type:"error",content:`Runtime Error:
${ne.stderr}`});else{const He=ne.stdout?.trim()===D.expectedOutput?.trim();d({type:He?"success":"warning",content:He?`All tests passed!
${ne.stdout}`:`Wrong answer
Expected: ${D.expectedOutput}
Got: ${ne.stdout}`}),He&&h&&await lS(h,n.id,1,!0)}}catch(ne){d({type:"error",content:ne.message})}o(!1)},hs=()=>{const ne=Fc();q(ne),ce(ne.starterCode),i("playing"),N(null),x(null),b(Date.now()),I(0)},Uu=()=>{i("lobby"),I(0),Z(null),x(null),N(null),J([]),Ce.current&&Ce.current(),n&&vo(n.id,"available")},ol=X==="win"?MM:DM,xi=({children:ne,onClose:He})=>y.jsx("div",{style:{position:"fixed",inset:0,background:"rgba(0,0,0,0.8)",backdropFilter:"blur(8px)",display:"flex",alignItems:"center",justifyContent:"center",zIndex:1e3},onClick:He,children:y.jsx("div",{style:{background:"var(--bg-elevated)",border:"1px solid var(--border)",borderRadius:"18px",padding:"32px",maxWidth:"400px",width:"90%"},onClick:It=>It.stopPropagation(),children:ne})});return y.jsxs("div",{className:"page",style:{display:"flex",flexDirection:"column",height:"100vh",paddingTop:"52px"},children:[he&&y.jsx(xi,{onClose:()=>M(!1),children:y.jsxs("div",{style:{textAlign:"center"},children:[y.jsx(JM,{size:40,style:{color:"var(--accent)",marginBottom:"16px"}}),y.jsx("h2",{className:"headline-small",style:{marginBottom:"8px"},children:"Sign In Required"}),y.jsx("p",{style:{color:"var(--text-secondary)",marginBottom:"28px"},children:"Create an account to compete with other players"}),y.jsxs("div",{style:{display:"flex",flexDirection:"column",gap:"12px"},children:[y.jsx(Tt,{to:"/signin",style:{textDecoration:"none"},children:y.jsx("button",{className:"btn btn-primary",style:{width:"100%",padding:"14px"},children:"Sign In / Sign Up"})}),y.jsx("button",{onClick:()=>M(!1),style:{padding:"12px",background:"transparent",border:"none",color:"var(--text-secondary)",cursor:"pointer"},children:"Maybe later"})]})]})}),se&&y.jsx(xi,{children:y.jsxs("div",{style:{textAlign:"center"},children:[y.jsx("div",{style:{width:"80px",height:"80px",margin:"0 auto 20px",borderRadius:"50%",background:"linear-gradient(135deg, rgba(0, 113, 227, 0.2), rgba(48, 209, 88, 0.2))",display:"flex",alignItems:"center",justifyContent:"center",border:"2px solid var(--border)"},children:se.from.avatar?y.jsx("img",{src:se.from.avatar,alt:"",style:{width:"72px",height:"72px",borderRadius:"50%",objectFit:"cover"}}):y.jsx("div",{style:{width:"72px",height:"72px",borderRadius:"50%",background:"var(--bg-elevated)",display:"flex",alignItems:"center",justifyContent:"center",fontSize:"28px",fontWeight:"600",color:"var(--accent)"},children:se.from.name?.charAt(0).toUpperCase()})}),y.jsx("h2",{className:"headline-small",style:{marginBottom:"4px"},children:se.from.name}),y.jsx("p",{style:{color:"var(--text-tertiary)",marginBottom:"28px",fontSize:"15px"},children:"wants to battle you"}),y.jsxs("div",{style:{display:"flex",gap:"12px"},children:[y.jsx("button",{onClick:sl,style:{flex:1,padding:"14px",background:"transparent",border:"1px solid var(--border)",borderRadius:"980px",color:"var(--text)",cursor:"pointer",fontSize:"15px",fontWeight:"500",transition:"all 0.2s"},children:"Decline"}),y.jsxs("button",{className:"btn btn-primary",onClick:ms,style:{flex:1,padding:"14px"},children:[y.jsx(Xm,{size:16})," Accept"]})]})]})}),V.length>0&&y.jsx(xi,{onClose:()=>J([]),children:y.jsxs("div",{style:{textAlign:"center"},children:[y.jsx("div",{style:{fontSize:"48px",marginBottom:"16px"},children:""}),y.jsx("h2",{className:"headline-small",style:{marginBottom:"8px"},children:"Achievement Unlocked!"}),V.map((ne,He)=>y.jsxs("div",{style:{padding:"16px",background:"var(--bg-secondary)",borderRadius:"12px",marginTop:"12px",textAlign:"left"},children:[y.jsx("div",{style:{fontWeight:"600",marginBottom:"4px"},children:ne.name}),y.jsx("div",{style:{fontSize:"14px",color:"var(--text-secondary)"},children:ne.desc})]},He)),y.jsx("button",{className:"btn btn-primary",onClick:()=>J([]),style:{marginTop:"20px",width:"100%",padding:"12px"},children:"Awesome!"})]})}),Dt&&y.jsxs(xi,{onClose:()=>st(!1),children:[y.jsxs("div",{style:{display:"flex",justifyContent:"space-between",alignItems:"center",marginBottom:"24px"},children:[y.jsx("h2",{className:"headline-small",style:{margin:0},children:"Online Players"}),y.jsx("button",{onClick:()=>st(!1),style:{background:"none",border:"none",color:"var(--text-tertiary)",cursor:"pointer",padding:"4px"},children:y.jsx($m,{size:20})})]}),K.length>0?y.jsx("div",{style:{display:"flex",flexDirection:"column",gap:"8px"},children:K.map(ne=>y.jsxs("div",{onClick:()=>Zr(ne),style:{display:"flex",alignItems:"center",gap:"12px",padding:"12px 16px",background:"var(--bg-secondary)",borderRadius:"12px",cursor:"pointer",transition:"background 0.15s"},children:[ne.avatar?y.jsx("img",{src:ne.avatar,alt:ne.name,style:{width:"40px",height:"40px",borderRadius:"50%",objectFit:"cover"}}):y.jsx("div",{className:"avatar",style:{width:"40px",height:"40px",fontSize:"15px"},children:ne.name?.charAt(0).toUpperCase()}),y.jsxs("div",{style:{flex:1},children:[y.jsx("div",{style:{fontWeight:"500"},children:ne.name}),y.jsx("div",{style:{fontSize:"12px",color:"var(--text-tertiary)"},children:"Available"})]}),y.jsx(Xm,{size:16,style:{color:"var(--accent)"}})]},ne.id))}):y.jsxs("div",{style:{textAlign:"center",padding:"40px 0",color:"var(--text-tertiary)"},children:[y.jsx(Vw,{size:32,style:{marginBottom:"12px",opacity:.5}}),y.jsx("p",{children:"No players online"})]})]}),e==="lobby"&&y.jsx("div",{style:{flex:1,display:"flex",alignItems:"center",justifyContent:"center",padding:"24px"},children:y.jsxs("div",{style:{maxWidth:"380px",width:"100%",textAlign:"center"},children:[y.jsx("h1",{className:"headline",style:{marginBottom:"12px"},children:"Ready to battle?"}),y.jsx("p",{style:{color:"var(--text-secondary)",marginBottom:"40px"},children:"Compete in real-time coding challenges"}),y.jsxs("div",{style:{display:"flex",flexDirection:"column",gap:"12px"},children:[y.jsxs("button",{className:"btn btn-primary",onClick:()=>n?We():M(!0),style:{width:"100%",padding:"14px"},children:[y.jsx(Hw,{size:18})," Find Match"]}),y.jsxs("button",{onClick:()=>n?st(!0):M(!0),style:{width:"100%",padding:"14px",background:"var(--bg-elevated)",border:"1px solid var(--border)",borderRadius:"980px",color:"var(--text)",cursor:"pointer",display:"flex",alignItems:"center",justifyContent:"center",gap:"8px"},children:[y.jsx(gR,{size:18})," Challenge Friend"]}),y.jsxs("button",{onClick:hs,style:{width:"100%",padding:"14px",background:"transparent",border:"none",borderRadius:"980px",color:"var(--text-secondary)",cursor:"pointer",display:"flex",alignItems:"center",justifyContent:"center",gap:"8px"},children:[y.jsx(PM,{size:18})," Solo Practice"]})]})]})}),e==="searching"&&y.jsxs("div",{style:{flex:1,display:"flex",alignItems:"center",justifyContent:"center",flexDirection:"column",gap:"24px"},children:[y.jsx("div",{className:"spinner",style:{width:"40px",height:"40px",borderWidth:"3px"}}),y.jsxs("div",{style:{textAlign:"center"},children:[y.jsx("p",{style:{color:"var(--text-secondary)",marginBottom:"8px"},children:"Finding opponent..."}),y.jsx("p",{className:"mono",style:{fontSize:"24px",fontWeight:"600"},children:ke(H)}),y.jsxs("p",{style:{fontSize:"13px",color:"var(--text-tertiary)",marginTop:"8px"},children:["Timeout in ",Math.max(0,30-H),"s"]})]}),y.jsx("button",{onClick:pr,style:{padding:"10px 24px",background:"transparent",border:"none",color:"var(--accent)",cursor:"pointer"},children:"Cancel"})]}),e==="timeout"&&y.jsxs("div",{style:{flex:1,display:"flex",alignItems:"center",justifyContent:"center",flexDirection:"column",gap:"24px"},children:[y.jsx(jM,{size:48,style:{color:"var(--orange)"}}),y.jsxs("div",{style:{textAlign:"center"},children:[y.jsx("h2",{className:"headline-small",style:{marginBottom:"8px"},children:"No opponents found"}),y.jsx("p",{style:{color:"var(--text-secondary)"},children:"Try again or practice solo"})]}),y.jsxs("div",{style:{display:"flex",gap:"12px"},children:[y.jsx("button",{onClick:We,className:"btn btn-primary",style:{padding:"12px 24px"},children:"Try Again"}),y.jsx("button",{onClick:()=>i("lobby"),style:{padding:"12px 24px",background:"var(--bg-elevated)",border:"1px solid var(--border)",borderRadius:"980px",color:"var(--text)",cursor:"pointer"},children:"Back"})]})]}),Me&&e==="lobby"&&y.jsxs("div",{style:{position:"fixed",bottom:"24px",right:"24px",background:"var(--bg-elevated)",border:"1px solid var(--border)",borderRadius:"14px",padding:"16px 20px",display:"flex",alignItems:"center",gap:"12px"},children:[y.jsx("div",{className:"spinner",style:{width:"16px",height:"16px"}}),y.jsxs("span",{style:{fontSize:"15px"},children:["Waiting for ",Me.target.name,"..."]}),y.jsx("button",{onClick:()=>qe(null),style:{background:"none",border:"none",color:"var(--text-tertiary)",cursor:"pointer",padding:"4px"},children:y.jsx($m,{size:16})})]}),(e==="playing"||e==="finished")&&y.jsxs("div",{style:{flex:1,display:"flex",overflow:"hidden"},children:[y.jsxs("div",{style:{flex:1,display:"flex",flexDirection:"column",borderRight:"1px solid var(--border)"},children:[y.jsx("div",{style:{padding:"12px 20px",borderBottom:"1px solid var(--border)",display:"flex",alignItems:"center"},children:y.jsx("span",{className:"mono",style:{fontSize:"13px",color:"var(--text-tertiary)"},children:"main.cpp"})}),y.jsx("div",{style:{flex:1},children:y.jsx(Zm,{height:"100%",defaultLanguage:"cpp",theme:"vs-dark",value:oe,onChange:ne=>ce(ne||""),options:{fontSize:14,minimap:{enabled:!1},automaticLayout:!0,readOnly:e==="finished",padding:{top:16},fontFamily:"SF Mono, Menlo, Monaco, monospace"}})}),y.jsxs("div",{style:{padding:"16px 20px",borderTop:"1px solid var(--border)",display:"flex",alignItems:"center",gap:"12px"},children:[y.jsx("button",{className:"btn btn-primary",onClick:fs,disabled:a||e==="finished",style:{padding:"10px 20px"},children:a?y.jsxs(y.Fragment,{children:[y.jsx("div",{className:"spinner",style:{width:"14px",height:"14px"}})," Running..."]}):y.jsxs(y.Fragment,{children:[y.jsx(Fw,{size:16})," Run"]})}),y.jsxs("button",{onClick:()=>ce(D.starterCode),disabled:e==="finished",style:{padding:"10px 16px",background:"transparent",border:"1px solid var(--border)",borderRadius:"980px",color:"var(--text-secondary)",cursor:"pointer",display:"flex",alignItems:"center",gap:"6px"},children:[y.jsx(oR,{size:14})," Reset"]}),_&&e==="playing"&&y.jsxs("button",{onClick:Bn,style:{marginLeft:"auto",padding:"10px 16px",background:"transparent",border:"none",color:"var(--red)",cursor:"pointer",display:"flex",alignItems:"center",gap:"6px"},children:[y.jsx(YM,{size:14})," Forfeit"]})]})]}),y.jsxs("div",{style:{width:"400px",display:"flex",flexDirection:"column",background:"var(--bg-secondary)"},children:[y.jsxs("div",{style:{padding:"24px",borderBottom:"1px solid var(--border)"},children:[y.jsx("span",{className:"badge",style:{marginBottom:"12px",background:D.difficulty==="EASY"?"rgba(48, 209, 88, 0.12)":"rgba(255, 159, 10, 0.12)",color:D.difficulty==="EASY"?"var(--green)":"var(--orange)"},children:D.difficulty}),y.jsx("h2",{style:{fontSize:"22px",fontWeight:"600",marginBottom:"12px"},children:D.title}),y.jsx("p",{style:{color:"var(--text-secondary)",fontSize:"15px",lineHeight:1.6},children:D.description})]}),y.jsxs("div",{style:{flex:1,padding:"20px",display:"flex",flexDirection:"column"},children:[y.jsx("span",{className:"caption",style:{marginBottom:"12px"},children:"OUTPUT"}),y.jsx("div",{style:{flex:1,padding:"16px",background:"var(--bg)",borderRadius:"12px",border:"1px solid var(--border)",overflow:"auto"},children:y.jsx("pre",{className:"mono",style:{margin:0,fontSize:"13px",whiteSpace:"pre-wrap",color:c.type==="success"?"var(--green)":c.type==="error"?"var(--red)":"var(--text-secondary)"},children:c.content})})]}),e==="finished"&&y.jsxs("div",{style:{padding:"24px",borderTop:"1px solid var(--border)",textAlign:"center"},children:[y.jsx(ol,{size:48,style:{color:X==="win"?"var(--green)":"var(--red)",marginBottom:"12px"}}),y.jsx("h3",{style:{fontSize:"24px",fontWeight:"600",marginBottom:"4px",color:X==="win"?"var(--green)":"var(--red)"},children:X==="win"?"Victory!":"Defeated"}),y.jsxs("p",{style:{color:"var(--text-tertiary)",marginBottom:"20px"},children:["Time: ",ke(F)]}),y.jsx("button",{className:"btn btn-primary",onClick:Uu,style:{width:"100%",padding:"14px"},children:"Play Again"})]})]})]})]})},Ac=20,l4=()=>{const[n,e]=S.useState("ALL"),[i,a]=S.useState("ALL"),[o,c]=S.useState(""),[d,m]=S.useState(null),[f,h]=S.useState({}),[x,v]=S.useState(1),b=S.useMemo(()=>["ALL",...Kw()],[]);S.useMemo(()=>Pu(),[]);const _=S.useMemo(()=>Gr.filter(z=>{const X=n==="ALL"||z.difficulty===n,Z=i==="ALL"||z.category===i,K=z.title.toLowerCase().includes(o.toLowerCase())||z.description.toLowerCase().includes(o.toLowerCase());return X&&Z&&K}),[n,i,o]),N=Math.ceil(_.length/Ac),D=(x-1)*Ac,q=_.slice(D,D+Ac);S.useMemo(()=>{v(1)},[n,i,o]);const F=z=>{m(d===z?null:z),d===z&&h({})},I=(z,X)=>{X.stopPropagation(),h(Z=>({...Z,[z]:!Z[z]}))},H=z=>{switch(z){case"EASY":return{background:"rgba(48, 209, 88, 0.12)",color:"var(--green)"};case"MEDIUM":return{background:"rgba(255, 159, 10, 0.12)",color:"var(--orange)"};case"HARD":return{background:"rgba(255, 69, 58, 0.12)",color:"var(--red)"};default:return{background:"rgba(0, 113, 227, 0.12)",color:"var(--accent)"}}};return y.jsx("div",{className:"page",children:y.jsxs("div",{className:"container",style:{paddingTop:"56px",paddingBottom:"56px"},children:[y.jsxs("div",{style:{marginBottom:"48px"},children:[y.jsx("p",{className:"caption",style:{marginBottom:"8px"},children:"Learn"}),y.jsx("h1",{className:"headline",children:"Master C++ Programming."}),y.jsx("p",{className:"body-large",style:{marginTop:"12px"},children:"600+ curated problems with solutions and explanations."})]}),y.jsxs("div",{className:"card",style:{padding:"20px",marginBottom:"24px"},children:[y.jsxs("div",{style:{display:"flex",gap:"12px",flexWrap:"wrap",alignItems:"center"},children:[y.jsxs("div",{style:{flex:1,minWidth:"200px",position:"relative"},children:[y.jsx(qw,{size:16,style:{position:"absolute",left:"14px",top:"50%",transform:"translateY(-50%)",color:"var(--text-tertiary)"}}),y.jsx("input",{type:"text",placeholder:"Search problems...",value:o,onChange:z=>c(z.target.value),className:"input",style:{paddingLeft:"40px"}})]}),y.jsxs("select",{value:n,onChange:z=>e(z.target.value),className:"input",style:{width:"auto",cursor:"pointer",fontFamily:"inherit"},children:[y.jsx("option",{value:"ALL",children:"All Levels"}),y.jsx("option",{value:"EASY",children:"Easy"}),y.jsx("option",{value:"MEDIUM",children:"Medium"}),y.jsx("option",{value:"HARD",children:"Hard"})]}),y.jsx("select",{value:i,onChange:z=>a(z.target.value),className:"input",style:{width:"auto",cursor:"pointer",fontFamily:"inherit"},children:b.map(z=>y.jsx("option",{value:z,children:z==="ALL"?"All Categories":z},z))})]}),y.jsx("div",{style:{display:"flex",justifyContent:"space-between",alignItems:"center",marginTop:"16px"},children:y.jsxs("span",{className:"caption",children:["Showing ",D+1,"-",Math.min(D+Ac,_.length)," of ",_.length]})})]}),y.jsx("div",{className:"card",style:{padding:0,overflow:"hidden"},children:y.jsxs("table",{className:"table",children:[y.jsx("thead",{children:y.jsxs("tr",{children:[y.jsx("th",{style:{width:"50px"},children:"#"}),y.jsx("th",{children:"Problem"}),y.jsx("th",{style:{width:"100px"},children:"Level"}),y.jsx("th",{style:{width:"140px"},children:"Category"})]})}),y.jsx("tbody",{children:q.map((z,X)=>y.jsxs(Pr.Fragment,{children:[y.jsxs("tr",{onClick:()=>F(z.id),style:{cursor:"pointer"},children:[y.jsx("td",{className:"mono",style:{color:"var(--text-tertiary)"},children:D+X+1}),y.jsx("td",{children:y.jsxs("div",{style:{display:"flex",alignItems:"center",gap:"8px"},children:[d===z.id?y.jsx(wM,{size:16,style:{color:"var(--accent)",flexShrink:0}}):y.jsx(qv,{size:16,style:{color:"var(--text-tertiary)",flexShrink:0}}),y.jsxs("div",{children:[y.jsx("div",{style:{fontWeight:"500"},children:z.title}),y.jsx("div",{style:{fontSize:"13px",color:"var(--text-tertiary)",marginTop:"2px"},children:z.description})]})]})}),y.jsx("td",{children:y.jsx("span",{className:"badge",style:H(z.difficulty),children:z.difficulty})}),y.jsx("td",{style:{color:"var(--text-secondary)"},children:z.category})]}),d===z.id&&y.jsx("tr",{children:y.jsx("td",{colSpan:4,style:{padding:0,background:"var(--bg-secondary)"},children:y.jsxs("div",{style:{padding:"24px"},children:[y.jsxs("div",{className:"grid grid-2",style:{marginBottom:"24px"},children:[y.jsxs("div",{children:[y.jsx("span",{className:"caption",style:{display:"block",marginBottom:"8px"},children:"DESCRIPTION"}),y.jsx("p",{style:{color:"var(--text)",lineHeight:"1.5"},children:z.description})]}),y.jsxs("div",{children:[y.jsx("span",{className:"caption",style:{display:"block",marginBottom:"8px"},children:"EXPECTED OUTPUT"}),y.jsx("code",{className:"mono",style:{background:"var(--bg-elevated)",padding:"10px 14px",borderRadius:"8px",display:"block",color:"var(--green)"},children:z.expectedOutput})]})]}),y.jsxs("div",{style:{marginBottom:"24px"},children:[y.jsx("span",{className:"caption",style:{display:"block",marginBottom:"12px"},children:"STARTER CODE"}),y.jsx("div",{style:{borderRadius:"12px",overflow:"hidden",border:"1px solid var(--border)"},children:y.jsx(Zm,{height:"160px",defaultLanguage:"cpp",value:z.starterCode,theme:"vs-dark",options:{readOnly:!0,minimap:{enabled:!1},fontSize:13,scrollBeyondLastLine:!1,lineNumbers:"on",padding:{top:12}}})})]}),y.jsxs("button",{onClick:Z=>I(z.id,Z),className:"btn btn-primary",style:{marginBottom:f[z.id]?"24px":0},children:[f[z.id]?y.jsx(zM,{size:16}):y.jsx(qM,{size:16}),f[z.id]?"Hide Solution":"Show Solution"]}),f[z.id]&&y.jsxs(y.Fragment,{children:[y.jsxs("div",{style:{marginBottom:"24px"},children:[y.jsx("span",{className:"caption",style:{display:"block",marginBottom:"12px"},children:"SOLUTION"}),y.jsx("div",{style:{borderRadius:"12px",overflow:"hidden",border:"1px solid rgba(255, 159, 10, 0.3)"},children:y.jsx(Zm,{height:"200px",defaultLanguage:"cpp",value:z.solution,theme:"vs-dark",options:{readOnly:!0,minimap:{enabled:!1},fontSize:13,scrollBeyondLastLine:!1,lineNumbers:"on",padding:{top:12}}})})]}),z.explanation&&y.jsxs("div",{className:"card",style:{background:"var(--bg-elevated)"},children:[y.jsx("span",{className:"caption",style:{display:"block",marginBottom:"16px"},children:"EXPLANATION"}),z.explanation.approach&&y.jsxs("div",{style:{marginBottom:"16px"},children:[y.jsx("span",{style:{fontWeight:"500",color:"var(--accent)"},children:"Approach: "}),y.jsx("span",{style:{color:"var(--text-secondary)"},children:z.explanation.approach})]}),z.explanation.analogy&&y.jsxs("div",{style:{marginBottom:"16px",padding:"14px 16px",background:"rgba(0, 113, 227, 0.08)",borderRadius:"10px",borderLeft:"3px solid var(--accent)"},children:[y.jsx("span",{style:{fontWeight:"500",color:"var(--accent)"},children:"Analogy: "}),y.jsx("span",{style:{color:"var(--text)"},children:z.explanation.analogy})]}),z.explanation.steps&&y.jsxs("div",{style:{marginBottom:"16px"},children:[y.jsx("span",{style:{fontWeight:"500",color:"var(--green)",display:"block",marginBottom:"8px"},children:"Steps:"}),y.jsx("ol",{style:{paddingLeft:"20px",color:"var(--text-secondary)",margin:0},children:z.explanation.steps.map((Z,K)=>y.jsx("li",{style:{marginBottom:"4px",lineHeight:"1.5"},children:Z},K))})]}),z.explanation.complexity&&y.jsx("div",{style:{display:"inline-block",padding:"8px 14px",background:"var(--bg-secondary)",borderRadius:"8px"},children:y.jsx("span",{className:"mono",style:{color:"var(--text-secondary)",fontSize:"13px"},children:z.explanation.complexity})})]})]})]})})})]},z.id))})]})}),N>1&&y.jsxs("div",{style:{display:"flex",justifyContent:"center",alignItems:"center",gap:"8px",marginTop:"24px"},children:[y.jsx("button",{onClick:()=>v(1),disabled:x===1,className:"btn btn-ghost",style:{padding:"8px"},children:y.jsx(TM,{size:18})}),y.jsx("button",{onClick:()=>v(z=>Math.max(1,z-1)),disabled:x===1,className:"btn btn-ghost",style:{padding:"8px"},children:y.jsx(CM,{size:18})}),y.jsxs("span",{style:{padding:"0 16px",color:"var(--text-secondary)"},children:["Page ",x," of ",N]}),y.jsx("button",{onClick:()=>v(z=>Math.min(N,z+1)),disabled:x===N,className:"btn btn-ghost",style:{padding:"8px"},children:y.jsx(qv,{size:18})}),y.jsx("button",{onClick:()=>v(N),disabled:x===N,className:"btn btn-ghost",style:{padding:"8px"},children:y.jsx(NM,{size:18})})]}),_.length===0&&y.jsxs("div",{className:"empty",children:[y.jsx("p",{style:{fontSize:"17px",marginBottom:"8px"},children:"No problems found"}),y.jsx("p",{style:{fontSize:"14px"},children:"Try adjusting your filters"})]})]})})};const dS="firebasestorage.googleapis.com",pS="storageBucket",c4=120*1e3,u4=600*1e3;class it extends gi{constructor(e,i,a=0){super(Om(e),`Firebase Storage: ${i} (${Om(e)})`),this.status_=a,this.customData={serverResponse:null},this._baseMessage=this.message,Object.setPrototypeOf(this,it.prototype)}get status(){return this.status_}set status(e){this.status_=e}_codeEquals(e){return Om(e)===this.code}get serverResponse(){return this.customData.serverResponse}set serverResponse(e){this.customData.serverResponse=e,this.customData.serverResponse?this.message=`${this._baseMessage}
${this.customData.serverResponse}`:this.message=this._baseMessage}}var tt;(function(n){n.UNKNOWN="unknown",n.OBJECT_NOT_FOUND="object-not-found",n.BUCKET_NOT_FOUND="bucket-not-found",n.PROJECT_NOT_FOUND="project-not-found",n.QUOTA_EXCEEDED="quota-exceeded",n.UNAUTHENTICATED="unauthenticated",n.UNAUTHORIZED="unauthorized",n.UNAUTHORIZED_APP="unauthorized-app",n.RETRY_LIMIT_EXCEEDED="retry-limit-exceeded",n.INVALID_CHECKSUM="invalid-checksum",n.CANCELED="canceled",n.INVALID_EVENT_NAME="invalid-event-name",n.INVALID_URL="invalid-url",n.INVALID_DEFAULT_BUCKET="invalid-default-bucket",n.NO_DEFAULT_BUCKET="no-default-bucket",n.CANNOT_SLICE_BLOB="cannot-slice-blob",n.SERVER_FILE_WRONG_SIZE="server-file-wrong-size",n.NO_DOWNLOAD_URL="no-download-url",n.INVALID_ARGUMENT="invalid-argument",n.INVALID_ARGUMENT_COUNT="invalid-argument-count",n.APP_DELETED="app-deleted",n.INVALID_ROOT_OPERATION="invalid-root-operation",n.INVALID_FORMAT="invalid-format",n.INTERNAL_ERROR="internal-error",n.UNSUPPORTED_ENVIRONMENT="unsupported-environment"})(tt||(tt={}));function Om(n){return"storage/"+n}function mh(){const n="An unknown error occurred, please check the error payload for server response.";return new it(tt.UNKNOWN,n)}function d4(n){return new it(tt.OBJECT_NOT_FOUND,"Object '"+n+"' does not exist.")}function p4(n){return new it(tt.QUOTA_EXCEEDED,"Quota for bucket '"+n+"' exceeded, please view quota on https://firebase.google.com/pricing/.")}function m4(){const n="User is not authenticated, please authenticate using Firebase Authentication and try again.";return new it(tt.UNAUTHENTICATED,n)}function f4(){return new it(tt.UNAUTHORIZED_APP,"This app does not have permission to access Firebase Storage on this project.")}function h4(n){return new it(tt.UNAUTHORIZED,"User does not have permission to access '"+n+"'.")}function g4(){return new it(tt.RETRY_LIMIT_EXCEEDED,"Max retry time for operation exceeded, please try again.")}function y4(){return new it(tt.CANCELED,"User canceled the upload/download.")}function v4(n){return new it(tt.INVALID_URL,"Invalid URL '"+n+"'.")}function x4(n){return new it(tt.INVALID_DEFAULT_BUCKET,"Invalid default bucket '"+n+"'.")}function b4(){return new it(tt.NO_DEFAULT_BUCKET,"No default bucket found. Did you set the '"+pS+"' property when initializing the app?")}function w4(){return new it(tt.CANNOT_SLICE_BLOB,"Cannot slice blob for upload. Please retry the upload.")}function S4(){return new it(tt.NO_DOWNLOAD_URL,"The given file does not have any download URLs.")}function C4(n){return new it(tt.UNSUPPORTED_ENVIRONMENT,`${n} is missing. Make sure to install the required polyfills. See https://firebase.google.com/docs/web/environments-js-sdk#polyfills for more information.`)}function ef(n){return new it(tt.INVALID_ARGUMENT,n)}function mS(){return new it(tt.APP_DELETED,"The Firebase app was deleted.")}function O4(n){return new it(tt.INVALID_ROOT_OPERATION,"The operation '"+n+"' cannot be performed on a root reference, create a non-root reference using child, such as .child('file.png').")}function Ao(n,e){return new it(tt.INVALID_FORMAT,"String does not match format '"+n+"': "+e)}function xo(n){throw new it(tt.INTERNAL_ERROR,"Internal error: "+n)}class tn{constructor(e,i){this.bucket=e,this.path_=i}get path(){return this.path_}get isRoot(){return this.path.length===0}fullServerUrl(){const e=encodeURIComponent;return"/b/"+e(this.bucket)+"/o/"+e(this.path)}bucketOnlyServerUrl(){return"/b/"+encodeURIComponent(this.bucket)+"/o"}static makeFromBucketSpec(e,i){let a;try{a=tn.makeFromUrl(e,i)}catch{return new tn(e,"")}if(a.path==="")return a;throw x4(e)}static makeFromUrl(e,i){let a=null;const o="([A-Za-z0-9.\\-_]+)";function c(z){z.path.charAt(z.path.length-1)==="/"&&(z.path_=z.path_.slice(0,-1))}const d="(/(.*))?$",m=new RegExp("^gs://"+o+d,"i"),f={bucket:1,path:3};function h(z){z.path_=decodeURIComponent(z.path)}const x="v[A-Za-z0-9_]+",v=i.replace(/[.]/g,"\\."),b="(/([^?#]*).*)?$",_=new RegExp(`^https?://${v}/${x}/b/${o}/o${b}`,"i"),N={bucket:1,path:3},D=i===dS?"(?:storage.googleapis.com|storage.cloud.google.com)":i,q="([^?#]*)",F=new RegExp(`^https?://${D}/${o}/${q}`,"i"),H=[{regex:m,indices:f,postModify:c},{regex:_,indices:N,postModify:h},{regex:F,indices:{bucket:1,path:2},postModify:h}];for(let z=0;z<H.length;z++){const X=H[z],Z=X.regex.exec(e);if(Z){const K=Z[X.indices.bucket];let fe=Z[X.indices.path];fe||(fe=""),a=new tn(K,fe),X.postModify(a);break}}if(a==null)throw v4(e);return a}}class _4{constructor(e){this.promise_=Promise.reject(e)}getPromise(){return this.promise_}cancel(e=!1){}}function T4(n,e,i){let a=1,o=null,c=null,d=!1,m=0;function f(){return m===2}let h=!1;function x(...q){h||(h=!0,e.apply(null,q))}function v(q){o=setTimeout(()=>{o=null,n(_,f())},q)}function b(){c&&clearTimeout(c)}function _(q,...F){if(h){b();return}if(q){b(),x.call(null,q,...F);return}if(f()||d){b(),x.call(null,q,...F);return}a<64&&(a*=2);let H;m===1?(m=2,H=0):H=(a+Math.random())*1e3,v(H)}let N=!1;function D(q){N||(N=!0,b(),!h&&(o!==null?(q||(m=2),clearTimeout(o),v(0)):q||(m=1)))}return v(0),c=setTimeout(()=>{d=!0,D(!0)},i),D}function k4(n){n(!1)}function N4(n){return n!==void 0}function E4(n){return typeof n=="object"&&!Array.isArray(n)}function fh(n){return typeof n=="string"||n instanceof String}function Zv(n){return hh()&&n instanceof Blob}function hh(){return typeof Blob<"u"}function Jv(n,e,i,a){if(a<e)throw ef(`Invalid value for '${n}'. Expected ${e} or greater.`);if(a>i)throw ef(`Invalid value for '${n}'. Expected ${i} or less.`)}function gh(n,e,i){let a=e;return i==null&&(a=`https://${e}`),`${i}://${a}/v0${n}`}function fS(n){const e=encodeURIComponent;let i="?";for(const a in n)if(n.hasOwnProperty(a)){const o=e(a)+"="+e(n[a]);i=i+o+"&"}return i=i.slice(0,-1),i}var Lr;(function(n){n[n.NO_ERROR=0]="NO_ERROR",n[n.NETWORK_ERROR=1]="NETWORK_ERROR",n[n.ABORT=2]="ABORT"})(Lr||(Lr={}));function j4(n,e){const i=n>=500&&n<600,o=[408,429].indexOf(n)!==-1,c=e.indexOf(n)!==-1;return i||o||c}class A4{constructor(e,i,a,o,c,d,m,f,h,x,v,b=!0,_=!1){this.url_=e,this.method_=i,this.headers_=a,this.body_=o,this.successCodes_=c,this.additionalRetryCodes_=d,this.callback_=m,this.errorCallback_=f,this.timeout_=h,this.progressCallback_=x,this.connectionFactory_=v,this.retry=b,this.isUsingEmulator=_,this.pendingConnection_=null,this.backoffId_=null,this.canceled_=!1,this.appDelete_=!1,this.promise_=new Promise((N,D)=>{this.resolve_=N,this.reject_=D,this.start_()})}start_(){const e=(a,o)=>{if(o){a(!1,new Mc(!1,null,!0));return}const c=this.connectionFactory_();this.pendingConnection_=c;const d=m=>{const f=m.loaded,h=m.lengthComputable?m.total:-1;this.progressCallback_!==null&&this.progressCallback_(f,h)};this.progressCallback_!==null&&c.addUploadProgressListener(d),c.send(this.url_,this.method_,this.isUsingEmulator,this.body_,this.headers_).then(()=>{this.progressCallback_!==null&&c.removeUploadProgressListener(d),this.pendingConnection_=null;const m=c.getErrorCode()===Lr.NO_ERROR,f=c.getStatus();if(!m||j4(f,this.additionalRetryCodes_)&&this.retry){const x=c.getErrorCode()===Lr.ABORT;a(!1,new Mc(!1,null,x));return}const h=this.successCodes_.indexOf(f)!==-1;a(!0,new Mc(h,c))})},i=(a,o)=>{const c=this.resolve_,d=this.reject_,m=o.connection;if(o.wasSuccessCode)try{const f=this.callback_(m,m.getResponse());N4(f)?c(f):c()}catch(f){d(f)}else if(m!==null){const f=mh();f.serverResponse=m.getErrorText(),this.errorCallback_?d(this.errorCallback_(m,f)):d(f)}else if(o.canceled){const f=this.appDelete_?mS():y4();d(f)}else{const f=g4();d(f)}};this.canceled_?i(!1,new Mc(!1,null,!0)):this.backoffId_=T4(e,i,this.timeout_)}getPromise(){return this.promise_}cancel(e){this.canceled_=!0,this.appDelete_=e||!1,this.backoffId_!==null&&k4(this.backoffId_),this.pendingConnection_!==null&&this.pendingConnection_.abort()}}class Mc{constructor(e,i,a){this.wasSuccessCode=e,this.connection=i,this.canceled=!!a}}function M4(n,e){e!==null&&e.length>0&&(n.Authorization="Firebase "+e)}function R4(n,e){n["X-Firebase-Storage-Version"]="webjs/"+(e??"AppManager")}function D4(n,e){e&&(n["X-Firebase-GMPID"]=e)}function I4(n,e){e!==null&&(n["X-Firebase-AppCheck"]=e)}function P4(n,e,i,a,o,c,d=!0,m=!1){const f=fS(n.urlParams),h=n.url+f,x=Object.assign({},n.headers);return D4(x,e),M4(x,i),R4(x,c),I4(x,a),new A4(h,n.method,x,n.body,n.successCodes,n.additionalRetryCodes,n.handler,n.errorHandler,n.timeout,n.progressCallback,o,d,m)}function L4(){return typeof BlobBuilder<"u"?BlobBuilder:typeof WebKitBlobBuilder<"u"?WebKitBlobBuilder:void 0}function U4(...n){const e=L4();if(e!==void 0){const i=new e;for(let a=0;a<n.length;a++)i.append(n[a]);return i.getBlob()}else{if(hh())return new Blob(n);throw new it(tt.UNSUPPORTED_ENVIRONMENT,"This browser doesn't seem to support creating Blobs")}}function B4(n,e,i){return n.webkitSlice?n.webkitSlice(e,i):n.mozSlice?n.mozSlice(e,i):n.slice?n.slice(e,i):null}function z4(n){if(typeof atob>"u")throw C4("base-64");return atob(n)}const Rn={RAW:"raw",BASE64:"base64",BASE64URL:"base64url",DATA_URL:"data_url"};class _m{constructor(e,i){this.data=e,this.contentType=i||null}}function F4(n,e){switch(n){case Rn.RAW:return new _m(hS(e));case Rn.BASE64:case Rn.BASE64URL:return new _m(gS(n,e));case Rn.DATA_URL:return new _m(H4(e),Y4(e))}throw mh()}function hS(n){const e=[];for(let i=0;i<n.length;i++){let a=n.charCodeAt(i);if(a<=127)e.push(a);else if(a<=2047)e.push(192|a>>6,128|a&63);else if((a&64512)===55296)if(!(i<n.length-1&&(n.charCodeAt(i+1)&64512)===56320))e.push(239,191,189);else{const c=a,d=n.charCodeAt(++i);a=65536|(c&1023)<<10|d&1023,e.push(240|a>>18,128|a>>12&63,128|a>>6&63,128|a&63)}else(a&64512)===56320?e.push(239,191,189):e.push(224|a>>12,128|a>>6&63,128|a&63)}return new Uint8Array(e)}function q4(n){let e;try{e=decodeURIComponent(n)}catch{throw Ao(Rn.DATA_URL,"Malformed data URL.")}return hS(e)}function gS(n,e){switch(n){case Rn.BASE64:{const o=e.indexOf("-")!==-1,c=e.indexOf("_")!==-1;if(o||c)throw Ao(n,"Invalid character '"+(o?"-":"_")+"' found: is it base64url encoded?");break}case Rn.BASE64URL:{const o=e.indexOf("+")!==-1,c=e.indexOf("/")!==-1;if(o||c)throw Ao(n,"Invalid character '"+(o?"+":"/")+"' found: is it base64 encoded?");e=e.replace(/-/g,"+").replace(/_/g,"/");break}}let i;try{i=z4(e)}catch(o){throw o.message.includes("polyfill")?o:Ao(n,"Invalid character found")}const a=new Uint8Array(i.length);for(let o=0;o<i.length;o++)a[o]=i.charCodeAt(o);return a}class yS{constructor(e){this.base64=!1,this.contentType=null;const i=e.match(/^data:([^,]+)?,/);if(i===null)throw Ao(Rn.DATA_URL,"Must be formatted 'data:[<mediatype>][;base64],<data>");const a=i[1]||null;a!=null&&(this.base64=G4(a,";base64"),this.contentType=this.base64?a.substring(0,a.length-7):a),this.rest=e.substring(e.indexOf(",")+1)}}function H4(n){const e=new yS(n);return e.base64?gS(Rn.BASE64,e.rest):q4(e.rest)}function Y4(n){return new yS(n).contentType}function G4(n,e){return n.length>=e.length?n.substring(n.length-e.length)===e:!1}class Xi{constructor(e,i){let a=0,o="";Zv(e)?(this.data_=e,a=e.size,o=e.type):e instanceof ArrayBuffer?(i?this.data_=new Uint8Array(e):(this.data_=new Uint8Array(e.byteLength),this.data_.set(new Uint8Array(e))),a=this.data_.length):e instanceof Uint8Array&&(i?this.data_=e:(this.data_=new Uint8Array(e.length),this.data_.set(e)),a=e.length),this.size_=a,this.type_=o}size(){return this.size_}type(){return this.type_}slice(e,i){if(Zv(this.data_)){const a=this.data_,o=B4(a,e,i);return o===null?null:new Xi(o)}else{const a=new Uint8Array(this.data_.buffer,e,i-e);return new Xi(a,!0)}}static getBlob(...e){if(hh()){const i=e.map(a=>a instanceof Xi?a.data_:a);return new Xi(U4.apply(null,i))}else{const i=e.map(d=>fh(d)?F4(Rn.RAW,d).data:d.data_);let a=0;i.forEach(d=>{a+=d.byteLength});const o=new Uint8Array(a);let c=0;return i.forEach(d=>{for(let m=0;m<d.length;m++)o[c++]=d[m]}),new Xi(o,!0)}}uploadData(){return this.data_}}function vS(n){let e;try{e=JSON.parse(n)}catch{return null}return E4(e)?e:null}function V4(n){if(n.length===0)return null;const e=n.lastIndexOf("/");return e===-1?"":n.slice(0,e)}function W4(n,e){const i=e.split("/").filter(a=>a.length>0).join("/");return n.length===0?i:n+"/"+i}function xS(n){const e=n.lastIndexOf("/",n.length-2);return e===-1?n:n.slice(e+1)}function K4(n,e){return e}class Et{constructor(e,i,a,o){this.server=e,this.local=i||e,this.writable=!!a,this.xform=o||K4}}let Rc=null;function Q4(n){return!fh(n)||n.length<2?n:xS(n)}function bS(){if(Rc)return Rc;const n=[];n.push(new Et("bucket")),n.push(new Et("generation")),n.push(new Et("metageneration")),n.push(new Et("name","fullPath",!0));function e(c,d){return Q4(d)}const i=new Et("name");i.xform=e,n.push(i);function a(c,d){return d!==void 0?Number(d):d}const o=new Et("size");return o.xform=a,n.push(o),n.push(new Et("timeCreated")),n.push(new Et("updated")),n.push(new Et("md5Hash",null,!0)),n.push(new Et("cacheControl",null,!0)),n.push(new Et("contentDisposition",null,!0)),n.push(new Et("contentEncoding",null,!0)),n.push(new Et("contentLanguage",null,!0)),n.push(new Et("contentType",null,!0)),n.push(new Et("metadata","customMetadata",!0)),Rc=n,Rc}function X4(n,e){function i(){const a=n.bucket,o=n.fullPath,c=new tn(a,o);return e._makeStorageReference(c)}Object.defineProperty(n,"ref",{get:i})}function $4(n,e,i){const a={};a.type="file";const o=i.length;for(let c=0;c<o;c++){const d=i[c];a[d.local]=d.xform(a,e[d.server])}return X4(a,n),a}function wS(n,e,i){const a=vS(e);return a===null?null:$4(n,a,i)}function Z4(n,e,i,a){const o=vS(e);if(o===null||!fh(o.downloadTokens))return null;const c=o.downloadTokens;if(c.length===0)return null;const d=encodeURIComponent;return c.split(",").map(h=>{const x=n.bucket,v=n.fullPath,b="/b/"+d(x)+"/o/"+d(v),_=gh(b,i,a),N=fS({alt:"media",token:h});return _+N})[0]}function J4(n,e){const i={},a=e.length;for(let o=0;o<a;o++){const c=e[o];c.writable&&(i[c.server]=n[c.local])}return JSON.stringify(i)}class SS{constructor(e,i,a,o){this.url=e,this.method=i,this.handler=a,this.timeout=o,this.urlParams={},this.headers={},this.body=null,this.errorHandler=null,this.progressCallback=null,this.successCodes=[200],this.additionalRetryCodes=[]}}function CS(n){if(!n)throw mh()}function eI(n,e){function i(a,o){const c=wS(n,o,e);return CS(c!==null),c}return i}function tI(n,e){function i(a,o){const c=wS(n,o,e);return CS(c!==null),Z4(c,o,n.host,n._protocol)}return i}function OS(n){function e(i,a){let o;return i.getStatus()===401?i.getErrorText().includes("Firebase App Check token is invalid")?o=f4():o=m4():i.getStatus()===402?o=p4(n.bucket):i.getStatus()===403?o=h4(n.path):o=a,o.status=i.getStatus(),o.serverResponse=a.serverResponse,o}return e}function nI(n){const e=OS(n);function i(a,o){let c=e(a,o);return a.getStatus()===404&&(c=d4(n.path)),c.serverResponse=o.serverResponse,c}return i}function iI(n,e,i){const a=e.fullServerUrl(),o=gh(a,n.host,n._protocol),c="GET",d=n.maxOperationRetryTime,m=new SS(o,c,tI(n,i),d);return m.errorHandler=nI(e),m}function rI(n,e){return n&&n.contentType||e&&e.type()||"application/octet-stream"}function aI(n,e,i){const a=Object.assign({},i);return a.fullPath=n.path,a.size=e.size(),a.contentType||(a.contentType=rI(null,e)),a}function sI(n,e,i,a,o){const c=e.bucketOnlyServerUrl(),d={"X-Goog-Upload-Protocol":"multipart"};function m(){let H="";for(let z=0;z<2;z++)H=H+Math.random().toString().slice(2);return H}const f=m();d["Content-Type"]="multipart/related; boundary="+f;const h=aI(e,a,o),x=J4(h,i),v="--"+f+`\r
Content-Type: application/json; charset=utf-8\r
\r
`+x+`\r
--`+f+`\r
Content-Type: `+h.contentType+`\r
\r
`,b=`\r
--`+f+"--",_=Xi.getBlob(v,a,b);if(_===null)throw w4();const N={name:h.fullPath},D=gh(c,n.host,n._protocol),q="POST",F=n.maxUploadRetryTime,I=new SS(D,q,eI(n,i),F);return I.urlParams=N,I.headers=d,I.body=_.uploadData(),I.errorHandler=OS(e),I}class oI{constructor(){this.sent_=!1,this.xhr_=new XMLHttpRequest,this.initXhr(),this.errorCode_=Lr.NO_ERROR,this.sendPromise_=new Promise(e=>{this.xhr_.addEventListener("abort",()=>{this.errorCode_=Lr.ABORT,e()}),this.xhr_.addEventListener("error",()=>{this.errorCode_=Lr.NETWORK_ERROR,e()}),this.xhr_.addEventListener("load",()=>{e()})})}send(e,i,a,o,c){if(this.sent_)throw xo("cannot .send() more than once");if(cr(e)&&a&&(this.xhr_.withCredentials=!0),this.sent_=!0,this.xhr_.open(i,e,!0),c!==void 0)for(const d in c)c.hasOwnProperty(d)&&this.xhr_.setRequestHeader(d,c[d].toString());return o!==void 0?this.xhr_.send(o):this.xhr_.send(),this.sendPromise_}getErrorCode(){if(!this.sent_)throw xo("cannot .getErrorCode() before sending");return this.errorCode_}getStatus(){if(!this.sent_)throw xo("cannot .getStatus() before sending");try{return this.xhr_.status}catch{return-1}}getResponse(){if(!this.sent_)throw xo("cannot .getResponse() before sending");return this.xhr_.response}getErrorText(){if(!this.sent_)throw xo("cannot .getErrorText() before sending");return this.xhr_.statusText}abort(){this.xhr_.abort()}getResponseHeader(e){return this.xhr_.getResponseHeader(e)}addUploadProgressListener(e){this.xhr_.upload!=null&&this.xhr_.upload.addEventListener("progress",e)}removeUploadProgressListener(e){this.xhr_.upload!=null&&this.xhr_.upload.removeEventListener("progress",e)}}class lI extends oI{initXhr(){this.xhr_.responseType="text"}}function _S(){return new lI}class Vr{constructor(e,i){this._service=e,i instanceof tn?this._location=i:this._location=tn.makeFromUrl(i,e.host)}toString(){return"gs://"+this._location.bucket+"/"+this._location.path}_newRef(e,i){return new Vr(e,i)}get root(){const e=new tn(this._location.bucket,"");return this._newRef(this._service,e)}get bucket(){return this._location.bucket}get fullPath(){return this._location.path}get name(){return xS(this._location.path)}get storage(){return this._service}get parent(){const e=V4(this._location.path);if(e===null)return null;const i=new tn(this._location.bucket,e);return new Vr(this._service,i)}_throwIfRoot(e){if(this._location.path==="")throw O4(e)}}function cI(n,e,i){n._throwIfRoot("uploadBytes");const a=sI(n.storage,n._location,bS(),new Xi(e,!0),i);return n.storage.makeRequestWithTokens(a,_S).then(o=>({metadata:o,ref:n}))}function uI(n){n._throwIfRoot("getDownloadURL");const e=iI(n.storage,n._location,bS());return n.storage.makeRequestWithTokens(e,_S).then(i=>{if(i===null)throw S4();return i})}function dI(n,e){const i=W4(n._location.path,e),a=new tn(n._location.bucket,i);return new Vr(n.storage,a)}function pI(n){return/^[A-Za-z]+:\/\//.test(n)}function mI(n,e){return new Vr(n,e)}function TS(n,e){if(n instanceof yh){const i=n;if(i._bucket==null)throw b4();const a=new Vr(i,i._bucket);return e!=null?TS(a,e):a}else return e!==void 0?dI(n,e):n}function fI(n,e){if(e&&pI(e)){if(n instanceof yh)return mI(n,e);throw ef("To use ref(service, url), the first argument must be a Storage instance.")}else return TS(n,e)}function ex(n,e){const i=e?.[pS];return i==null?null:tn.makeFromBucketSpec(i,n)}function hI(n,e,i,a={}){n.host=`${e}:${i}`;const o=cr(e);o&&(pf(`https://${n.host}/b`),mf("Storage",!0)),n._isUsingEmulator=!0,n._protocol=o?"https":"http";const{mockUserToken:c}=a;c&&(n._overrideAuthToken=typeof c=="string"?c:jx(c,n.app.options.projectId))}class yh{constructor(e,i,a,o,c,d=!1){this.app=e,this._authProvider=i,this._appCheckProvider=a,this._url=o,this._firebaseVersion=c,this._isUsingEmulator=d,this._bucket=null,this._host=dS,this._protocol="https",this._appId=null,this._deleted=!1,this._maxOperationRetryTime=c4,this._maxUploadRetryTime=u4,this._requests=new Set,o!=null?this._bucket=tn.makeFromBucketSpec(o,this._host):this._bucket=ex(this._host,this.app.options)}get host(){return this._host}set host(e){this._host=e,this._url!=null?this._bucket=tn.makeFromBucketSpec(this._url,e):this._bucket=ex(e,this.app.options)}get maxUploadRetryTime(){return this._maxUploadRetryTime}set maxUploadRetryTime(e){Jv("time",0,Number.POSITIVE_INFINITY,e),this._maxUploadRetryTime=e}get maxOperationRetryTime(){return this._maxOperationRetryTime}set maxOperationRetryTime(e){Jv("time",0,Number.POSITIVE_INFINITY,e),this._maxOperationRetryTime=e}async _getAuthToken(){if(this._overrideAuthToken)return this._overrideAuthToken;const e=this._authProvider.getImmediate({optional:!0});if(e){const i=await e.getToken();if(i!==null)return i.accessToken}return null}async _getAppCheckToken(){if(Ht(this.app)&&this.app.settings.appCheckToken)return this.app.settings.appCheckToken;const e=this._appCheckProvider.getImmediate({optional:!0});return e?(await e.getToken()).token:null}_delete(){return this._deleted||(this._deleted=!0,this._requests.forEach(e=>e.cancel()),this._requests.clear()),Promise.resolve()}_makeStorageReference(e){return new Vr(this,e)}_makeRequest(e,i,a,o,c=!0){if(this._deleted)return new _4(mS());{const d=P4(e,this._appId,a,o,i,this._firebaseVersion,c,this._isUsingEmulator);return this._requests.add(d),d.getPromise().then(()=>this._requests.delete(d),()=>this._requests.delete(d)),d}}async makeRequestWithTokens(e,i){const[a,o]=await Promise.all([this._getAuthToken(),this._getAppCheckToken()]);return this._makeRequest(e,i,a,o).getPromise()}}const tx="@firebase/storage",nx="0.14.0";const kS="storage";function gI(n,e,i){return n=nt(n),cI(n,e,i)}function yI(n){return n=nt(n),uI(n)}function vI(n,e){return n=nt(n),fI(n,e)}function xI(n=yf(),e){n=nt(n);const a=bu(n,kS).getImmediate({identifier:e}),o=kx("storage");return o&&bI(a,...o),a}function bI(n,e,i,a={}){hI(n,e,i,a)}function wI(n,{instanceIdentifier:e}){const i=n.getProvider("app").getImmediate(),a=n.getProvider("auth-internal"),o=n.getProvider("app-check-internal");return new yh(i,a,o,e,Wr)}function SI(){Br(new ir(kS,wI,"PUBLIC").setMultipleInstances(!0)),Dn(tx,nx,""),Dn(tx,nx,"esm2020")}SI();const CI=()=>{const{user:n,loading:e}=$r(),i=yu(),a=S.useRef(null),[o,c]=S.useState(""),[d,m]=S.useState(null),[f,h]=S.useState(null),[x,v]=S.useState(!1),[b,_]=S.useState({type:"",text:""});if(S.useEffect(()=>{n&&(c(n.name||""),m(n.avatar||null))},[n]),!e&&!n)return y.jsx(yx,{to:"/signin",replace:!0});const N=(F,I=400,H=400,z=.8)=>new Promise(X=>{const Z=new FileReader;Z.onload=K=>{const fe=new Image;fe.onload=()=>{const se=document.createElement("canvas");let{width:te,height:Me}=fe;te>Me?te>I&&(Me=Me*I/te,te=I):Me>H&&(te=te*H/Me,Me=H),se.width=te,se.height=Me,se.getContext("2d").drawImage(fe,0,0,te,Me),se.toBlob(X,"image/jpeg",z)},fe.src=K.target.result},Z.readAsDataURL(F)}),D=async F=>{const I=F.target.files[0];if(I){if(I.size>10*1024*1024){_({type:"error",text:"Image must be smaller than 10MB"});return}const H=new FileReader;H.onloadend=()=>{m(H.result)},H.readAsDataURL(I),_({type:"info",text:"Optimizing image..."});const z=await N(I),X=new File([z],I.name,{type:"image/jpeg"});h(X),_({type:"",text:""})}},q=async()=>{v(!0),_({type:"",text:""});try{let F=n?.avatar;if(f){const I=xI(),H=vI(I,`avatars/${n.id}/${Date.now()}`);await gI(H,f),F=await yI(H)}await sb(za.currentUser,{displayName:o,photoURL:F}),F&&await $A(n.id,F),_({type:"success",text:"Profile updated successfully!"}),setTimeout(()=>{window.location.reload()},1e3)}catch(F){console.error("Error updating profile:",F),_({type:"error",text:"Failed to update profile. Please try again."})}v(!1)};return y.jsx("div",{className:"page",children:y.jsxs("div",{className:"container",style:{paddingTop:"56px",paddingBottom:"56px",maxWidth:"500px"},children:[y.jsxs("button",{onClick:()=>i(-1),className:"btn btn-ghost",style:{marginBottom:"24px",padding:"8px 0"},children:[y.jsx(mM,{size:18}),"Back"]}),y.jsxs("div",{style:{marginBottom:"40px"},children:[y.jsx("p",{className:"caption",style:{marginBottom:"8px"},children:"Settings"}),y.jsx("h1",{className:"headline",children:"Your Profile"})]}),y.jsxs("div",{style:{textAlign:"center",marginBottom:"40px"},children:[y.jsxs("div",{onClick:()=>a.current?.click(),style:{width:"120px",height:"120px",borderRadius:"50%",margin:"0 auto 16px",background:d?`url(${d}) center/cover`:"var(--bg-elevated)",border:"2px solid var(--border)",display:"flex",alignItems:"center",justifyContent:"center",cursor:"pointer",transition:"border-color 0.2s",position:"relative"},onMouseEnter:F=>F.currentTarget.style.borderColor="var(--accent)",onMouseLeave:F=>F.currentTarget.style.borderColor="var(--border)",children:[!d&&y.jsx("span",{style:{fontSize:"40px",color:"var(--text-tertiary)"},children:n?.name?.charAt(0).toUpperCase()||"U"}),y.jsx("div",{style:{position:"absolute",bottom:"4px",right:"4px",width:"32px",height:"32px",borderRadius:"50%",background:"var(--accent)",display:"flex",alignItems:"center",justifyContent:"center"},children:y.jsx(xM,{size:16,color:"white"})})]}),y.jsx("input",{ref:a,type:"file",accept:"image/*",onChange:D,style:{display:"none"}}),y.jsx("p",{className:"caption",children:"Click to upload a photo"})]}),y.jsxs("div",{className:"card",style:{background:"var(--bg-elevated)"},children:[y.jsxs("div",{style:{marginBottom:"20px"},children:[y.jsx("label",{className:"caption",style:{display:"block",marginBottom:"8px"},children:"Display Name"}),y.jsxs("div",{style:{position:"relative"},children:[y.jsx(Gw,{size:16,style:{position:"absolute",left:"14px",top:"50%",transform:"translateY(-50%)",color:"var(--text-tertiary)"}}),y.jsx("input",{type:"text",value:o,onChange:F=>c(F.target.value),className:"input",style:{paddingLeft:"40px"},placeholder:"Your name"})]})]}),y.jsxs("div",{style:{marginBottom:"20px"},children:[y.jsx("label",{className:"caption",style:{display:"block",marginBottom:"8px"},children:"Email"}),y.jsxs("div",{style:{position:"relative"},children:[y.jsx(zw,{size:16,style:{position:"absolute",left:"14px",top:"50%",transform:"translateY(-50%)",color:"var(--text-tertiary)"}}),y.jsx("input",{type:"email",value:n?.email||"",className:"input",style:{paddingLeft:"40px",opacity:.6},disabled:!0})]}),y.jsx("p",{style:{fontSize:"12px",color:"var(--text-tertiary)",marginTop:"6px"},children:"Email cannot be changed"})]}),y.jsxs("div",{style:{marginBottom:"24px"},children:[y.jsx("label",{className:"caption",style:{display:"block",marginBottom:"8px"},children:"Username"}),y.jsxs("div",{style:{position:"relative"},children:[y.jsx(gM,{size:16,style:{position:"absolute",left:"14px",top:"50%",transform:"translateY(-50%)",color:"var(--text-tertiary)"}}),y.jsx("input",{type:"text",value:n?.handle||"",className:"input",style:{paddingLeft:"40px",opacity:.6},disabled:!0})]})]}),b.text&&y.jsx("div",{style:{padding:"12px 16px",borderRadius:"10px",marginBottom:"20px",background:b.type==="success"?"rgba(48, 209, 88, 0.1)":b.type==="info"?"rgba(0, 113, 227, 0.1)":"rgba(255, 69, 58, 0.1)",color:b.type==="success"?"var(--green)":b.type==="info"?"var(--accent)":"var(--red)",fontSize:"14px"},children:b.text}),y.jsxs("button",{onClick:q,disabled:x||!o.trim(),className:"btn btn-primary",style:{width:"100%",padding:"14px",opacity:x?.7:1},children:[y.jsx(cR,{size:16}),x?"Saving...":"Save Changes"]})]})]})})},OI=()=>{const[n,e]=S.useState({totalPlayers:0,totalBattles:0}),i=Pu();return S.useEffect(()=>{oh().then(e)},[]),y.jsxs("div",{className:"page",children:[y.jsxs("section",{style:{minHeight:"calc(100vh - 52px)",display:"flex",flexDirection:"column",alignItems:"center",justifyContent:"center",textAlign:"center",padding:"0 22px"},children:[y.jsx("p",{className:"caption",style:{marginBottom:"12px",color:"var(--accent)"},children:"About"}),y.jsx("h1",{className:"headline-super",style:{marginBottom:"16px"},children:"Valkry"}),y.jsxs("p",{className:"body-large",style:{maxWidth:"500px",marginBottom:"0"},children:["Real-time competitive programming battles.",y.jsx("br",{}),"Solve. Debug. Climb."]})]}),y.jsx("section",{style:{padding:"88px 22px",background:"var(--bg-secondary)"},children:y.jsx("div",{className:"container",children:y.jsxs("div",{className:"grid grid-3",style:{textAlign:"center"},children:[y.jsxs("div",{children:[y.jsx("div",{style:{fontSize:"48px",fontWeight:"600",letterSpacing:"-0.02em"},children:n.totalPlayers||0}),y.jsx("div",{className:"caption",children:"Players"})]}),y.jsxs("div",{children:[y.jsx("div",{style:{fontSize:"48px",fontWeight:"600",letterSpacing:"-0.02em"},children:n.totalBattles||0}),y.jsx("div",{className:"caption",children:"Battles"})]}),y.jsxs("div",{children:[y.jsxs("div",{style:{fontSize:"48px",fontWeight:"600",letterSpacing:"-0.02em"},children:[i.total,"+"]}),y.jsx("div",{className:"caption",children:"Problems"})]})]})})}),y.jsx("section",{style:{padding:"120px 22px"},children:y.jsxs("div",{className:"container",style:{maxWidth:"600px",textAlign:"center"},children:[y.jsx("img",{src:"/creator.jpg",alt:"Muhammad Dyen Asif",style:{width:"140px",height:"140px",borderRadius:"50%",objectFit:"cover",marginBottom:"32px"}}),y.jsx("h2",{className:"headline",style:{marginBottom:"8px"},children:"Muhammad Dyen Asif"}),y.jsx("p",{className:"caption",style:{marginBottom:"24px"},children:"FAST NUCES"}),y.jsx("p",{style:{fontSize:"17px",color:"var(--text-secondary)",lineHeight:1.7,marginBottom:"40px"},children:"Built Valkry to explore real-time systems, competitive programming, and modern web development. A passion project combining coding challenges with hands-on Firebase and React experience."}),y.jsxs("div",{style:{display:"flex",justifyContent:"center",gap:"20px"},children:[y.jsx("a",{href:"https://github.com/DyneStein",target:"_blank",rel:"noopener noreferrer",style:{width:"48px",height:"48px",borderRadius:"50%",background:"var(--bg-elevated)",border:"1px solid var(--border)",display:"flex",alignItems:"center",justifyContent:"center",color:"var(--text)",transition:"all 0.2s"},onMouseOver:a=>{a.currentTarget.style.background="var(--text)",a.currentTarget.style.color="var(--bg)"},onMouseOut:a=>{a.currentTarget.style.background="var(--bg-elevated)",a.currentTarget.style.color="var(--text)"},children:y.jsx(WM,{size:20})}),y.jsx("a",{href:"https://www.linkedin.com/in/dynestein/",target:"_blank",rel:"noopener noreferrer",style:{width:"48px",height:"48px",borderRadius:"50%",background:"var(--bg-elevated)",border:"1px solid var(--border)",display:"flex",alignItems:"center",justifyContent:"center",color:"var(--text)",transition:"all 0.2s"},onMouseOver:a=>{a.currentTarget.style.background="#0077b5",a.currentTarget.style.color="#fff",a.currentTarget.style.borderColor="#0077b5"},onMouseOut:a=>{a.currentTarget.style.background="var(--bg-elevated)",a.currentTarget.style.color="var(--text)",a.currentTarget.style.borderColor="var(--border)"},children:y.jsx(QM,{size:20})}),y.jsx("a",{href:"https://www.youtube.com/@dyenasif6247",target:"_blank",rel:"noopener noreferrer",style:{width:"48px",height:"48px",borderRadius:"50%",background:"var(--bg-elevated)",border:"1px solid var(--border)",display:"flex",alignItems:"center",justifyContent:"center",color:"var(--text)",transition:"all 0.2s"},onMouseOver:a=>{a.currentTarget.style.background="#ff0000",a.currentTarget.style.color="#fff",a.currentTarget.style.borderColor="#ff0000"},onMouseOut:a=>{a.currentTarget.style.background="var(--bg-elevated)",a.currentTarget.style.color="var(--text)",a.currentTarget.style.borderColor="var(--border)"},children:y.jsx(wR,{size:20})})]})]})}),y.jsxs("section",{style:{padding:"88px 22px",background:"var(--bg-secondary)",textAlign:"center"},children:[y.jsx("h2",{className:"headline",style:{marginBottom:"12px"},children:"Ready to compete?"}),y.jsx("p",{className:"body-large",style:{marginBottom:"32px"},children:"Join the arena."}),y.jsx(Tt,{to:"/arena",children:y.jsxs("button",{className:"btn btn-primary",children:["Enter Arena ",y.jsx(fu,{size:14})]})})]}),y.jsx("footer",{style:{padding:"24px 22px",textAlign:"center",borderTop:"1px solid var(--border)"},children:y.jsx("span",{className:"caption",children:"Valkry  2024  Built with React & Firebase"})})]})};function _I(){return y.jsx(sM,{children:y.jsx(C_,{children:y.jsxs("div",{children:[y.jsx(SR,{}),y.jsxs(JO,{children:[y.jsx(An,{path:"/",element:y.jsx(Yv,{})}),y.jsx(An,{path:"/signin",element:y.jsx(I5,{})}),y.jsx(An,{path:"/dashboard",element:y.jsx(P5,{})}),y.jsx(An,{path:"/leaderboard",element:y.jsx(L5,{})}),y.jsx(An,{path:"/arena",element:y.jsx(o4,{})}),y.jsx(An,{path:"/learn",element:y.jsx(l4,{})}),y.jsx(An,{path:"/profile",element:y.jsx(CI,{})}),y.jsx(An,{path:"/about",element:y.jsx(OI,{})}),y.jsx(An,{path:"/features",element:y.jsx(Yv,{})})]})]})})})}nO.createRoot(document.getElementById("root")).render(y.jsx(S.StrictMode,{children:y.jsx(_I,{})}));
