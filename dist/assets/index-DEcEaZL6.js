(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const o of document.querySelectorAll('link[rel="modulepreload"]'))r(o);new MutationObserver(o=>{for(const l of o)if(l.type==="childList")for(const p of l.addedNodes)p.tagName==="LINK"&&p.rel==="modulepreload"&&r(p)}).observe(document,{childList:!0,subtree:!0});function i(o){const l={};return o.integrity&&(l.integrity=o.integrity),o.referrerPolicy&&(l.referrerPolicy=o.referrerPolicy),o.crossOrigin==="use-credentials"?l.credentials="include":o.crossOrigin==="anonymous"?l.credentials="omit":l.credentials="same-origin",l}function r(o){if(o.ep)return;o.ep=!0;const l=i(o);fetch(o.href,l)}})();function tw(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}var um={exports:{}},ho={};var _g;function nw(){if(_g)return ho;_g=1;var n=Symbol.for("react.transitional.element"),e=Symbol.for("react.fragment");function i(r,o,l){var p=null;if(l!==void 0&&(p=""+l),o.key!==void 0&&(p=""+o.key),"key"in o){l={};for(var m in o)m!=="key"&&(l[m]=o[m])}else l=o;return o=l.ref,{$$typeof:n,type:r,key:p,ref:o!==void 0?o:null,props:l}}return ho.Fragment=e,ho.jsx=i,ho.jsxs=i,ho}var Tg;function iw(){return Tg||(Tg=1,um.exports=nw()),um.exports}var f=iw(),lm={exports:{}},fe={};var Ng;function aw(){if(Ng)return fe;Ng=1;var n=Symbol.for("react.transitional.element"),e=Symbol.for("react.portal"),i=Symbol.for("react.fragment"),r=Symbol.for("react.strict_mode"),o=Symbol.for("react.profiler"),l=Symbol.for("react.consumer"),p=Symbol.for("react.context"),m=Symbol.for("react.forward_ref"),h=Symbol.for("react.suspense"),x=Symbol.for("react.memo"),O=Symbol.for("react.lazy"),y=Symbol.for("react.activity"),v=Symbol.iterator;function _(C){return C===null||typeof C!="object"?null:(C=v&&C[v]||C["@@iterator"],typeof C=="function"?C:null)}var k={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},I=Object.assign,D={};function q(C,P,K){this.props=C,this.context=P,this.refs=D,this.updater=K||k}q.prototype.isReactComponent={},q.prototype.setState=function(C,P){if(typeof C!="object"&&typeof C!="function"&&C!=null)throw Error("takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,C,P,"setState")},q.prototype.forceUpdate=function(C){this.updater.enqueueForceUpdate(this,C,"forceUpdate")};function z(){}z.prototype=q.prototype;function H(C,P,K){this.props=C,this.context=P,this.refs=D,this.updater=K||k}var J=H.prototype=new z;J.constructor=H,I(J,q.prototype),J.isPureReactComponent=!0;var $=Array.isArray;function B(){}var W={H:null,A:null,T:null,S:null},ae=Object.prototype.hasOwnProperty;function ce(C,P,K){var Q=K.ref;return{$$typeof:n,type:C,key:P,ref:Q!==void 0?Q:null,props:K}}function te(C,P){return ce(C.type,P,C.props)}function Ue(C){return typeof C=="object"&&C!==null&&C.$$typeof===n}function Y(C){var P={"=":"=0",":":"=2"};return"$"+C.replace(/[=:]/g,function(K){return P[K]})}var ye=/\/+/g;function st(C,P){return typeof C=="object"&&C!==null&&C.key!=null?Y(""+C.key):P.toString(36)}function de(C){switch(C.status){case"fulfilled":return C.value;case"rejected":throw C.reason;default:switch(typeof C.status=="string"?C.then(B,B):(C.status="pending",C.then(function(P){C.status==="pending"&&(C.status="fulfilled",C.value=P)},function(P){C.status==="pending"&&(C.status="rejected",C.reason=P)})),C.status){case"fulfilled":return C.value;case"rejected":throw C.reason}}throw C}function M(C,P,K,Q,me){var he=typeof C;(he==="undefined"||he==="boolean")&&(C=null);var Ee=!1;if(C===null)Ee=!0;else switch(he){case"bigint":case"string":case"number":Ee=!0;break;case"object":switch(C.$$typeof){case n:case e:Ee=!0;break;case O:return Ee=C._init,M(Ee(C._payload),P,K,Q,me)}}if(Ee)return me=me(C),Ee=Q===""?"."+st(C,0):Q,$(me)?(K="",Ee!=null&&(K=Ee.replace(ye,"$&/")+"/"),M(me,P,K,"",function(Vn){return Vn})):me!=null&&(Ue(me)&&(me=te(me,K+(me.key==null||C&&C.key===me.key?"":(""+me.key).replace(ye,"$&/")+"/")+Ee)),P.push(me)),1;Ee=0;var ot=Q===""?".":Q+":";if($(C))for(var Ye=0;Ye<C.length;Ye++)Q=C[Ye],he=ot+st(Q,Ye),Ee+=M(Q,P,K,he,me);else if(Ye=_(C),typeof Ye=="function")for(C=Ye.call(C),Ye=0;!(Q=C.next()).done;)Q=Q.value,he=ot+st(Q,Ye++),Ee+=M(Q,P,K,he,me);else if(he==="object"){if(typeof C.then=="function")return M(de(C),P,K,Q,me);throw P=String(C),Error("Objects are not valid as a React child (found: "+(P==="[object Object]"?"object with keys {"+Object.keys(C).join(", ")+"}":P)+"). If you meant to render a collection of children, use an array instead.")}return Ee}function V(C,P,K){if(C==null)return C;var Q=[],me=0;return M(C,Q,"","",function(he){return P.call(K,he,me++)}),Q}function ne(C){if(C._status===-1){var P=C._result;P=P(),P.then(function(K){(C._status===0||C._status===-1)&&(C._status=1,C._result=K)},function(K){(C._status===0||C._status===-1)&&(C._status=2,C._result=K)}),C._status===-1&&(C._status=0,C._result=P)}if(C._status===1)return C._result.default;throw C._result}var Ce=typeof reportError=="function"?reportError:function(C){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var P=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof C=="object"&&C!==null&&typeof C.message=="string"?String(C.message):String(C),error:C});if(!window.dispatchEvent(P))return}else if(typeof process=="object"&&typeof process.emit=="function"){process.emit("uncaughtException",C);return}console.error(C)},Re={map:V,forEach:function(C,P,K){V(C,function(){P.apply(this,arguments)},K)},count:function(C){var P=0;return V(C,function(){P++}),P},toArray:function(C){return V(C,function(P){return P})||[]},only:function(C){if(!Ue(C))throw Error("React.Children.only expected to receive a single React element child.");return C}};return fe.Activity=y,fe.Children=Re,fe.Component=q,fe.Fragment=i,fe.Profiler=o,fe.PureComponent=H,fe.StrictMode=r,fe.Suspense=h,fe.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=W,fe.__COMPILER_RUNTIME={__proto__:null,c:function(C){return W.H.useMemoCache(C)}},fe.cache=function(C){return function(){return C.apply(null,arguments)}},fe.cacheSignal=function(){return null},fe.cloneElement=function(C,P,K){if(C==null)throw Error("The argument must be a React element, but you passed "+C+".");var Q=I({},C.props),me=C.key;if(P!=null)for(he in P.key!==void 0&&(me=""+P.key),P)!ae.call(P,he)||he==="key"||he==="__self"||he==="__source"||he==="ref"&&P.ref===void 0||(Q[he]=P[he]);var he=arguments.length-2;if(he===1)Q.children=K;else if(1<he){for(var Ee=Array(he),ot=0;ot<he;ot++)Ee[ot]=arguments[ot+2];Q.children=Ee}return ce(C.type,me,Q)},fe.createContext=function(C){return C={$$typeof:p,_currentValue:C,_currentValue2:C,_threadCount:0,Provider:null,Consumer:null},C.Provider=C,C.Consumer={$$typeof:l,_context:C},C},fe.createElement=function(C,P,K){var Q,me={},he=null;if(P!=null)for(Q in P.key!==void 0&&(he=""+P.key),P)ae.call(P,Q)&&Q!=="key"&&Q!=="__self"&&Q!=="__source"&&(me[Q]=P[Q]);var Ee=arguments.length-2;if(Ee===1)me.children=K;else if(1<Ee){for(var ot=Array(Ee),Ye=0;Ye<Ee;Ye++)ot[Ye]=arguments[Ye+2];me.children=ot}if(C&&C.defaultProps)for(Q in Ee=C.defaultProps,Ee)me[Q]===void 0&&(me[Q]=Ee[Q]);return ce(C,he,me)},fe.createRef=function(){return{current:null}},fe.forwardRef=function(C){return{$$typeof:m,render:C}},fe.isValidElement=Ue,fe.lazy=function(C){return{$$typeof:O,_payload:{_status:-1,_result:C},_init:ne}},fe.memo=function(C,P){return{$$typeof:x,type:C,compare:P===void 0?null:P}},fe.startTransition=function(C){var P=W.T,K={};W.T=K;try{var Q=C(),me=W.S;me!==null&&me(K,Q),typeof Q=="object"&&Q!==null&&typeof Q.then=="function"&&Q.then(B,Ce)}catch(he){Ce(he)}finally{P!==null&&K.types!==null&&(P.types=K.types),W.T=P}},fe.unstable_useCacheRefresh=function(){return W.H.useCacheRefresh()},fe.use=function(C){return W.H.use(C)},fe.useActionState=function(C,P,K){return W.H.useActionState(C,P,K)},fe.useCallback=function(C,P){return W.H.useCallback(C,P)},fe.useContext=function(C){return W.H.useContext(C)},fe.useDebugValue=function(){},fe.useDeferredValue=function(C,P){return W.H.useDeferredValue(C,P)},fe.useEffect=function(C,P){return W.H.useEffect(C,P)},fe.useEffectEvent=function(C){return W.H.useEffectEvent(C)},fe.useId=function(){return W.H.useId()},fe.useImperativeHandle=function(C,P,K){return W.H.useImperativeHandle(C,P,K)},fe.useInsertionEffect=function(C,P){return W.H.useInsertionEffect(C,P)},fe.useLayoutEffect=function(C,P){return W.H.useLayoutEffect(C,P)},fe.useMemo=function(C,P){return W.H.useMemo(C,P)},fe.useOptimistic=function(C,P){return W.H.useOptimistic(C,P)},fe.useReducer=function(C,P,K){return W.H.useReducer(C,P,K)},fe.useRef=function(C){return W.H.useRef(C)},fe.useState=function(C){return W.H.useState(C)},fe.useSyncExternalStore=function(C,P,K){return W.H.useSyncExternalStore(C,P,K)},fe.useTransition=function(){return W.H.useTransition()},fe.version="19.2.3",fe}var kg;function df(){return kg||(kg=1,lm.exports=aw()),lm.exports}var S=df();const Ha=tw(S);var cm={exports:{}},xo={},pm={exports:{}},dm={};var Eg;function rw(){return Eg||(Eg=1,(function(n){function e(M,V){var ne=M.length;M.push(V);e:for(;0<ne;){var Ce=ne-1>>>1,Re=M[Ce];if(0<o(Re,V))M[Ce]=V,M[ne]=Re,ne=Ce;else break e}}function i(M){return M.length===0?null:M[0]}function r(M){if(M.length===0)return null;var V=M[0],ne=M.pop();if(ne!==V){M[0]=ne;e:for(var Ce=0,Re=M.length,C=Re>>>1;Ce<C;){var P=2*(Ce+1)-1,K=M[P],Q=P+1,me=M[Q];if(0>o(K,ne))Q<Re&&0>o(me,K)?(M[Ce]=me,M[Q]=ne,Ce=Q):(M[Ce]=K,M[P]=ne,Ce=P);else if(Q<Re&&0>o(me,ne))M[Ce]=me,M[Q]=ne,Ce=Q;else break e}}return V}function o(M,V){var ne=M.sortIndex-V.sortIndex;return ne!==0?ne:M.id-V.id}if(n.unstable_now=void 0,typeof performance=="object"&&typeof performance.now=="function"){var l=performance;n.unstable_now=function(){return l.now()}}else{var p=Date,m=p.now();n.unstable_now=function(){return p.now()-m}}var h=[],x=[],O=1,y=null,v=3,_=!1,k=!1,I=!1,D=!1,q=typeof setTimeout=="function"?setTimeout:null,z=typeof clearTimeout=="function"?clearTimeout:null,H=typeof setImmediate<"u"?setImmediate:null;function J(M){for(var V=i(x);V!==null;){if(V.callback===null)r(x);else if(V.startTime<=M)r(x),V.sortIndex=V.expirationTime,e(h,V);else break;V=i(x)}}function $(M){if(I=!1,J(M),!k)if(i(h)!==null)k=!0,B||(B=!0,Y());else{var V=i(x);V!==null&&de($,V.startTime-M)}}var B=!1,W=-1,ae=5,ce=-1;function te(){return D?!0:!(n.unstable_now()-ce<ae)}function Ue(){if(D=!1,B){var M=n.unstable_now();ce=M;var V=!0;try{e:{k=!1,I&&(I=!1,z(W),W=-1),_=!0;var ne=v;try{t:{for(J(M),y=i(h);y!==null&&!(y.expirationTime>M&&te());){var Ce=y.callback;if(typeof Ce=="function"){y.callback=null,v=y.priorityLevel;var Re=Ce(y.expirationTime<=M);if(M=n.unstable_now(),typeof Re=="function"){y.callback=Re,J(M),V=!0;break t}y===i(h)&&r(h),J(M)}else r(h);y=i(h)}if(y!==null)V=!0;else{var C=i(x);C!==null&&de($,C.startTime-M),V=!1}}break e}finally{y=null,v=ne,_=!1}V=void 0}}finally{V?Y():B=!1}}}var Y;if(typeof H=="function")Y=function(){H(Ue)};else if(typeof MessageChannel<"u"){var ye=new MessageChannel,st=ye.port2;ye.port1.onmessage=Ue,Y=function(){st.postMessage(null)}}else Y=function(){q(Ue,0)};function de(M,V){W=q(function(){M(n.unstable_now())},V)}n.unstable_IdlePriority=5,n.unstable_ImmediatePriority=1,n.unstable_LowPriority=4,n.unstable_NormalPriority=3,n.unstable_Profiling=null,n.unstable_UserBlockingPriority=2,n.unstable_cancelCallback=function(M){M.callback=null},n.unstable_forceFrameRate=function(M){0>M||125<M?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):ae=0<M?Math.floor(1e3/M):5},n.unstable_getCurrentPriorityLevel=function(){return v},n.unstable_next=function(M){switch(v){case 1:case 2:case 3:var V=3;break;default:V=v}var ne=v;v=V;try{return M()}finally{v=ne}},n.unstable_requestPaint=function(){D=!0},n.unstable_runWithPriority=function(M,V){switch(M){case 1:case 2:case 3:case 4:case 5:break;default:M=3}var ne=v;v=M;try{return V()}finally{v=ne}},n.unstable_scheduleCallback=function(M,V,ne){var Ce=n.unstable_now();switch(typeof ne=="object"&&ne!==null?(ne=ne.delay,ne=typeof ne=="number"&&0<ne?Ce+ne:Ce):ne=Ce,M){case 1:var Re=-1;break;case 2:Re=250;break;case 5:Re=1073741823;break;case 4:Re=1e4;break;default:Re=5e3}return Re=ne+Re,M={id:O++,callback:V,priorityLevel:M,startTime:ne,expirationTime:Re,sortIndex:-1},ne>Ce?(M.sortIndex=ne,e(x,M),i(h)===null&&M===i(x)&&(I?(z(W),W=-1):I=!0,de($,ne-Ce))):(M.sortIndex=Re,e(h,M),k||_||(k=!0,B||(B=!0,Y()))),M},n.unstable_shouldYield=te,n.unstable_wrapCallback=function(M){var V=v;return function(){var ne=v;v=V;try{return M.apply(this,arguments)}finally{v=ne}}}})(dm)),dm}var Ag;function sw(){return Ag||(Ag=1,pm.exports=rw()),pm.exports}var mm={exports:{}},kt={};var jg;function ow(){if(jg)return kt;jg=1;var n=df();function e(h){var x="https://react.dev/errors/"+h;if(1<arguments.length){x+="?args[]="+encodeURIComponent(arguments[1]);for(var O=2;O<arguments.length;O++)x+="&args[]="+encodeURIComponent(arguments[O])}return"Minified React error #"+h+"; visit "+x+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function i(){}var r={d:{f:i,r:function(){throw Error(e(522))},D:i,C:i,L:i,m:i,X:i,S:i,M:i},p:0,findDOMNode:null},o=Symbol.for("react.portal");function l(h,x,O){var y=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:o,key:y==null?null:""+y,children:h,containerInfo:x,implementation:O}}var p=n.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;function m(h,x){if(h==="font")return"";if(typeof x=="string")return x==="use-credentials"?x:""}return kt.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=r,kt.createPortal=function(h,x){var O=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!x||x.nodeType!==1&&x.nodeType!==9&&x.nodeType!==11)throw Error(e(299));return l(h,x,null,O)},kt.flushSync=function(h){var x=p.T,O=r.p;try{if(p.T=null,r.p=2,h)return h()}finally{p.T=x,r.p=O,r.d.f()}},kt.preconnect=function(h,x){typeof h=="string"&&(x?(x=x.crossOrigin,x=typeof x=="string"?x==="use-credentials"?x:"":void 0):x=null,r.d.C(h,x))},kt.prefetchDNS=function(h){typeof h=="string"&&r.d.D(h)},kt.preinit=function(h,x){if(typeof h=="string"&&x&&typeof x.as=="string"){var O=x.as,y=m(O,x.crossOrigin),v=typeof x.integrity=="string"?x.integrity:void 0,_=typeof x.fetchPriority=="string"?x.fetchPriority:void 0;O==="style"?r.d.S(h,typeof x.precedence=="string"?x.precedence:void 0,{crossOrigin:y,integrity:v,fetchPriority:_}):O==="script"&&r.d.X(h,{crossOrigin:y,integrity:v,fetchPriority:_,nonce:typeof x.nonce=="string"?x.nonce:void 0})}},kt.preinitModule=function(h,x){if(typeof h=="string")if(typeof x=="object"&&x!==null){if(x.as==null||x.as==="script"){var O=m(x.as,x.crossOrigin);r.d.M(h,{crossOrigin:O,integrity:typeof x.integrity=="string"?x.integrity:void 0,nonce:typeof x.nonce=="string"?x.nonce:void 0})}}else x==null&&r.d.M(h)},kt.preload=function(h,x){if(typeof h=="string"&&typeof x=="object"&&x!==null&&typeof x.as=="string"){var O=x.as,y=m(O,x.crossOrigin);r.d.L(h,O,{crossOrigin:y,integrity:typeof x.integrity=="string"?x.integrity:void 0,nonce:typeof x.nonce=="string"?x.nonce:void 0,type:typeof x.type=="string"?x.type:void 0,fetchPriority:typeof x.fetchPriority=="string"?x.fetchPriority:void 0,referrerPolicy:typeof x.referrerPolicy=="string"?x.referrerPolicy:void 0,imageSrcSet:typeof x.imageSrcSet=="string"?x.imageSrcSet:void 0,imageSizes:typeof x.imageSizes=="string"?x.imageSizes:void 0,media:typeof x.media=="string"?x.media:void 0})}},kt.preloadModule=function(h,x){if(typeof h=="string")if(x){var O=m(x.as,x.crossOrigin);r.d.m(h,{as:typeof x.as=="string"&&x.as!=="script"?x.as:void 0,crossOrigin:O,integrity:typeof x.integrity=="string"?x.integrity:void 0})}else r.d.m(h)},kt.requestFormReset=function(h){r.d.r(h)},kt.unstable_batchedUpdates=function(h,x){return h(x)},kt.useFormState=function(h,x,O){return p.H.useFormState(h,x,O)},kt.useFormStatus=function(){return p.H.useHostTransitionStatus()},kt.version="19.2.3",kt}var Mg;function uw(){if(Mg)return mm.exports;Mg=1;function n(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n)}catch(e){console.error(e)}}return n(),mm.exports=ow(),mm.exports}var Rg;function lw(){if(Rg)return xo;Rg=1;var n=sw(),e=df(),i=uw();function r(t){var a="https://react.dev/errors/"+t;if(1<arguments.length){a+="?args[]="+encodeURIComponent(arguments[1]);for(var s=2;s<arguments.length;s++)a+="&args[]="+encodeURIComponent(arguments[s])}return"Minified React error #"+t+"; visit "+a+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function o(t){return!(!t||t.nodeType!==1&&t.nodeType!==9&&t.nodeType!==11)}function l(t){var a=t,s=t;if(t.alternate)for(;a.return;)a=a.return;else{t=a;do a=t,(a.flags&4098)!==0&&(s=a.return),t=a.return;while(t)}return a.tag===3?s:null}function p(t){if(t.tag===13){var a=t.memoizedState;if(a===null&&(t=t.alternate,t!==null&&(a=t.memoizedState)),a!==null)return a.dehydrated}return null}function m(t){if(t.tag===31){var a=t.memoizedState;if(a===null&&(t=t.alternate,t!==null&&(a=t.memoizedState)),a!==null)return a.dehydrated}return null}function h(t){if(l(t)!==t)throw Error(r(188))}function x(t){var a=t.alternate;if(!a){if(a=l(t),a===null)throw Error(r(188));return a!==t?null:t}for(var s=t,u=a;;){var c=s.return;if(c===null)break;var d=c.alternate;if(d===null){if(u=c.return,u!==null){s=u;continue}break}if(c.child===d.child){for(d=c.child;d;){if(d===s)return h(c),t;if(d===u)return h(c),a;d=d.sibling}throw Error(r(188))}if(s.return!==u.return)s=c,u=d;else{for(var g=!1,b=c.child;b;){if(b===s){g=!0,s=c,u=d;break}if(b===u){g=!0,u=c,s=d;break}b=b.sibling}if(!g){for(b=d.child;b;){if(b===s){g=!0,s=d,u=c;break}if(b===u){g=!0,u=d,s=c;break}b=b.sibling}if(!g)throw Error(r(189))}}if(s.alternate!==u)throw Error(r(190))}if(s.tag!==3)throw Error(r(188));return s.stateNode.current===s?t:a}function O(t){var a=t.tag;if(a===5||a===26||a===27||a===6)return t;for(t=t.child;t!==null;){if(a=O(t),a!==null)return a;t=t.sibling}return null}var y=Object.assign,v=Symbol.for("react.element"),_=Symbol.for("react.transitional.element"),k=Symbol.for("react.portal"),I=Symbol.for("react.fragment"),D=Symbol.for("react.strict_mode"),q=Symbol.for("react.profiler"),z=Symbol.for("react.consumer"),H=Symbol.for("react.context"),J=Symbol.for("react.forward_ref"),$=Symbol.for("react.suspense"),B=Symbol.for("react.suspense_list"),W=Symbol.for("react.memo"),ae=Symbol.for("react.lazy"),ce=Symbol.for("react.activity"),te=Symbol.for("react.memo_cache_sentinel"),Ue=Symbol.iterator;function Y(t){return t===null||typeof t!="object"?null:(t=Ue&&t[Ue]||t["@@iterator"],typeof t=="function"?t:null)}var ye=Symbol.for("react.client.reference");function st(t){if(t==null)return null;if(typeof t=="function")return t.$$typeof===ye?null:t.displayName||t.name||null;if(typeof t=="string")return t;switch(t){case I:return"Fragment";case q:return"Profiler";case D:return"StrictMode";case $:return"Suspense";case B:return"SuspenseList";case ce:return"Activity"}if(typeof t=="object")switch(t.$$typeof){case k:return"Portal";case H:return t.displayName||"Context";case z:return(t._context.displayName||"Context")+".Consumer";case J:var a=t.render;return t=t.displayName,t||(t=a.displayName||a.name||"",t=t!==""?"ForwardRef("+t+")":"ForwardRef"),t;case W:return a=t.displayName||null,a!==null?a:st(t.type)||"Memo";case ae:a=t._payload,t=t._init;try{return st(t(a))}catch{}}return null}var de=Array.isArray,M=e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,V=i.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,ne={pending:!1,data:null,method:null,action:null},Ce=[],Re=-1;function C(t){return{current:t}}function P(t){0>Re||(t.current=Ce[Re],Ce[Re]=null,Re--)}function K(t,a){Re++,Ce[Re]=t.current,t.current=a}var Q=C(null),me=C(null),he=C(null),Ee=C(null);function ot(t,a){switch(K(he,a),K(me,t),K(Q,null),a.nodeType){case 9:case 11:t=(t=a.documentElement)&&(t=t.namespaceURI)?K0(t):0;break;default:if(t=a.tagName,a=a.namespaceURI)a=K0(a),t=X0(a,t);else switch(t){case"svg":t=1;break;case"math":t=2;break;default:t=0}}P(Q),K(Q,t)}function Ye(){P(Q),P(me),P(he)}function Vn(t){t.memoizedState!==null&&K(Ee,t);var a=Q.current,s=X0(a,t.type);a!==s&&(K(me,t),K(Q,s))}function _i(t){me.current===t&&(P(Q),P(me)),Ee.current===t&&(P(Ee),co._currentValue=ne)}var Kt,Bt;function Sn(t){if(Kt===void 0)try{throw Error()}catch(s){var a=s.stack.trim().match(/\n( *(at )?)/);Kt=a&&a[1]||"",Bt=-1<s.stack.indexOf(`
    at`)?" (<anonymous>)":-1<s.stack.indexOf("@")?"@unknown:0:0":""}return`
`+Kt+t+Bt}var ir=!1;function ar(t,a){if(!t||ir)return"";ir=!0;var s=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{var u={DetermineComponentFrameRoot:function(){try{if(a){var F=function(){throw Error()};if(Object.defineProperty(F.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(F,[])}catch(R){var j=R}Reflect.construct(t,[],F)}else{try{F.call()}catch(R){j=R}t.call(F.prototype)}}else{try{throw Error()}catch(R){j=R}(F=t())&&typeof F.catch=="function"&&F.catch(function(){})}}catch(R){if(R&&j&&typeof R.stack=="string")return[R.stack,j.stack]}return[null,null]}};u.DetermineComponentFrameRoot.displayName="DetermineComponentFrameRoot";var c=Object.getOwnPropertyDescriptor(u.DetermineComponentFrameRoot,"name");c&&c.configurable&&Object.defineProperty(u.DetermineComponentFrameRoot,"name",{value:"DetermineComponentFrameRoot"});var d=u.DetermineComponentFrameRoot(),g=d[0],b=d[1];if(g&&b){var w=g.split(`
`),A=b.split(`
`);for(c=u=0;u<w.length&&!w[u].includes("DetermineComponentFrameRoot");)u++;for(;c<A.length&&!A[c].includes("DetermineComponentFrameRoot");)c++;if(u===w.length||c===A.length)for(u=w.length-1,c=A.length-1;1<=u&&0<=c&&w[u]!==A[c];)c--;for(;1<=u&&0<=c;u--,c--)if(w[u]!==A[c]){if(u!==1||c!==1)do if(u--,c--,0>c||w[u]!==A[c]){var L=`
`+w[u].replace(" at new "," at ");return t.displayName&&L.includes("<anonymous>")&&(L=L.replace("<anonymous>",t.displayName)),L}while(1<=u&&0<=c);break}}}finally{ir=!1,Error.prepareStackTrace=s}return(s=t?t.displayName||t.name:"")?Sn(s):""}function rr(t,a){switch(t.tag){case 26:case 27:case 5:return Sn(t.type);case 16:return Sn("Lazy");case 13:return t.child!==a&&a!==null?Sn("Suspense Fallback"):Sn("Suspense");case 19:return Sn("SuspenseList");case 0:case 15:return ar(t.type,!1);case 11:return ar(t.type.render,!1);case 1:return ar(t.type,!0);case 31:return Sn("Activity");default:return""}}function bs(t){try{var a="",s=null;do a+=rr(t,s),s=t,t=t.return;while(t);return a}catch(u){return`
Error generating stack: `+u.message+`
`+u.stack}}var Ti=Object.prototype.hasOwnProperty,sr=n.unstable_scheduleCallback,Ss=n.unstable_cancelCallback,Gc=n.unstable_shouldYield,Vc=n.unstable_requestPaint,At=n.unstable_now,Wc=n.unstable_getCurrentPriorityLevel,du=n.unstable_ImmediatePriority,mu=n.unstable_UserBlockingPriority,or=n.unstable_NormalPriority,Kc=n.unstable_LowPriority,fu=n.unstable_IdlePriority,ya=n.log,X=n.unstable_setDisableYieldValue,_e=null,De=null;function Xt(t){if(typeof ya=="function"&&X(t),De&&typeof De.setStrictMode=="function")try{De.setStrictMode(_e,t)}catch{}}var jt=Math.clz32?Math.clz32:hu,Ni=Math.log,Xc=Math.LN2;function hu(t){return t>>>=0,t===0?32:31-(Ni(t)/Xc|0)|0}var ur=256,lr=262144,Oa=4194304;function va(t){var a=t&42;if(a!==0)return a;switch(t&-t){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:return 64;case 128:return 128;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:return t&261888;case 262144:case 524288:case 1048576:case 2097152:return t&3932160;case 4194304:case 8388608:case 16777216:case 33554432:return t&62914560;case 67108864:return 67108864;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 0;default:return t}}function xu(t,a,s){var u=t.pendingLanes;if(u===0)return 0;var c=0,d=t.suspendedLanes,g=t.pingedLanes;t=t.warmLanes;var b=u&134217727;return b!==0?(u=b&~d,u!==0?c=va(u):(g&=b,g!==0?c=va(g):s||(s=b&~t,s!==0&&(c=va(s))))):(b=u&~d,b!==0?c=va(b):g!==0?c=va(g):s||(s=u&~t,s!==0&&(c=va(s)))),c===0?0:a!==0&&a!==c&&(a&d)===0&&(d=c&-c,s=a&-a,d>=s||d===32&&(s&4194048)!==0)?a:c}function ws(t,a){return(t.pendingLanes&~(t.suspendedLanes&~t.pingedLanes)&a)===0}function qb(t,a){switch(t){case 1:case 2:case 4:case 8:case 64:return a+250;case 16:case 32:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return a+5e3;case 4194304:case 8388608:case 16777216:case 33554432:return-1;case 67108864:case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function Eh(){var t=Oa;return Oa<<=1,(Oa&62914560)===0&&(Oa=4194304),t}function Qc(t){for(var a=[],s=0;31>s;s++)a.push(t);return a}function Cs(t,a){t.pendingLanes|=a,a!==268435456&&(t.suspendedLanes=0,t.pingedLanes=0,t.warmLanes=0)}function Hb(t,a,s,u,c,d){var g=t.pendingLanes;t.pendingLanes=s,t.suspendedLanes=0,t.pingedLanes=0,t.warmLanes=0,t.expiredLanes&=s,t.entangledLanes&=s,t.errorRecoveryDisabledLanes&=s,t.shellSuspendCounter=0;var b=t.entanglements,w=t.expirationTimes,A=t.hiddenUpdates;for(s=g&~s;0<s;){var L=31-jt(s),F=1<<L;b[L]=0,w[L]=-1;var j=A[L];if(j!==null)for(A[L]=null,L=0;L<j.length;L++){var R=j[L];R!==null&&(R.lane&=-536870913)}s&=~F}u!==0&&Ah(t,u,0),d!==0&&c===0&&t.tag!==0&&(t.suspendedLanes|=d&~(g&~a))}function Ah(t,a,s){t.pendingLanes|=a,t.suspendedLanes&=~a;var u=31-jt(a);t.entangledLanes|=a,t.entanglements[u]=t.entanglements[u]|1073741824|s&261930}function jh(t,a){var s=t.entangledLanes|=a;for(t=t.entanglements;s;){var u=31-jt(s),c=1<<u;c&a|t[u]&a&&(t[u]|=a),s&=~c}}function Mh(t,a){var s=a&-a;return s=(s&42)!==0?1:Jc(s),(s&(t.suspendedLanes|a))!==0?0:s}function Jc(t){switch(t){case 2:t=1;break;case 8:t=4;break;case 32:t=16;break;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:t=128;break;case 268435456:t=134217728;break;default:t=0}return t}function $c(t){return t&=-t,2<t?8<t?(t&134217727)!==0?32:268435456:8:2}function Rh(){var t=V.p;return t!==0?t:(t=window.event,t===void 0?32:yg(t.type))}function Dh(t,a){var s=V.p;try{return V.p=t,a()}finally{V.p=s}}var ki=Math.random().toString(36).slice(2),wt="__reactFiber$"+ki,Ut="__reactProps$"+ki,cr="__reactContainer$"+ki,Zc="__reactEvents$"+ki,Yb="__reactListeners$"+ki,Gb="__reactHandles$"+ki,Ih="__reactResources$"+ki,_s="__reactMarker$"+ki;function ep(t){delete t[wt],delete t[Ut],delete t[Zc],delete t[Yb],delete t[Gb]}function pr(t){var a=t[wt];if(a)return a;for(var s=t.parentNode;s;){if(a=s[cr]||s[wt]){if(s=a.alternate,a.child!==null||s!==null&&s.child!==null)for(t=ng(t);t!==null;){if(s=t[wt])return s;t=ng(t)}return a}t=s,s=t.parentNode}return null}function dr(t){if(t=t[wt]||t[cr]){var a=t.tag;if(a===5||a===6||a===13||a===31||a===26||a===27||a===3)return t}return null}function Ts(t){var a=t.tag;if(a===5||a===26||a===27||a===6)return t.stateNode;throw Error(r(33))}function mr(t){var a=t[Ih];return a||(a=t[Ih]={hoistableStyles:new Map,hoistableScripts:new Map}),a}function gt(t){t[_s]=!0}var Lh=new Set,Ph={};function ba(t,a){fr(t,a),fr(t+"Capture",a)}function fr(t,a){for(Ph[t]=a,t=0;t<a.length;t++)Lh.add(a[t])}var Vb=RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"),Bh={},Uh={};function Wb(t){return Ti.call(Uh,t)?!0:Ti.call(Bh,t)?!1:Vb.test(t)?Uh[t]=!0:(Bh[t]=!0,!1)}function gu(t,a,s){if(Wb(a))if(s===null)t.removeAttribute(a);else{switch(typeof s){case"undefined":case"function":case"symbol":t.removeAttribute(a);return;case"boolean":var u=a.toLowerCase().slice(0,5);if(u!=="data-"&&u!=="aria-"){t.removeAttribute(a);return}}t.setAttribute(a,""+s)}}function yu(t,a,s){if(s===null)t.removeAttribute(a);else{switch(typeof s){case"undefined":case"function":case"symbol":case"boolean":t.removeAttribute(a);return}t.setAttribute(a,""+s)}}function Wn(t,a,s,u){if(u===null)t.removeAttribute(s);else{switch(typeof u){case"undefined":case"function":case"symbol":case"boolean":t.removeAttribute(s);return}t.setAttributeNS(a,s,""+u)}}function un(t){switch(typeof t){case"bigint":case"boolean":case"number":case"string":case"undefined":return t;case"object":return t;default:return""}}function zh(t){var a=t.type;return(t=t.nodeName)&&t.toLowerCase()==="input"&&(a==="checkbox"||a==="radio")}function Kb(t,a,s){var u=Object.getOwnPropertyDescriptor(t.constructor.prototype,a);if(!t.hasOwnProperty(a)&&typeof u<"u"&&typeof u.get=="function"&&typeof u.set=="function"){var c=u.get,d=u.set;return Object.defineProperty(t,a,{configurable:!0,get:function(){return c.call(this)},set:function(g){s=""+g,d.call(this,g)}}),Object.defineProperty(t,a,{enumerable:u.enumerable}),{getValue:function(){return s},setValue:function(g){s=""+g},stopTracking:function(){t._valueTracker=null,delete t[a]}}}}function tp(t){if(!t._valueTracker){var a=zh(t)?"checked":"value";t._valueTracker=Kb(t,a,""+t[a])}}function Fh(t){if(!t)return!1;var a=t._valueTracker;if(!a)return!0;var s=a.getValue(),u="";return t&&(u=zh(t)?t.checked?"true":"false":t.value),t=u,t!==s?(a.setValue(t),!0):!1}function Ou(t){if(t=t||(typeof document<"u"?document:void 0),typeof t>"u")return null;try{return t.activeElement||t.body}catch{return t.body}}var Xb=/[\n"\\]/g;function ln(t){return t.replace(Xb,function(a){return"\\"+a.charCodeAt(0).toString(16)+" "})}function np(t,a,s,u,c,d,g,b){t.name="",g!=null&&typeof g!="function"&&typeof g!="symbol"&&typeof g!="boolean"?t.type=g:t.removeAttribute("type"),a!=null?g==="number"?(a===0&&t.value===""||t.value!=a)&&(t.value=""+un(a)):t.value!==""+un(a)&&(t.value=""+un(a)):g!=="submit"&&g!=="reset"||t.removeAttribute("value"),a!=null?ip(t,g,un(a)):s!=null?ip(t,g,un(s)):u!=null&&t.removeAttribute("value"),c==null&&d!=null&&(t.defaultChecked=!!d),c!=null&&(t.checked=c&&typeof c!="function"&&typeof c!="symbol"),b!=null&&typeof b!="function"&&typeof b!="symbol"&&typeof b!="boolean"?t.name=""+un(b):t.removeAttribute("name")}function qh(t,a,s,u,c,d,g,b){if(d!=null&&typeof d!="function"&&typeof d!="symbol"&&typeof d!="boolean"&&(t.type=d),a!=null||s!=null){if(!(d!=="submit"&&d!=="reset"||a!=null)){tp(t);return}s=s!=null?""+un(s):"",a=a!=null?""+un(a):s,b||a===t.value||(t.value=a),t.defaultValue=a}u=u??c,u=typeof u!="function"&&typeof u!="symbol"&&!!u,t.checked=b?t.checked:!!u,t.defaultChecked=!!u,g!=null&&typeof g!="function"&&typeof g!="symbol"&&typeof g!="boolean"&&(t.name=g),tp(t)}function ip(t,a,s){a==="number"&&Ou(t.ownerDocument)===t||t.defaultValue===""+s||(t.defaultValue=""+s)}function hr(t,a,s,u){if(t=t.options,a){a={};for(var c=0;c<s.length;c++)a["$"+s[c]]=!0;for(s=0;s<t.length;s++)c=a.hasOwnProperty("$"+t[s].value),t[s].selected!==c&&(t[s].selected=c),c&&u&&(t[s].defaultSelected=!0)}else{for(s=""+un(s),a=null,c=0;c<t.length;c++){if(t[c].value===s){t[c].selected=!0,u&&(t[c].defaultSelected=!0);return}a!==null||t[c].disabled||(a=t[c])}a!==null&&(a.selected=!0)}}function Hh(t,a,s){if(a!=null&&(a=""+un(a),a!==t.value&&(t.value=a),s==null)){t.defaultValue!==a&&(t.defaultValue=a);return}t.defaultValue=s!=null?""+un(s):""}function Yh(t,a,s,u){if(a==null){if(u!=null){if(s!=null)throw Error(r(92));if(de(u)){if(1<u.length)throw Error(r(93));u=u[0]}s=u}s==null&&(s=""),a=s}s=un(a),t.defaultValue=s,u=t.textContent,u===s&&u!==""&&u!==null&&(t.value=u),tp(t)}function xr(t,a){if(a){var s=t.firstChild;if(s&&s===t.lastChild&&s.nodeType===3){s.nodeValue=a;return}}t.textContent=a}var Qb=new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));function Gh(t,a,s){var u=a.indexOf("--")===0;s==null||typeof s=="boolean"||s===""?u?t.setProperty(a,""):a==="float"?t.cssFloat="":t[a]="":u?t.setProperty(a,s):typeof s!="number"||s===0||Qb.has(a)?a==="float"?t.cssFloat=s:t[a]=(""+s).trim():t[a]=s+"px"}function Vh(t,a,s){if(a!=null&&typeof a!="object")throw Error(r(62));if(t=t.style,s!=null){for(var u in s)!s.hasOwnProperty(u)||a!=null&&a.hasOwnProperty(u)||(u.indexOf("--")===0?t.setProperty(u,""):u==="float"?t.cssFloat="":t[u]="");for(var c in a)u=a[c],a.hasOwnProperty(c)&&s[c]!==u&&Gh(t,c,u)}else for(var d in a)a.hasOwnProperty(d)&&Gh(t,d,a[d])}function ap(t){if(t.indexOf("-")===-1)return!1;switch(t){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var Jb=new Map([["acceptCharset","accept-charset"],["htmlFor","for"],["httpEquiv","http-equiv"],["crossOrigin","crossorigin"],["accentHeight","accent-height"],["alignmentBaseline","alignment-baseline"],["arabicForm","arabic-form"],["baselineShift","baseline-shift"],["capHeight","cap-height"],["clipPath","clip-path"],["clipRule","clip-rule"],["colorInterpolation","color-interpolation"],["colorInterpolationFilters","color-interpolation-filters"],["colorProfile","color-profile"],["colorRendering","color-rendering"],["dominantBaseline","dominant-baseline"],["enableBackground","enable-background"],["fillOpacity","fill-opacity"],["fillRule","fill-rule"],["floodColor","flood-color"],["floodOpacity","flood-opacity"],["fontFamily","font-family"],["fontSize","font-size"],["fontSizeAdjust","font-size-adjust"],["fontStretch","font-stretch"],["fontStyle","font-style"],["fontVariant","font-variant"],["fontWeight","font-weight"],["glyphName","glyph-name"],["glyphOrientationHorizontal","glyph-orientation-horizontal"],["glyphOrientationVertical","glyph-orientation-vertical"],["horizAdvX","horiz-adv-x"],["horizOriginX","horiz-origin-x"],["imageRendering","image-rendering"],["letterSpacing","letter-spacing"],["lightingColor","lighting-color"],["markerEnd","marker-end"],["markerMid","marker-mid"],["markerStart","marker-start"],["overlinePosition","overline-position"],["overlineThickness","overline-thickness"],["paintOrder","paint-order"],["panose-1","panose-1"],["pointerEvents","pointer-events"],["renderingIntent","rendering-intent"],["shapeRendering","shape-rendering"],["stopColor","stop-color"],["stopOpacity","stop-opacity"],["strikethroughPosition","strikethrough-position"],["strikethroughThickness","strikethrough-thickness"],["strokeDasharray","stroke-dasharray"],["strokeDashoffset","stroke-dashoffset"],["strokeLinecap","stroke-linecap"],["strokeLinejoin","stroke-linejoin"],["strokeMiterlimit","stroke-miterlimit"],["strokeOpacity","stroke-opacity"],["strokeWidth","stroke-width"],["textAnchor","text-anchor"],["textDecoration","text-decoration"],["textRendering","text-rendering"],["transformOrigin","transform-origin"],["underlinePosition","underline-position"],["underlineThickness","underline-thickness"],["unicodeBidi","unicode-bidi"],["unicodeRange","unicode-range"],["unitsPerEm","units-per-em"],["vAlphabetic","v-alphabetic"],["vHanging","v-hanging"],["vIdeographic","v-ideographic"],["vMathematical","v-mathematical"],["vectorEffect","vector-effect"],["vertAdvY","vert-adv-y"],["vertOriginX","vert-origin-x"],["vertOriginY","vert-origin-y"],["wordSpacing","word-spacing"],["writingMode","writing-mode"],["xmlnsXlink","xmlns:xlink"],["xHeight","x-height"]]),$b=/^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;function vu(t){return $b.test(""+t)?"javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')":t}function Kn(){}var rp=null;function sp(t){return t=t.target||t.srcElement||window,t.correspondingUseElement&&(t=t.correspondingUseElement),t.nodeType===3?t.parentNode:t}var gr=null,yr=null;function Wh(t){var a=dr(t);if(a&&(t=a.stateNode)){var s=t[Ut]||null;e:switch(t=a.stateNode,a.type){case"input":if(np(t,s.value,s.defaultValue,s.defaultValue,s.checked,s.defaultChecked,s.type,s.name),a=s.name,s.type==="radio"&&a!=null){for(s=t;s.parentNode;)s=s.parentNode;for(s=s.querySelectorAll('input[name="'+ln(""+a)+'"][type="radio"]'),a=0;a<s.length;a++){var u=s[a];if(u!==t&&u.form===t.form){var c=u[Ut]||null;if(!c)throw Error(r(90));np(u,c.value,c.defaultValue,c.defaultValue,c.checked,c.defaultChecked,c.type,c.name)}}for(a=0;a<s.length;a++)u=s[a],u.form===t.form&&Fh(u)}break e;case"textarea":Hh(t,s.value,s.defaultValue);break e;case"select":a=s.value,a!=null&&hr(t,!!s.multiple,a,!1)}}}var op=!1;function Kh(t,a,s){if(op)return t(a,s);op=!0;try{var u=t(a);return u}finally{if(op=!1,(gr!==null||yr!==null)&&(ol(),gr&&(a=gr,t=yr,yr=gr=null,Wh(a),t)))for(a=0;a<t.length;a++)Wh(t[a])}}function Ns(t,a){var s=t.stateNode;if(s===null)return null;var u=s[Ut]||null;if(u===null)return null;s=u[a];e:switch(a){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(u=!u.disabled)||(t=t.type,u=!(t==="button"||t==="input"||t==="select"||t==="textarea")),t=!u;break e;default:t=!1}if(t)return null;if(s&&typeof s!="function")throw Error(r(231,a,typeof s));return s}var Xn=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),up=!1;if(Xn)try{var ks={};Object.defineProperty(ks,"passive",{get:function(){up=!0}}),window.addEventListener("test",ks,ks),window.removeEventListener("test",ks,ks)}catch{up=!1}var Ei=null,lp=null,bu=null;function Xh(){if(bu)return bu;var t,a=lp,s=a.length,u,c="value"in Ei?Ei.value:Ei.textContent,d=c.length;for(t=0;t<s&&a[t]===c[t];t++);var g=s-t;for(u=1;u<=g&&a[s-u]===c[d-u];u++);return bu=c.slice(t,1<u?1-u:void 0)}function Su(t){var a=t.keyCode;return"charCode"in t?(t=t.charCode,t===0&&a===13&&(t=13)):t=a,t===10&&(t=13),32<=t||t===13?t:0}function wu(){return!0}function Qh(){return!1}function zt(t){function a(s,u,c,d,g){this._reactName=s,this._targetInst=c,this.type=u,this.nativeEvent=d,this.target=g,this.currentTarget=null;for(var b in t)t.hasOwnProperty(b)&&(s=t[b],this[b]=s?s(d):d[b]);return this.isDefaultPrevented=(d.defaultPrevented!=null?d.defaultPrevented:d.returnValue===!1)?wu:Qh,this.isPropagationStopped=Qh,this}return y(a.prototype,{preventDefault:function(){this.defaultPrevented=!0;var s=this.nativeEvent;s&&(s.preventDefault?s.preventDefault():typeof s.returnValue!="unknown"&&(s.returnValue=!1),this.isDefaultPrevented=wu)},stopPropagation:function(){var s=this.nativeEvent;s&&(s.stopPropagation?s.stopPropagation():typeof s.cancelBubble!="unknown"&&(s.cancelBubble=!0),this.isPropagationStopped=wu)},persist:function(){},isPersistent:wu}),a}var Sa={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(t){return t.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},Cu=zt(Sa),Es=y({},Sa,{view:0,detail:0}),Zb=zt(Es),cp,pp,As,_u=y({},Es,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:mp,button:0,buttons:0,relatedTarget:function(t){return t.relatedTarget===void 0?t.fromElement===t.srcElement?t.toElement:t.fromElement:t.relatedTarget},movementX:function(t){return"movementX"in t?t.movementX:(t!==As&&(As&&t.type==="mousemove"?(cp=t.screenX-As.screenX,pp=t.screenY-As.screenY):pp=cp=0,As=t),cp)},movementY:function(t){return"movementY"in t?t.movementY:pp}}),Jh=zt(_u),e3=y({},_u,{dataTransfer:0}),t3=zt(e3),n3=y({},Es,{relatedTarget:0}),dp=zt(n3),i3=y({},Sa,{animationName:0,elapsedTime:0,pseudoElement:0}),a3=zt(i3),r3=y({},Sa,{clipboardData:function(t){return"clipboardData"in t?t.clipboardData:window.clipboardData}}),s3=zt(r3),o3=y({},Sa,{data:0}),$h=zt(o3),u3={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},l3={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},c3={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function p3(t){var a=this.nativeEvent;return a.getModifierState?a.getModifierState(t):(t=c3[t])?!!a[t]:!1}function mp(){return p3}var d3=y({},Es,{key:function(t){if(t.key){var a=u3[t.key]||t.key;if(a!=="Unidentified")return a}return t.type==="keypress"?(t=Su(t),t===13?"Enter":String.fromCharCode(t)):t.type==="keydown"||t.type==="keyup"?l3[t.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:mp,charCode:function(t){return t.type==="keypress"?Su(t):0},keyCode:function(t){return t.type==="keydown"||t.type==="keyup"?t.keyCode:0},which:function(t){return t.type==="keypress"?Su(t):t.type==="keydown"||t.type==="keyup"?t.keyCode:0}}),m3=zt(d3),f3=y({},_u,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),Zh=zt(f3),h3=y({},Es,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:mp}),x3=zt(h3),g3=y({},Sa,{propertyName:0,elapsedTime:0,pseudoElement:0}),y3=zt(g3),O3=y({},_u,{deltaX:function(t){return"deltaX"in t?t.deltaX:"wheelDeltaX"in t?-t.wheelDeltaX:0},deltaY:function(t){return"deltaY"in t?t.deltaY:"wheelDeltaY"in t?-t.wheelDeltaY:"wheelDelta"in t?-t.wheelDelta:0},deltaZ:0,deltaMode:0}),v3=zt(O3),b3=y({},Sa,{newState:0,oldState:0}),S3=zt(b3),w3=[9,13,27,32],fp=Xn&&"CompositionEvent"in window,js=null;Xn&&"documentMode"in document&&(js=document.documentMode);var C3=Xn&&"TextEvent"in window&&!js,e1=Xn&&(!fp||js&&8<js&&11>=js),t1=" ",n1=!1;function i1(t,a){switch(t){case"keyup":return w3.indexOf(a.keyCode)!==-1;case"keydown":return a.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function a1(t){return t=t.detail,typeof t=="object"&&"data"in t?t.data:null}var Or=!1;function _3(t,a){switch(t){case"compositionend":return a1(a);case"keypress":return a.which!==32?null:(n1=!0,t1);case"textInput":return t=a.data,t===t1&&n1?null:t;default:return null}}function T3(t,a){if(Or)return t==="compositionend"||!fp&&i1(t,a)?(t=Xh(),bu=lp=Ei=null,Or=!1,t):null;switch(t){case"paste":return null;case"keypress":if(!(a.ctrlKey||a.altKey||a.metaKey)||a.ctrlKey&&a.altKey){if(a.char&&1<a.char.length)return a.char;if(a.which)return String.fromCharCode(a.which)}return null;case"compositionend":return e1&&a.locale!=="ko"?null:a.data;default:return null}}var N3={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function r1(t){var a=t&&t.nodeName&&t.nodeName.toLowerCase();return a==="input"?!!N3[t.type]:a==="textarea"}function s1(t,a,s,u){gr?yr?yr.push(u):yr=[u]:gr=u,a=fl(a,"onChange"),0<a.length&&(s=new Cu("onChange","change",null,s,u),t.push({event:s,listeners:a}))}var Ms=null,Rs=null;function k3(t){q0(t,0)}function Tu(t){var a=Ts(t);if(Fh(a))return t}function o1(t,a){if(t==="change")return a}var u1=!1;if(Xn){var hp;if(Xn){var xp="oninput"in document;if(!xp){var l1=document.createElement("div");l1.setAttribute("oninput","return;"),xp=typeof l1.oninput=="function"}hp=xp}else hp=!1;u1=hp&&(!document.documentMode||9<document.documentMode)}function c1(){Ms&&(Ms.detachEvent("onpropertychange",p1),Rs=Ms=null)}function p1(t){if(t.propertyName==="value"&&Tu(Rs)){var a=[];s1(a,Rs,t,sp(t)),Kh(k3,a)}}function E3(t,a,s){t==="focusin"?(c1(),Ms=a,Rs=s,Ms.attachEvent("onpropertychange",p1)):t==="focusout"&&c1()}function A3(t){if(t==="selectionchange"||t==="keyup"||t==="keydown")return Tu(Rs)}function j3(t,a){if(t==="click")return Tu(a)}function M3(t,a){if(t==="input"||t==="change")return Tu(a)}function R3(t,a){return t===a&&(t!==0||1/t===1/a)||t!==t&&a!==a}var Qt=typeof Object.is=="function"?Object.is:R3;function Ds(t,a){if(Qt(t,a))return!0;if(typeof t!="object"||t===null||typeof a!="object"||a===null)return!1;var s=Object.keys(t),u=Object.keys(a);if(s.length!==u.length)return!1;for(u=0;u<s.length;u++){var c=s[u];if(!Ti.call(a,c)||!Qt(t[c],a[c]))return!1}return!0}function d1(t){for(;t&&t.firstChild;)t=t.firstChild;return t}function m1(t,a){var s=d1(t);t=0;for(var u;s;){if(s.nodeType===3){if(u=t+s.textContent.length,t<=a&&u>=a)return{node:s,offset:a-t};t=u}e:{for(;s;){if(s.nextSibling){s=s.nextSibling;break e}s=s.parentNode}s=void 0}s=d1(s)}}function f1(t,a){return t&&a?t===a?!0:t&&t.nodeType===3?!1:a&&a.nodeType===3?f1(t,a.parentNode):"contains"in t?t.contains(a):t.compareDocumentPosition?!!(t.compareDocumentPosition(a)&16):!1:!1}function h1(t){t=t!=null&&t.ownerDocument!=null&&t.ownerDocument.defaultView!=null?t.ownerDocument.defaultView:window;for(var a=Ou(t.document);a instanceof t.HTMLIFrameElement;){try{var s=typeof a.contentWindow.location.href=="string"}catch{s=!1}if(s)t=a.contentWindow;else break;a=Ou(t.document)}return a}function gp(t){var a=t&&t.nodeName&&t.nodeName.toLowerCase();return a&&(a==="input"&&(t.type==="text"||t.type==="search"||t.type==="tel"||t.type==="url"||t.type==="password")||a==="textarea"||t.contentEditable==="true")}var D3=Xn&&"documentMode"in document&&11>=document.documentMode,vr=null,yp=null,Is=null,Op=!1;function x1(t,a,s){var u=s.window===s?s.document:s.nodeType===9?s:s.ownerDocument;Op||vr==null||vr!==Ou(u)||(u=vr,"selectionStart"in u&&gp(u)?u={start:u.selectionStart,end:u.selectionEnd}:(u=(u.ownerDocument&&u.ownerDocument.defaultView||window).getSelection(),u={anchorNode:u.anchorNode,anchorOffset:u.anchorOffset,focusNode:u.focusNode,focusOffset:u.focusOffset}),Is&&Ds(Is,u)||(Is=u,u=fl(yp,"onSelect"),0<u.length&&(a=new Cu("onSelect","select",null,a,s),t.push({event:a,listeners:u}),a.target=vr)))}function wa(t,a){var s={};return s[t.toLowerCase()]=a.toLowerCase(),s["Webkit"+t]="webkit"+a,s["Moz"+t]="moz"+a,s}var br={animationend:wa("Animation","AnimationEnd"),animationiteration:wa("Animation","AnimationIteration"),animationstart:wa("Animation","AnimationStart"),transitionrun:wa("Transition","TransitionRun"),transitionstart:wa("Transition","TransitionStart"),transitioncancel:wa("Transition","TransitionCancel"),transitionend:wa("Transition","TransitionEnd")},vp={},g1={};Xn&&(g1=document.createElement("div").style,"AnimationEvent"in window||(delete br.animationend.animation,delete br.animationiteration.animation,delete br.animationstart.animation),"TransitionEvent"in window||delete br.transitionend.transition);function Ca(t){if(vp[t])return vp[t];if(!br[t])return t;var a=br[t],s;for(s in a)if(a.hasOwnProperty(s)&&s in g1)return vp[t]=a[s];return t}var y1=Ca("animationend"),O1=Ca("animationiteration"),v1=Ca("animationstart"),I3=Ca("transitionrun"),L3=Ca("transitionstart"),P3=Ca("transitioncancel"),b1=Ca("transitionend"),S1=new Map,bp="abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");bp.push("scrollEnd");function wn(t,a){S1.set(t,a),ba(a,[t])}var Nu=typeof reportError=="function"?reportError:function(t){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var a=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof t=="object"&&t!==null&&typeof t.message=="string"?String(t.message):String(t),error:t});if(!window.dispatchEvent(a))return}else if(typeof process=="object"&&typeof process.emit=="function"){process.emit("uncaughtException",t);return}console.error(t)},cn=[],Sr=0,Sp=0;function ku(){for(var t=Sr,a=Sp=Sr=0;a<t;){var s=cn[a];cn[a++]=null;var u=cn[a];cn[a++]=null;var c=cn[a];cn[a++]=null;var d=cn[a];if(cn[a++]=null,u!==null&&c!==null){var g=u.pending;g===null?c.next=c:(c.next=g.next,g.next=c),u.pending=c}d!==0&&w1(s,c,d)}}function Eu(t,a,s,u){cn[Sr++]=t,cn[Sr++]=a,cn[Sr++]=s,cn[Sr++]=u,Sp|=u,t.lanes|=u,t=t.alternate,t!==null&&(t.lanes|=u)}function wp(t,a,s,u){return Eu(t,a,s,u),Au(t)}function _a(t,a){return Eu(t,null,null,a),Au(t)}function w1(t,a,s){t.lanes|=s;var u=t.alternate;u!==null&&(u.lanes|=s);for(var c=!1,d=t.return;d!==null;)d.childLanes|=s,u=d.alternate,u!==null&&(u.childLanes|=s),d.tag===22&&(t=d.stateNode,t===null||t._visibility&1||(c=!0)),t=d,d=d.return;return t.tag===3?(d=t.stateNode,c&&a!==null&&(c=31-jt(s),t=d.hiddenUpdates,u=t[c],u===null?t[c]=[a]:u.push(a),a.lane=s|536870912),d):null}function Au(t){if(50<io)throw io=0,Md=null,Error(r(185));for(var a=t.return;a!==null;)t=a,a=t.return;return t.tag===3?t.stateNode:null}var wr={};function B3(t,a,s,u){this.tag=t,this.key=s,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.refCleanup=this.ref=null,this.pendingProps=a,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=u,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function Jt(t,a,s,u){return new B3(t,a,s,u)}function Cp(t){return t=t.prototype,!(!t||!t.isReactComponent)}function Qn(t,a){var s=t.alternate;return s===null?(s=Jt(t.tag,a,t.key,t.mode),s.elementType=t.elementType,s.type=t.type,s.stateNode=t.stateNode,s.alternate=t,t.alternate=s):(s.pendingProps=a,s.type=t.type,s.flags=0,s.subtreeFlags=0,s.deletions=null),s.flags=t.flags&65011712,s.childLanes=t.childLanes,s.lanes=t.lanes,s.child=t.child,s.memoizedProps=t.memoizedProps,s.memoizedState=t.memoizedState,s.updateQueue=t.updateQueue,a=t.dependencies,s.dependencies=a===null?null:{lanes:a.lanes,firstContext:a.firstContext},s.sibling=t.sibling,s.index=t.index,s.ref=t.ref,s.refCleanup=t.refCleanup,s}function C1(t,a){t.flags&=65011714;var s=t.alternate;return s===null?(t.childLanes=0,t.lanes=a,t.child=null,t.subtreeFlags=0,t.memoizedProps=null,t.memoizedState=null,t.updateQueue=null,t.dependencies=null,t.stateNode=null):(t.childLanes=s.childLanes,t.lanes=s.lanes,t.child=s.child,t.subtreeFlags=0,t.deletions=null,t.memoizedProps=s.memoizedProps,t.memoizedState=s.memoizedState,t.updateQueue=s.updateQueue,t.type=s.type,a=s.dependencies,t.dependencies=a===null?null:{lanes:a.lanes,firstContext:a.firstContext}),t}function ju(t,a,s,u,c,d){var g=0;if(u=t,typeof t=="function")Cp(t)&&(g=1);else if(typeof t=="string")g=HS(t,s,Q.current)?26:t==="html"||t==="head"||t==="body"?27:5;else e:switch(t){case ce:return t=Jt(31,s,a,c),t.elementType=ce,t.lanes=d,t;case I:return Ta(s.children,c,d,a);case D:g=8,c|=24;break;case q:return t=Jt(12,s,a,c|2),t.elementType=q,t.lanes=d,t;case $:return t=Jt(13,s,a,c),t.elementType=$,t.lanes=d,t;case B:return t=Jt(19,s,a,c),t.elementType=B,t.lanes=d,t;default:if(typeof t=="object"&&t!==null)switch(t.$$typeof){case H:g=10;break e;case z:g=9;break e;case J:g=11;break e;case W:g=14;break e;case ae:g=16,u=null;break e}g=29,s=Error(r(130,t===null?"null":typeof t,"")),u=null}return a=Jt(g,s,a,c),a.elementType=t,a.type=u,a.lanes=d,a}function Ta(t,a,s,u){return t=Jt(7,t,u,a),t.lanes=s,t}function _p(t,a,s){return t=Jt(6,t,null,a),t.lanes=s,t}function _1(t){var a=Jt(18,null,null,0);return a.stateNode=t,a}function Tp(t,a,s){return a=Jt(4,t.children!==null?t.children:[],t.key,a),a.lanes=s,a.stateNode={containerInfo:t.containerInfo,pendingChildren:null,implementation:t.implementation},a}var T1=new WeakMap;function pn(t,a){if(typeof t=="object"&&t!==null){var s=T1.get(t);return s!==void 0?s:(a={value:t,source:a,stack:bs(a)},T1.set(t,a),a)}return{value:t,source:a,stack:bs(a)}}var Cr=[],_r=0,Mu=null,Ls=0,dn=[],mn=0,Ai=null,Rn=1,Dn="";function Jn(t,a){Cr[_r++]=Ls,Cr[_r++]=Mu,Mu=t,Ls=a}function N1(t,a,s){dn[mn++]=Rn,dn[mn++]=Dn,dn[mn++]=Ai,Ai=t;var u=Rn;t=Dn;var c=32-jt(u)-1;u&=~(1<<c),s+=1;var d=32-jt(a)+c;if(30<d){var g=c-c%5;d=(u&(1<<g)-1).toString(32),u>>=g,c-=g,Rn=1<<32-jt(a)+c|s<<c|u,Dn=d+t}else Rn=1<<d|s<<c|u,Dn=t}function Np(t){t.return!==null&&(Jn(t,1),N1(t,1,0))}function kp(t){for(;t===Mu;)Mu=Cr[--_r],Cr[_r]=null,Ls=Cr[--_r],Cr[_r]=null;for(;t===Ai;)Ai=dn[--mn],dn[mn]=null,Dn=dn[--mn],dn[mn]=null,Rn=dn[--mn],dn[mn]=null}function k1(t,a){dn[mn++]=Rn,dn[mn++]=Dn,dn[mn++]=Ai,Rn=a.id,Dn=a.overflow,Ai=t}var Ct=null,Ke=null,ke=!1,ji=null,fn=!1,Ep=Error(r(519));function Mi(t){var a=Error(r(418,1<arguments.length&&arguments[1]!==void 0&&arguments[1]?"text":"HTML",""));throw Ps(pn(a,t)),Ep}function E1(t){var a=t.stateNode,s=t.type,u=t.memoizedProps;switch(a[wt]=t,a[Ut]=u,s){case"dialog":we("cancel",a),we("close",a);break;case"iframe":case"object":case"embed":we("load",a);break;case"video":case"audio":for(s=0;s<ro.length;s++)we(ro[s],a);break;case"source":we("error",a);break;case"img":case"image":case"link":we("error",a),we("load",a);break;case"details":we("toggle",a);break;case"input":we("invalid",a),qh(a,u.value,u.defaultValue,u.checked,u.defaultChecked,u.type,u.name,!0);break;case"select":we("invalid",a);break;case"textarea":we("invalid",a),Yh(a,u.value,u.defaultValue,u.children)}s=u.children,typeof s!="string"&&typeof s!="number"&&typeof s!="bigint"||a.textContent===""+s||u.suppressHydrationWarning===!0||V0(a.textContent,s)?(u.popover!=null&&(we("beforetoggle",a),we("toggle",a)),u.onScroll!=null&&we("scroll",a),u.onScrollEnd!=null&&we("scrollend",a),u.onClick!=null&&(a.onclick=Kn),a=!0):a=!1,a||Mi(t,!0)}function A1(t){for(Ct=t.return;Ct;)switch(Ct.tag){case 5:case 31:case 13:fn=!1;return;case 27:case 3:fn=!0;return;default:Ct=Ct.return}}function Tr(t){if(t!==Ct)return!1;if(!ke)return A1(t),ke=!0,!1;var a=t.tag,s;if((s=a!==3&&a!==27)&&((s=a===5)&&(s=t.type,s=!(s!=="form"&&s!=="button")||Wd(t.type,t.memoizedProps)),s=!s),s&&Ke&&Mi(t),A1(t),a===13){if(t=t.memoizedState,t=t!==null?t.dehydrated:null,!t)throw Error(r(317));Ke=tg(t)}else if(a===31){if(t=t.memoizedState,t=t!==null?t.dehydrated:null,!t)throw Error(r(317));Ke=tg(t)}else a===27?(a=Ke,Vi(t.type)?(t=$d,$d=null,Ke=t):Ke=a):Ke=Ct?xn(t.stateNode.nextSibling):null;return!0}function Na(){Ke=Ct=null,ke=!1}function Ap(){var t=ji;return t!==null&&(Yt===null?Yt=t:Yt.push.apply(Yt,t),ji=null),t}function Ps(t){ji===null?ji=[t]:ji.push(t)}var jp=C(null),ka=null,$n=null;function Ri(t,a,s){K(jp,a._currentValue),a._currentValue=s}function Zn(t){t._currentValue=jp.current,P(jp)}function Mp(t,a,s){for(;t!==null;){var u=t.alternate;if((t.childLanes&a)!==a?(t.childLanes|=a,u!==null&&(u.childLanes|=a)):u!==null&&(u.childLanes&a)!==a&&(u.childLanes|=a),t===s)break;t=t.return}}function Rp(t,a,s,u){var c=t.child;for(c!==null&&(c.return=t);c!==null;){var d=c.dependencies;if(d!==null){var g=c.child;d=d.firstContext;e:for(;d!==null;){var b=d;d=c;for(var w=0;w<a.length;w++)if(b.context===a[w]){d.lanes|=s,b=d.alternate,b!==null&&(b.lanes|=s),Mp(d.return,s,t),u||(g=null);break e}d=b.next}}else if(c.tag===18){if(g=c.return,g===null)throw Error(r(341));g.lanes|=s,d=g.alternate,d!==null&&(d.lanes|=s),Mp(g,s,t),g=null}else g=c.child;if(g!==null)g.return=c;else for(g=c;g!==null;){if(g===t){g=null;break}if(c=g.sibling,c!==null){c.return=g.return,g=c;break}g=g.return}c=g}}function Nr(t,a,s,u){t=null;for(var c=a,d=!1;c!==null;){if(!d){if((c.flags&524288)!==0)d=!0;else if((c.flags&262144)!==0)break}if(c.tag===10){var g=c.alternate;if(g===null)throw Error(r(387));if(g=g.memoizedProps,g!==null){var b=c.type;Qt(c.pendingProps.value,g.value)||(t!==null?t.push(b):t=[b])}}else if(c===Ee.current){if(g=c.alternate,g===null)throw Error(r(387));g.memoizedState.memoizedState!==c.memoizedState.memoizedState&&(t!==null?t.push(co):t=[co])}c=c.return}t!==null&&Rp(a,t,s,u),a.flags|=262144}function Ru(t){for(t=t.firstContext;t!==null;){if(!Qt(t.context._currentValue,t.memoizedValue))return!0;t=t.next}return!1}function Ea(t){ka=t,$n=null,t=t.dependencies,t!==null&&(t.firstContext=null)}function _t(t){return j1(ka,t)}function Du(t,a){return ka===null&&Ea(t),j1(t,a)}function j1(t,a){var s=a._currentValue;if(a={context:a,memoizedValue:s,next:null},$n===null){if(t===null)throw Error(r(308));$n=a,t.dependencies={lanes:0,firstContext:a},t.flags|=524288}else $n=$n.next=a;return s}var U3=typeof AbortController<"u"?AbortController:function(){var t=[],a=this.signal={aborted:!1,addEventListener:function(s,u){t.push(u)}};this.abort=function(){a.aborted=!0,t.forEach(function(s){return s()})}},z3=n.unstable_scheduleCallback,F3=n.unstable_NormalPriority,ct={$$typeof:H,Consumer:null,Provider:null,_currentValue:null,_currentValue2:null,_threadCount:0};function Dp(){return{controller:new U3,data:new Map,refCount:0}}function Bs(t){t.refCount--,t.refCount===0&&z3(F3,function(){t.controller.abort()})}var Us=null,Ip=0,kr=0,Er=null;function q3(t,a){if(Us===null){var s=Us=[];Ip=0,kr=Bd(),Er={status:"pending",value:void 0,then:function(u){s.push(u)}}}return Ip++,a.then(M1,M1),a}function M1(){if(--Ip===0&&Us!==null){Er!==null&&(Er.status="fulfilled");var t=Us;Us=null,kr=0,Er=null;for(var a=0;a<t.length;a++)(0,t[a])()}}function H3(t,a){var s=[],u={status:"pending",value:null,reason:null,then:function(c){s.push(c)}};return t.then(function(){u.status="fulfilled",u.value=a;for(var c=0;c<s.length;c++)(0,s[c])(a)},function(c){for(u.status="rejected",u.reason=c,c=0;c<s.length;c++)(0,s[c])(void 0)}),u}var R1=M.S;M.S=function(t,a){x0=At(),typeof a=="object"&&a!==null&&typeof a.then=="function"&&q3(t,a),R1!==null&&R1(t,a)};var Aa=C(null);function Lp(){var t=Aa.current;return t!==null?t:Ge.pooledCache}function Iu(t,a){a===null?K(Aa,Aa.current):K(Aa,a.pool)}function D1(){var t=Lp();return t===null?null:{parent:ct._currentValue,pool:t}}var Ar=Error(r(460)),Pp=Error(r(474)),Lu=Error(r(542)),Pu={then:function(){}};function I1(t){return t=t.status,t==="fulfilled"||t==="rejected"}function L1(t,a,s){switch(s=t[s],s===void 0?t.push(a):s!==a&&(a.then(Kn,Kn),a=s),a.status){case"fulfilled":return a.value;case"rejected":throw t=a.reason,B1(t),t;default:if(typeof a.status=="string")a.then(Kn,Kn);else{if(t=Ge,t!==null&&100<t.shellSuspendCounter)throw Error(r(482));t=a,t.status="pending",t.then(function(u){if(a.status==="pending"){var c=a;c.status="fulfilled",c.value=u}},function(u){if(a.status==="pending"){var c=a;c.status="rejected",c.reason=u}})}switch(a.status){case"fulfilled":return a.value;case"rejected":throw t=a.reason,B1(t),t}throw Ma=a,Ar}}function ja(t){try{var a=t._init;return a(t._payload)}catch(s){throw s!==null&&typeof s=="object"&&typeof s.then=="function"?(Ma=s,Ar):s}}var Ma=null;function P1(){if(Ma===null)throw Error(r(459));var t=Ma;return Ma=null,t}function B1(t){if(t===Ar||t===Lu)throw Error(r(483))}var jr=null,zs=0;function Bu(t){var a=zs;return zs+=1,jr===null&&(jr=[]),L1(jr,t,a)}function Fs(t,a){a=a.props.ref,t.ref=a!==void 0?a:null}function Uu(t,a){throw a.$$typeof===v?Error(r(525)):(t=Object.prototype.toString.call(a),Error(r(31,t==="[object Object]"?"object with keys {"+Object.keys(a).join(", ")+"}":t)))}function U1(t){function a(N,T){if(t){var E=N.deletions;E===null?(N.deletions=[T],N.flags|=16):E.push(T)}}function s(N,T){if(!t)return null;for(;T!==null;)a(N,T),T=T.sibling;return null}function u(N){for(var T=new Map;N!==null;)N.key!==null?T.set(N.key,N):T.set(N.index,N),N=N.sibling;return T}function c(N,T){return N=Qn(N,T),N.index=0,N.sibling=null,N}function d(N,T,E){return N.index=E,t?(E=N.alternate,E!==null?(E=E.index,E<T?(N.flags|=67108866,T):E):(N.flags|=67108866,T)):(N.flags|=1048576,T)}function g(N){return t&&N.alternate===null&&(N.flags|=67108866),N}function b(N,T,E,U){return T===null||T.tag!==6?(T=_p(E,N.mode,U),T.return=N,T):(T=c(T,E),T.return=N,T)}function w(N,T,E,U){var ie=E.type;return ie===I?L(N,T,E.props.children,U,E.key):T!==null&&(T.elementType===ie||typeof ie=="object"&&ie!==null&&ie.$$typeof===ae&&ja(ie)===T.type)?(T=c(T,E.props),Fs(T,E),T.return=N,T):(T=ju(E.type,E.key,E.props,null,N.mode,U),Fs(T,E),T.return=N,T)}function A(N,T,E,U){return T===null||T.tag!==4||T.stateNode.containerInfo!==E.containerInfo||T.stateNode.implementation!==E.implementation?(T=Tp(E,N.mode,U),T.return=N,T):(T=c(T,E.children||[]),T.return=N,T)}function L(N,T,E,U,ie){return T===null||T.tag!==7?(T=Ta(E,N.mode,U,ie),T.return=N,T):(T=c(T,E),T.return=N,T)}function F(N,T,E){if(typeof T=="string"&&T!==""||typeof T=="number"||typeof T=="bigint")return T=_p(""+T,N.mode,E),T.return=N,T;if(typeof T=="object"&&T!==null){switch(T.$$typeof){case _:return E=ju(T.type,T.key,T.props,null,N.mode,E),Fs(E,T),E.return=N,E;case k:return T=Tp(T,N.mode,E),T.return=N,T;case ae:return T=ja(T),F(N,T,E)}if(de(T)||Y(T))return T=Ta(T,N.mode,E,null),T.return=N,T;if(typeof T.then=="function")return F(N,Bu(T),E);if(T.$$typeof===H)return F(N,Du(N,T),E);Uu(N,T)}return null}function j(N,T,E,U){var ie=T!==null?T.key:null;if(typeof E=="string"&&E!==""||typeof E=="number"||typeof E=="bigint")return ie!==null?null:b(N,T,""+E,U);if(typeof E=="object"&&E!==null){switch(E.$$typeof){case _:return E.key===ie?w(N,T,E,U):null;case k:return E.key===ie?A(N,T,E,U):null;case ae:return E=ja(E),j(N,T,E,U)}if(de(E)||Y(E))return ie!==null?null:L(N,T,E,U,null);if(typeof E.then=="function")return j(N,T,Bu(E),U);if(E.$$typeof===H)return j(N,T,Du(N,E),U);Uu(N,E)}return null}function R(N,T,E,U,ie){if(typeof U=="string"&&U!==""||typeof U=="number"||typeof U=="bigint")return N=N.get(E)||null,b(T,N,""+U,ie);if(typeof U=="object"&&U!==null){switch(U.$$typeof){case _:return N=N.get(U.key===null?E:U.key)||null,w(T,N,U,ie);case k:return N=N.get(U.key===null?E:U.key)||null,A(T,N,U,ie);case ae:return U=ja(U),R(N,T,E,U,ie)}if(de(U)||Y(U))return N=N.get(E)||null,L(T,N,U,ie,null);if(typeof U.then=="function")return R(N,T,E,Bu(U),ie);if(U.$$typeof===H)return R(N,T,E,Du(T,U),ie);Uu(T,U)}return null}function Z(N,T,E,U){for(var ie=null,Ae=null,ee=T,ge=T=0,Ne=null;ee!==null&&ge<E.length;ge++){ee.index>ge?(Ne=ee,ee=null):Ne=ee.sibling;var je=j(N,ee,E[ge],U);if(je===null){ee===null&&(ee=Ne);break}t&&ee&&je.alternate===null&&a(N,ee),T=d(je,T,ge),Ae===null?ie=je:Ae.sibling=je,Ae=je,ee=Ne}if(ge===E.length)return s(N,ee),ke&&Jn(N,ge),ie;if(ee===null){for(;ge<E.length;ge++)ee=F(N,E[ge],U),ee!==null&&(T=d(ee,T,ge),Ae===null?ie=ee:Ae.sibling=ee,Ae=ee);return ke&&Jn(N,ge),ie}for(ee=u(ee);ge<E.length;ge++)Ne=R(ee,N,ge,E[ge],U),Ne!==null&&(t&&Ne.alternate!==null&&ee.delete(Ne.key===null?ge:Ne.key),T=d(Ne,T,ge),Ae===null?ie=Ne:Ae.sibling=Ne,Ae=Ne);return t&&ee.forEach(function(Ji){return a(N,Ji)}),ke&&Jn(N,ge),ie}function re(N,T,E,U){if(E==null)throw Error(r(151));for(var ie=null,Ae=null,ee=T,ge=T=0,Ne=null,je=E.next();ee!==null&&!je.done;ge++,je=E.next()){ee.index>ge?(Ne=ee,ee=null):Ne=ee.sibling;var Ji=j(N,ee,je.value,U);if(Ji===null){ee===null&&(ee=Ne);break}t&&ee&&Ji.alternate===null&&a(N,ee),T=d(Ji,T,ge),Ae===null?ie=Ji:Ae.sibling=Ji,Ae=Ji,ee=Ne}if(je.done)return s(N,ee),ke&&Jn(N,ge),ie;if(ee===null){for(;!je.done;ge++,je=E.next())je=F(N,je.value,U),je!==null&&(T=d(je,T,ge),Ae===null?ie=je:Ae.sibling=je,Ae=je);return ke&&Jn(N,ge),ie}for(ee=u(ee);!je.done;ge++,je=E.next())je=R(ee,N,ge,je.value,U),je!==null&&(t&&je.alternate!==null&&ee.delete(je.key===null?ge:je.key),T=d(je,T,ge),Ae===null?ie=je:Ae.sibling=je,Ae=je);return t&&ee.forEach(function(ew){return a(N,ew)}),ke&&Jn(N,ge),ie}function qe(N,T,E,U){if(typeof E=="object"&&E!==null&&E.type===I&&E.key===null&&(E=E.props.children),typeof E=="object"&&E!==null){switch(E.$$typeof){case _:e:{for(var ie=E.key;T!==null;){if(T.key===ie){if(ie=E.type,ie===I){if(T.tag===7){s(N,T.sibling),U=c(T,E.props.children),U.return=N,N=U;break e}}else if(T.elementType===ie||typeof ie=="object"&&ie!==null&&ie.$$typeof===ae&&ja(ie)===T.type){s(N,T.sibling),U=c(T,E.props),Fs(U,E),U.return=N,N=U;break e}s(N,T);break}else a(N,T);T=T.sibling}E.type===I?(U=Ta(E.props.children,N.mode,U,E.key),U.return=N,N=U):(U=ju(E.type,E.key,E.props,null,N.mode,U),Fs(U,E),U.return=N,N=U)}return g(N);case k:e:{for(ie=E.key;T!==null;){if(T.key===ie)if(T.tag===4&&T.stateNode.containerInfo===E.containerInfo&&T.stateNode.implementation===E.implementation){s(N,T.sibling),U=c(T,E.children||[]),U.return=N,N=U;break e}else{s(N,T);break}else a(N,T);T=T.sibling}U=Tp(E,N.mode,U),U.return=N,N=U}return g(N);case ae:return E=ja(E),qe(N,T,E,U)}if(de(E))return Z(N,T,E,U);if(Y(E)){if(ie=Y(E),typeof ie!="function")throw Error(r(150));return E=ie.call(E),re(N,T,E,U)}if(typeof E.then=="function")return qe(N,T,Bu(E),U);if(E.$$typeof===H)return qe(N,T,Du(N,E),U);Uu(N,E)}return typeof E=="string"&&E!==""||typeof E=="number"||typeof E=="bigint"?(E=""+E,T!==null&&T.tag===6?(s(N,T.sibling),U=c(T,E),U.return=N,N=U):(s(N,T),U=_p(E,N.mode,U),U.return=N,N=U),g(N)):s(N,T)}return function(N,T,E,U){try{zs=0;var ie=qe(N,T,E,U);return jr=null,ie}catch(ee){if(ee===Ar||ee===Lu)throw ee;var Ae=Jt(29,ee,null,N.mode);return Ae.lanes=U,Ae.return=N,Ae}}}var Ra=U1(!0),z1=U1(!1),Di=!1;function Bp(t){t.updateQueue={baseState:t.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,lanes:0,hiddenCallbacks:null},callbacks:null}}function Up(t,a){t=t.updateQueue,a.updateQueue===t&&(a.updateQueue={baseState:t.baseState,firstBaseUpdate:t.firstBaseUpdate,lastBaseUpdate:t.lastBaseUpdate,shared:t.shared,callbacks:null})}function Ii(t){return{lane:t,tag:0,payload:null,callback:null,next:null}}function Li(t,a,s){var u=t.updateQueue;if(u===null)return null;if(u=u.shared,(Ie&2)!==0){var c=u.pending;return c===null?a.next=a:(a.next=c.next,c.next=a),u.pending=a,a=Au(t),w1(t,null,s),a}return Eu(t,u,a,s),Au(t)}function qs(t,a,s){if(a=a.updateQueue,a!==null&&(a=a.shared,(s&4194048)!==0)){var u=a.lanes;u&=t.pendingLanes,s|=u,a.lanes=s,jh(t,s)}}function zp(t,a){var s=t.updateQueue,u=t.alternate;if(u!==null&&(u=u.updateQueue,s===u)){var c=null,d=null;if(s=s.firstBaseUpdate,s!==null){do{var g={lane:s.lane,tag:s.tag,payload:s.payload,callback:null,next:null};d===null?c=d=g:d=d.next=g,s=s.next}while(s!==null);d===null?c=d=a:d=d.next=a}else c=d=a;s={baseState:u.baseState,firstBaseUpdate:c,lastBaseUpdate:d,shared:u.shared,callbacks:u.callbacks},t.updateQueue=s;return}t=s.lastBaseUpdate,t===null?s.firstBaseUpdate=a:t.next=a,s.lastBaseUpdate=a}var Fp=!1;function Hs(){if(Fp){var t=Er;if(t!==null)throw t}}function Ys(t,a,s,u){Fp=!1;var c=t.updateQueue;Di=!1;var d=c.firstBaseUpdate,g=c.lastBaseUpdate,b=c.shared.pending;if(b!==null){c.shared.pending=null;var w=b,A=w.next;w.next=null,g===null?d=A:g.next=A,g=w;var L=t.alternate;L!==null&&(L=L.updateQueue,b=L.lastBaseUpdate,b!==g&&(b===null?L.firstBaseUpdate=A:b.next=A,L.lastBaseUpdate=w))}if(d!==null){var F=c.baseState;g=0,L=A=w=null,b=d;do{var j=b.lane&-536870913,R=j!==b.lane;if(R?(Te&j)===j:(u&j)===j){j!==0&&j===kr&&(Fp=!0),L!==null&&(L=L.next={lane:0,tag:b.tag,payload:b.payload,callback:null,next:null});e:{var Z=t,re=b;j=a;var qe=s;switch(re.tag){case 1:if(Z=re.payload,typeof Z=="function"){F=Z.call(qe,F,j);break e}F=Z;break e;case 3:Z.flags=Z.flags&-65537|128;case 0:if(Z=re.payload,j=typeof Z=="function"?Z.call(qe,F,j):Z,j==null)break e;F=y({},F,j);break e;case 2:Di=!0}}j=b.callback,j!==null&&(t.flags|=64,R&&(t.flags|=8192),R=c.callbacks,R===null?c.callbacks=[j]:R.push(j))}else R={lane:j,tag:b.tag,payload:b.payload,callback:b.callback,next:null},L===null?(A=L=R,w=F):L=L.next=R,g|=j;if(b=b.next,b===null){if(b=c.shared.pending,b===null)break;R=b,b=R.next,R.next=null,c.lastBaseUpdate=R,c.shared.pending=null}}while(!0);L===null&&(w=F),c.baseState=w,c.firstBaseUpdate=A,c.lastBaseUpdate=L,d===null&&(c.shared.lanes=0),Fi|=g,t.lanes=g,t.memoizedState=F}}function F1(t,a){if(typeof t!="function")throw Error(r(191,t));t.call(a)}function q1(t,a){var s=t.callbacks;if(s!==null)for(t.callbacks=null,t=0;t<s.length;t++)F1(s[t],a)}var Mr=C(null),zu=C(0);function H1(t,a){t=ui,K(zu,t),K(Mr,a),ui=t|a.baseLanes}function qp(){K(zu,ui),K(Mr,Mr.current)}function Hp(){ui=zu.current,P(Mr),P(zu)}var $t=C(null),hn=null;function Pi(t){var a=t.alternate;K(ut,ut.current&1),K($t,t),hn===null&&(a===null||Mr.current!==null||a.memoizedState!==null)&&(hn=t)}function Yp(t){K(ut,ut.current),K($t,t),hn===null&&(hn=t)}function Y1(t){t.tag===22?(K(ut,ut.current),K($t,t),hn===null&&(hn=t)):Bi()}function Bi(){K(ut,ut.current),K($t,$t.current)}function Zt(t){P($t),hn===t&&(hn=null),P(ut)}var ut=C(0);function Fu(t){for(var a=t;a!==null;){if(a.tag===13){var s=a.memoizedState;if(s!==null&&(s=s.dehydrated,s===null||Qd(s)||Jd(s)))return a}else if(a.tag===19&&(a.memoizedProps.revealOrder==="forwards"||a.memoizedProps.revealOrder==="backwards"||a.memoizedProps.revealOrder==="unstable_legacy-backwards"||a.memoizedProps.revealOrder==="together")){if((a.flags&128)!==0)return a}else if(a.child!==null){a.child.return=a,a=a.child;continue}if(a===t)break;for(;a.sibling===null;){if(a.return===null||a.return===t)return null;a=a.return}a.sibling.return=a.return,a=a.sibling}return null}var ei=0,xe=null,ze=null,pt=null,qu=!1,Rr=!1,Da=!1,Hu=0,Gs=0,Dr=null,Y3=0;function et(){throw Error(r(321))}function Gp(t,a){if(a===null)return!1;for(var s=0;s<a.length&&s<t.length;s++)if(!Qt(t[s],a[s]))return!1;return!0}function Vp(t,a,s,u,c,d){return ei=d,xe=a,a.memoizedState=null,a.updateQueue=null,a.lanes=0,M.H=t===null||t.memoizedState===null?Nx:od,Da=!1,d=s(u,c),Da=!1,Rr&&(d=V1(a,s,u,c)),G1(t),d}function G1(t){M.H=Ks;var a=ze!==null&&ze.next!==null;if(ei=0,pt=ze=xe=null,qu=!1,Gs=0,Dr=null,a)throw Error(r(300));t===null||dt||(t=t.dependencies,t!==null&&Ru(t)&&(dt=!0))}function V1(t,a,s,u){xe=t;var c=0;do{if(Rr&&(Dr=null),Gs=0,Rr=!1,25<=c)throw Error(r(301));if(c+=1,pt=ze=null,t.updateQueue!=null){var d=t.updateQueue;d.lastEffect=null,d.events=null,d.stores=null,d.memoCache!=null&&(d.memoCache.index=0)}M.H=kx,d=a(s,u)}while(Rr);return d}function G3(){var t=M.H,a=t.useState()[0];return a=typeof a.then=="function"?Vs(a):a,t=t.useState()[0],(ze!==null?ze.memoizedState:null)!==t&&(xe.flags|=1024),a}function Wp(){var t=Hu!==0;return Hu=0,t}function Kp(t,a,s){a.updateQueue=t.updateQueue,a.flags&=-2053,t.lanes&=~s}function Xp(t){if(qu){for(t=t.memoizedState;t!==null;){var a=t.queue;a!==null&&(a.pending=null),t=t.next}qu=!1}ei=0,pt=ze=xe=null,Rr=!1,Gs=Hu=0,Dr=null}function Mt(){var t={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return pt===null?xe.memoizedState=pt=t:pt=pt.next=t,pt}function lt(){if(ze===null){var t=xe.alternate;t=t!==null?t.memoizedState:null}else t=ze.next;var a=pt===null?xe.memoizedState:pt.next;if(a!==null)pt=a,ze=t;else{if(t===null)throw xe.alternate===null?Error(r(467)):Error(r(310));ze=t,t={memoizedState:ze.memoizedState,baseState:ze.baseState,baseQueue:ze.baseQueue,queue:ze.queue,next:null},pt===null?xe.memoizedState=pt=t:pt=pt.next=t}return pt}function Yu(){return{lastEffect:null,events:null,stores:null,memoCache:null}}function Vs(t){var a=Gs;return Gs+=1,Dr===null&&(Dr=[]),t=L1(Dr,t,a),a=xe,(pt===null?a.memoizedState:pt.next)===null&&(a=a.alternate,M.H=a===null||a.memoizedState===null?Nx:od),t}function Gu(t){if(t!==null&&typeof t=="object"){if(typeof t.then=="function")return Vs(t);if(t.$$typeof===H)return _t(t)}throw Error(r(438,String(t)))}function Qp(t){var a=null,s=xe.updateQueue;if(s!==null&&(a=s.memoCache),a==null){var u=xe.alternate;u!==null&&(u=u.updateQueue,u!==null&&(u=u.memoCache,u!=null&&(a={data:u.data.map(function(c){return c.slice()}),index:0})))}if(a==null&&(a={data:[],index:0}),s===null&&(s=Yu(),xe.updateQueue=s),s.memoCache=a,s=a.data[a.index],s===void 0)for(s=a.data[a.index]=Array(t),u=0;u<t;u++)s[u]=te;return a.index++,s}function ti(t,a){return typeof a=="function"?a(t):a}function Vu(t){var a=lt();return Jp(a,ze,t)}function Jp(t,a,s){var u=t.queue;if(u===null)throw Error(r(311));u.lastRenderedReducer=s;var c=t.baseQueue,d=u.pending;if(d!==null){if(c!==null){var g=c.next;c.next=d.next,d.next=g}a.baseQueue=c=d,u.pending=null}if(d=t.baseState,c===null)t.memoizedState=d;else{a=c.next;var b=g=null,w=null,A=a,L=!1;do{var F=A.lane&-536870913;if(F!==A.lane?(Te&F)===F:(ei&F)===F){var j=A.revertLane;if(j===0)w!==null&&(w=w.next={lane:0,revertLane:0,gesture:null,action:A.action,hasEagerState:A.hasEagerState,eagerState:A.eagerState,next:null}),F===kr&&(L=!0);else if((ei&j)===j){A=A.next,j===kr&&(L=!0);continue}else F={lane:0,revertLane:A.revertLane,gesture:null,action:A.action,hasEagerState:A.hasEagerState,eagerState:A.eagerState,next:null},w===null?(b=w=F,g=d):w=w.next=F,xe.lanes|=j,Fi|=j;F=A.action,Da&&s(d,F),d=A.hasEagerState?A.eagerState:s(d,F)}else j={lane:F,revertLane:A.revertLane,gesture:A.gesture,action:A.action,hasEagerState:A.hasEagerState,eagerState:A.eagerState,next:null},w===null?(b=w=j,g=d):w=w.next=j,xe.lanes|=F,Fi|=F;A=A.next}while(A!==null&&A!==a);if(w===null?g=d:w.next=b,!Qt(d,t.memoizedState)&&(dt=!0,L&&(s=Er,s!==null)))throw s;t.memoizedState=d,t.baseState=g,t.baseQueue=w,u.lastRenderedState=d}return c===null&&(u.lanes=0),[t.memoizedState,u.dispatch]}function $p(t){var a=lt(),s=a.queue;if(s===null)throw Error(r(311));s.lastRenderedReducer=t;var u=s.dispatch,c=s.pending,d=a.memoizedState;if(c!==null){s.pending=null;var g=c=c.next;do d=t(d,g.action),g=g.next;while(g!==c);Qt(d,a.memoizedState)||(dt=!0),a.memoizedState=d,a.baseQueue===null&&(a.baseState=d),s.lastRenderedState=d}return[d,u]}function W1(t,a,s){var u=xe,c=lt(),d=ke;if(d){if(s===void 0)throw Error(r(407));s=s()}else s=a();var g=!Qt((ze||c).memoizedState,s);if(g&&(c.memoizedState=s,dt=!0),c=c.queue,td(Q1.bind(null,u,c,t),[t]),c.getSnapshot!==a||g||pt!==null&&pt.memoizedState.tag&1){if(u.flags|=2048,Ir(9,{destroy:void 0},X1.bind(null,u,c,s,a),null),Ge===null)throw Error(r(349));d||(ei&127)!==0||K1(u,a,s)}return s}function K1(t,a,s){t.flags|=16384,t={getSnapshot:a,value:s},a=xe.updateQueue,a===null?(a=Yu(),xe.updateQueue=a,a.stores=[t]):(s=a.stores,s===null?a.stores=[t]:s.push(t))}function X1(t,a,s,u){a.value=s,a.getSnapshot=u,J1(a)&&$1(t)}function Q1(t,a,s){return s(function(){J1(a)&&$1(t)})}function J1(t){var a=t.getSnapshot;t=t.value;try{var s=a();return!Qt(t,s)}catch{return!0}}function $1(t){var a=_a(t,2);a!==null&&Gt(a,t,2)}function Zp(t){var a=Mt();if(typeof t=="function"){var s=t;if(t=s(),Da){Xt(!0);try{s()}finally{Xt(!1)}}}return a.memoizedState=a.baseState=t,a.queue={pending:null,lanes:0,dispatch:null,lastRenderedReducer:ti,lastRenderedState:t},a}function Z1(t,a,s,u){return t.baseState=s,Jp(t,ze,typeof u=="function"?u:ti)}function V3(t,a,s,u,c){if(Xu(t))throw Error(r(485));if(t=a.action,t!==null){var d={payload:c,action:t,next:null,isTransition:!0,status:"pending",value:null,reason:null,listeners:[],then:function(g){d.listeners.push(g)}};M.T!==null?s(!0):d.isTransition=!1,u(d),s=a.pending,s===null?(d.next=a.pending=d,ex(a,d)):(d.next=s.next,a.pending=s.next=d)}}function ex(t,a){var s=a.action,u=a.payload,c=t.state;if(a.isTransition){var d=M.T,g={};M.T=g;try{var b=s(c,u),w=M.S;w!==null&&w(g,b),tx(t,a,b)}catch(A){ed(t,a,A)}finally{d!==null&&g.types!==null&&(d.types=g.types),M.T=d}}else try{d=s(c,u),tx(t,a,d)}catch(A){ed(t,a,A)}}function tx(t,a,s){s!==null&&typeof s=="object"&&typeof s.then=="function"?s.then(function(u){nx(t,a,u)},function(u){return ed(t,a,u)}):nx(t,a,s)}function nx(t,a,s){a.status="fulfilled",a.value=s,ix(a),t.state=s,a=t.pending,a!==null&&(s=a.next,s===a?t.pending=null:(s=s.next,a.next=s,ex(t,s)))}function ed(t,a,s){var u=t.pending;if(t.pending=null,u!==null){u=u.next;do a.status="rejected",a.reason=s,ix(a),a=a.next;while(a!==u)}t.action=null}function ix(t){t=t.listeners;for(var a=0;a<t.length;a++)(0,t[a])()}function ax(t,a){return a}function rx(t,a){if(ke){var s=Ge.formState;if(s!==null){e:{var u=xe;if(ke){if(Ke){t:{for(var c=Ke,d=fn;c.nodeType!==8;){if(!d){c=null;break t}if(c=xn(c.nextSibling),c===null){c=null;break t}}d=c.data,c=d==="F!"||d==="F"?c:null}if(c){Ke=xn(c.nextSibling),u=c.data==="F!";break e}}Mi(u)}u=!1}u&&(a=s[0])}}return s=Mt(),s.memoizedState=s.baseState=a,u={pending:null,lanes:0,dispatch:null,lastRenderedReducer:ax,lastRenderedState:a},s.queue=u,s=Cx.bind(null,xe,u),u.dispatch=s,u=Zp(!1),d=sd.bind(null,xe,!1,u.queue),u=Mt(),c={state:a,dispatch:null,action:t,pending:null},u.queue=c,s=V3.bind(null,xe,c,d,s),c.dispatch=s,u.memoizedState=t,[a,s,!1]}function sx(t){var a=lt();return ox(a,ze,t)}function ox(t,a,s){if(a=Jp(t,a,ax)[0],t=Vu(ti)[0],typeof a=="object"&&a!==null&&typeof a.then=="function")try{var u=Vs(a)}catch(g){throw g===Ar?Lu:g}else u=a;a=lt();var c=a.queue,d=c.dispatch;return s!==a.memoizedState&&(xe.flags|=2048,Ir(9,{destroy:void 0},W3.bind(null,c,s),null)),[u,d,t]}function W3(t,a){t.action=a}function ux(t){var a=lt(),s=ze;if(s!==null)return ox(a,s,t);lt(),a=a.memoizedState,s=lt();var u=s.queue.dispatch;return s.memoizedState=t,[a,u,!1]}function Ir(t,a,s,u){return t={tag:t,create:s,deps:u,inst:a,next:null},a=xe.updateQueue,a===null&&(a=Yu(),xe.updateQueue=a),s=a.lastEffect,s===null?a.lastEffect=t.next=t:(u=s.next,s.next=t,t.next=u,a.lastEffect=t),t}function lx(){return lt().memoizedState}function Wu(t,a,s,u){var c=Mt();xe.flags|=t,c.memoizedState=Ir(1|a,{destroy:void 0},s,u===void 0?null:u)}function Ku(t,a,s,u){var c=lt();u=u===void 0?null:u;var d=c.memoizedState.inst;ze!==null&&u!==null&&Gp(u,ze.memoizedState.deps)?c.memoizedState=Ir(a,d,s,u):(xe.flags|=t,c.memoizedState=Ir(1|a,d,s,u))}function cx(t,a){Wu(8390656,8,t,a)}function td(t,a){Ku(2048,8,t,a)}function K3(t){xe.flags|=4;var a=xe.updateQueue;if(a===null)a=Yu(),xe.updateQueue=a,a.events=[t];else{var s=a.events;s===null?a.events=[t]:s.push(t)}}function px(t){var a=lt().memoizedState;return K3({ref:a,nextImpl:t}),function(){if((Ie&2)!==0)throw Error(r(440));return a.impl.apply(void 0,arguments)}}function dx(t,a){return Ku(4,2,t,a)}function mx(t,a){return Ku(4,4,t,a)}function fx(t,a){if(typeof a=="function"){t=t();var s=a(t);return function(){typeof s=="function"?s():a(null)}}if(a!=null)return t=t(),a.current=t,function(){a.current=null}}function hx(t,a,s){s=s!=null?s.concat([t]):null,Ku(4,4,fx.bind(null,a,t),s)}function nd(){}function xx(t,a){var s=lt();a=a===void 0?null:a;var u=s.memoizedState;return a!==null&&Gp(a,u[1])?u[0]:(s.memoizedState=[t,a],t)}function gx(t,a){var s=lt();a=a===void 0?null:a;var u=s.memoizedState;if(a!==null&&Gp(a,u[1]))return u[0];if(u=t(),Da){Xt(!0);try{t()}finally{Xt(!1)}}return s.memoizedState=[u,a],u}function id(t,a,s){return s===void 0||(ei&1073741824)!==0&&(Te&261930)===0?t.memoizedState=a:(t.memoizedState=s,t=y0(),xe.lanes|=t,Fi|=t,s)}function yx(t,a,s,u){return Qt(s,a)?s:Mr.current!==null?(t=id(t,s,u),Qt(t,a)||(dt=!0),t):(ei&42)===0||(ei&1073741824)!==0&&(Te&261930)===0?(dt=!0,t.memoizedState=s):(t=y0(),xe.lanes|=t,Fi|=t,a)}function Ox(t,a,s,u,c){var d=V.p;V.p=d!==0&&8>d?d:8;var g=M.T,b={};M.T=b,sd(t,!1,a,s);try{var w=c(),A=M.S;if(A!==null&&A(b,w),w!==null&&typeof w=="object"&&typeof w.then=="function"){var L=H3(w,u);Ws(t,a,L,nn(t))}else Ws(t,a,u,nn(t))}catch(F){Ws(t,a,{then:function(){},status:"rejected",reason:F},nn())}finally{V.p=d,g!==null&&b.types!==null&&(g.types=b.types),M.T=g}}function X3(){}function ad(t,a,s,u){if(t.tag!==5)throw Error(r(476));var c=vx(t).queue;Ox(t,c,a,ne,s===null?X3:function(){return bx(t),s(u)})}function vx(t){var a=t.memoizedState;if(a!==null)return a;a={memoizedState:ne,baseState:ne,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:ti,lastRenderedState:ne},next:null};var s={};return a.next={memoizedState:s,baseState:s,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:ti,lastRenderedState:s},next:null},t.memoizedState=a,t=t.alternate,t!==null&&(t.memoizedState=a),a}function bx(t){var a=vx(t);a.next===null&&(a=t.alternate.memoizedState),Ws(t,a.next.queue,{},nn())}function rd(){return _t(co)}function Sx(){return lt().memoizedState}function wx(){return lt().memoizedState}function Q3(t){for(var a=t.return;a!==null;){switch(a.tag){case 24:case 3:var s=nn();t=Ii(s);var u=Li(a,t,s);u!==null&&(Gt(u,a,s),qs(u,a,s)),a={cache:Dp()},t.payload=a;return}a=a.return}}function J3(t,a,s){var u=nn();s={lane:u,revertLane:0,gesture:null,action:s,hasEagerState:!1,eagerState:null,next:null},Xu(t)?_x(a,s):(s=wp(t,a,s,u),s!==null&&(Gt(s,t,u),Tx(s,a,u)))}function Cx(t,a,s){var u=nn();Ws(t,a,s,u)}function Ws(t,a,s,u){var c={lane:u,revertLane:0,gesture:null,action:s,hasEagerState:!1,eagerState:null,next:null};if(Xu(t))_x(a,c);else{var d=t.alternate;if(t.lanes===0&&(d===null||d.lanes===0)&&(d=a.lastRenderedReducer,d!==null))try{var g=a.lastRenderedState,b=d(g,s);if(c.hasEagerState=!0,c.eagerState=b,Qt(b,g))return Eu(t,a,c,0),Ge===null&&ku(),!1}catch{}if(s=wp(t,a,c,u),s!==null)return Gt(s,t,u),Tx(s,a,u),!0}return!1}function sd(t,a,s,u){if(u={lane:2,revertLane:Bd(),gesture:null,action:u,hasEagerState:!1,eagerState:null,next:null},Xu(t)){if(a)throw Error(r(479))}else a=wp(t,s,u,2),a!==null&&Gt(a,t,2)}function Xu(t){var a=t.alternate;return t===xe||a!==null&&a===xe}function _x(t,a){Rr=qu=!0;var s=t.pending;s===null?a.next=a:(a.next=s.next,s.next=a),t.pending=a}function Tx(t,a,s){if((s&4194048)!==0){var u=a.lanes;u&=t.pendingLanes,s|=u,a.lanes=s,jh(t,s)}}var Ks={readContext:_t,use:Gu,useCallback:et,useContext:et,useEffect:et,useImperativeHandle:et,useLayoutEffect:et,useInsertionEffect:et,useMemo:et,useReducer:et,useRef:et,useState:et,useDebugValue:et,useDeferredValue:et,useTransition:et,useSyncExternalStore:et,useId:et,useHostTransitionStatus:et,useFormState:et,useActionState:et,useOptimistic:et,useMemoCache:et,useCacheRefresh:et};Ks.useEffectEvent=et;var Nx={readContext:_t,use:Gu,useCallback:function(t,a){return Mt().memoizedState=[t,a===void 0?null:a],t},useContext:_t,useEffect:cx,useImperativeHandle:function(t,a,s){s=s!=null?s.concat([t]):null,Wu(4194308,4,fx.bind(null,a,t),s)},useLayoutEffect:function(t,a){return Wu(4194308,4,t,a)},useInsertionEffect:function(t,a){Wu(4,2,t,a)},useMemo:function(t,a){var s=Mt();a=a===void 0?null:a;var u=t();if(Da){Xt(!0);try{t()}finally{Xt(!1)}}return s.memoizedState=[u,a],u},useReducer:function(t,a,s){var u=Mt();if(s!==void 0){var c=s(a);if(Da){Xt(!0);try{s(a)}finally{Xt(!1)}}}else c=a;return u.memoizedState=u.baseState=c,t={pending:null,lanes:0,dispatch:null,lastRenderedReducer:t,lastRenderedState:c},u.queue=t,t=t.dispatch=J3.bind(null,xe,t),[u.memoizedState,t]},useRef:function(t){var a=Mt();return t={current:t},a.memoizedState=t},useState:function(t){t=Zp(t);var a=t.queue,s=Cx.bind(null,xe,a);return a.dispatch=s,[t.memoizedState,s]},useDebugValue:nd,useDeferredValue:function(t,a){var s=Mt();return id(s,t,a)},useTransition:function(){var t=Zp(!1);return t=Ox.bind(null,xe,t.queue,!0,!1),Mt().memoizedState=t,[!1,t]},useSyncExternalStore:function(t,a,s){var u=xe,c=Mt();if(ke){if(s===void 0)throw Error(r(407));s=s()}else{if(s=a(),Ge===null)throw Error(r(349));(Te&127)!==0||K1(u,a,s)}c.memoizedState=s;var d={value:s,getSnapshot:a};return c.queue=d,cx(Q1.bind(null,u,d,t),[t]),u.flags|=2048,Ir(9,{destroy:void 0},X1.bind(null,u,d,s,a),null),s},useId:function(){var t=Mt(),a=Ge.identifierPrefix;if(ke){var s=Dn,u=Rn;s=(u&~(1<<32-jt(u)-1)).toString(32)+s,a="_"+a+"R_"+s,s=Hu++,0<s&&(a+="H"+s.toString(32)),a+="_"}else s=Y3++,a="_"+a+"r_"+s.toString(32)+"_";return t.memoizedState=a},useHostTransitionStatus:rd,useFormState:rx,useActionState:rx,useOptimistic:function(t){var a=Mt();a.memoizedState=a.baseState=t;var s={pending:null,lanes:0,dispatch:null,lastRenderedReducer:null,lastRenderedState:null};return a.queue=s,a=sd.bind(null,xe,!0,s),s.dispatch=a,[t,a]},useMemoCache:Qp,useCacheRefresh:function(){return Mt().memoizedState=Q3.bind(null,xe)},useEffectEvent:function(t){var a=Mt(),s={impl:t};return a.memoizedState=s,function(){if((Ie&2)!==0)throw Error(r(440));return s.impl.apply(void 0,arguments)}}},od={readContext:_t,use:Gu,useCallback:xx,useContext:_t,useEffect:td,useImperativeHandle:hx,useInsertionEffect:dx,useLayoutEffect:mx,useMemo:gx,useReducer:Vu,useRef:lx,useState:function(){return Vu(ti)},useDebugValue:nd,useDeferredValue:function(t,a){var s=lt();return yx(s,ze.memoizedState,t,a)},useTransition:function(){var t=Vu(ti)[0],a=lt().memoizedState;return[typeof t=="boolean"?t:Vs(t),a]},useSyncExternalStore:W1,useId:Sx,useHostTransitionStatus:rd,useFormState:sx,useActionState:sx,useOptimistic:function(t,a){var s=lt();return Z1(s,ze,t,a)},useMemoCache:Qp,useCacheRefresh:wx};od.useEffectEvent=px;var kx={readContext:_t,use:Gu,useCallback:xx,useContext:_t,useEffect:td,useImperativeHandle:hx,useInsertionEffect:dx,useLayoutEffect:mx,useMemo:gx,useReducer:$p,useRef:lx,useState:function(){return $p(ti)},useDebugValue:nd,useDeferredValue:function(t,a){var s=lt();return ze===null?id(s,t,a):yx(s,ze.memoizedState,t,a)},useTransition:function(){var t=$p(ti)[0],a=lt().memoizedState;return[typeof t=="boolean"?t:Vs(t),a]},useSyncExternalStore:W1,useId:Sx,useHostTransitionStatus:rd,useFormState:ux,useActionState:ux,useOptimistic:function(t,a){var s=lt();return ze!==null?Z1(s,ze,t,a):(s.baseState=t,[t,s.queue.dispatch])},useMemoCache:Qp,useCacheRefresh:wx};kx.useEffectEvent=px;function ud(t,a,s,u){a=t.memoizedState,s=s(u,a),s=s==null?a:y({},a,s),t.memoizedState=s,t.lanes===0&&(t.updateQueue.baseState=s)}var ld={enqueueSetState:function(t,a,s){t=t._reactInternals;var u=nn(),c=Ii(u);c.payload=a,s!=null&&(c.callback=s),a=Li(t,c,u),a!==null&&(Gt(a,t,u),qs(a,t,u))},enqueueReplaceState:function(t,a,s){t=t._reactInternals;var u=nn(),c=Ii(u);c.tag=1,c.payload=a,s!=null&&(c.callback=s),a=Li(t,c,u),a!==null&&(Gt(a,t,u),qs(a,t,u))},enqueueForceUpdate:function(t,a){t=t._reactInternals;var s=nn(),u=Ii(s);u.tag=2,a!=null&&(u.callback=a),a=Li(t,u,s),a!==null&&(Gt(a,t,s),qs(a,t,s))}};function Ex(t,a,s,u,c,d,g){return t=t.stateNode,typeof t.shouldComponentUpdate=="function"?t.shouldComponentUpdate(u,d,g):a.prototype&&a.prototype.isPureReactComponent?!Ds(s,u)||!Ds(c,d):!0}function Ax(t,a,s,u){t=a.state,typeof a.componentWillReceiveProps=="function"&&a.componentWillReceiveProps(s,u),typeof a.UNSAFE_componentWillReceiveProps=="function"&&a.UNSAFE_componentWillReceiveProps(s,u),a.state!==t&&ld.enqueueReplaceState(a,a.state,null)}function Ia(t,a){var s=a;if("ref"in a){s={};for(var u in a)u!=="ref"&&(s[u]=a[u])}if(t=t.defaultProps){s===a&&(s=y({},s));for(var c in t)s[c]===void 0&&(s[c]=t[c])}return s}function jx(t){Nu(t)}function Mx(t){console.error(t)}function Rx(t){Nu(t)}function Qu(t,a){try{var s=t.onUncaughtError;s(a.value,{componentStack:a.stack})}catch(u){setTimeout(function(){throw u})}}function Dx(t,a,s){try{var u=t.onCaughtError;u(s.value,{componentStack:s.stack,errorBoundary:a.tag===1?a.stateNode:null})}catch(c){setTimeout(function(){throw c})}}function cd(t,a,s){return s=Ii(s),s.tag=3,s.payload={element:null},s.callback=function(){Qu(t,a)},s}function Ix(t){return t=Ii(t),t.tag=3,t}function Lx(t,a,s,u){var c=s.type.getDerivedStateFromError;if(typeof c=="function"){var d=u.value;t.payload=function(){return c(d)},t.callback=function(){Dx(a,s,u)}}var g=s.stateNode;g!==null&&typeof g.componentDidCatch=="function"&&(t.callback=function(){Dx(a,s,u),typeof c!="function"&&(qi===null?qi=new Set([this]):qi.add(this));var b=u.stack;this.componentDidCatch(u.value,{componentStack:b!==null?b:""})})}function $3(t,a,s,u,c){if(s.flags|=32768,u!==null&&typeof u=="object"&&typeof u.then=="function"){if(a=s.alternate,a!==null&&Nr(a,s,c,!0),s=$t.current,s!==null){switch(s.tag){case 31:case 13:return hn===null?ul():s.alternate===null&&tt===0&&(tt=3),s.flags&=-257,s.flags|=65536,s.lanes=c,u===Pu?s.flags|=16384:(a=s.updateQueue,a===null?s.updateQueue=new Set([u]):a.add(u),Id(t,u,c)),!1;case 22:return s.flags|=65536,u===Pu?s.flags|=16384:(a=s.updateQueue,a===null?(a={transitions:null,markerInstances:null,retryQueue:new Set([u])},s.updateQueue=a):(s=a.retryQueue,s===null?a.retryQueue=new Set([u]):s.add(u)),Id(t,u,c)),!1}throw Error(r(435,s.tag))}return Id(t,u,c),ul(),!1}if(ke)return a=$t.current,a!==null?((a.flags&65536)===0&&(a.flags|=256),a.flags|=65536,a.lanes=c,u!==Ep&&(t=Error(r(422),{cause:u}),Ps(pn(t,s)))):(u!==Ep&&(a=Error(r(423),{cause:u}),Ps(pn(a,s))),t=t.current.alternate,t.flags|=65536,c&=-c,t.lanes|=c,u=pn(u,s),c=cd(t.stateNode,u,c),zp(t,c),tt!==4&&(tt=2)),!1;var d=Error(r(520),{cause:u});if(d=pn(d,s),no===null?no=[d]:no.push(d),tt!==4&&(tt=2),a===null)return!0;u=pn(u,s),s=a;do{switch(s.tag){case 3:return s.flags|=65536,t=c&-c,s.lanes|=t,t=cd(s.stateNode,u,t),zp(s,t),!1;case 1:if(a=s.type,d=s.stateNode,(s.flags&128)===0&&(typeof a.getDerivedStateFromError=="function"||d!==null&&typeof d.componentDidCatch=="function"&&(qi===null||!qi.has(d))))return s.flags|=65536,c&=-c,s.lanes|=c,c=Ix(c),Lx(c,t,s,u),zp(s,c),!1}s=s.return}while(s!==null);return!1}var pd=Error(r(461)),dt=!1;function Tt(t,a,s,u){a.child=t===null?z1(a,null,s,u):Ra(a,t.child,s,u)}function Px(t,a,s,u,c){s=s.render;var d=a.ref;if("ref"in u){var g={};for(var b in u)b!=="ref"&&(g[b]=u[b])}else g=u;return Ea(a),u=Vp(t,a,s,g,d,c),b=Wp(),t!==null&&!dt?(Kp(t,a,c),ni(t,a,c)):(ke&&b&&Np(a),a.flags|=1,Tt(t,a,u,c),a.child)}function Bx(t,a,s,u,c){if(t===null){var d=s.type;return typeof d=="function"&&!Cp(d)&&d.defaultProps===void 0&&s.compare===null?(a.tag=15,a.type=d,Ux(t,a,d,u,c)):(t=ju(s.type,null,u,a,a.mode,c),t.ref=a.ref,t.return=a,a.child=t)}if(d=t.child,!Od(t,c)){var g=d.memoizedProps;if(s=s.compare,s=s!==null?s:Ds,s(g,u)&&t.ref===a.ref)return ni(t,a,c)}return a.flags|=1,t=Qn(d,u),t.ref=a.ref,t.return=a,a.child=t}function Ux(t,a,s,u,c){if(t!==null){var d=t.memoizedProps;if(Ds(d,u)&&t.ref===a.ref)if(dt=!1,a.pendingProps=u=d,Od(t,c))(t.flags&131072)!==0&&(dt=!0);else return a.lanes=t.lanes,ni(t,a,c)}return dd(t,a,s,u,c)}function zx(t,a,s,u){var c=u.children,d=t!==null?t.memoizedState:null;if(t===null&&a.stateNode===null&&(a.stateNode={_visibility:1,_pendingMarkers:null,_retryCache:null,_transitions:null}),u.mode==="hidden"){if((a.flags&128)!==0){if(d=d!==null?d.baseLanes|s:s,t!==null){for(u=a.child=t.child,c=0;u!==null;)c=c|u.lanes|u.childLanes,u=u.sibling;u=c&~d}else u=0,a.child=null;return Fx(t,a,d,s,u)}if((s&536870912)!==0)a.memoizedState={baseLanes:0,cachePool:null},t!==null&&Iu(a,d!==null?d.cachePool:null),d!==null?H1(a,d):qp(),Y1(a);else return u=a.lanes=536870912,Fx(t,a,d!==null?d.baseLanes|s:s,s,u)}else d!==null?(Iu(a,d.cachePool),H1(a,d),Bi(),a.memoizedState=null):(t!==null&&Iu(a,null),qp(),Bi());return Tt(t,a,c,s),a.child}function Xs(t,a){return t!==null&&t.tag===22||a.stateNode!==null||(a.stateNode={_visibility:1,_pendingMarkers:null,_retryCache:null,_transitions:null}),a.sibling}function Fx(t,a,s,u,c){var d=Lp();return d=d===null?null:{parent:ct._currentValue,pool:d},a.memoizedState={baseLanes:s,cachePool:d},t!==null&&Iu(a,null),qp(),Y1(a),t!==null&&Nr(t,a,u,!0),a.childLanes=c,null}function Ju(t,a){return a=Zu({mode:a.mode,children:a.children},t.mode),a.ref=t.ref,t.child=a,a.return=t,a}function qx(t,a,s){return Ra(a,t.child,null,s),t=Ju(a,a.pendingProps),t.flags|=2,Zt(a),a.memoizedState=null,t}function Z3(t,a,s){var u=a.pendingProps,c=(a.flags&128)!==0;if(a.flags&=-129,t===null){if(ke){if(u.mode==="hidden")return t=Ju(a,u),a.lanes=536870912,Xs(null,t);if(Yp(a),(t=Ke)?(t=eg(t,fn),t=t!==null&&t.data==="&"?t:null,t!==null&&(a.memoizedState={dehydrated:t,treeContext:Ai!==null?{id:Rn,overflow:Dn}:null,retryLane:536870912,hydrationErrors:null},s=_1(t),s.return=a,a.child=s,Ct=a,Ke=null)):t=null,t===null)throw Mi(a);return a.lanes=536870912,null}return Ju(a,u)}var d=t.memoizedState;if(d!==null){var g=d.dehydrated;if(Yp(a),c)if(a.flags&256)a.flags&=-257,a=qx(t,a,s);else if(a.memoizedState!==null)a.child=t.child,a.flags|=128,a=null;else throw Error(r(558));else if(dt||Nr(t,a,s,!1),c=(s&t.childLanes)!==0,dt||c){if(u=Ge,u!==null&&(g=Mh(u,s),g!==0&&g!==d.retryLane))throw d.retryLane=g,_a(t,g),Gt(u,t,g),pd;ul(),a=qx(t,a,s)}else t=d.treeContext,Ke=xn(g.nextSibling),Ct=a,ke=!0,ji=null,fn=!1,t!==null&&k1(a,t),a=Ju(a,u),a.flags|=4096;return a}return t=Qn(t.child,{mode:u.mode,children:u.children}),t.ref=a.ref,a.child=t,t.return=a,t}function $u(t,a){var s=a.ref;if(s===null)t!==null&&t.ref!==null&&(a.flags|=4194816);else{if(typeof s!="function"&&typeof s!="object")throw Error(r(284));(t===null||t.ref!==s)&&(a.flags|=4194816)}}function dd(t,a,s,u,c){return Ea(a),s=Vp(t,a,s,u,void 0,c),u=Wp(),t!==null&&!dt?(Kp(t,a,c),ni(t,a,c)):(ke&&u&&Np(a),a.flags|=1,Tt(t,a,s,c),a.child)}function Hx(t,a,s,u,c,d){return Ea(a),a.updateQueue=null,s=V1(a,u,s,c),G1(t),u=Wp(),t!==null&&!dt?(Kp(t,a,d),ni(t,a,d)):(ke&&u&&Np(a),a.flags|=1,Tt(t,a,s,d),a.child)}function Yx(t,a,s,u,c){if(Ea(a),a.stateNode===null){var d=wr,g=s.contextType;typeof g=="object"&&g!==null&&(d=_t(g)),d=new s(u,d),a.memoizedState=d.state!==null&&d.state!==void 0?d.state:null,d.updater=ld,a.stateNode=d,d._reactInternals=a,d=a.stateNode,d.props=u,d.state=a.memoizedState,d.refs={},Bp(a),g=s.contextType,d.context=typeof g=="object"&&g!==null?_t(g):wr,d.state=a.memoizedState,g=s.getDerivedStateFromProps,typeof g=="function"&&(ud(a,s,g,u),d.state=a.memoizedState),typeof s.getDerivedStateFromProps=="function"||typeof d.getSnapshotBeforeUpdate=="function"||typeof d.UNSAFE_componentWillMount!="function"&&typeof d.componentWillMount!="function"||(g=d.state,typeof d.componentWillMount=="function"&&d.componentWillMount(),typeof d.UNSAFE_componentWillMount=="function"&&d.UNSAFE_componentWillMount(),g!==d.state&&ld.enqueueReplaceState(d,d.state,null),Ys(a,u,d,c),Hs(),d.state=a.memoizedState),typeof d.componentDidMount=="function"&&(a.flags|=4194308),u=!0}else if(t===null){d=a.stateNode;var b=a.memoizedProps,w=Ia(s,b);d.props=w;var A=d.context,L=s.contextType;g=wr,typeof L=="object"&&L!==null&&(g=_t(L));var F=s.getDerivedStateFromProps;L=typeof F=="function"||typeof d.getSnapshotBeforeUpdate=="function",b=a.pendingProps!==b,L||typeof d.UNSAFE_componentWillReceiveProps!="function"&&typeof d.componentWillReceiveProps!="function"||(b||A!==g)&&Ax(a,d,u,g),Di=!1;var j=a.memoizedState;d.state=j,Ys(a,u,d,c),Hs(),A=a.memoizedState,b||j!==A||Di?(typeof F=="function"&&(ud(a,s,F,u),A=a.memoizedState),(w=Di||Ex(a,s,w,u,j,A,g))?(L||typeof d.UNSAFE_componentWillMount!="function"&&typeof d.componentWillMount!="function"||(typeof d.componentWillMount=="function"&&d.componentWillMount(),typeof d.UNSAFE_componentWillMount=="function"&&d.UNSAFE_componentWillMount()),typeof d.componentDidMount=="function"&&(a.flags|=4194308)):(typeof d.componentDidMount=="function"&&(a.flags|=4194308),a.memoizedProps=u,a.memoizedState=A),d.props=u,d.state=A,d.context=g,u=w):(typeof d.componentDidMount=="function"&&(a.flags|=4194308),u=!1)}else{d=a.stateNode,Up(t,a),g=a.memoizedProps,L=Ia(s,g),d.props=L,F=a.pendingProps,j=d.context,A=s.contextType,w=wr,typeof A=="object"&&A!==null&&(w=_t(A)),b=s.getDerivedStateFromProps,(A=typeof b=="function"||typeof d.getSnapshotBeforeUpdate=="function")||typeof d.UNSAFE_componentWillReceiveProps!="function"&&typeof d.componentWillReceiveProps!="function"||(g!==F||j!==w)&&Ax(a,d,u,w),Di=!1,j=a.memoizedState,d.state=j,Ys(a,u,d,c),Hs();var R=a.memoizedState;g!==F||j!==R||Di||t!==null&&t.dependencies!==null&&Ru(t.dependencies)?(typeof b=="function"&&(ud(a,s,b,u),R=a.memoizedState),(L=Di||Ex(a,s,L,u,j,R,w)||t!==null&&t.dependencies!==null&&Ru(t.dependencies))?(A||typeof d.UNSAFE_componentWillUpdate!="function"&&typeof d.componentWillUpdate!="function"||(typeof d.componentWillUpdate=="function"&&d.componentWillUpdate(u,R,w),typeof d.UNSAFE_componentWillUpdate=="function"&&d.UNSAFE_componentWillUpdate(u,R,w)),typeof d.componentDidUpdate=="function"&&(a.flags|=4),typeof d.getSnapshotBeforeUpdate=="function"&&(a.flags|=1024)):(typeof d.componentDidUpdate!="function"||g===t.memoizedProps&&j===t.memoizedState||(a.flags|=4),typeof d.getSnapshotBeforeUpdate!="function"||g===t.memoizedProps&&j===t.memoizedState||(a.flags|=1024),a.memoizedProps=u,a.memoizedState=R),d.props=u,d.state=R,d.context=w,u=L):(typeof d.componentDidUpdate!="function"||g===t.memoizedProps&&j===t.memoizedState||(a.flags|=4),typeof d.getSnapshotBeforeUpdate!="function"||g===t.memoizedProps&&j===t.memoizedState||(a.flags|=1024),u=!1)}return d=u,$u(t,a),u=(a.flags&128)!==0,d||u?(d=a.stateNode,s=u&&typeof s.getDerivedStateFromError!="function"?null:d.render(),a.flags|=1,t!==null&&u?(a.child=Ra(a,t.child,null,c),a.child=Ra(a,null,s,c)):Tt(t,a,s,c),a.memoizedState=d.state,t=a.child):t=ni(t,a,c),t}function Gx(t,a,s,u){return Na(),a.flags|=256,Tt(t,a,s,u),a.child}var md={dehydrated:null,treeContext:null,retryLane:0,hydrationErrors:null};function fd(t){return{baseLanes:t,cachePool:D1()}}function hd(t,a,s){return t=t!==null?t.childLanes&~s:0,a&&(t|=tn),t}function Vx(t,a,s){var u=a.pendingProps,c=!1,d=(a.flags&128)!==0,g;if((g=d)||(g=t!==null&&t.memoizedState===null?!1:(ut.current&2)!==0),g&&(c=!0,a.flags&=-129),g=(a.flags&32)!==0,a.flags&=-33,t===null){if(ke){if(c?Pi(a):Bi(),(t=Ke)?(t=eg(t,fn),t=t!==null&&t.data!=="&"?t:null,t!==null&&(a.memoizedState={dehydrated:t,treeContext:Ai!==null?{id:Rn,overflow:Dn}:null,retryLane:536870912,hydrationErrors:null},s=_1(t),s.return=a,a.child=s,Ct=a,Ke=null)):t=null,t===null)throw Mi(a);return Jd(t)?a.lanes=32:a.lanes=536870912,null}var b=u.children;return u=u.fallback,c?(Bi(),c=a.mode,b=Zu({mode:"hidden",children:b},c),u=Ta(u,c,s,null),b.return=a,u.return=a,b.sibling=u,a.child=b,u=a.child,u.memoizedState=fd(s),u.childLanes=hd(t,g,s),a.memoizedState=md,Xs(null,u)):(Pi(a),xd(a,b))}var w=t.memoizedState;if(w!==null&&(b=w.dehydrated,b!==null)){if(d)a.flags&256?(Pi(a),a.flags&=-257,a=gd(t,a,s)):a.memoizedState!==null?(Bi(),a.child=t.child,a.flags|=128,a=null):(Bi(),b=u.fallback,c=a.mode,u=Zu({mode:"visible",children:u.children},c),b=Ta(b,c,s,null),b.flags|=2,u.return=a,b.return=a,u.sibling=b,a.child=u,Ra(a,t.child,null,s),u=a.child,u.memoizedState=fd(s),u.childLanes=hd(t,g,s),a.memoizedState=md,a=Xs(null,u));else if(Pi(a),Jd(b)){if(g=b.nextSibling&&b.nextSibling.dataset,g)var A=g.dgst;g=A,u=Error(r(419)),u.stack="",u.digest=g,Ps({value:u,source:null,stack:null}),a=gd(t,a,s)}else if(dt||Nr(t,a,s,!1),g=(s&t.childLanes)!==0,dt||g){if(g=Ge,g!==null&&(u=Mh(g,s),u!==0&&u!==w.retryLane))throw w.retryLane=u,_a(t,u),Gt(g,t,u),pd;Qd(b)||ul(),a=gd(t,a,s)}else Qd(b)?(a.flags|=192,a.child=t.child,a=null):(t=w.treeContext,Ke=xn(b.nextSibling),Ct=a,ke=!0,ji=null,fn=!1,t!==null&&k1(a,t),a=xd(a,u.children),a.flags|=4096);return a}return c?(Bi(),b=u.fallback,c=a.mode,w=t.child,A=w.sibling,u=Qn(w,{mode:"hidden",children:u.children}),u.subtreeFlags=w.subtreeFlags&65011712,A!==null?b=Qn(A,b):(b=Ta(b,c,s,null),b.flags|=2),b.return=a,u.return=a,u.sibling=b,a.child=u,Xs(null,u),u=a.child,b=t.child.memoizedState,b===null?b=fd(s):(c=b.cachePool,c!==null?(w=ct._currentValue,c=c.parent!==w?{parent:w,pool:w}:c):c=D1(),b={baseLanes:b.baseLanes|s,cachePool:c}),u.memoizedState=b,u.childLanes=hd(t,g,s),a.memoizedState=md,Xs(t.child,u)):(Pi(a),s=t.child,t=s.sibling,s=Qn(s,{mode:"visible",children:u.children}),s.return=a,s.sibling=null,t!==null&&(g=a.deletions,g===null?(a.deletions=[t],a.flags|=16):g.push(t)),a.child=s,a.memoizedState=null,s)}function xd(t,a){return a=Zu({mode:"visible",children:a},t.mode),a.return=t,t.child=a}function Zu(t,a){return t=Jt(22,t,null,a),t.lanes=0,t}function gd(t,a,s){return Ra(a,t.child,null,s),t=xd(a,a.pendingProps.children),t.flags|=2,a.memoizedState=null,t}function Wx(t,a,s){t.lanes|=a;var u=t.alternate;u!==null&&(u.lanes|=a),Mp(t.return,a,s)}function yd(t,a,s,u,c,d){var g=t.memoizedState;g===null?t.memoizedState={isBackwards:a,rendering:null,renderingStartTime:0,last:u,tail:s,tailMode:c,treeForkCount:d}:(g.isBackwards=a,g.rendering=null,g.renderingStartTime=0,g.last=u,g.tail=s,g.tailMode=c,g.treeForkCount=d)}function Kx(t,a,s){var u=a.pendingProps,c=u.revealOrder,d=u.tail;u=u.children;var g=ut.current,b=(g&2)!==0;if(b?(g=g&1|2,a.flags|=128):g&=1,K(ut,g),Tt(t,a,u,s),u=ke?Ls:0,!b&&t!==null&&(t.flags&128)!==0)e:for(t=a.child;t!==null;){if(t.tag===13)t.memoizedState!==null&&Wx(t,s,a);else if(t.tag===19)Wx(t,s,a);else if(t.child!==null){t.child.return=t,t=t.child;continue}if(t===a)break e;for(;t.sibling===null;){if(t.return===null||t.return===a)break e;t=t.return}t.sibling.return=t.return,t=t.sibling}switch(c){case"forwards":for(s=a.child,c=null;s!==null;)t=s.alternate,t!==null&&Fu(t)===null&&(c=s),s=s.sibling;s=c,s===null?(c=a.child,a.child=null):(c=s.sibling,s.sibling=null),yd(a,!1,c,s,d,u);break;case"backwards":case"unstable_legacy-backwards":for(s=null,c=a.child,a.child=null;c!==null;){if(t=c.alternate,t!==null&&Fu(t)===null){a.child=c;break}t=c.sibling,c.sibling=s,s=c,c=t}yd(a,!0,s,null,d,u);break;case"together":yd(a,!1,null,null,void 0,u);break;default:a.memoizedState=null}return a.child}function ni(t,a,s){if(t!==null&&(a.dependencies=t.dependencies),Fi|=a.lanes,(s&a.childLanes)===0)if(t!==null){if(Nr(t,a,s,!1),(s&a.childLanes)===0)return null}else return null;if(t!==null&&a.child!==t.child)throw Error(r(153));if(a.child!==null){for(t=a.child,s=Qn(t,t.pendingProps),a.child=s,s.return=a;t.sibling!==null;)t=t.sibling,s=s.sibling=Qn(t,t.pendingProps),s.return=a;s.sibling=null}return a.child}function Od(t,a){return(t.lanes&a)!==0?!0:(t=t.dependencies,!!(t!==null&&Ru(t)))}function eS(t,a,s){switch(a.tag){case 3:ot(a,a.stateNode.containerInfo),Ri(a,ct,t.memoizedState.cache),Na();break;case 27:case 5:Vn(a);break;case 4:ot(a,a.stateNode.containerInfo);break;case 10:Ri(a,a.type,a.memoizedProps.value);break;case 31:if(a.memoizedState!==null)return a.flags|=128,Yp(a),null;break;case 13:var u=a.memoizedState;if(u!==null)return u.dehydrated!==null?(Pi(a),a.flags|=128,null):(s&a.child.childLanes)!==0?Vx(t,a,s):(Pi(a),t=ni(t,a,s),t!==null?t.sibling:null);Pi(a);break;case 19:var c=(t.flags&128)!==0;if(u=(s&a.childLanes)!==0,u||(Nr(t,a,s,!1),u=(s&a.childLanes)!==0),c){if(u)return Kx(t,a,s);a.flags|=128}if(c=a.memoizedState,c!==null&&(c.rendering=null,c.tail=null,c.lastEffect=null),K(ut,ut.current),u)break;return null;case 22:return a.lanes=0,zx(t,a,s,a.pendingProps);case 24:Ri(a,ct,t.memoizedState.cache)}return ni(t,a,s)}function Xx(t,a,s){if(t!==null)if(t.memoizedProps!==a.pendingProps)dt=!0;else{if(!Od(t,s)&&(a.flags&128)===0)return dt=!1,eS(t,a,s);dt=(t.flags&131072)!==0}else dt=!1,ke&&(a.flags&1048576)!==0&&N1(a,Ls,a.index);switch(a.lanes=0,a.tag){case 16:e:{var u=a.pendingProps;if(t=ja(a.elementType),a.type=t,typeof t=="function")Cp(t)?(u=Ia(t,u),a.tag=1,a=Yx(null,a,t,u,s)):(a.tag=0,a=dd(null,a,t,u,s));else{if(t!=null){var c=t.$$typeof;if(c===J){a.tag=11,a=Px(null,a,t,u,s);break e}else if(c===W){a.tag=14,a=Bx(null,a,t,u,s);break e}}throw a=st(t)||t,Error(r(306,a,""))}}return a;case 0:return dd(t,a,a.type,a.pendingProps,s);case 1:return u=a.type,c=Ia(u,a.pendingProps),Yx(t,a,u,c,s);case 3:e:{if(ot(a,a.stateNode.containerInfo),t===null)throw Error(r(387));u=a.pendingProps;var d=a.memoizedState;c=d.element,Up(t,a),Ys(a,u,null,s);var g=a.memoizedState;if(u=g.cache,Ri(a,ct,u),u!==d.cache&&Rp(a,[ct],s,!0),Hs(),u=g.element,d.isDehydrated)if(d={element:u,isDehydrated:!1,cache:g.cache},a.updateQueue.baseState=d,a.memoizedState=d,a.flags&256){a=Gx(t,a,u,s);break e}else if(u!==c){c=pn(Error(r(424)),a),Ps(c),a=Gx(t,a,u,s);break e}else for(t=a.stateNode.containerInfo,t.nodeType===9?t=t.body:t=t.nodeName==="HTML"?t.ownerDocument.body:t,Ke=xn(t.firstChild),Ct=a,ke=!0,ji=null,fn=!0,s=z1(a,null,u,s),a.child=s;s;)s.flags=s.flags&-3|4096,s=s.sibling;else{if(Na(),u===c){a=ni(t,a,s);break e}Tt(t,a,u,s)}a=a.child}return a;case 26:return $u(t,a),t===null?(s=sg(a.type,null,a.pendingProps,null))?a.memoizedState=s:ke||(s=a.type,t=a.pendingProps,u=hl(he.current).createElement(s),u[wt]=a,u[Ut]=t,Nt(u,s,t),gt(u),a.stateNode=u):a.memoizedState=sg(a.type,t.memoizedProps,a.pendingProps,t.memoizedState),null;case 27:return Vn(a),t===null&&ke&&(u=a.stateNode=ig(a.type,a.pendingProps,he.current),Ct=a,fn=!0,c=Ke,Vi(a.type)?($d=c,Ke=xn(u.firstChild)):Ke=c),Tt(t,a,a.pendingProps.children,s),$u(t,a),t===null&&(a.flags|=4194304),a.child;case 5:return t===null&&ke&&((c=u=Ke)&&(u=AS(u,a.type,a.pendingProps,fn),u!==null?(a.stateNode=u,Ct=a,Ke=xn(u.firstChild),fn=!1,c=!0):c=!1),c||Mi(a)),Vn(a),c=a.type,d=a.pendingProps,g=t!==null?t.memoizedProps:null,u=d.children,Wd(c,d)?u=null:g!==null&&Wd(c,g)&&(a.flags|=32),a.memoizedState!==null&&(c=Vp(t,a,G3,null,null,s),co._currentValue=c),$u(t,a),Tt(t,a,u,s),a.child;case 6:return t===null&&ke&&((t=s=Ke)&&(s=jS(s,a.pendingProps,fn),s!==null?(a.stateNode=s,Ct=a,Ke=null,t=!0):t=!1),t||Mi(a)),null;case 13:return Vx(t,a,s);case 4:return ot(a,a.stateNode.containerInfo),u=a.pendingProps,t===null?a.child=Ra(a,null,u,s):Tt(t,a,u,s),a.child;case 11:return Px(t,a,a.type,a.pendingProps,s);case 7:return Tt(t,a,a.pendingProps,s),a.child;case 8:return Tt(t,a,a.pendingProps.children,s),a.child;case 12:return Tt(t,a,a.pendingProps.children,s),a.child;case 10:return u=a.pendingProps,Ri(a,a.type,u.value),Tt(t,a,u.children,s),a.child;case 9:return c=a.type._context,u=a.pendingProps.children,Ea(a),c=_t(c),u=u(c),a.flags|=1,Tt(t,a,u,s),a.child;case 14:return Bx(t,a,a.type,a.pendingProps,s);case 15:return Ux(t,a,a.type,a.pendingProps,s);case 19:return Kx(t,a,s);case 31:return Z3(t,a,s);case 22:return zx(t,a,s,a.pendingProps);case 24:return Ea(a),u=_t(ct),t===null?(c=Lp(),c===null&&(c=Ge,d=Dp(),c.pooledCache=d,d.refCount++,d!==null&&(c.pooledCacheLanes|=s),c=d),a.memoizedState={parent:u,cache:c},Bp(a),Ri(a,ct,c)):((t.lanes&s)!==0&&(Up(t,a),Ys(a,null,null,s),Hs()),c=t.memoizedState,d=a.memoizedState,c.parent!==u?(c={parent:u,cache:u},a.memoizedState=c,a.lanes===0&&(a.memoizedState=a.updateQueue.baseState=c),Ri(a,ct,u)):(u=d.cache,Ri(a,ct,u),u!==c.cache&&Rp(a,[ct],s,!0))),Tt(t,a,a.pendingProps.children,s),a.child;case 29:throw a.pendingProps}throw Error(r(156,a.tag))}function ii(t){t.flags|=4}function vd(t,a,s,u,c){if((a=(t.mode&32)!==0)&&(a=!1),a){if(t.flags|=16777216,(c&335544128)===c)if(t.stateNode.complete)t.flags|=8192;else if(S0())t.flags|=8192;else throw Ma=Pu,Pp}else t.flags&=-16777217}function Qx(t,a){if(a.type!=="stylesheet"||(a.state.loading&4)!==0)t.flags&=-16777217;else if(t.flags|=16777216,!pg(a))if(S0())t.flags|=8192;else throw Ma=Pu,Pp}function el(t,a){a!==null&&(t.flags|=4),t.flags&16384&&(a=t.tag!==22?Eh():536870912,t.lanes|=a,Ur|=a)}function Qs(t,a){if(!ke)switch(t.tailMode){case"hidden":a=t.tail;for(var s=null;a!==null;)a.alternate!==null&&(s=a),a=a.sibling;s===null?t.tail=null:s.sibling=null;break;case"collapsed":s=t.tail;for(var u=null;s!==null;)s.alternate!==null&&(u=s),s=s.sibling;u===null?a||t.tail===null?t.tail=null:t.tail.sibling=null:u.sibling=null}}function Xe(t){var a=t.alternate!==null&&t.alternate.child===t.child,s=0,u=0;if(a)for(var c=t.child;c!==null;)s|=c.lanes|c.childLanes,u|=c.subtreeFlags&65011712,u|=c.flags&65011712,c.return=t,c=c.sibling;else for(c=t.child;c!==null;)s|=c.lanes|c.childLanes,u|=c.subtreeFlags,u|=c.flags,c.return=t,c=c.sibling;return t.subtreeFlags|=u,t.childLanes=s,a}function tS(t,a,s){var u=a.pendingProps;switch(kp(a),a.tag){case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return Xe(a),null;case 1:return Xe(a),null;case 3:return s=a.stateNode,u=null,t!==null&&(u=t.memoizedState.cache),a.memoizedState.cache!==u&&(a.flags|=2048),Zn(ct),Ye(),s.pendingContext&&(s.context=s.pendingContext,s.pendingContext=null),(t===null||t.child===null)&&(Tr(a)?ii(a):t===null||t.memoizedState.isDehydrated&&(a.flags&256)===0||(a.flags|=1024,Ap())),Xe(a),null;case 26:var c=a.type,d=a.memoizedState;return t===null?(ii(a),d!==null?(Xe(a),Qx(a,d)):(Xe(a),vd(a,c,null,u,s))):d?d!==t.memoizedState?(ii(a),Xe(a),Qx(a,d)):(Xe(a),a.flags&=-16777217):(t=t.memoizedProps,t!==u&&ii(a),Xe(a),vd(a,c,t,u,s)),null;case 27:if(_i(a),s=he.current,c=a.type,t!==null&&a.stateNode!=null)t.memoizedProps!==u&&ii(a);else{if(!u){if(a.stateNode===null)throw Error(r(166));return Xe(a),null}t=Q.current,Tr(a)?E1(a):(t=ig(c,u,s),a.stateNode=t,ii(a))}return Xe(a),null;case 5:if(_i(a),c=a.type,t!==null&&a.stateNode!=null)t.memoizedProps!==u&&ii(a);else{if(!u){if(a.stateNode===null)throw Error(r(166));return Xe(a),null}if(d=Q.current,Tr(a))E1(a);else{var g=hl(he.current);switch(d){case 1:d=g.createElementNS("http://www.w3.org/2000/svg",c);break;case 2:d=g.createElementNS("http://www.w3.org/1998/Math/MathML",c);break;default:switch(c){case"svg":d=g.createElementNS("http://www.w3.org/2000/svg",c);break;case"math":d=g.createElementNS("http://www.w3.org/1998/Math/MathML",c);break;case"script":d=g.createElement("div"),d.innerHTML="<script><\/script>",d=d.removeChild(d.firstChild);break;case"select":d=typeof u.is=="string"?g.createElement("select",{is:u.is}):g.createElement("select"),u.multiple?d.multiple=!0:u.size&&(d.size=u.size);break;default:d=typeof u.is=="string"?g.createElement(c,{is:u.is}):g.createElement(c)}}d[wt]=a,d[Ut]=u;e:for(g=a.child;g!==null;){if(g.tag===5||g.tag===6)d.appendChild(g.stateNode);else if(g.tag!==4&&g.tag!==27&&g.child!==null){g.child.return=g,g=g.child;continue}if(g===a)break e;for(;g.sibling===null;){if(g.return===null||g.return===a)break e;g=g.return}g.sibling.return=g.return,g=g.sibling}a.stateNode=d;e:switch(Nt(d,c,u),c){case"button":case"input":case"select":case"textarea":u=!!u.autoFocus;break e;case"img":u=!0;break e;default:u=!1}u&&ii(a)}}return Xe(a),vd(a,a.type,t===null?null:t.memoizedProps,a.pendingProps,s),null;case 6:if(t&&a.stateNode!=null)t.memoizedProps!==u&&ii(a);else{if(typeof u!="string"&&a.stateNode===null)throw Error(r(166));if(t=he.current,Tr(a)){if(t=a.stateNode,s=a.memoizedProps,u=null,c=Ct,c!==null)switch(c.tag){case 27:case 5:u=c.memoizedProps}t[wt]=a,t=!!(t.nodeValue===s||u!==null&&u.suppressHydrationWarning===!0||V0(t.nodeValue,s)),t||Mi(a,!0)}else t=hl(t).createTextNode(u),t[wt]=a,a.stateNode=t}return Xe(a),null;case 31:if(s=a.memoizedState,t===null||t.memoizedState!==null){if(u=Tr(a),s!==null){if(t===null){if(!u)throw Error(r(318));if(t=a.memoizedState,t=t!==null?t.dehydrated:null,!t)throw Error(r(557));t[wt]=a}else Na(),(a.flags&128)===0&&(a.memoizedState=null),a.flags|=4;Xe(a),t=!1}else s=Ap(),t!==null&&t.memoizedState!==null&&(t.memoizedState.hydrationErrors=s),t=!0;if(!t)return a.flags&256?(Zt(a),a):(Zt(a),null);if((a.flags&128)!==0)throw Error(r(558))}return Xe(a),null;case 13:if(u=a.memoizedState,t===null||t.memoizedState!==null&&t.memoizedState.dehydrated!==null){if(c=Tr(a),u!==null&&u.dehydrated!==null){if(t===null){if(!c)throw Error(r(318));if(c=a.memoizedState,c=c!==null?c.dehydrated:null,!c)throw Error(r(317));c[wt]=a}else Na(),(a.flags&128)===0&&(a.memoizedState=null),a.flags|=4;Xe(a),c=!1}else c=Ap(),t!==null&&t.memoizedState!==null&&(t.memoizedState.hydrationErrors=c),c=!0;if(!c)return a.flags&256?(Zt(a),a):(Zt(a),null)}return Zt(a),(a.flags&128)!==0?(a.lanes=s,a):(s=u!==null,t=t!==null&&t.memoizedState!==null,s&&(u=a.child,c=null,u.alternate!==null&&u.alternate.memoizedState!==null&&u.alternate.memoizedState.cachePool!==null&&(c=u.alternate.memoizedState.cachePool.pool),d=null,u.memoizedState!==null&&u.memoizedState.cachePool!==null&&(d=u.memoizedState.cachePool.pool),d!==c&&(u.flags|=2048)),s!==t&&s&&(a.child.flags|=8192),el(a,a.updateQueue),Xe(a),null);case 4:return Ye(),t===null&&qd(a.stateNode.containerInfo),Xe(a),null;case 10:return Zn(a.type),Xe(a),null;case 19:if(P(ut),u=a.memoizedState,u===null)return Xe(a),null;if(c=(a.flags&128)!==0,d=u.rendering,d===null)if(c)Qs(u,!1);else{if(tt!==0||t!==null&&(t.flags&128)!==0)for(t=a.child;t!==null;){if(d=Fu(t),d!==null){for(a.flags|=128,Qs(u,!1),t=d.updateQueue,a.updateQueue=t,el(a,t),a.subtreeFlags=0,t=s,s=a.child;s!==null;)C1(s,t),s=s.sibling;return K(ut,ut.current&1|2),ke&&Jn(a,u.treeForkCount),a.child}t=t.sibling}u.tail!==null&&At()>rl&&(a.flags|=128,c=!0,Qs(u,!1),a.lanes=4194304)}else{if(!c)if(t=Fu(d),t!==null){if(a.flags|=128,c=!0,t=t.updateQueue,a.updateQueue=t,el(a,t),Qs(u,!0),u.tail===null&&u.tailMode==="hidden"&&!d.alternate&&!ke)return Xe(a),null}else 2*At()-u.renderingStartTime>rl&&s!==536870912&&(a.flags|=128,c=!0,Qs(u,!1),a.lanes=4194304);u.isBackwards?(d.sibling=a.child,a.child=d):(t=u.last,t!==null?t.sibling=d:a.child=d,u.last=d)}return u.tail!==null?(t=u.tail,u.rendering=t,u.tail=t.sibling,u.renderingStartTime=At(),t.sibling=null,s=ut.current,K(ut,c?s&1|2:s&1),ke&&Jn(a,u.treeForkCount),t):(Xe(a),null);case 22:case 23:return Zt(a),Hp(),u=a.memoizedState!==null,t!==null?t.memoizedState!==null!==u&&(a.flags|=8192):u&&(a.flags|=8192),u?(s&536870912)!==0&&(a.flags&128)===0&&(Xe(a),a.subtreeFlags&6&&(a.flags|=8192)):Xe(a),s=a.updateQueue,s!==null&&el(a,s.retryQueue),s=null,t!==null&&t.memoizedState!==null&&t.memoizedState.cachePool!==null&&(s=t.memoizedState.cachePool.pool),u=null,a.memoizedState!==null&&a.memoizedState.cachePool!==null&&(u=a.memoizedState.cachePool.pool),u!==s&&(a.flags|=2048),t!==null&&P(Aa),null;case 24:return s=null,t!==null&&(s=t.memoizedState.cache),a.memoizedState.cache!==s&&(a.flags|=2048),Zn(ct),Xe(a),null;case 25:return null;case 30:return null}throw Error(r(156,a.tag))}function nS(t,a){switch(kp(a),a.tag){case 1:return t=a.flags,t&65536?(a.flags=t&-65537|128,a):null;case 3:return Zn(ct),Ye(),t=a.flags,(t&65536)!==0&&(t&128)===0?(a.flags=t&-65537|128,a):null;case 26:case 27:case 5:return _i(a),null;case 31:if(a.memoizedState!==null){if(Zt(a),a.alternate===null)throw Error(r(340));Na()}return t=a.flags,t&65536?(a.flags=t&-65537|128,a):null;case 13:if(Zt(a),t=a.memoizedState,t!==null&&t.dehydrated!==null){if(a.alternate===null)throw Error(r(340));Na()}return t=a.flags,t&65536?(a.flags=t&-65537|128,a):null;case 19:return P(ut),null;case 4:return Ye(),null;case 10:return Zn(a.type),null;case 22:case 23:return Zt(a),Hp(),t!==null&&P(Aa),t=a.flags,t&65536?(a.flags=t&-65537|128,a):null;case 24:return Zn(ct),null;case 25:return null;default:return null}}function Jx(t,a){switch(kp(a),a.tag){case 3:Zn(ct),Ye();break;case 26:case 27:case 5:_i(a);break;case 4:Ye();break;case 31:a.memoizedState!==null&&Zt(a);break;case 13:Zt(a);break;case 19:P(ut);break;case 10:Zn(a.type);break;case 22:case 23:Zt(a),Hp(),t!==null&&P(Aa);break;case 24:Zn(ct)}}function Js(t,a){try{var s=a.updateQueue,u=s!==null?s.lastEffect:null;if(u!==null){var c=u.next;s=c;do{if((s.tag&t)===t){u=void 0;var d=s.create,g=s.inst;u=d(),g.destroy=u}s=s.next}while(s!==c)}}catch(b){Pe(a,a.return,b)}}function Ui(t,a,s){try{var u=a.updateQueue,c=u!==null?u.lastEffect:null;if(c!==null){var d=c.next;u=d;do{if((u.tag&t)===t){var g=u.inst,b=g.destroy;if(b!==void 0){g.destroy=void 0,c=a;var w=s,A=b;try{A()}catch(L){Pe(c,w,L)}}}u=u.next}while(u!==d)}}catch(L){Pe(a,a.return,L)}}function $x(t){var a=t.updateQueue;if(a!==null){var s=t.stateNode;try{q1(a,s)}catch(u){Pe(t,t.return,u)}}}function Zx(t,a,s){s.props=Ia(t.type,t.memoizedProps),s.state=t.memoizedState;try{s.componentWillUnmount()}catch(u){Pe(t,a,u)}}function $s(t,a){try{var s=t.ref;if(s!==null){switch(t.tag){case 26:case 27:case 5:var u=t.stateNode;break;case 30:u=t.stateNode;break;default:u=t.stateNode}typeof s=="function"?t.refCleanup=s(u):s.current=u}}catch(c){Pe(t,a,c)}}function In(t,a){var s=t.ref,u=t.refCleanup;if(s!==null)if(typeof u=="function")try{u()}catch(c){Pe(t,a,c)}finally{t.refCleanup=null,t=t.alternate,t!=null&&(t.refCleanup=null)}else if(typeof s=="function")try{s(null)}catch(c){Pe(t,a,c)}else s.current=null}function e0(t){var a=t.type,s=t.memoizedProps,u=t.stateNode;try{e:switch(a){case"button":case"input":case"select":case"textarea":s.autoFocus&&u.focus();break e;case"img":s.src?u.src=s.src:s.srcSet&&(u.srcset=s.srcSet)}}catch(c){Pe(t,t.return,c)}}function bd(t,a,s){try{var u=t.stateNode;CS(u,t.type,s,a),u[Ut]=a}catch(c){Pe(t,t.return,c)}}function t0(t){return t.tag===5||t.tag===3||t.tag===26||t.tag===27&&Vi(t.type)||t.tag===4}function Sd(t){e:for(;;){for(;t.sibling===null;){if(t.return===null||t0(t.return))return null;t=t.return}for(t.sibling.return=t.return,t=t.sibling;t.tag!==5&&t.tag!==6&&t.tag!==18;){if(t.tag===27&&Vi(t.type)||t.flags&2||t.child===null||t.tag===4)continue e;t.child.return=t,t=t.child}if(!(t.flags&2))return t.stateNode}}function wd(t,a,s){var u=t.tag;if(u===5||u===6)t=t.stateNode,a?(s.nodeType===9?s.body:s.nodeName==="HTML"?s.ownerDocument.body:s).insertBefore(t,a):(a=s.nodeType===9?s.body:s.nodeName==="HTML"?s.ownerDocument.body:s,a.appendChild(t),s=s._reactRootContainer,s!=null||a.onclick!==null||(a.onclick=Kn));else if(u!==4&&(u===27&&Vi(t.type)&&(s=t.stateNode,a=null),t=t.child,t!==null))for(wd(t,a,s),t=t.sibling;t!==null;)wd(t,a,s),t=t.sibling}function tl(t,a,s){var u=t.tag;if(u===5||u===6)t=t.stateNode,a?s.insertBefore(t,a):s.appendChild(t);else if(u!==4&&(u===27&&Vi(t.type)&&(s=t.stateNode),t=t.child,t!==null))for(tl(t,a,s),t=t.sibling;t!==null;)tl(t,a,s),t=t.sibling}function n0(t){var a=t.stateNode,s=t.memoizedProps;try{for(var u=t.type,c=a.attributes;c.length;)a.removeAttributeNode(c[0]);Nt(a,u,s),a[wt]=t,a[Ut]=s}catch(d){Pe(t,t.return,d)}}var ai=!1,mt=!1,Cd=!1,i0=typeof WeakSet=="function"?WeakSet:Set,yt=null;function iS(t,a){if(t=t.containerInfo,Gd=Sl,t=h1(t),gp(t)){if("selectionStart"in t)var s={start:t.selectionStart,end:t.selectionEnd};else e:{s=(s=t.ownerDocument)&&s.defaultView||window;var u=s.getSelection&&s.getSelection();if(u&&u.rangeCount!==0){s=u.anchorNode;var c=u.anchorOffset,d=u.focusNode;u=u.focusOffset;try{s.nodeType,d.nodeType}catch{s=null;break e}var g=0,b=-1,w=-1,A=0,L=0,F=t,j=null;t:for(;;){for(var R;F!==s||c!==0&&F.nodeType!==3||(b=g+c),F!==d||u!==0&&F.nodeType!==3||(w=g+u),F.nodeType===3&&(g+=F.nodeValue.length),(R=F.firstChild)!==null;)j=F,F=R;for(;;){if(F===t)break t;if(j===s&&++A===c&&(b=g),j===d&&++L===u&&(w=g),(R=F.nextSibling)!==null)break;F=j,j=F.parentNode}F=R}s=b===-1||w===-1?null:{start:b,end:w}}else s=null}s=s||{start:0,end:0}}else s=null;for(Vd={focusedElem:t,selectionRange:s},Sl=!1,yt=a;yt!==null;)if(a=yt,t=a.child,(a.subtreeFlags&1028)!==0&&t!==null)t.return=a,yt=t;else for(;yt!==null;){switch(a=yt,d=a.alternate,t=a.flags,a.tag){case 0:if((t&4)!==0&&(t=a.updateQueue,t=t!==null?t.events:null,t!==null))for(s=0;s<t.length;s++)c=t[s],c.ref.impl=c.nextImpl;break;case 11:case 15:break;case 1:if((t&1024)!==0&&d!==null){t=void 0,s=a,c=d.memoizedProps,d=d.memoizedState,u=s.stateNode;try{var Z=Ia(s.type,c);t=u.getSnapshotBeforeUpdate(Z,d),u.__reactInternalSnapshotBeforeUpdate=t}catch(re){Pe(s,s.return,re)}}break;case 3:if((t&1024)!==0){if(t=a.stateNode.containerInfo,s=t.nodeType,s===9)Xd(t);else if(s===1)switch(t.nodeName){case"HEAD":case"HTML":case"BODY":Xd(t);break;default:t.textContent=""}}break;case 5:case 26:case 27:case 6:case 4:case 17:break;default:if((t&1024)!==0)throw Error(r(163))}if(t=a.sibling,t!==null){t.return=a.return,yt=t;break}yt=a.return}}function a0(t,a,s){var u=s.flags;switch(s.tag){case 0:case 11:case 15:si(t,s),u&4&&Js(5,s);break;case 1:if(si(t,s),u&4)if(t=s.stateNode,a===null)try{t.componentDidMount()}catch(g){Pe(s,s.return,g)}else{var c=Ia(s.type,a.memoizedProps);a=a.memoizedState;try{t.componentDidUpdate(c,a,t.__reactInternalSnapshotBeforeUpdate)}catch(g){Pe(s,s.return,g)}}u&64&&$x(s),u&512&&$s(s,s.return);break;case 3:if(si(t,s),u&64&&(t=s.updateQueue,t!==null)){if(a=null,s.child!==null)switch(s.child.tag){case 27:case 5:a=s.child.stateNode;break;case 1:a=s.child.stateNode}try{q1(t,a)}catch(g){Pe(s,s.return,g)}}break;case 27:a===null&&u&4&&n0(s);case 26:case 5:si(t,s),a===null&&u&4&&e0(s),u&512&&$s(s,s.return);break;case 12:si(t,s);break;case 31:si(t,s),u&4&&o0(t,s);break;case 13:si(t,s),u&4&&u0(t,s),u&64&&(t=s.memoizedState,t!==null&&(t=t.dehydrated,t!==null&&(s=dS.bind(null,s),MS(t,s))));break;case 22:if(u=s.memoizedState!==null||ai,!u){a=a!==null&&a.memoizedState!==null||mt,c=ai;var d=mt;ai=u,(mt=a)&&!d?oi(t,s,(s.subtreeFlags&8772)!==0):si(t,s),ai=c,mt=d}break;case 30:break;default:si(t,s)}}function r0(t){var a=t.alternate;a!==null&&(t.alternate=null,r0(a)),t.child=null,t.deletions=null,t.sibling=null,t.tag===5&&(a=t.stateNode,a!==null&&ep(a)),t.stateNode=null,t.return=null,t.dependencies=null,t.memoizedProps=null,t.memoizedState=null,t.pendingProps=null,t.stateNode=null,t.updateQueue=null}var Qe=null,Ft=!1;function ri(t,a,s){for(s=s.child;s!==null;)s0(t,a,s),s=s.sibling}function s0(t,a,s){if(De&&typeof De.onCommitFiberUnmount=="function")try{De.onCommitFiberUnmount(_e,s)}catch{}switch(s.tag){case 26:mt||In(s,a),ri(t,a,s),s.memoizedState?s.memoizedState.count--:s.stateNode&&(s=s.stateNode,s.parentNode.removeChild(s));break;case 27:mt||In(s,a);var u=Qe,c=Ft;Vi(s.type)&&(Qe=s.stateNode,Ft=!1),ri(t,a,s),oo(s.stateNode),Qe=u,Ft=c;break;case 5:mt||In(s,a);case 6:if(u=Qe,c=Ft,Qe=null,ri(t,a,s),Qe=u,Ft=c,Qe!==null)if(Ft)try{(Qe.nodeType===9?Qe.body:Qe.nodeName==="HTML"?Qe.ownerDocument.body:Qe).removeChild(s.stateNode)}catch(d){Pe(s,a,d)}else try{Qe.removeChild(s.stateNode)}catch(d){Pe(s,a,d)}break;case 18:Qe!==null&&(Ft?(t=Qe,$0(t.nodeType===9?t.body:t.nodeName==="HTML"?t.ownerDocument.body:t,s.stateNode),Wr(t)):$0(Qe,s.stateNode));break;case 4:u=Qe,c=Ft,Qe=s.stateNode.containerInfo,Ft=!0,ri(t,a,s),Qe=u,Ft=c;break;case 0:case 11:case 14:case 15:Ui(2,s,a),mt||Ui(4,s,a),ri(t,a,s);break;case 1:mt||(In(s,a),u=s.stateNode,typeof u.componentWillUnmount=="function"&&Zx(s,a,u)),ri(t,a,s);break;case 21:ri(t,a,s);break;case 22:mt=(u=mt)||s.memoizedState!==null,ri(t,a,s),mt=u;break;default:ri(t,a,s)}}function o0(t,a){if(a.memoizedState===null&&(t=a.alternate,t!==null&&(t=t.memoizedState,t!==null))){t=t.dehydrated;try{Wr(t)}catch(s){Pe(a,a.return,s)}}}function u0(t,a){if(a.memoizedState===null&&(t=a.alternate,t!==null&&(t=t.memoizedState,t!==null&&(t=t.dehydrated,t!==null))))try{Wr(t)}catch(s){Pe(a,a.return,s)}}function aS(t){switch(t.tag){case 31:case 13:case 19:var a=t.stateNode;return a===null&&(a=t.stateNode=new i0),a;case 22:return t=t.stateNode,a=t._retryCache,a===null&&(a=t._retryCache=new i0),a;default:throw Error(r(435,t.tag))}}function nl(t,a){var s=aS(t);a.forEach(function(u){if(!s.has(u)){s.add(u);var c=mS.bind(null,t,u);u.then(c,c)}})}function qt(t,a){var s=a.deletions;if(s!==null)for(var u=0;u<s.length;u++){var c=s[u],d=t,g=a,b=g;e:for(;b!==null;){switch(b.tag){case 27:if(Vi(b.type)){Qe=b.stateNode,Ft=!1;break e}break;case 5:Qe=b.stateNode,Ft=!1;break e;case 3:case 4:Qe=b.stateNode.containerInfo,Ft=!0;break e}b=b.return}if(Qe===null)throw Error(r(160));s0(d,g,c),Qe=null,Ft=!1,d=c.alternate,d!==null&&(d.return=null),c.return=null}if(a.subtreeFlags&13886)for(a=a.child;a!==null;)l0(a,t),a=a.sibling}var Cn=null;function l0(t,a){var s=t.alternate,u=t.flags;switch(t.tag){case 0:case 11:case 14:case 15:qt(a,t),Ht(t),u&4&&(Ui(3,t,t.return),Js(3,t),Ui(5,t,t.return));break;case 1:qt(a,t),Ht(t),u&512&&(mt||s===null||In(s,s.return)),u&64&&ai&&(t=t.updateQueue,t!==null&&(u=t.callbacks,u!==null&&(s=t.shared.hiddenCallbacks,t.shared.hiddenCallbacks=s===null?u:s.concat(u))));break;case 26:var c=Cn;if(qt(a,t),Ht(t),u&512&&(mt||s===null||In(s,s.return)),u&4){var d=s!==null?s.memoizedState:null;if(u=t.memoizedState,s===null)if(u===null)if(t.stateNode===null){e:{u=t.type,s=t.memoizedProps,c=c.ownerDocument||c;t:switch(u){case"title":d=c.getElementsByTagName("title")[0],(!d||d[_s]||d[wt]||d.namespaceURI==="http://www.w3.org/2000/svg"||d.hasAttribute("itemprop"))&&(d=c.createElement(u),c.head.insertBefore(d,c.querySelector("head > title"))),Nt(d,u,s),d[wt]=t,gt(d),u=d;break e;case"link":var g=lg("link","href",c).get(u+(s.href||""));if(g){for(var b=0;b<g.length;b++)if(d=g[b],d.getAttribute("href")===(s.href==null||s.href===""?null:s.href)&&d.getAttribute("rel")===(s.rel==null?null:s.rel)&&d.getAttribute("title")===(s.title==null?null:s.title)&&d.getAttribute("crossorigin")===(s.crossOrigin==null?null:s.crossOrigin)){g.splice(b,1);break t}}d=c.createElement(u),Nt(d,u,s),c.head.appendChild(d);break;case"meta":if(g=lg("meta","content",c).get(u+(s.content||""))){for(b=0;b<g.length;b++)if(d=g[b],d.getAttribute("content")===(s.content==null?null:""+s.content)&&d.getAttribute("name")===(s.name==null?null:s.name)&&d.getAttribute("property")===(s.property==null?null:s.property)&&d.getAttribute("http-equiv")===(s.httpEquiv==null?null:s.httpEquiv)&&d.getAttribute("charset")===(s.charSet==null?null:s.charSet)){g.splice(b,1);break t}}d=c.createElement(u),Nt(d,u,s),c.head.appendChild(d);break;default:throw Error(r(468,u))}d[wt]=t,gt(d),u=d}t.stateNode=u}else cg(c,t.type,t.stateNode);else t.stateNode=ug(c,u,t.memoizedProps);else d!==u?(d===null?s.stateNode!==null&&(s=s.stateNode,s.parentNode.removeChild(s)):d.count--,u===null?cg(c,t.type,t.stateNode):ug(c,u,t.memoizedProps)):u===null&&t.stateNode!==null&&bd(t,t.memoizedProps,s.memoizedProps)}break;case 27:qt(a,t),Ht(t),u&512&&(mt||s===null||In(s,s.return)),s!==null&&u&4&&bd(t,t.memoizedProps,s.memoizedProps);break;case 5:if(qt(a,t),Ht(t),u&512&&(mt||s===null||In(s,s.return)),t.flags&32){c=t.stateNode;try{xr(c,"")}catch(Z){Pe(t,t.return,Z)}}u&4&&t.stateNode!=null&&(c=t.memoizedProps,bd(t,c,s!==null?s.memoizedProps:c)),u&1024&&(Cd=!0);break;case 6:if(qt(a,t),Ht(t),u&4){if(t.stateNode===null)throw Error(r(162));u=t.memoizedProps,s=t.stateNode;try{s.nodeValue=u}catch(Z){Pe(t,t.return,Z)}}break;case 3:if(yl=null,c=Cn,Cn=xl(a.containerInfo),qt(a,t),Cn=c,Ht(t),u&4&&s!==null&&s.memoizedState.isDehydrated)try{Wr(a.containerInfo)}catch(Z){Pe(t,t.return,Z)}Cd&&(Cd=!1,c0(t));break;case 4:u=Cn,Cn=xl(t.stateNode.containerInfo),qt(a,t),Ht(t),Cn=u;break;case 12:qt(a,t),Ht(t);break;case 31:qt(a,t),Ht(t),u&4&&(u=t.updateQueue,u!==null&&(t.updateQueue=null,nl(t,u)));break;case 13:qt(a,t),Ht(t),t.child.flags&8192&&t.memoizedState!==null!=(s!==null&&s.memoizedState!==null)&&(al=At()),u&4&&(u=t.updateQueue,u!==null&&(t.updateQueue=null,nl(t,u)));break;case 22:c=t.memoizedState!==null;var w=s!==null&&s.memoizedState!==null,A=ai,L=mt;if(ai=A||c,mt=L||w,qt(a,t),mt=L,ai=A,Ht(t),u&8192)e:for(a=t.stateNode,a._visibility=c?a._visibility&-2:a._visibility|1,c&&(s===null||w||ai||mt||La(t)),s=null,a=t;;){if(a.tag===5||a.tag===26){if(s===null){w=s=a;try{if(d=w.stateNode,c)g=d.style,typeof g.setProperty=="function"?g.setProperty("display","none","important"):g.display="none";else{b=w.stateNode;var F=w.memoizedProps.style,j=F!=null&&F.hasOwnProperty("display")?F.display:null;b.style.display=j==null||typeof j=="boolean"?"":(""+j).trim()}}catch(Z){Pe(w,w.return,Z)}}}else if(a.tag===6){if(s===null){w=a;try{w.stateNode.nodeValue=c?"":w.memoizedProps}catch(Z){Pe(w,w.return,Z)}}}else if(a.tag===18){if(s===null){w=a;try{var R=w.stateNode;c?Z0(R,!0):Z0(w.stateNode,!1)}catch(Z){Pe(w,w.return,Z)}}}else if((a.tag!==22&&a.tag!==23||a.memoizedState===null||a===t)&&a.child!==null){a.child.return=a,a=a.child;continue}if(a===t)break e;for(;a.sibling===null;){if(a.return===null||a.return===t)break e;s===a&&(s=null),a=a.return}s===a&&(s=null),a.sibling.return=a.return,a=a.sibling}u&4&&(u=t.updateQueue,u!==null&&(s=u.retryQueue,s!==null&&(u.retryQueue=null,nl(t,s))));break;case 19:qt(a,t),Ht(t),u&4&&(u=t.updateQueue,u!==null&&(t.updateQueue=null,nl(t,u)));break;case 30:break;case 21:break;default:qt(a,t),Ht(t)}}function Ht(t){var a=t.flags;if(a&2){try{for(var s,u=t.return;u!==null;){if(t0(u)){s=u;break}u=u.return}if(s==null)throw Error(r(160));switch(s.tag){case 27:var c=s.stateNode,d=Sd(t);tl(t,d,c);break;case 5:var g=s.stateNode;s.flags&32&&(xr(g,""),s.flags&=-33);var b=Sd(t);tl(t,b,g);break;case 3:case 4:var w=s.stateNode.containerInfo,A=Sd(t);wd(t,A,w);break;default:throw Error(r(161))}}catch(L){Pe(t,t.return,L)}t.flags&=-3}a&4096&&(t.flags&=-4097)}function c0(t){if(t.subtreeFlags&1024)for(t=t.child;t!==null;){var a=t;c0(a),a.tag===5&&a.flags&1024&&a.stateNode.reset(),t=t.sibling}}function si(t,a){if(a.subtreeFlags&8772)for(a=a.child;a!==null;)a0(t,a.alternate,a),a=a.sibling}function La(t){for(t=t.child;t!==null;){var a=t;switch(a.tag){case 0:case 11:case 14:case 15:Ui(4,a,a.return),La(a);break;case 1:In(a,a.return);var s=a.stateNode;typeof s.componentWillUnmount=="function"&&Zx(a,a.return,s),La(a);break;case 27:oo(a.stateNode);case 26:case 5:In(a,a.return),La(a);break;case 22:a.memoizedState===null&&La(a);break;case 30:La(a);break;default:La(a)}t=t.sibling}}function oi(t,a,s){for(s=s&&(a.subtreeFlags&8772)!==0,a=a.child;a!==null;){var u=a.alternate,c=t,d=a,g=d.flags;switch(d.tag){case 0:case 11:case 15:oi(c,d,s),Js(4,d);break;case 1:if(oi(c,d,s),u=d,c=u.stateNode,typeof c.componentDidMount=="function")try{c.componentDidMount()}catch(A){Pe(u,u.return,A)}if(u=d,c=u.updateQueue,c!==null){var b=u.stateNode;try{var w=c.shared.hiddenCallbacks;if(w!==null)for(c.shared.hiddenCallbacks=null,c=0;c<w.length;c++)F1(w[c],b)}catch(A){Pe(u,u.return,A)}}s&&g&64&&$x(d),$s(d,d.return);break;case 27:n0(d);case 26:case 5:oi(c,d,s),s&&u===null&&g&4&&e0(d),$s(d,d.return);break;case 12:oi(c,d,s);break;case 31:oi(c,d,s),s&&g&4&&o0(c,d);break;case 13:oi(c,d,s),s&&g&4&&u0(c,d);break;case 22:d.memoizedState===null&&oi(c,d,s),$s(d,d.return);break;case 30:break;default:oi(c,d,s)}a=a.sibling}}function _d(t,a){var s=null;t!==null&&t.memoizedState!==null&&t.memoizedState.cachePool!==null&&(s=t.memoizedState.cachePool.pool),t=null,a.memoizedState!==null&&a.memoizedState.cachePool!==null&&(t=a.memoizedState.cachePool.pool),t!==s&&(t!=null&&t.refCount++,s!=null&&Bs(s))}function Td(t,a){t=null,a.alternate!==null&&(t=a.alternate.memoizedState.cache),a=a.memoizedState.cache,a!==t&&(a.refCount++,t!=null&&Bs(t))}function _n(t,a,s,u){if(a.subtreeFlags&10256)for(a=a.child;a!==null;)p0(t,a,s,u),a=a.sibling}function p0(t,a,s,u){var c=a.flags;switch(a.tag){case 0:case 11:case 15:_n(t,a,s,u),c&2048&&Js(9,a);break;case 1:_n(t,a,s,u);break;case 3:_n(t,a,s,u),c&2048&&(t=null,a.alternate!==null&&(t=a.alternate.memoizedState.cache),a=a.memoizedState.cache,a!==t&&(a.refCount++,t!=null&&Bs(t)));break;case 12:if(c&2048){_n(t,a,s,u),t=a.stateNode;try{var d=a.memoizedProps,g=d.id,b=d.onPostCommit;typeof b=="function"&&b(g,a.alternate===null?"mount":"update",t.passiveEffectDuration,-0)}catch(w){Pe(a,a.return,w)}}else _n(t,a,s,u);break;case 31:_n(t,a,s,u);break;case 13:_n(t,a,s,u);break;case 23:break;case 22:d=a.stateNode,g=a.alternate,a.memoizedState!==null?d._visibility&2?_n(t,a,s,u):Zs(t,a):d._visibility&2?_n(t,a,s,u):(d._visibility|=2,Lr(t,a,s,u,(a.subtreeFlags&10256)!==0||!1)),c&2048&&_d(g,a);break;case 24:_n(t,a,s,u),c&2048&&Td(a.alternate,a);break;default:_n(t,a,s,u)}}function Lr(t,a,s,u,c){for(c=c&&((a.subtreeFlags&10256)!==0||!1),a=a.child;a!==null;){var d=t,g=a,b=s,w=u,A=g.flags;switch(g.tag){case 0:case 11:case 15:Lr(d,g,b,w,c),Js(8,g);break;case 23:break;case 22:var L=g.stateNode;g.memoizedState!==null?L._visibility&2?Lr(d,g,b,w,c):Zs(d,g):(L._visibility|=2,Lr(d,g,b,w,c)),c&&A&2048&&_d(g.alternate,g);break;case 24:Lr(d,g,b,w,c),c&&A&2048&&Td(g.alternate,g);break;default:Lr(d,g,b,w,c)}a=a.sibling}}function Zs(t,a){if(a.subtreeFlags&10256)for(a=a.child;a!==null;){var s=t,u=a,c=u.flags;switch(u.tag){case 22:Zs(s,u),c&2048&&_d(u.alternate,u);break;case 24:Zs(s,u),c&2048&&Td(u.alternate,u);break;default:Zs(s,u)}a=a.sibling}}var eo=8192;function Pr(t,a,s){if(t.subtreeFlags&eo)for(t=t.child;t!==null;)d0(t,a,s),t=t.sibling}function d0(t,a,s){switch(t.tag){case 26:Pr(t,a,s),t.flags&eo&&t.memoizedState!==null&&YS(s,Cn,t.memoizedState,t.memoizedProps);break;case 5:Pr(t,a,s);break;case 3:case 4:var u=Cn;Cn=xl(t.stateNode.containerInfo),Pr(t,a,s),Cn=u;break;case 22:t.memoizedState===null&&(u=t.alternate,u!==null&&u.memoizedState!==null?(u=eo,eo=16777216,Pr(t,a,s),eo=u):Pr(t,a,s));break;default:Pr(t,a,s)}}function m0(t){var a=t.alternate;if(a!==null&&(t=a.child,t!==null)){a.child=null;do a=t.sibling,t.sibling=null,t=a;while(t!==null)}}function to(t){var a=t.deletions;if((t.flags&16)!==0){if(a!==null)for(var s=0;s<a.length;s++){var u=a[s];yt=u,h0(u,t)}m0(t)}if(t.subtreeFlags&10256)for(t=t.child;t!==null;)f0(t),t=t.sibling}function f0(t){switch(t.tag){case 0:case 11:case 15:to(t),t.flags&2048&&Ui(9,t,t.return);break;case 3:to(t);break;case 12:to(t);break;case 22:var a=t.stateNode;t.memoizedState!==null&&a._visibility&2&&(t.return===null||t.return.tag!==13)?(a._visibility&=-3,il(t)):to(t);break;default:to(t)}}function il(t){var a=t.deletions;if((t.flags&16)!==0){if(a!==null)for(var s=0;s<a.length;s++){var u=a[s];yt=u,h0(u,t)}m0(t)}for(t=t.child;t!==null;){switch(a=t,a.tag){case 0:case 11:case 15:Ui(8,a,a.return),il(a);break;case 22:s=a.stateNode,s._visibility&2&&(s._visibility&=-3,il(a));break;default:il(a)}t=t.sibling}}function h0(t,a){for(;yt!==null;){var s=yt;switch(s.tag){case 0:case 11:case 15:Ui(8,s,a);break;case 23:case 22:if(s.memoizedState!==null&&s.memoizedState.cachePool!==null){var u=s.memoizedState.cachePool.pool;u!=null&&u.refCount++}break;case 24:Bs(s.memoizedState.cache)}if(u=s.child,u!==null)u.return=s,yt=u;else e:for(s=t;yt!==null;){u=yt;var c=u.sibling,d=u.return;if(r0(u),u===s){yt=null;break e}if(c!==null){c.return=d,yt=c;break e}yt=d}}}var rS={getCacheForType:function(t){var a=_t(ct),s=a.data.get(t);return s===void 0&&(s=t(),a.data.set(t,s)),s},cacheSignal:function(){return _t(ct).controller.signal}},sS=typeof WeakMap=="function"?WeakMap:Map,Ie=0,Ge=null,Se=null,Te=0,Le=0,en=null,zi=!1,Br=!1,Nd=!1,ui=0,tt=0,Fi=0,Pa=0,kd=0,tn=0,Ur=0,no=null,Yt=null,Ed=!1,al=0,x0=0,rl=1/0,sl=null,qi=null,ft=0,Hi=null,zr=null,li=0,Ad=0,jd=null,g0=null,io=0,Md=null;function nn(){return(Ie&2)!==0&&Te!==0?Te&-Te:M.T!==null?Bd():Rh()}function y0(){if(tn===0)if((Te&536870912)===0||ke){var t=lr;lr<<=1,(lr&3932160)===0&&(lr=262144),tn=t}else tn=536870912;return t=$t.current,t!==null&&(t.flags|=32),tn}function Gt(t,a,s){(t===Ge&&(Le===2||Le===9)||t.cancelPendingCommit!==null)&&(Fr(t,0),Yi(t,Te,tn,!1)),Cs(t,s),((Ie&2)===0||t!==Ge)&&(t===Ge&&((Ie&2)===0&&(Pa|=s),tt===4&&Yi(t,Te,tn,!1)),Ln(t))}function O0(t,a,s){if((Ie&6)!==0)throw Error(r(327));var u=!s&&(a&127)===0&&(a&t.expiredLanes)===0||ws(t,a),c=u?lS(t,a):Dd(t,a,!0),d=u;do{if(c===0){Br&&!u&&Yi(t,a,0,!1);break}else{if(s=t.current.alternate,d&&!oS(s)){c=Dd(t,a,!1),d=!1;continue}if(c===2){if(d=a,t.errorRecoveryDisabledLanes&d)var g=0;else g=t.pendingLanes&-536870913,g=g!==0?g:g&536870912?536870912:0;if(g!==0){a=g;e:{var b=t;c=no;var w=b.current.memoizedState.isDehydrated;if(w&&(Fr(b,g).flags|=256),g=Dd(b,g,!1),g!==2){if(Nd&&!w){b.errorRecoveryDisabledLanes|=d,Pa|=d,c=4;break e}d=Yt,Yt=c,d!==null&&(Yt===null?Yt=d:Yt.push.apply(Yt,d))}c=g}if(d=!1,c!==2)continue}}if(c===1){Fr(t,0),Yi(t,a,0,!0);break}e:{switch(u=t,d=c,d){case 0:case 1:throw Error(r(345));case 4:if((a&4194048)!==a)break;case 6:Yi(u,a,tn,!zi);break e;case 2:Yt=null;break;case 3:case 5:break;default:throw Error(r(329))}if((a&62914560)===a&&(c=al+300-At(),10<c)){if(Yi(u,a,tn,!zi),xu(u,0,!0)!==0)break e;li=a,u.timeoutHandle=Q0(v0.bind(null,u,s,Yt,sl,Ed,a,tn,Pa,Ur,zi,d,"Throttled",-0,0),c);break e}v0(u,s,Yt,sl,Ed,a,tn,Pa,Ur,zi,d,null,-0,0)}}break}while(!0);Ln(t)}function v0(t,a,s,u,c,d,g,b,w,A,L,F,j,R){if(t.timeoutHandle=-1,F=a.subtreeFlags,F&8192||(F&16785408)===16785408){F={stylesheets:null,count:0,imgCount:0,imgBytes:0,suspenseyImages:[],waitingForImages:!0,waitingForViewTransition:!1,unsuspend:Kn},d0(a,d,F);var Z=(d&62914560)===d?al-At():(d&4194048)===d?x0-At():0;if(Z=GS(F,Z),Z!==null){li=d,t.cancelPendingCommit=Z(k0.bind(null,t,a,d,s,u,c,g,b,w,L,F,null,j,R)),Yi(t,d,g,!A);return}}k0(t,a,d,s,u,c,g,b,w)}function oS(t){for(var a=t;;){var s=a.tag;if((s===0||s===11||s===15)&&a.flags&16384&&(s=a.updateQueue,s!==null&&(s=s.stores,s!==null)))for(var u=0;u<s.length;u++){var c=s[u],d=c.getSnapshot;c=c.value;try{if(!Qt(d(),c))return!1}catch{return!1}}if(s=a.child,a.subtreeFlags&16384&&s!==null)s.return=a,a=s;else{if(a===t)break;for(;a.sibling===null;){if(a.return===null||a.return===t)return!0;a=a.return}a.sibling.return=a.return,a=a.sibling}}return!0}function Yi(t,a,s,u){a&=~kd,a&=~Pa,t.suspendedLanes|=a,t.pingedLanes&=~a,u&&(t.warmLanes|=a),u=t.expirationTimes;for(var c=a;0<c;){var d=31-jt(c),g=1<<d;u[d]=-1,c&=~g}s!==0&&Ah(t,s,a)}function ol(){return(Ie&6)===0?(ao(0),!1):!0}function Rd(){if(Se!==null){if(Le===0)var t=Se.return;else t=Se,$n=ka=null,Xp(t),jr=null,zs=0,t=Se;for(;t!==null;)Jx(t.alternate,t),t=t.return;Se=null}}function Fr(t,a){var s=t.timeoutHandle;s!==-1&&(t.timeoutHandle=-1,NS(s)),s=t.cancelPendingCommit,s!==null&&(t.cancelPendingCommit=null,s()),li=0,Rd(),Ge=t,Se=s=Qn(t.current,null),Te=a,Le=0,en=null,zi=!1,Br=ws(t,a),Nd=!1,Ur=tn=kd=Pa=Fi=tt=0,Yt=no=null,Ed=!1,(a&8)!==0&&(a|=a&32);var u=t.entangledLanes;if(u!==0)for(t=t.entanglements,u&=a;0<u;){var c=31-jt(u),d=1<<c;a|=t[c],u&=~d}return ui=a,ku(),s}function b0(t,a){xe=null,M.H=Ks,a===Ar||a===Lu?(a=P1(),Le=3):a===Pp?(a=P1(),Le=4):Le=a===pd?8:a!==null&&typeof a=="object"&&typeof a.then=="function"?6:1,en=a,Se===null&&(tt=1,Qu(t,pn(a,t.current)))}function S0(){var t=$t.current;return t===null?!0:(Te&4194048)===Te?hn===null:(Te&62914560)===Te||(Te&536870912)!==0?t===hn:!1}function w0(){var t=M.H;return M.H=Ks,t===null?Ks:t}function C0(){var t=M.A;return M.A=rS,t}function ul(){tt=4,zi||(Te&4194048)!==Te&&$t.current!==null||(Br=!0),(Fi&134217727)===0&&(Pa&134217727)===0||Ge===null||Yi(Ge,Te,tn,!1)}function Dd(t,a,s){var u=Ie;Ie|=2;var c=w0(),d=C0();(Ge!==t||Te!==a)&&(sl=null,Fr(t,a)),a=!1;var g=tt;e:do try{if(Le!==0&&Se!==null){var b=Se,w=en;switch(Le){case 8:Rd(),g=6;break e;case 3:case 2:case 9:case 6:$t.current===null&&(a=!0);var A=Le;if(Le=0,en=null,qr(t,b,w,A),s&&Br){g=0;break e}break;default:A=Le,Le=0,en=null,qr(t,b,w,A)}}uS(),g=tt;break}catch(L){b0(t,L)}while(!0);return a&&t.shellSuspendCounter++,$n=ka=null,Ie=u,M.H=c,M.A=d,Se===null&&(Ge=null,Te=0,ku()),g}function uS(){for(;Se!==null;)_0(Se)}function lS(t,a){var s=Ie;Ie|=2;var u=w0(),c=C0();Ge!==t||Te!==a?(sl=null,rl=At()+500,Fr(t,a)):Br=ws(t,a);e:do try{if(Le!==0&&Se!==null){a=Se;var d=en;t:switch(Le){case 1:Le=0,en=null,qr(t,a,d,1);break;case 2:case 9:if(I1(d)){Le=0,en=null,T0(a);break}a=function(){Le!==2&&Le!==9||Ge!==t||(Le=7),Ln(t)},d.then(a,a);break e;case 3:Le=7;break e;case 4:Le=5;break e;case 7:I1(d)?(Le=0,en=null,T0(a)):(Le=0,en=null,qr(t,a,d,7));break;case 5:var g=null;switch(Se.tag){case 26:g=Se.memoizedState;case 5:case 27:var b=Se;if(g?pg(g):b.stateNode.complete){Le=0,en=null;var w=b.sibling;if(w!==null)Se=w;else{var A=b.return;A!==null?(Se=A,ll(A)):Se=null}break t}}Le=0,en=null,qr(t,a,d,5);break;case 6:Le=0,en=null,qr(t,a,d,6);break;case 8:Rd(),tt=6;break e;default:throw Error(r(462))}}cS();break}catch(L){b0(t,L)}while(!0);return $n=ka=null,M.H=u,M.A=c,Ie=s,Se!==null?0:(Ge=null,Te=0,ku(),tt)}function cS(){for(;Se!==null&&!Gc();)_0(Se)}function _0(t){var a=Xx(t.alternate,t,ui);t.memoizedProps=t.pendingProps,a===null?ll(t):Se=a}function T0(t){var a=t,s=a.alternate;switch(a.tag){case 15:case 0:a=Hx(s,a,a.pendingProps,a.type,void 0,Te);break;case 11:a=Hx(s,a,a.pendingProps,a.type.render,a.ref,Te);break;case 5:Xp(a);default:Jx(s,a),a=Se=C1(a,ui),a=Xx(s,a,ui)}t.memoizedProps=t.pendingProps,a===null?ll(t):Se=a}function qr(t,a,s,u){$n=ka=null,Xp(a),jr=null,zs=0;var c=a.return;try{if($3(t,c,a,s,Te)){tt=1,Qu(t,pn(s,t.current)),Se=null;return}}catch(d){if(c!==null)throw Se=c,d;tt=1,Qu(t,pn(s,t.current)),Se=null;return}a.flags&32768?(ke||u===1?t=!0:Br||(Te&536870912)!==0?t=!1:(zi=t=!0,(u===2||u===9||u===3||u===6)&&(u=$t.current,u!==null&&u.tag===13&&(u.flags|=16384))),N0(a,t)):ll(a)}function ll(t){var a=t;do{if((a.flags&32768)!==0){N0(a,zi);return}t=a.return;var s=tS(a.alternate,a,ui);if(s!==null){Se=s;return}if(a=a.sibling,a!==null){Se=a;return}Se=a=t}while(a!==null);tt===0&&(tt=5)}function N0(t,a){do{var s=nS(t.alternate,t);if(s!==null){s.flags&=32767,Se=s;return}if(s=t.return,s!==null&&(s.flags|=32768,s.subtreeFlags=0,s.deletions=null),!a&&(t=t.sibling,t!==null)){Se=t;return}Se=t=s}while(t!==null);tt=6,Se=null}function k0(t,a,s,u,c,d,g,b,w){t.cancelPendingCommit=null;do cl();while(ft!==0);if((Ie&6)!==0)throw Error(r(327));if(a!==null){if(a===t.current)throw Error(r(177));if(d=a.lanes|a.childLanes,d|=Sp,Hb(t,s,d,g,b,w),t===Ge&&(Se=Ge=null,Te=0),zr=a,Hi=t,li=s,Ad=d,jd=c,g0=u,(a.subtreeFlags&10256)!==0||(a.flags&10256)!==0?(t.callbackNode=null,t.callbackPriority=0,fS(or,function(){return R0(),null})):(t.callbackNode=null,t.callbackPriority=0),u=(a.flags&13878)!==0,(a.subtreeFlags&13878)!==0||u){u=M.T,M.T=null,c=V.p,V.p=2,g=Ie,Ie|=4;try{iS(t,a,s)}finally{Ie=g,V.p=c,M.T=u}}ft=1,E0(),A0(),j0()}}function E0(){if(ft===1){ft=0;var t=Hi,a=zr,s=(a.flags&13878)!==0;if((a.subtreeFlags&13878)!==0||s){s=M.T,M.T=null;var u=V.p;V.p=2;var c=Ie;Ie|=4;try{l0(a,t);var d=Vd,g=h1(t.containerInfo),b=d.focusedElem,w=d.selectionRange;if(g!==b&&b&&b.ownerDocument&&f1(b.ownerDocument.documentElement,b)){if(w!==null&&gp(b)){var A=w.start,L=w.end;if(L===void 0&&(L=A),"selectionStart"in b)b.selectionStart=A,b.selectionEnd=Math.min(L,b.value.length);else{var F=b.ownerDocument||document,j=F&&F.defaultView||window;if(j.getSelection){var R=j.getSelection(),Z=b.textContent.length,re=Math.min(w.start,Z),qe=w.end===void 0?re:Math.min(w.end,Z);!R.extend&&re>qe&&(g=qe,qe=re,re=g);var N=m1(b,re),T=m1(b,qe);if(N&&T&&(R.rangeCount!==1||R.anchorNode!==N.node||R.anchorOffset!==N.offset||R.focusNode!==T.node||R.focusOffset!==T.offset)){var E=F.createRange();E.setStart(N.node,N.offset),R.removeAllRanges(),re>qe?(R.addRange(E),R.extend(T.node,T.offset)):(E.setEnd(T.node,T.offset),R.addRange(E))}}}}for(F=[],R=b;R=R.parentNode;)R.nodeType===1&&F.push({element:R,left:R.scrollLeft,top:R.scrollTop});for(typeof b.focus=="function"&&b.focus(),b=0;b<F.length;b++){var U=F[b];U.element.scrollLeft=U.left,U.element.scrollTop=U.top}}Sl=!!Gd,Vd=Gd=null}finally{Ie=c,V.p=u,M.T=s}}t.current=a,ft=2}}function A0(){if(ft===2){ft=0;var t=Hi,a=zr,s=(a.flags&8772)!==0;if((a.subtreeFlags&8772)!==0||s){s=M.T,M.T=null;var u=V.p;V.p=2;var c=Ie;Ie|=4;try{a0(t,a.alternate,a)}finally{Ie=c,V.p=u,M.T=s}}ft=3}}function j0(){if(ft===4||ft===3){ft=0,Vc();var t=Hi,a=zr,s=li,u=g0;(a.subtreeFlags&10256)!==0||(a.flags&10256)!==0?ft=5:(ft=0,zr=Hi=null,M0(t,t.pendingLanes));var c=t.pendingLanes;if(c===0&&(qi=null),$c(s),a=a.stateNode,De&&typeof De.onCommitFiberRoot=="function")try{De.onCommitFiberRoot(_e,a,void 0,(a.current.flags&128)===128)}catch{}if(u!==null){a=M.T,c=V.p,V.p=2,M.T=null;try{for(var d=t.onRecoverableError,g=0;g<u.length;g++){var b=u[g];d(b.value,{componentStack:b.stack})}}finally{M.T=a,V.p=c}}(li&3)!==0&&cl(),Ln(t),c=t.pendingLanes,(s&261930)!==0&&(c&42)!==0?t===Md?io++:(io=0,Md=t):io=0,ao(0)}}function M0(t,a){(t.pooledCacheLanes&=a)===0&&(a=t.pooledCache,a!=null&&(t.pooledCache=null,Bs(a)))}function cl(){return E0(),A0(),j0(),R0()}function R0(){if(ft!==5)return!1;var t=Hi,a=Ad;Ad=0;var s=$c(li),u=M.T,c=V.p;try{V.p=32>s?32:s,M.T=null,s=jd,jd=null;var d=Hi,g=li;if(ft=0,zr=Hi=null,li=0,(Ie&6)!==0)throw Error(r(331));var b=Ie;if(Ie|=4,f0(d.current),p0(d,d.current,g,s),Ie=b,ao(0,!1),De&&typeof De.onPostCommitFiberRoot=="function")try{De.onPostCommitFiberRoot(_e,d)}catch{}return!0}finally{V.p=c,M.T=u,M0(t,a)}}function D0(t,a,s){a=pn(s,a),a=cd(t.stateNode,a,2),t=Li(t,a,2),t!==null&&(Cs(t,2),Ln(t))}function Pe(t,a,s){if(t.tag===3)D0(t,t,s);else for(;a!==null;){if(a.tag===3){D0(a,t,s);break}else if(a.tag===1){var u=a.stateNode;if(typeof a.type.getDerivedStateFromError=="function"||typeof u.componentDidCatch=="function"&&(qi===null||!qi.has(u))){t=pn(s,t),s=Ix(2),u=Li(a,s,2),u!==null&&(Lx(s,u,a,t),Cs(u,2),Ln(u));break}}a=a.return}}function Id(t,a,s){var u=t.pingCache;if(u===null){u=t.pingCache=new sS;var c=new Set;u.set(a,c)}else c=u.get(a),c===void 0&&(c=new Set,u.set(a,c));c.has(s)||(Nd=!0,c.add(s),t=pS.bind(null,t,a,s),a.then(t,t))}function pS(t,a,s){var u=t.pingCache;u!==null&&u.delete(a),t.pingedLanes|=t.suspendedLanes&s,t.warmLanes&=~s,Ge===t&&(Te&s)===s&&(tt===4||tt===3&&(Te&62914560)===Te&&300>At()-al?(Ie&2)===0&&Fr(t,0):kd|=s,Ur===Te&&(Ur=0)),Ln(t)}function I0(t,a){a===0&&(a=Eh()),t=_a(t,a),t!==null&&(Cs(t,a),Ln(t))}function dS(t){var a=t.memoizedState,s=0;a!==null&&(s=a.retryLane),I0(t,s)}function mS(t,a){var s=0;switch(t.tag){case 31:case 13:var u=t.stateNode,c=t.memoizedState;c!==null&&(s=c.retryLane);break;case 19:u=t.stateNode;break;case 22:u=t.stateNode._retryCache;break;default:throw Error(r(314))}u!==null&&u.delete(a),I0(t,s)}function fS(t,a){return sr(t,a)}var pl=null,Hr=null,Ld=!1,dl=!1,Pd=!1,Gi=0;function Ln(t){t!==Hr&&t.next===null&&(Hr===null?pl=Hr=t:Hr=Hr.next=t),dl=!0,Ld||(Ld=!0,xS())}function ao(t,a){if(!Pd&&dl){Pd=!0;do for(var s=!1,u=pl;u!==null;){if(t!==0){var c=u.pendingLanes;if(c===0)var d=0;else{var g=u.suspendedLanes,b=u.pingedLanes;d=(1<<31-jt(42|t)+1)-1,d&=c&~(g&~b),d=d&201326741?d&201326741|1:d?d|2:0}d!==0&&(s=!0,U0(u,d))}else d=Te,d=xu(u,u===Ge?d:0,u.cancelPendingCommit!==null||u.timeoutHandle!==-1),(d&3)===0||ws(u,d)||(s=!0,U0(u,d));u=u.next}while(s);Pd=!1}}function hS(){L0()}function L0(){dl=Ld=!1;var t=0;Gi!==0&&TS()&&(t=Gi);for(var a=At(),s=null,u=pl;u!==null;){var c=u.next,d=P0(u,a);d===0?(u.next=null,s===null?pl=c:s.next=c,c===null&&(Hr=s)):(s=u,(t!==0||(d&3)!==0)&&(dl=!0)),u=c}ft!==0&&ft!==5||ao(t),Gi!==0&&(Gi=0)}function P0(t,a){for(var s=t.suspendedLanes,u=t.pingedLanes,c=t.expirationTimes,d=t.pendingLanes&-62914561;0<d;){var g=31-jt(d),b=1<<g,w=c[g];w===-1?((b&s)===0||(b&u)!==0)&&(c[g]=qb(b,a)):w<=a&&(t.expiredLanes|=b),d&=~b}if(a=Ge,s=Te,s=xu(t,t===a?s:0,t.cancelPendingCommit!==null||t.timeoutHandle!==-1),u=t.callbackNode,s===0||t===a&&(Le===2||Le===9)||t.cancelPendingCommit!==null)return u!==null&&u!==null&&Ss(u),t.callbackNode=null,t.callbackPriority=0;if((s&3)===0||ws(t,s)){if(a=s&-s,a===t.callbackPriority)return a;switch(u!==null&&Ss(u),$c(s)){case 2:case 8:s=mu;break;case 32:s=or;break;case 268435456:s=fu;break;default:s=or}return u=B0.bind(null,t),s=sr(s,u),t.callbackPriority=a,t.callbackNode=s,a}return u!==null&&u!==null&&Ss(u),t.callbackPriority=2,t.callbackNode=null,2}function B0(t,a){if(ft!==0&&ft!==5)return t.callbackNode=null,t.callbackPriority=0,null;var s=t.callbackNode;if(cl()&&t.callbackNode!==s)return null;var u=Te;return u=xu(t,t===Ge?u:0,t.cancelPendingCommit!==null||t.timeoutHandle!==-1),u===0?null:(O0(t,u,a),P0(t,At()),t.callbackNode!=null&&t.callbackNode===s?B0.bind(null,t):null)}function U0(t,a){if(cl())return null;O0(t,a,!0)}function xS(){kS(function(){(Ie&6)!==0?sr(du,hS):L0()})}function Bd(){if(Gi===0){var t=kr;t===0&&(t=ur,ur<<=1,(ur&261888)===0&&(ur=256)),Gi=t}return Gi}function z0(t){return t==null||typeof t=="symbol"||typeof t=="boolean"?null:typeof t=="function"?t:vu(""+t)}function F0(t,a){var s=a.ownerDocument.createElement("input");return s.name=a.name,s.value=a.value,t.id&&s.setAttribute("form",t.id),a.parentNode.insertBefore(s,a),t=new FormData(t),s.parentNode.removeChild(s),t}function gS(t,a,s,u,c){if(a==="submit"&&s&&s.stateNode===c){var d=z0((c[Ut]||null).action),g=u.submitter;g&&(a=(a=g[Ut]||null)?z0(a.formAction):g.getAttribute("formAction"),a!==null&&(d=a,g=null));var b=new Cu("action","action",null,u,c);t.push({event:b,listeners:[{instance:null,listener:function(){if(u.defaultPrevented){if(Gi!==0){var w=g?F0(c,g):new FormData(c);ad(s,{pending:!0,data:w,method:c.method,action:d},null,w)}}else typeof d=="function"&&(b.preventDefault(),w=g?F0(c,g):new FormData(c),ad(s,{pending:!0,data:w,method:c.method,action:d},d,w))},currentTarget:c}]})}}for(var Ud=0;Ud<bp.length;Ud++){var zd=bp[Ud],yS=zd.toLowerCase(),OS=zd[0].toUpperCase()+zd.slice(1);wn(yS,"on"+OS)}wn(y1,"onAnimationEnd"),wn(O1,"onAnimationIteration"),wn(v1,"onAnimationStart"),wn("dblclick","onDoubleClick"),wn("focusin","onFocus"),wn("focusout","onBlur"),wn(I3,"onTransitionRun"),wn(L3,"onTransitionStart"),wn(P3,"onTransitionCancel"),wn(b1,"onTransitionEnd"),fr("onMouseEnter",["mouseout","mouseover"]),fr("onMouseLeave",["mouseout","mouseover"]),fr("onPointerEnter",["pointerout","pointerover"]),fr("onPointerLeave",["pointerout","pointerover"]),ba("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),ba("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),ba("onBeforeInput",["compositionend","keypress","textInput","paste"]),ba("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),ba("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),ba("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var ro="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),vS=new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(ro));function q0(t,a){a=(a&4)!==0;for(var s=0;s<t.length;s++){var u=t[s],c=u.event;u=u.listeners;e:{var d=void 0;if(a)for(var g=u.length-1;0<=g;g--){var b=u[g],w=b.instance,A=b.currentTarget;if(b=b.listener,w!==d&&c.isPropagationStopped())break e;d=b,c.currentTarget=A;try{d(c)}catch(L){Nu(L)}c.currentTarget=null,d=w}else for(g=0;g<u.length;g++){if(b=u[g],w=b.instance,A=b.currentTarget,b=b.listener,w!==d&&c.isPropagationStopped())break e;d=b,c.currentTarget=A;try{d(c)}catch(L){Nu(L)}c.currentTarget=null,d=w}}}}function we(t,a){var s=a[Zc];s===void 0&&(s=a[Zc]=new Set);var u=t+"__bubble";s.has(u)||(H0(a,t,2,!1),s.add(u))}function Fd(t,a,s){var u=0;a&&(u|=4),H0(s,t,u,a)}var ml="_reactListening"+Math.random().toString(36).slice(2);function qd(t){if(!t[ml]){t[ml]=!0,Lh.forEach(function(s){s!=="selectionchange"&&(vS.has(s)||Fd(s,!1,t),Fd(s,!0,t))});var a=t.nodeType===9?t:t.ownerDocument;a===null||a[ml]||(a[ml]=!0,Fd("selectionchange",!1,a))}}function H0(t,a,s,u){switch(yg(a)){case 2:var c=KS;break;case 8:c=XS;break;default:c=im}s=c.bind(null,a,s,t),c=void 0,!up||a!=="touchstart"&&a!=="touchmove"&&a!=="wheel"||(c=!0),u?c!==void 0?t.addEventListener(a,s,{capture:!0,passive:c}):t.addEventListener(a,s,!0):c!==void 0?t.addEventListener(a,s,{passive:c}):t.addEventListener(a,s,!1)}function Hd(t,a,s,u,c){var d=u;if((a&1)===0&&(a&2)===0&&u!==null)e:for(;;){if(u===null)return;var g=u.tag;if(g===3||g===4){var b=u.stateNode.containerInfo;if(b===c)break;if(g===4)for(g=u.return;g!==null;){var w=g.tag;if((w===3||w===4)&&g.stateNode.containerInfo===c)return;g=g.return}for(;b!==null;){if(g=pr(b),g===null)return;if(w=g.tag,w===5||w===6||w===26||w===27){u=d=g;continue e}b=b.parentNode}}u=u.return}Kh(function(){var A=d,L=sp(s),F=[];e:{var j=S1.get(t);if(j!==void 0){var R=Cu,Z=t;switch(t){case"keypress":if(Su(s)===0)break e;case"keydown":case"keyup":R=m3;break;case"focusin":Z="focus",R=dp;break;case"focusout":Z="blur",R=dp;break;case"beforeblur":case"afterblur":R=dp;break;case"click":if(s.button===2)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":R=Jh;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":R=t3;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":R=x3;break;case y1:case O1:case v1:R=a3;break;case b1:R=y3;break;case"scroll":case"scrollend":R=Zb;break;case"wheel":R=v3;break;case"copy":case"cut":case"paste":R=s3;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":R=Zh;break;case"toggle":case"beforetoggle":R=S3}var re=(a&4)!==0,qe=!re&&(t==="scroll"||t==="scrollend"),N=re?j!==null?j+"Capture":null:j;re=[];for(var T=A,E;T!==null;){var U=T;if(E=U.stateNode,U=U.tag,U!==5&&U!==26&&U!==27||E===null||N===null||(U=Ns(T,N),U!=null&&re.push(so(T,U,E))),qe)break;T=T.return}0<re.length&&(j=new R(j,Z,null,s,L),F.push({event:j,listeners:re}))}}if((a&7)===0){e:{if(j=t==="mouseover"||t==="pointerover",R=t==="mouseout"||t==="pointerout",j&&s!==rp&&(Z=s.relatedTarget||s.fromElement)&&(pr(Z)||Z[cr]))break e;if((R||j)&&(j=L.window===L?L:(j=L.ownerDocument)?j.defaultView||j.parentWindow:window,R?(Z=s.relatedTarget||s.toElement,R=A,Z=Z?pr(Z):null,Z!==null&&(qe=l(Z),re=Z.tag,Z!==qe||re!==5&&re!==27&&re!==6)&&(Z=null)):(R=null,Z=A),R!==Z)){if(re=Jh,U="onMouseLeave",N="onMouseEnter",T="mouse",(t==="pointerout"||t==="pointerover")&&(re=Zh,U="onPointerLeave",N="onPointerEnter",T="pointer"),qe=R==null?j:Ts(R),E=Z==null?j:Ts(Z),j=new re(U,T+"leave",R,s,L),j.target=qe,j.relatedTarget=E,U=null,pr(L)===A&&(re=new re(N,T+"enter",Z,s,L),re.target=E,re.relatedTarget=qe,U=re),qe=U,R&&Z)t:{for(re=bS,N=R,T=Z,E=0,U=N;U;U=re(U))E++;U=0;for(var ie=T;ie;ie=re(ie))U++;for(;0<E-U;)N=re(N),E--;for(;0<U-E;)T=re(T),U--;for(;E--;){if(N===T||T!==null&&N===T.alternate){re=N;break t}N=re(N),T=re(T)}re=null}else re=null;R!==null&&Y0(F,j,R,re,!1),Z!==null&&qe!==null&&Y0(F,qe,Z,re,!0)}}e:{if(j=A?Ts(A):window,R=j.nodeName&&j.nodeName.toLowerCase(),R==="select"||R==="input"&&j.type==="file")var Ae=o1;else if(r1(j))if(u1)Ae=M3;else{Ae=A3;var ee=E3}else R=j.nodeName,!R||R.toLowerCase()!=="input"||j.type!=="checkbox"&&j.type!=="radio"?A&&ap(A.elementType)&&(Ae=o1):Ae=j3;if(Ae&&(Ae=Ae(t,A))){s1(F,Ae,s,L);break e}ee&&ee(t,j,A),t==="focusout"&&A&&j.type==="number"&&A.memoizedProps.value!=null&&ip(j,"number",j.value)}switch(ee=A?Ts(A):window,t){case"focusin":(r1(ee)||ee.contentEditable==="true")&&(vr=ee,yp=A,Is=null);break;case"focusout":Is=yp=vr=null;break;case"mousedown":Op=!0;break;case"contextmenu":case"mouseup":case"dragend":Op=!1,x1(F,s,L);break;case"selectionchange":if(D3)break;case"keydown":case"keyup":x1(F,s,L)}var ge;if(fp)e:{switch(t){case"compositionstart":var Ne="onCompositionStart";break e;case"compositionend":Ne="onCompositionEnd";break e;case"compositionupdate":Ne="onCompositionUpdate";break e}Ne=void 0}else Or?i1(t,s)&&(Ne="onCompositionEnd"):t==="keydown"&&s.keyCode===229&&(Ne="onCompositionStart");Ne&&(e1&&s.locale!=="ko"&&(Or||Ne!=="onCompositionStart"?Ne==="onCompositionEnd"&&Or&&(ge=Xh()):(Ei=L,lp="value"in Ei?Ei.value:Ei.textContent,Or=!0)),ee=fl(A,Ne),0<ee.length&&(Ne=new $h(Ne,t,null,s,L),F.push({event:Ne,listeners:ee}),ge?Ne.data=ge:(ge=a1(s),ge!==null&&(Ne.data=ge)))),(ge=C3?_3(t,s):T3(t,s))&&(Ne=fl(A,"onBeforeInput"),0<Ne.length&&(ee=new $h("onBeforeInput","beforeinput",null,s,L),F.push({event:ee,listeners:Ne}),ee.data=ge)),gS(F,t,A,s,L)}q0(F,a)})}function so(t,a,s){return{instance:t,listener:a,currentTarget:s}}function fl(t,a){for(var s=a+"Capture",u=[];t!==null;){var c=t,d=c.stateNode;if(c=c.tag,c!==5&&c!==26&&c!==27||d===null||(c=Ns(t,s),c!=null&&u.unshift(so(t,c,d)),c=Ns(t,a),c!=null&&u.push(so(t,c,d))),t.tag===3)return u;t=t.return}return[]}function bS(t){if(t===null)return null;do t=t.return;while(t&&t.tag!==5&&t.tag!==27);return t||null}function Y0(t,a,s,u,c){for(var d=a._reactName,g=[];s!==null&&s!==u;){var b=s,w=b.alternate,A=b.stateNode;if(b=b.tag,w!==null&&w===u)break;b!==5&&b!==26&&b!==27||A===null||(w=A,c?(A=Ns(s,d),A!=null&&g.unshift(so(s,A,w))):c||(A=Ns(s,d),A!=null&&g.push(so(s,A,w)))),s=s.return}g.length!==0&&t.push({event:a,listeners:g})}var SS=/\r\n?/g,wS=/\u0000|\uFFFD/g;function G0(t){return(typeof t=="string"?t:""+t).replace(SS,`
`).replace(wS,"")}function V0(t,a){return a=G0(a),G0(t)===a}function Fe(t,a,s,u,c,d){switch(s){case"children":typeof u=="string"?a==="body"||a==="textarea"&&u===""||xr(t,u):(typeof u=="number"||typeof u=="bigint")&&a!=="body"&&xr(t,""+u);break;case"className":yu(t,"class",u);break;case"tabIndex":yu(t,"tabindex",u);break;case"dir":case"role":case"viewBox":case"width":case"height":yu(t,s,u);break;case"style":Vh(t,u,d);break;case"data":if(a!=="object"){yu(t,"data",u);break}case"src":case"href":if(u===""&&(a!=="a"||s!=="href")){t.removeAttribute(s);break}if(u==null||typeof u=="function"||typeof u=="symbol"||typeof u=="boolean"){t.removeAttribute(s);break}u=vu(""+u),t.setAttribute(s,u);break;case"action":case"formAction":if(typeof u=="function"){t.setAttribute(s,"javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");break}else typeof d=="function"&&(s==="formAction"?(a!=="input"&&Fe(t,a,"name",c.name,c,null),Fe(t,a,"formEncType",c.formEncType,c,null),Fe(t,a,"formMethod",c.formMethod,c,null),Fe(t,a,"formTarget",c.formTarget,c,null)):(Fe(t,a,"encType",c.encType,c,null),Fe(t,a,"method",c.method,c,null),Fe(t,a,"target",c.target,c,null)));if(u==null||typeof u=="symbol"||typeof u=="boolean"){t.removeAttribute(s);break}u=vu(""+u),t.setAttribute(s,u);break;case"onClick":u!=null&&(t.onclick=Kn);break;case"onScroll":u!=null&&we("scroll",t);break;case"onScrollEnd":u!=null&&we("scrollend",t);break;case"dangerouslySetInnerHTML":if(u!=null){if(typeof u!="object"||!("__html"in u))throw Error(r(61));if(s=u.__html,s!=null){if(c.children!=null)throw Error(r(60));t.innerHTML=s}}break;case"multiple":t.multiple=u&&typeof u!="function"&&typeof u!="symbol";break;case"muted":t.muted=u&&typeof u!="function"&&typeof u!="symbol";break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"defaultValue":case"defaultChecked":case"innerHTML":case"ref":break;case"autoFocus":break;case"xlinkHref":if(u==null||typeof u=="function"||typeof u=="boolean"||typeof u=="symbol"){t.removeAttribute("xlink:href");break}s=vu(""+u),t.setAttributeNS("http://www.w3.org/1999/xlink","xlink:href",s);break;case"contentEditable":case"spellCheck":case"draggable":case"value":case"autoReverse":case"externalResourcesRequired":case"focusable":case"preserveAlpha":u!=null&&typeof u!="function"&&typeof u!="symbol"?t.setAttribute(s,""+u):t.removeAttribute(s);break;case"inert":case"allowFullScreen":case"async":case"autoPlay":case"controls":case"default":case"defer":case"disabled":case"disablePictureInPicture":case"disableRemotePlayback":case"formNoValidate":case"hidden":case"loop":case"noModule":case"noValidate":case"open":case"playsInline":case"readOnly":case"required":case"reversed":case"scoped":case"seamless":case"itemScope":u&&typeof u!="function"&&typeof u!="symbol"?t.setAttribute(s,""):t.removeAttribute(s);break;case"capture":case"download":u===!0?t.setAttribute(s,""):u!==!1&&u!=null&&typeof u!="function"&&typeof u!="symbol"?t.setAttribute(s,u):t.removeAttribute(s);break;case"cols":case"rows":case"size":case"span":u!=null&&typeof u!="function"&&typeof u!="symbol"&&!isNaN(u)&&1<=u?t.setAttribute(s,u):t.removeAttribute(s);break;case"rowSpan":case"start":u==null||typeof u=="function"||typeof u=="symbol"||isNaN(u)?t.removeAttribute(s):t.setAttribute(s,u);break;case"popover":we("beforetoggle",t),we("toggle",t),gu(t,"popover",u);break;case"xlinkActuate":Wn(t,"http://www.w3.org/1999/xlink","xlink:actuate",u);break;case"xlinkArcrole":Wn(t,"http://www.w3.org/1999/xlink","xlink:arcrole",u);break;case"xlinkRole":Wn(t,"http://www.w3.org/1999/xlink","xlink:role",u);break;case"xlinkShow":Wn(t,"http://www.w3.org/1999/xlink","xlink:show",u);break;case"xlinkTitle":Wn(t,"http://www.w3.org/1999/xlink","xlink:title",u);break;case"xlinkType":Wn(t,"http://www.w3.org/1999/xlink","xlink:type",u);break;case"xmlBase":Wn(t,"http://www.w3.org/XML/1998/namespace","xml:base",u);break;case"xmlLang":Wn(t,"http://www.w3.org/XML/1998/namespace","xml:lang",u);break;case"xmlSpace":Wn(t,"http://www.w3.org/XML/1998/namespace","xml:space",u);break;case"is":gu(t,"is",u);break;case"innerText":case"textContent":break;default:(!(2<s.length)||s[0]!=="o"&&s[0]!=="O"||s[1]!=="n"&&s[1]!=="N")&&(s=Jb.get(s)||s,gu(t,s,u))}}function Yd(t,a,s,u,c,d){switch(s){case"style":Vh(t,u,d);break;case"dangerouslySetInnerHTML":if(u!=null){if(typeof u!="object"||!("__html"in u))throw Error(r(61));if(s=u.__html,s!=null){if(c.children!=null)throw Error(r(60));t.innerHTML=s}}break;case"children":typeof u=="string"?xr(t,u):(typeof u=="number"||typeof u=="bigint")&&xr(t,""+u);break;case"onScroll":u!=null&&we("scroll",t);break;case"onScrollEnd":u!=null&&we("scrollend",t);break;case"onClick":u!=null&&(t.onclick=Kn);break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"innerHTML":case"ref":break;case"innerText":case"textContent":break;default:if(!Ph.hasOwnProperty(s))e:{if(s[0]==="o"&&s[1]==="n"&&(c=s.endsWith("Capture"),a=s.slice(2,c?s.length-7:void 0),d=t[Ut]||null,d=d!=null?d[s]:null,typeof d=="function"&&t.removeEventListener(a,d,c),typeof u=="function")){typeof d!="function"&&d!==null&&(s in t?t[s]=null:t.hasAttribute(s)&&t.removeAttribute(s)),t.addEventListener(a,u,c);break e}s in t?t[s]=u:u===!0?t.setAttribute(s,""):gu(t,s,u)}}}function Nt(t,a,s){switch(a){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"img":we("error",t),we("load",t);var u=!1,c=!1,d;for(d in s)if(s.hasOwnProperty(d)){var g=s[d];if(g!=null)switch(d){case"src":u=!0;break;case"srcSet":c=!0;break;case"children":case"dangerouslySetInnerHTML":throw Error(r(137,a));default:Fe(t,a,d,g,s,null)}}c&&Fe(t,a,"srcSet",s.srcSet,s,null),u&&Fe(t,a,"src",s.src,s,null);return;case"input":we("invalid",t);var b=d=g=c=null,w=null,A=null;for(u in s)if(s.hasOwnProperty(u)){var L=s[u];if(L!=null)switch(u){case"name":c=L;break;case"type":g=L;break;case"checked":w=L;break;case"defaultChecked":A=L;break;case"value":d=L;break;case"defaultValue":b=L;break;case"children":case"dangerouslySetInnerHTML":if(L!=null)throw Error(r(137,a));break;default:Fe(t,a,u,L,s,null)}}qh(t,d,b,w,A,g,c,!1);return;case"select":we("invalid",t),u=g=d=null;for(c in s)if(s.hasOwnProperty(c)&&(b=s[c],b!=null))switch(c){case"value":d=b;break;case"defaultValue":g=b;break;case"multiple":u=b;default:Fe(t,a,c,b,s,null)}a=d,s=g,t.multiple=!!u,a!=null?hr(t,!!u,a,!1):s!=null&&hr(t,!!u,s,!0);return;case"textarea":we("invalid",t),d=c=u=null;for(g in s)if(s.hasOwnProperty(g)&&(b=s[g],b!=null))switch(g){case"value":u=b;break;case"defaultValue":c=b;break;case"children":d=b;break;case"dangerouslySetInnerHTML":if(b!=null)throw Error(r(91));break;default:Fe(t,a,g,b,s,null)}Yh(t,u,c,d);return;case"option":for(w in s)s.hasOwnProperty(w)&&(u=s[w],u!=null)&&(w==="selected"?t.selected=u&&typeof u!="function"&&typeof u!="symbol":Fe(t,a,w,u,s,null));return;case"dialog":we("beforetoggle",t),we("toggle",t),we("cancel",t),we("close",t);break;case"iframe":case"object":we("load",t);break;case"video":case"audio":for(u=0;u<ro.length;u++)we(ro[u],t);break;case"image":we("error",t),we("load",t);break;case"details":we("toggle",t);break;case"embed":case"source":case"link":we("error",t),we("load",t);case"area":case"base":case"br":case"col":case"hr":case"keygen":case"meta":case"param":case"track":case"wbr":case"menuitem":for(A in s)if(s.hasOwnProperty(A)&&(u=s[A],u!=null))switch(A){case"children":case"dangerouslySetInnerHTML":throw Error(r(137,a));default:Fe(t,a,A,u,s,null)}return;default:if(ap(a)){for(L in s)s.hasOwnProperty(L)&&(u=s[L],u!==void 0&&Yd(t,a,L,u,s,void 0));return}}for(b in s)s.hasOwnProperty(b)&&(u=s[b],u!=null&&Fe(t,a,b,u,s,null))}function CS(t,a,s,u){switch(a){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"input":var c=null,d=null,g=null,b=null,w=null,A=null,L=null;for(R in s){var F=s[R];if(s.hasOwnProperty(R)&&F!=null)switch(R){case"checked":break;case"value":break;case"defaultValue":w=F;default:u.hasOwnProperty(R)||Fe(t,a,R,null,u,F)}}for(var j in u){var R=u[j];if(F=s[j],u.hasOwnProperty(j)&&(R!=null||F!=null))switch(j){case"type":d=R;break;case"name":c=R;break;case"checked":A=R;break;case"defaultChecked":L=R;break;case"value":g=R;break;case"defaultValue":b=R;break;case"children":case"dangerouslySetInnerHTML":if(R!=null)throw Error(r(137,a));break;default:R!==F&&Fe(t,a,j,R,u,F)}}np(t,g,b,w,A,L,d,c);return;case"select":R=g=b=j=null;for(d in s)if(w=s[d],s.hasOwnProperty(d)&&w!=null)switch(d){case"value":break;case"multiple":R=w;default:u.hasOwnProperty(d)||Fe(t,a,d,null,u,w)}for(c in u)if(d=u[c],w=s[c],u.hasOwnProperty(c)&&(d!=null||w!=null))switch(c){case"value":j=d;break;case"defaultValue":b=d;break;case"multiple":g=d;default:d!==w&&Fe(t,a,c,d,u,w)}a=b,s=g,u=R,j!=null?hr(t,!!s,j,!1):!!u!=!!s&&(a!=null?hr(t,!!s,a,!0):hr(t,!!s,s?[]:"",!1));return;case"textarea":R=j=null;for(b in s)if(c=s[b],s.hasOwnProperty(b)&&c!=null&&!u.hasOwnProperty(b))switch(b){case"value":break;case"children":break;default:Fe(t,a,b,null,u,c)}for(g in u)if(c=u[g],d=s[g],u.hasOwnProperty(g)&&(c!=null||d!=null))switch(g){case"value":j=c;break;case"defaultValue":R=c;break;case"children":break;case"dangerouslySetInnerHTML":if(c!=null)throw Error(r(91));break;default:c!==d&&Fe(t,a,g,c,u,d)}Hh(t,j,R);return;case"option":for(var Z in s)j=s[Z],s.hasOwnProperty(Z)&&j!=null&&!u.hasOwnProperty(Z)&&(Z==="selected"?t.selected=!1:Fe(t,a,Z,null,u,j));for(w in u)j=u[w],R=s[w],u.hasOwnProperty(w)&&j!==R&&(j!=null||R!=null)&&(w==="selected"?t.selected=j&&typeof j!="function"&&typeof j!="symbol":Fe(t,a,w,j,u,R));return;case"img":case"link":case"area":case"base":case"br":case"col":case"embed":case"hr":case"keygen":case"meta":case"param":case"source":case"track":case"wbr":case"menuitem":for(var re in s)j=s[re],s.hasOwnProperty(re)&&j!=null&&!u.hasOwnProperty(re)&&Fe(t,a,re,null,u,j);for(A in u)if(j=u[A],R=s[A],u.hasOwnProperty(A)&&j!==R&&(j!=null||R!=null))switch(A){case"children":case"dangerouslySetInnerHTML":if(j!=null)throw Error(r(137,a));break;default:Fe(t,a,A,j,u,R)}return;default:if(ap(a)){for(var qe in s)j=s[qe],s.hasOwnProperty(qe)&&j!==void 0&&!u.hasOwnProperty(qe)&&Yd(t,a,qe,void 0,u,j);for(L in u)j=u[L],R=s[L],!u.hasOwnProperty(L)||j===R||j===void 0&&R===void 0||Yd(t,a,L,j,u,R);return}}for(var N in s)j=s[N],s.hasOwnProperty(N)&&j!=null&&!u.hasOwnProperty(N)&&Fe(t,a,N,null,u,j);for(F in u)j=u[F],R=s[F],!u.hasOwnProperty(F)||j===R||j==null&&R==null||Fe(t,a,F,j,u,R)}function W0(t){switch(t){case"css":case"script":case"font":case"img":case"image":case"input":case"link":return!0;default:return!1}}function _S(){if(typeof performance.getEntriesByType=="function"){for(var t=0,a=0,s=performance.getEntriesByType("resource"),u=0;u<s.length;u++){var c=s[u],d=c.transferSize,g=c.initiatorType,b=c.duration;if(d&&b&&W0(g)){for(g=0,b=c.responseEnd,u+=1;u<s.length;u++){var w=s[u],A=w.startTime;if(A>b)break;var L=w.transferSize,F=w.initiatorType;L&&W0(F)&&(w=w.responseEnd,g+=L*(w<b?1:(b-A)/(w-A)))}if(--u,a+=8*(d+g)/(c.duration/1e3),t++,10<t)break}}if(0<t)return a/t/1e6}return navigator.connection&&(t=navigator.connection.downlink,typeof t=="number")?t:5}var Gd=null,Vd=null;function hl(t){return t.nodeType===9?t:t.ownerDocument}function K0(t){switch(t){case"http://www.w3.org/2000/svg":return 1;case"http://www.w3.org/1998/Math/MathML":return 2;default:return 0}}function X0(t,a){if(t===0)switch(a){case"svg":return 1;case"math":return 2;default:return 0}return t===1&&a==="foreignObject"?0:t}function Wd(t,a){return t==="textarea"||t==="noscript"||typeof a.children=="string"||typeof a.children=="number"||typeof a.children=="bigint"||typeof a.dangerouslySetInnerHTML=="object"&&a.dangerouslySetInnerHTML!==null&&a.dangerouslySetInnerHTML.__html!=null}var Kd=null;function TS(){var t=window.event;return t&&t.type==="popstate"?t===Kd?!1:(Kd=t,!0):(Kd=null,!1)}var Q0=typeof setTimeout=="function"?setTimeout:void 0,NS=typeof clearTimeout=="function"?clearTimeout:void 0,J0=typeof Promise=="function"?Promise:void 0,kS=typeof queueMicrotask=="function"?queueMicrotask:typeof J0<"u"?function(t){return J0.resolve(null).then(t).catch(ES)}:Q0;function ES(t){setTimeout(function(){throw t})}function Vi(t){return t==="head"}function $0(t,a){var s=a,u=0;do{var c=s.nextSibling;if(t.removeChild(s),c&&c.nodeType===8)if(s=c.data,s==="/$"||s==="/&"){if(u===0){t.removeChild(c),Wr(a);return}u--}else if(s==="$"||s==="$?"||s==="$~"||s==="$!"||s==="&")u++;else if(s==="html")oo(t.ownerDocument.documentElement);else if(s==="head"){s=t.ownerDocument.head,oo(s);for(var d=s.firstChild;d;){var g=d.nextSibling,b=d.nodeName;d[_s]||b==="SCRIPT"||b==="STYLE"||b==="LINK"&&d.rel.toLowerCase()==="stylesheet"||s.removeChild(d),d=g}}else s==="body"&&oo(t.ownerDocument.body);s=c}while(s);Wr(a)}function Z0(t,a){var s=t;t=0;do{var u=s.nextSibling;if(s.nodeType===1?a?(s._stashedDisplay=s.style.display,s.style.display="none"):(s.style.display=s._stashedDisplay||"",s.getAttribute("style")===""&&s.removeAttribute("style")):s.nodeType===3&&(a?(s._stashedText=s.nodeValue,s.nodeValue=""):s.nodeValue=s._stashedText||""),u&&u.nodeType===8)if(s=u.data,s==="/$"){if(t===0)break;t--}else s!=="$"&&s!=="$?"&&s!=="$~"&&s!=="$!"||t++;s=u}while(s)}function Xd(t){var a=t.firstChild;for(a&&a.nodeType===10&&(a=a.nextSibling);a;){var s=a;switch(a=a.nextSibling,s.nodeName){case"HTML":case"HEAD":case"BODY":Xd(s),ep(s);continue;case"SCRIPT":case"STYLE":continue;case"LINK":if(s.rel.toLowerCase()==="stylesheet")continue}t.removeChild(s)}}function AS(t,a,s,u){for(;t.nodeType===1;){var c=s;if(t.nodeName.toLowerCase()!==a.toLowerCase()){if(!u&&(t.nodeName!=="INPUT"||t.type!=="hidden"))break}else if(u){if(!t[_s])switch(a){case"meta":if(!t.hasAttribute("itemprop"))break;return t;case"link":if(d=t.getAttribute("rel"),d==="stylesheet"&&t.hasAttribute("data-precedence"))break;if(d!==c.rel||t.getAttribute("href")!==(c.href==null||c.href===""?null:c.href)||t.getAttribute("crossorigin")!==(c.crossOrigin==null?null:c.crossOrigin)||t.getAttribute("title")!==(c.title==null?null:c.title))break;return t;case"style":if(t.hasAttribute("data-precedence"))break;return t;case"script":if(d=t.getAttribute("src"),(d!==(c.src==null?null:c.src)||t.getAttribute("type")!==(c.type==null?null:c.type)||t.getAttribute("crossorigin")!==(c.crossOrigin==null?null:c.crossOrigin))&&d&&t.hasAttribute("async")&&!t.hasAttribute("itemprop"))break;return t;default:return t}}else if(a==="input"&&t.type==="hidden"){var d=c.name==null?null:""+c.name;if(c.type==="hidden"&&t.getAttribute("name")===d)return t}else return t;if(t=xn(t.nextSibling),t===null)break}return null}function jS(t,a,s){if(a==="")return null;for(;t.nodeType!==3;)if((t.nodeType!==1||t.nodeName!=="INPUT"||t.type!=="hidden")&&!s||(t=xn(t.nextSibling),t===null))return null;return t}function eg(t,a){for(;t.nodeType!==8;)if((t.nodeType!==1||t.nodeName!=="INPUT"||t.type!=="hidden")&&!a||(t=xn(t.nextSibling),t===null))return null;return t}function Qd(t){return t.data==="$?"||t.data==="$~"}function Jd(t){return t.data==="$!"||t.data==="$?"&&t.ownerDocument.readyState!=="loading"}function MS(t,a){var s=t.ownerDocument;if(t.data==="$~")t._reactRetry=a;else if(t.data!=="$?"||s.readyState!=="loading")a();else{var u=function(){a(),s.removeEventListener("DOMContentLoaded",u)};s.addEventListener("DOMContentLoaded",u),t._reactRetry=u}}function xn(t){for(;t!=null;t=t.nextSibling){var a=t.nodeType;if(a===1||a===3)break;if(a===8){if(a=t.data,a==="$"||a==="$!"||a==="$?"||a==="$~"||a==="&"||a==="F!"||a==="F")break;if(a==="/$"||a==="/&")return null}}return t}var $d=null;function tg(t){t=t.nextSibling;for(var a=0;t;){if(t.nodeType===8){var s=t.data;if(s==="/$"||s==="/&"){if(a===0)return xn(t.nextSibling);a--}else s!=="$"&&s!=="$!"&&s!=="$?"&&s!=="$~"&&s!=="&"||a++}t=t.nextSibling}return null}function ng(t){t=t.previousSibling;for(var a=0;t;){if(t.nodeType===8){var s=t.data;if(s==="$"||s==="$!"||s==="$?"||s==="$~"||s==="&"){if(a===0)return t;a--}else s!=="/$"&&s!=="/&"||a++}t=t.previousSibling}return null}function ig(t,a,s){switch(a=hl(s),t){case"html":if(t=a.documentElement,!t)throw Error(r(452));return t;case"head":if(t=a.head,!t)throw Error(r(453));return t;case"body":if(t=a.body,!t)throw Error(r(454));return t;default:throw Error(r(451))}}function oo(t){for(var a=t.attributes;a.length;)t.removeAttributeNode(a[0]);ep(t)}var gn=new Map,ag=new Set;function xl(t){return typeof t.getRootNode=="function"?t.getRootNode():t.nodeType===9?t:t.ownerDocument}var ci=V.d;V.d={f:RS,r:DS,D:IS,C:LS,L:PS,m:BS,X:zS,S:US,M:FS};function RS(){var t=ci.f(),a=ol();return t||a}function DS(t){var a=dr(t);a!==null&&a.tag===5&&a.type==="form"?bx(a):ci.r(t)}var Yr=typeof document>"u"?null:document;function rg(t,a,s){var u=Yr;if(u&&typeof a=="string"&&a){var c=ln(a);c='link[rel="'+t+'"][href="'+c+'"]',typeof s=="string"&&(c+='[crossorigin="'+s+'"]'),ag.has(c)||(ag.add(c),t={rel:t,crossOrigin:s,href:a},u.querySelector(c)===null&&(a=u.createElement("link"),Nt(a,"link",t),gt(a),u.head.appendChild(a)))}}function IS(t){ci.D(t),rg("dns-prefetch",t,null)}function LS(t,a){ci.C(t,a),rg("preconnect",t,a)}function PS(t,a,s){ci.L(t,a,s);var u=Yr;if(u&&t&&a){var c='link[rel="preload"][as="'+ln(a)+'"]';a==="image"&&s&&s.imageSrcSet?(c+='[imagesrcset="'+ln(s.imageSrcSet)+'"]',typeof s.imageSizes=="string"&&(c+='[imagesizes="'+ln(s.imageSizes)+'"]')):c+='[href="'+ln(t)+'"]';var d=c;switch(a){case"style":d=Gr(t);break;case"script":d=Vr(t)}gn.has(d)||(t=y({rel:"preload",href:a==="image"&&s&&s.imageSrcSet?void 0:t,as:a},s),gn.set(d,t),u.querySelector(c)!==null||a==="style"&&u.querySelector(uo(d))||a==="script"&&u.querySelector(lo(d))||(a=u.createElement("link"),Nt(a,"link",t),gt(a),u.head.appendChild(a)))}}function BS(t,a){ci.m(t,a);var s=Yr;if(s&&t){var u=a&&typeof a.as=="string"?a.as:"script",c='link[rel="modulepreload"][as="'+ln(u)+'"][href="'+ln(t)+'"]',d=c;switch(u){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":d=Vr(t)}if(!gn.has(d)&&(t=y({rel:"modulepreload",href:t},a),gn.set(d,t),s.querySelector(c)===null)){switch(u){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":if(s.querySelector(lo(d)))return}u=s.createElement("link"),Nt(u,"link",t),gt(u),s.head.appendChild(u)}}}function US(t,a,s){ci.S(t,a,s);var u=Yr;if(u&&t){var c=mr(u).hoistableStyles,d=Gr(t);a=a||"default";var g=c.get(d);if(!g){var b={loading:0,preload:null};if(g=u.querySelector(uo(d)))b.loading=5;else{t=y({rel:"stylesheet",href:t,"data-precedence":a},s),(s=gn.get(d))&&Zd(t,s);var w=g=u.createElement("link");gt(w),Nt(w,"link",t),w._p=new Promise(function(A,L){w.onload=A,w.onerror=L}),w.addEventListener("load",function(){b.loading|=1}),w.addEventListener("error",function(){b.loading|=2}),b.loading|=4,gl(g,a,u)}g={type:"stylesheet",instance:g,count:1,state:b},c.set(d,g)}}}function zS(t,a){ci.X(t,a);var s=Yr;if(s&&t){var u=mr(s).hoistableScripts,c=Vr(t),d=u.get(c);d||(d=s.querySelector(lo(c)),d||(t=y({src:t,async:!0},a),(a=gn.get(c))&&em(t,a),d=s.createElement("script"),gt(d),Nt(d,"link",t),s.head.appendChild(d)),d={type:"script",instance:d,count:1,state:null},u.set(c,d))}}function FS(t,a){ci.M(t,a);var s=Yr;if(s&&t){var u=mr(s).hoistableScripts,c=Vr(t),d=u.get(c);d||(d=s.querySelector(lo(c)),d||(t=y({src:t,async:!0,type:"module"},a),(a=gn.get(c))&&em(t,a),d=s.createElement("script"),gt(d),Nt(d,"link",t),s.head.appendChild(d)),d={type:"script",instance:d,count:1,state:null},u.set(c,d))}}function sg(t,a,s,u){var c=(c=he.current)?xl(c):null;if(!c)throw Error(r(446));switch(t){case"meta":case"title":return null;case"style":return typeof s.precedence=="string"&&typeof s.href=="string"?(a=Gr(s.href),s=mr(c).hoistableStyles,u=s.get(a),u||(u={type:"style",instance:null,count:0,state:null},s.set(a,u)),u):{type:"void",instance:null,count:0,state:null};case"link":if(s.rel==="stylesheet"&&typeof s.href=="string"&&typeof s.precedence=="string"){t=Gr(s.href);var d=mr(c).hoistableStyles,g=d.get(t);if(g||(c=c.ownerDocument||c,g={type:"stylesheet",instance:null,count:0,state:{loading:0,preload:null}},d.set(t,g),(d=c.querySelector(uo(t)))&&!d._p&&(g.instance=d,g.state.loading=5),gn.has(t)||(s={rel:"preload",as:"style",href:s.href,crossOrigin:s.crossOrigin,integrity:s.integrity,media:s.media,hrefLang:s.hrefLang,referrerPolicy:s.referrerPolicy},gn.set(t,s),d||qS(c,t,s,g.state))),a&&u===null)throw Error(r(528,""));return g}if(a&&u!==null)throw Error(r(529,""));return null;case"script":return a=s.async,s=s.src,typeof s=="string"&&a&&typeof a!="function"&&typeof a!="symbol"?(a=Vr(s),s=mr(c).hoistableScripts,u=s.get(a),u||(u={type:"script",instance:null,count:0,state:null},s.set(a,u)),u):{type:"void",instance:null,count:0,state:null};default:throw Error(r(444,t))}}function Gr(t){return'href="'+ln(t)+'"'}function uo(t){return'link[rel="stylesheet"]['+t+"]"}function og(t){return y({},t,{"data-precedence":t.precedence,precedence:null})}function qS(t,a,s,u){t.querySelector('link[rel="preload"][as="style"]['+a+"]")?u.loading=1:(a=t.createElement("link"),u.preload=a,a.addEventListener("load",function(){return u.loading|=1}),a.addEventListener("error",function(){return u.loading|=2}),Nt(a,"link",s),gt(a),t.head.appendChild(a))}function Vr(t){return'[src="'+ln(t)+'"]'}function lo(t){return"script[async]"+t}function ug(t,a,s){if(a.count++,a.instance===null)switch(a.type){case"style":var u=t.querySelector('style[data-href~="'+ln(s.href)+'"]');if(u)return a.instance=u,gt(u),u;var c=y({},s,{"data-href":s.href,"data-precedence":s.precedence,href:null,precedence:null});return u=(t.ownerDocument||t).createElement("style"),gt(u),Nt(u,"style",c),gl(u,s.precedence,t),a.instance=u;case"stylesheet":c=Gr(s.href);var d=t.querySelector(uo(c));if(d)return a.state.loading|=4,a.instance=d,gt(d),d;u=og(s),(c=gn.get(c))&&Zd(u,c),d=(t.ownerDocument||t).createElement("link"),gt(d);var g=d;return g._p=new Promise(function(b,w){g.onload=b,g.onerror=w}),Nt(d,"link",u),a.state.loading|=4,gl(d,s.precedence,t),a.instance=d;case"script":return d=Vr(s.src),(c=t.querySelector(lo(d)))?(a.instance=c,gt(c),c):(u=s,(c=gn.get(d))&&(u=y({},s),em(u,c)),t=t.ownerDocument||t,c=t.createElement("script"),gt(c),Nt(c,"link",u),t.head.appendChild(c),a.instance=c);case"void":return null;default:throw Error(r(443,a.type))}else a.type==="stylesheet"&&(a.state.loading&4)===0&&(u=a.instance,a.state.loading|=4,gl(u,s.precedence,t));return a.instance}function gl(t,a,s){for(var u=s.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'),c=u.length?u[u.length-1]:null,d=c,g=0;g<u.length;g++){var b=u[g];if(b.dataset.precedence===a)d=b;else if(d!==c)break}d?d.parentNode.insertBefore(t,d.nextSibling):(a=s.nodeType===9?s.head:s,a.insertBefore(t,a.firstChild))}function Zd(t,a){t.crossOrigin==null&&(t.crossOrigin=a.crossOrigin),t.referrerPolicy==null&&(t.referrerPolicy=a.referrerPolicy),t.title==null&&(t.title=a.title)}function em(t,a){t.crossOrigin==null&&(t.crossOrigin=a.crossOrigin),t.referrerPolicy==null&&(t.referrerPolicy=a.referrerPolicy),t.integrity==null&&(t.integrity=a.integrity)}var yl=null;function lg(t,a,s){if(yl===null){var u=new Map,c=yl=new Map;c.set(s,u)}else c=yl,u=c.get(s),u||(u=new Map,c.set(s,u));if(u.has(t))return u;for(u.set(t,null),s=s.getElementsByTagName(t),c=0;c<s.length;c++){var d=s[c];if(!(d[_s]||d[wt]||t==="link"&&d.getAttribute("rel")==="stylesheet")&&d.namespaceURI!=="http://www.w3.org/2000/svg"){var g=d.getAttribute(a)||"";g=t+g;var b=u.get(g);b?b.push(d):u.set(g,[d])}}return u}function cg(t,a,s){t=t.ownerDocument||t,t.head.insertBefore(s,a==="title"?t.querySelector("head > title"):null)}function HS(t,a,s){if(s===1||a.itemProp!=null)return!1;switch(t){case"meta":case"title":return!0;case"style":if(typeof a.precedence!="string"||typeof a.href!="string"||a.href==="")break;return!0;case"link":if(typeof a.rel!="string"||typeof a.href!="string"||a.href===""||a.onLoad||a.onError)break;return a.rel==="stylesheet"?(t=a.disabled,typeof a.precedence=="string"&&t==null):!0;case"script":if(a.async&&typeof a.async!="function"&&typeof a.async!="symbol"&&!a.onLoad&&!a.onError&&a.src&&typeof a.src=="string")return!0}return!1}function pg(t){return!(t.type==="stylesheet"&&(t.state.loading&3)===0)}function YS(t,a,s,u){if(s.type==="stylesheet"&&(typeof u.media!="string"||matchMedia(u.media).matches!==!1)&&(s.state.loading&4)===0){if(s.instance===null){var c=Gr(u.href),d=a.querySelector(uo(c));if(d){a=d._p,a!==null&&typeof a=="object"&&typeof a.then=="function"&&(t.count++,t=Ol.bind(t),a.then(t,t)),s.state.loading|=4,s.instance=d,gt(d);return}d=a.ownerDocument||a,u=og(u),(c=gn.get(c))&&Zd(u,c),d=d.createElement("link"),gt(d);var g=d;g._p=new Promise(function(b,w){g.onload=b,g.onerror=w}),Nt(d,"link",u),s.instance=d}t.stylesheets===null&&(t.stylesheets=new Map),t.stylesheets.set(s,a),(a=s.state.preload)&&(s.state.loading&3)===0&&(t.count++,s=Ol.bind(t),a.addEventListener("load",s),a.addEventListener("error",s))}}var tm=0;function GS(t,a){return t.stylesheets&&t.count===0&&bl(t,t.stylesheets),0<t.count||0<t.imgCount?function(s){var u=setTimeout(function(){if(t.stylesheets&&bl(t,t.stylesheets),t.unsuspend){var d=t.unsuspend;t.unsuspend=null,d()}},6e4+a);0<t.imgBytes&&tm===0&&(tm=62500*_S());var c=setTimeout(function(){if(t.waitingForImages=!1,t.count===0&&(t.stylesheets&&bl(t,t.stylesheets),t.unsuspend)){var d=t.unsuspend;t.unsuspend=null,d()}},(t.imgBytes>tm?50:800)+a);return t.unsuspend=s,function(){t.unsuspend=null,clearTimeout(u),clearTimeout(c)}}:null}function Ol(){if(this.count--,this.count===0&&(this.imgCount===0||!this.waitingForImages)){if(this.stylesheets)bl(this,this.stylesheets);else if(this.unsuspend){var t=this.unsuspend;this.unsuspend=null,t()}}}var vl=null;function bl(t,a){t.stylesheets=null,t.unsuspend!==null&&(t.count++,vl=new Map,a.forEach(VS,t),vl=null,Ol.call(t))}function VS(t,a){if(!(a.state.loading&4)){var s=vl.get(t);if(s)var u=s.get(null);else{s=new Map,vl.set(t,s);for(var c=t.querySelectorAll("link[data-precedence],style[data-precedence]"),d=0;d<c.length;d++){var g=c[d];(g.nodeName==="LINK"||g.getAttribute("media")!=="not all")&&(s.set(g.dataset.precedence,g),u=g)}u&&s.set(null,u)}c=a.instance,g=c.getAttribute("data-precedence"),d=s.get(g)||u,d===u&&s.set(null,c),s.set(g,c),this.count++,u=Ol.bind(this),c.addEventListener("load",u),c.addEventListener("error",u),d?d.parentNode.insertBefore(c,d.nextSibling):(t=t.nodeType===9?t.head:t,t.insertBefore(c,t.firstChild)),a.state.loading|=4}}var co={$$typeof:H,Provider:null,Consumer:null,_currentValue:ne,_currentValue2:ne,_threadCount:0};function WS(t,a,s,u,c,d,g,b,w){this.tag=1,this.containerInfo=t,this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.next=this.pendingContext=this.context=this.cancelPendingCommit=null,this.callbackPriority=0,this.expirationTimes=Qc(-1),this.entangledLanes=this.shellSuspendCounter=this.errorRecoveryDisabledLanes=this.expiredLanes=this.warmLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=Qc(0),this.hiddenUpdates=Qc(null),this.identifierPrefix=u,this.onUncaughtError=c,this.onCaughtError=d,this.onRecoverableError=g,this.pooledCache=null,this.pooledCacheLanes=0,this.formState=w,this.incompleteTransitions=new Map}function dg(t,a,s,u,c,d,g,b,w,A,L,F){return t=new WS(t,a,s,g,w,A,L,F,b),a=1,d===!0&&(a|=24),d=Jt(3,null,null,a),t.current=d,d.stateNode=t,a=Dp(),a.refCount++,t.pooledCache=a,a.refCount++,d.memoizedState={element:u,isDehydrated:s,cache:a},Bp(d),t}function mg(t){return t?(t=wr,t):wr}function fg(t,a,s,u,c,d){c=mg(c),u.context===null?u.context=c:u.pendingContext=c,u=Ii(a),u.payload={element:s},d=d===void 0?null:d,d!==null&&(u.callback=d),s=Li(t,u,a),s!==null&&(Gt(s,t,a),qs(s,t,a))}function hg(t,a){if(t=t.memoizedState,t!==null&&t.dehydrated!==null){var s=t.retryLane;t.retryLane=s!==0&&s<a?s:a}}function nm(t,a){hg(t,a),(t=t.alternate)&&hg(t,a)}function xg(t){if(t.tag===13||t.tag===31){var a=_a(t,67108864);a!==null&&Gt(a,t,67108864),nm(t,67108864)}}function gg(t){if(t.tag===13||t.tag===31){var a=nn();a=Jc(a);var s=_a(t,a);s!==null&&Gt(s,t,a),nm(t,a)}}var Sl=!0;function KS(t,a,s,u){var c=M.T;M.T=null;var d=V.p;try{V.p=2,im(t,a,s,u)}finally{V.p=d,M.T=c}}function XS(t,a,s,u){var c=M.T;M.T=null;var d=V.p;try{V.p=8,im(t,a,s,u)}finally{V.p=d,M.T=c}}function im(t,a,s,u){if(Sl){var c=am(u);if(c===null)Hd(t,a,u,wl,s),Og(t,u);else if(JS(c,t,a,s,u))u.stopPropagation();else if(Og(t,u),a&4&&-1<QS.indexOf(t)){for(;c!==null;){var d=dr(c);if(d!==null)switch(d.tag){case 3:if(d=d.stateNode,d.current.memoizedState.isDehydrated){var g=va(d.pendingLanes);if(g!==0){var b=d;for(b.pendingLanes|=2,b.entangledLanes|=2;g;){var w=1<<31-jt(g);b.entanglements[1]|=w,g&=~w}Ln(d),(Ie&6)===0&&(rl=At()+500,ao(0))}}break;case 31:case 13:b=_a(d,2),b!==null&&Gt(b,d,2),ol(),nm(d,2)}if(d=am(u),d===null&&Hd(t,a,u,wl,s),d===c)break;c=d}c!==null&&u.stopPropagation()}else Hd(t,a,u,null,s)}}function am(t){return t=sp(t),rm(t)}var wl=null;function rm(t){if(wl=null,t=pr(t),t!==null){var a=l(t);if(a===null)t=null;else{var s=a.tag;if(s===13){if(t=p(a),t!==null)return t;t=null}else if(s===31){if(t=m(a),t!==null)return t;t=null}else if(s===3){if(a.stateNode.current.memoizedState.isDehydrated)return a.tag===3?a.stateNode.containerInfo:null;t=null}else a!==t&&(t=null)}}return wl=t,null}function yg(t){switch(t){case"beforetoggle":case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"toggle":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 2;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 8;case"message":switch(Wc()){case du:return 2;case mu:return 8;case or:case Kc:return 32;case fu:return 268435456;default:return 32}default:return 32}}var sm=!1,Wi=null,Ki=null,Xi=null,po=new Map,mo=new Map,Qi=[],QS="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" ");function Og(t,a){switch(t){case"focusin":case"focusout":Wi=null;break;case"dragenter":case"dragleave":Ki=null;break;case"mouseover":case"mouseout":Xi=null;break;case"pointerover":case"pointerout":po.delete(a.pointerId);break;case"gotpointercapture":case"lostpointercapture":mo.delete(a.pointerId)}}function fo(t,a,s,u,c,d){return t===null||t.nativeEvent!==d?(t={blockedOn:a,domEventName:s,eventSystemFlags:u,nativeEvent:d,targetContainers:[c]},a!==null&&(a=dr(a),a!==null&&xg(a)),t):(t.eventSystemFlags|=u,a=t.targetContainers,c!==null&&a.indexOf(c)===-1&&a.push(c),t)}function JS(t,a,s,u,c){switch(a){case"focusin":return Wi=fo(Wi,t,a,s,u,c),!0;case"dragenter":return Ki=fo(Ki,t,a,s,u,c),!0;case"mouseover":return Xi=fo(Xi,t,a,s,u,c),!0;case"pointerover":var d=c.pointerId;return po.set(d,fo(po.get(d)||null,t,a,s,u,c)),!0;case"gotpointercapture":return d=c.pointerId,mo.set(d,fo(mo.get(d)||null,t,a,s,u,c)),!0}return!1}function vg(t){var a=pr(t.target);if(a!==null){var s=l(a);if(s!==null){if(a=s.tag,a===13){if(a=p(s),a!==null){t.blockedOn=a,Dh(t.priority,function(){gg(s)});return}}else if(a===31){if(a=m(s),a!==null){t.blockedOn=a,Dh(t.priority,function(){gg(s)});return}}else if(a===3&&s.stateNode.current.memoizedState.isDehydrated){t.blockedOn=s.tag===3?s.stateNode.containerInfo:null;return}}}t.blockedOn=null}function Cl(t){if(t.blockedOn!==null)return!1;for(var a=t.targetContainers;0<a.length;){var s=am(t.nativeEvent);if(s===null){s=t.nativeEvent;var u=new s.constructor(s.type,s);rp=u,s.target.dispatchEvent(u),rp=null}else return a=dr(s),a!==null&&xg(a),t.blockedOn=s,!1;a.shift()}return!0}function bg(t,a,s){Cl(t)&&s.delete(a)}function $S(){sm=!1,Wi!==null&&Cl(Wi)&&(Wi=null),Ki!==null&&Cl(Ki)&&(Ki=null),Xi!==null&&Cl(Xi)&&(Xi=null),po.forEach(bg),mo.forEach(bg)}function _l(t,a){t.blockedOn===a&&(t.blockedOn=null,sm||(sm=!0,n.unstable_scheduleCallback(n.unstable_NormalPriority,$S)))}var Tl=null;function Sg(t){Tl!==t&&(Tl=t,n.unstable_scheduleCallback(n.unstable_NormalPriority,function(){Tl===t&&(Tl=null);for(var a=0;a<t.length;a+=3){var s=t[a],u=t[a+1],c=t[a+2];if(typeof u!="function"){if(rm(u||s)===null)continue;break}var d=dr(s);d!==null&&(t.splice(a,3),a-=3,ad(d,{pending:!0,data:c,method:s.method,action:u},u,c))}}))}function Wr(t){function a(w){return _l(w,t)}Wi!==null&&_l(Wi,t),Ki!==null&&_l(Ki,t),Xi!==null&&_l(Xi,t),po.forEach(a),mo.forEach(a);for(var s=0;s<Qi.length;s++){var u=Qi[s];u.blockedOn===t&&(u.blockedOn=null)}for(;0<Qi.length&&(s=Qi[0],s.blockedOn===null);)vg(s),s.blockedOn===null&&Qi.shift();if(s=(t.ownerDocument||t).$$reactFormReplay,s!=null)for(u=0;u<s.length;u+=3){var c=s[u],d=s[u+1],g=c[Ut]||null;if(typeof d=="function")g||Sg(s);else if(g){var b=null;if(d&&d.hasAttribute("formAction")){if(c=d,g=d[Ut]||null)b=g.formAction;else if(rm(c)!==null)continue}else b=g.action;typeof b=="function"?s[u+1]=b:(s.splice(u,3),u-=3),Sg(s)}}}function wg(){function t(d){d.canIntercept&&d.info==="react-transition"&&d.intercept({handler:function(){return new Promise(function(g){return c=g})},focusReset:"manual",scroll:"manual"})}function a(){c!==null&&(c(),c=null),u||setTimeout(s,20)}function s(){if(!u&&!navigation.transition){var d=navigation.currentEntry;d&&d.url!=null&&navigation.navigate(d.url,{state:d.getState(),info:"react-transition",history:"replace"})}}if(typeof navigation=="object"){var u=!1,c=null;return navigation.addEventListener("navigate",t),navigation.addEventListener("navigatesuccess",a),navigation.addEventListener("navigateerror",a),setTimeout(s,100),function(){u=!0,navigation.removeEventListener("navigate",t),navigation.removeEventListener("navigatesuccess",a),navigation.removeEventListener("navigateerror",a),c!==null&&(c(),c=null)}}}function om(t){this._internalRoot=t}Nl.prototype.render=om.prototype.render=function(t){var a=this._internalRoot;if(a===null)throw Error(r(409));var s=a.current,u=nn();fg(s,u,t,a,null,null)},Nl.prototype.unmount=om.prototype.unmount=function(){var t=this._internalRoot;if(t!==null){this._internalRoot=null;var a=t.containerInfo;fg(t.current,2,null,t,null,null),ol(),a[cr]=null}};function Nl(t){this._internalRoot=t}Nl.prototype.unstable_scheduleHydration=function(t){if(t){var a=Rh();t={blockedOn:null,target:t,priority:a};for(var s=0;s<Qi.length&&a!==0&&a<Qi[s].priority;s++);Qi.splice(s,0,t),s===0&&vg(t)}};var Cg=e.version;if(Cg!=="19.2.3")throw Error(r(527,Cg,"19.2.3"));V.findDOMNode=function(t){var a=t._reactInternals;if(a===void 0)throw typeof t.render=="function"?Error(r(188)):(t=Object.keys(t).join(","),Error(r(268,t)));return t=x(a),t=t!==null?O(t):null,t=t===null?null:t.stateNode,t};var ZS={bundleType:0,version:"19.2.3",rendererPackageName:"react-dom",currentDispatcherRef:M,reconcilerVersion:"19.2.3"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var kl=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!kl.isDisabled&&kl.supportsFiber)try{_e=kl.inject(ZS),De=kl}catch{}}return xo.createRoot=function(t,a){if(!o(t))throw Error(r(299));var s=!1,u="",c=jx,d=Mx,g=Rx;return a!=null&&(a.unstable_strictMode===!0&&(s=!0),a.identifierPrefix!==void 0&&(u=a.identifierPrefix),a.onUncaughtError!==void 0&&(c=a.onUncaughtError),a.onCaughtError!==void 0&&(d=a.onCaughtError),a.onRecoverableError!==void 0&&(g=a.onRecoverableError)),a=dg(t,1,!1,null,null,s,u,null,c,d,g,wg),t[cr]=a.current,qd(t),new om(a)},xo.hydrateRoot=function(t,a,s){if(!o(t))throw Error(r(299));var u=!1,c="",d=jx,g=Mx,b=Rx,w=null;return s!=null&&(s.unstable_strictMode===!0&&(u=!0),s.identifierPrefix!==void 0&&(c=s.identifierPrefix),s.onUncaughtError!==void 0&&(d=s.onUncaughtError),s.onCaughtError!==void 0&&(g=s.onCaughtError),s.onRecoverableError!==void 0&&(b=s.onRecoverableError),s.formState!==void 0&&(w=s.formState)),a=dg(t,1,!0,a,s??null,u,c,w,d,g,b,wg),a.context=mg(null),s=a.current,u=nn(),u=Jc(u),c=Ii(u),c.callback=null,Li(s,c,u),s=u,a.current.lanes=s,Cs(a,s),Ln(a),t[cr]=a.current,qd(t),new Nl(a)},xo.version="19.2.3",xo}var Dg;function cw(){if(Dg)return cm.exports;Dg=1;function n(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n)}catch(e){console.error(e)}}return n(),cm.exports=lw(),cm.exports}var pw=cw();var Ig="popstate";function dw(n={}){function e(r,o){let{pathname:l,search:p,hash:m}=r.location;return Lm("",{pathname:l,search:p,hash:m},o.state&&o.state.usr||null,o.state&&o.state.key||"default")}function i(r,o){return typeof o=="string"?o:Bo(o)}return fw(e,i,null,n)}function Je(n,e){if(n===!1||n===null||typeof n>"u")throw new Error(e)}function On(n,e){if(!n){typeof console<"u"&&console.warn(e);try{throw new Error(e)}catch{}}}function mw(){return Math.random().toString(36).substring(2,10)}function Lg(n,e){return{usr:n.state,key:n.key,idx:e}}function Lm(n,e,i=null,r){return{pathname:typeof n=="string"?n:n.pathname,search:"",hash:"",...typeof e=="string"?ps(e):e,state:i,key:e&&e.key||r||mw()}}function Bo({pathname:n="/",search:e="",hash:i=""}){return e&&e!=="?"&&(n+=e.charAt(0)==="?"?e:"?"+e),i&&i!=="#"&&(n+=i.charAt(0)==="#"?i:"#"+i),n}function ps(n){let e={};if(n){let i=n.indexOf("#");i>=0&&(e.hash=n.substring(i),n=n.substring(0,i));let r=n.indexOf("?");r>=0&&(e.search=n.substring(r),n=n.substring(0,r)),n&&(e.pathname=n)}return e}function fw(n,e,i,r={}){let{window:o=document.defaultView,v5Compat:l=!1}=r,p=o.history,m="POP",h=null,x=O();x==null&&(x=0,p.replaceState({...p.state,idx:x},""));function O(){return(p.state||{idx:null}).idx}function y(){m="POP";let D=O(),q=D==null?null:D-x;x=D,h&&h({action:m,location:I.location,delta:q})}function v(D,q){m="PUSH";let z=Lm(I.location,D,q);x=O()+1;let H=Lg(z,x),J=I.createHref(z);try{p.pushState(H,"",J)}catch($){if($ instanceof DOMException&&$.name==="DataCloneError")throw $;o.location.assign(J)}l&&h&&h({action:m,location:I.location,delta:1})}function _(D,q){m="REPLACE";let z=Lm(I.location,D,q);x=O();let H=Lg(z,x),J=I.createHref(z);p.replaceState(H,"",J),l&&h&&h({action:m,location:I.location,delta:0})}function k(D){return hw(D)}let I={get action(){return m},get location(){return n(o,p)},listen(D){if(h)throw new Error("A history only accepts one active listener");return o.addEventListener(Ig,y),h=D,()=>{o.removeEventListener(Ig,y),h=null}},createHref(D){return e(o,D)},createURL:k,encodeLocation(D){let q=k(D);return{pathname:q.pathname,search:q.search,hash:q.hash}},push:v,replace:_,go(D){return p.go(D)}};return I}function hw(n,e=!1){let i="http://localhost";typeof window<"u"&&(i=window.location.origin!=="null"?window.location.origin:window.location.href),Je(i,"No window.location.(origin|href) available to create URL");let r=typeof n=="string"?n:Bo(n);return r=r.replace(/ $/,"%20"),!e&&r.startsWith("//")&&(r=i+r),new URL(r,i)}function x2(n,e,i="/"){return xw(n,e,i,!1)}function xw(n,e,i,r){let o=typeof e=="string"?ps(e):e,l=yi(o.pathname||"/",i);if(l==null)return null;let p=g2(n);gw(p);let m=null;for(let h=0;m==null&&h<p.length;++h){let x=kw(l);m=Tw(p[h],x,r)}return m}function g2(n,e=[],i=[],r="",o=!1){let l=(p,m,h=o,x)=>{let O={relativePath:x===void 0?p.path||"":x,caseSensitive:p.caseSensitive===!0,childrenIndex:m,route:p};if(O.relativePath.startsWith("/")){if(!O.relativePath.startsWith(r)&&h)return;Je(O.relativePath.startsWith(r),`Absolute route path "${O.relativePath}" nested under path "${r}" is not valid. An absolute child route path must start with the combined path of all its parent routes.`),O.relativePath=O.relativePath.slice(r.length)}let y=hi([r,O.relativePath]),v=i.concat(O);p.children&&p.children.length>0&&(Je(p.index!==!0,`Index routes must not have child routes. Please remove all child routes from route path "${y}".`),g2(p.children,e,v,y,h)),!(p.path==null&&!p.index)&&e.push({path:y,score:Cw(y,p.index),routesMeta:v})};return n.forEach((p,m)=>{if(p.path===""||!p.path?.includes("?"))l(p,m);else for(let h of y2(p.path))l(p,m,!0,h)}),e}function y2(n){let e=n.split("/");if(e.length===0)return[];let[i,...r]=e,o=i.endsWith("?"),l=i.replace(/\?$/,"");if(r.length===0)return o?[l,""]:[l];let p=y2(r.join("/")),m=[];return m.push(...p.map(h=>h===""?l:[l,h].join("/"))),o&&m.push(...p),m.map(h=>n.startsWith("/")&&h===""?"/":h)}function gw(n){n.sort((e,i)=>e.score!==i.score?i.score-e.score:_w(e.routesMeta.map(r=>r.childrenIndex),i.routesMeta.map(r=>r.childrenIndex)))}var yw=/^:[\w-]+$/,Ow=3,vw=2,bw=1,Sw=10,ww=-2,Pg=n=>n==="*";function Cw(n,e){let i=n.split("/"),r=i.length;return i.some(Pg)&&(r+=ww),e&&(r+=vw),i.filter(o=>!Pg(o)).reduce((o,l)=>o+(yw.test(l)?Ow:l===""?bw:Sw),r)}function _w(n,e){return n.length===e.length&&n.slice(0,-1).every((r,o)=>r===e[o])?n[n.length-1]-e[e.length-1]:0}function Tw(n,e,i=!1){let{routesMeta:r}=n,o={},l="/",p=[];for(let m=0;m<r.length;++m){let h=r[m],x=m===r.length-1,O=l==="/"?e:e.slice(l.length)||"/",y=Gl({path:h.relativePath,caseSensitive:h.caseSensitive,end:x},O),v=h.route;if(!y&&x&&i&&!r[r.length-1].route.index&&(y=Gl({path:h.relativePath,caseSensitive:h.caseSensitive,end:!1},O)),!y)return null;Object.assign(o,y.params),p.push({params:o,pathname:hi([l,y.pathname]),pathnameBase:Mw(hi([l,y.pathnameBase])),route:v}),y.pathnameBase!=="/"&&(l=hi([l,y.pathnameBase]))}return p}function Gl(n,e){typeof n=="string"&&(n={path:n,caseSensitive:!1,end:!0});let[i,r]=Nw(n.path,n.caseSensitive,n.end),o=e.match(i);if(!o)return null;let l=o[0],p=l.replace(/(.)\/+$/,"$1"),m=o.slice(1);return{params:r.reduce((x,{paramName:O,isOptional:y},v)=>{if(O==="*"){let k=m[v]||"";p=l.slice(0,l.length-k.length).replace(/(.)\/+$/,"$1")}const _=m[v];return y&&!_?x[O]=void 0:x[O]=(_||"").replace(/%2F/g,"/"),x},{}),pathname:l,pathnameBase:p,pattern:n}}function Nw(n,e=!1,i=!0){On(n==="*"||!n.endsWith("*")||n.endsWith("/*"),`Route path "${n}" will be treated as if it were "${n.replace(/\*$/,"/*")}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${n.replace(/\*$/,"/*")}".`);let r=[],o="^"+n.replace(/\/*\*?$/,"").replace(/^\/*/,"/").replace(/[\\.*+^${}|()[\]]/g,"\\$&").replace(/\/:([\w-]+)(\?)?/g,(p,m,h)=>(r.push({paramName:m,isOptional:h!=null}),h?"/?([^\\/]+)?":"/([^\\/]+)")).replace(/\/([\w-]+)\?(\/|$)/g,"(/$1)?$2");return n.endsWith("*")?(r.push({paramName:"*"}),o+=n==="*"||n==="/*"?"(.*)$":"(?:\\/(.+)|\\/*)$"):i?o+="\\/*$":n!==""&&n!=="/"&&(o+="(?:(?=\\/|$))"),[new RegExp(o,e?void 0:"i"),r]}function kw(n){try{return n.split("/").map(e=>decodeURIComponent(e).replace(/\//g,"%2F")).join("/")}catch(e){return On(!1,`The URL path "${n}" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (${e}).`),n}}function yi(n,e){if(e==="/")return n;if(!n.toLowerCase().startsWith(e.toLowerCase()))return null;let i=e.endsWith("/")?e.length-1:e.length,r=n.charAt(i);return r&&r!=="/"?null:n.slice(i)||"/"}var O2=/^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,Ew=n=>O2.test(n);function Aw(n,e="/"){let{pathname:i,search:r="",hash:o=""}=typeof n=="string"?ps(n):n,l;if(i)if(Ew(i))l=i;else{if(i.includes("//")){let p=i;i=i.replace(/\/\/+/g,"/"),On(!1,`Pathnames cannot have embedded double slashes - normalizing ${p} -> ${i}`)}i.startsWith("/")?l=Bg(i.substring(1),"/"):l=Bg(i,e)}else l=e;return{pathname:l,search:Rw(r),hash:Dw(o)}}function Bg(n,e){let i=e.replace(/\/+$/,"").split("/");return n.split("/").forEach(o=>{o===".."?i.length>1&&i.pop():o!=="."&&i.push(o)}),i.length>1?i.join("/"):"/"}function fm(n,e,i,r){return`Cannot include a '${n}' character in a manually specified \`to.${e}\` field [${JSON.stringify(r)}].  Please separate it out to the \`to.${i}\` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.`}function jw(n){return n.filter((e,i)=>i===0||e.route.path&&e.route.path.length>0)}function mf(n){let e=jw(n);return e.map((i,r)=>r===e.length-1?i.pathname:i.pathnameBase)}function ff(n,e,i,r=!1){let o;typeof n=="string"?o=ps(n):(o={...n},Je(!o.pathname||!o.pathname.includes("?"),fm("?","pathname","search",o)),Je(!o.pathname||!o.pathname.includes("#"),fm("#","pathname","hash",o)),Je(!o.search||!o.search.includes("#"),fm("#","search","hash",o)));let l=n===""||o.pathname==="",p=l?"/":o.pathname,m;if(p==null)m=i;else{let y=e.length-1;if(!r&&p.startsWith("..")){let v=p.split("/");for(;v[0]==="..";)v.shift(),y-=1;o.pathname=v.join("/")}m=y>=0?e[y]:"/"}let h=Aw(o,m),x=p&&p!=="/"&&p.endsWith("/"),O=(l||p===".")&&i.endsWith("/");return!h.pathname.endsWith("/")&&(x||O)&&(h.pathname+="/"),h}var hi=n=>n.join("/").replace(/\/\/+/g,"/"),Mw=n=>n.replace(/\/+$/,"").replace(/^\/*/,"/"),Rw=n=>!n||n==="?"?"":n.startsWith("?")?n:"?"+n,Dw=n=>!n||n==="#"?"":n.startsWith("#")?n:"#"+n,Iw=class{constructor(n,e,i,r=!1){this.status=n,this.statusText=e||"",this.internal=r,i instanceof Error?(this.data=i.toString(),this.error=i):this.data=i}};function Lw(n){return n!=null&&typeof n.status=="number"&&typeof n.statusText=="string"&&typeof n.internal=="boolean"&&"data"in n}function Pw(n){return n.map(e=>e.route.path).filter(Boolean).join("/").replace(/\/\/*/g,"/")||"/"}var v2=typeof window<"u"&&typeof window.document<"u"&&typeof window.document.createElement<"u";function b2(n,e){let i=n;if(typeof i!="string"||!O2.test(i))return{absoluteURL:void 0,isExternal:!1,to:i};let r=i,o=!1;if(v2)try{let l=new URL(window.location.href),p=i.startsWith("//")?new URL(l.protocol+i):new URL(i),m=yi(p.pathname,e);p.origin===l.origin&&m!=null?i=m+p.search+p.hash:o=!0}catch{On(!1,`<Link to="${i}"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`)}return{absoluteURL:r,isExternal:o,to:i}}Object.getOwnPropertyNames(Object.prototype).sort().join("\0");var S2=["POST","PUT","PATCH","DELETE"];new Set(S2);var Bw=["GET",...S2];new Set(Bw);var ds=S.createContext(null);ds.displayName="DataRouter";var wc=S.createContext(null);wc.displayName="DataRouterState";var Uw=S.createContext(!1),w2=S.createContext({isTransitioning:!1});w2.displayName="ViewTransition";var zw=S.createContext(new Map);zw.displayName="Fetchers";var Fw=S.createContext(null);Fw.displayName="Await";var on=S.createContext(null);on.displayName="Navigation";var $o=S.createContext(null);$o.displayName="Location";var qn=S.createContext({outlet:null,matches:[],isDataRoute:!1});qn.displayName="Route";var hf=S.createContext(null);hf.displayName="RouteError";var C2="REACT_ROUTER_ERROR",qw="REDIRECT",Hw="ROUTE_ERROR_RESPONSE";function Yw(n){if(n.startsWith(`${C2}:${qw}:{`))try{let e=JSON.parse(n.slice(28));if(typeof e=="object"&&e&&typeof e.status=="number"&&typeof e.statusText=="string"&&typeof e.location=="string"&&typeof e.reloadDocument=="boolean"&&typeof e.replace=="boolean")return e}catch{}}function Gw(n){if(n.startsWith(`${C2}:${Hw}:{`))try{let e=JSON.parse(n.slice(40));if(typeof e=="object"&&e&&typeof e.status=="number"&&typeof e.statusText=="string")return new Iw(e.status,e.statusText,e.data)}catch{}}function Vw(n,{relative:e}={}){Je(ms(),"useHref() may be used only in the context of a <Router> component.");let{basename:i,navigator:r}=S.useContext(on),{hash:o,pathname:l,search:p}=Zo(n,{relative:e}),m=l;return i!=="/"&&(m=l==="/"?i:hi([i,l])),r.createHref({pathname:m,search:p,hash:o})}function ms(){return S.useContext($o)!=null}function Hn(){return Je(ms(),"useLocation() may be used only in the context of a <Router> component."),S.useContext($o).location}var _2="You should call navigate() in a React.useEffect(), not when your component is first rendered.";function T2(n){S.useContext(on).static||S.useLayoutEffect(n)}function Cc(){let{isDataRoute:n}=S.useContext(qn);return n?rC():Ww()}function Ww(){Je(ms(),"useNavigate() may be used only in the context of a <Router> component.");let n=S.useContext(ds),{basename:e,navigator:i}=S.useContext(on),{matches:r}=S.useContext(qn),{pathname:o}=Hn(),l=JSON.stringify(mf(r)),p=S.useRef(!1);return T2(()=>{p.current=!0}),S.useCallback((h,x={})=>{if(On(p.current,_2),!p.current)return;if(typeof h=="number"){i.go(h);return}let O=ff(h,JSON.parse(l),o,x.relative==="path");n==null&&e!=="/"&&(O.pathname=O.pathname==="/"?e:hi([e,O.pathname])),(x.replace?i.replace:i.push)(O,x.state,x)},[e,i,l,o,n])}S.createContext(null);function Zo(n,{relative:e}={}){let{matches:i}=S.useContext(qn),{pathname:r}=Hn(),o=JSON.stringify(mf(i));return S.useMemo(()=>ff(n,JSON.parse(o),r,e==="path"),[n,o,r,e])}function Kw(n,e){return N2(n,e)}function N2(n,e,i,r,o){Je(ms(),"useRoutes() may be used only in the context of a <Router> component.");let{navigator:l}=S.useContext(on),{matches:p}=S.useContext(qn),m=p[p.length-1],h=m?m.params:{},x=m?m.pathname:"/",O=m?m.pathnameBase:"/",y=m&&m.route;{let z=y&&y.path||"";E2(x,!y||z.endsWith("*")||z.endsWith("*?"),`You rendered descendant <Routes> (or called \`useRoutes()\`) at "${x}" (under <Route path="${z}">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

Please change the parent <Route path="${z}"> to <Route path="${z==="/"?"*":`${z}/*`}">.`)}let v=Hn(),_;if(e){let z=typeof e=="string"?ps(e):e;Je(O==="/"||z.pathname?.startsWith(O),`When overriding the location using \`<Routes location>\` or \`useRoutes(routes, location)\`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is "${O}" but pathname "${z.pathname}" was given in the \`location\` prop.`),_=z}else _=v;let k=_.pathname||"/",I=k;if(O!=="/"){let z=O.replace(/^\//,"").split("/");I="/"+k.replace(/^\//,"").split("/").slice(z.length).join("/")}let D=x2(n,{pathname:I});On(y||D!=null,`No routes matched location "${_.pathname}${_.search}${_.hash}" `),On(D==null||D[D.length-1].route.element!==void 0||D[D.length-1].route.Component!==void 0||D[D.length-1].route.lazy!==void 0,`Matched leaf route at location "${_.pathname}${_.search}${_.hash}" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.`);let q=Zw(D&&D.map(z=>Object.assign({},z,{params:Object.assign({},h,z.params),pathname:hi([O,l.encodeLocation?l.encodeLocation(z.pathname.replace(/\?/g,"%3F").replace(/#/g,"%23")).pathname:z.pathname]),pathnameBase:z.pathnameBase==="/"?O:hi([O,l.encodeLocation?l.encodeLocation(z.pathnameBase.replace(/\?/g,"%3F").replace(/#/g,"%23")).pathname:z.pathnameBase])})),p,i,r,o);return e&&q?S.createElement($o.Provider,{value:{location:{pathname:"/",search:"",hash:"",state:null,key:"default",..._},navigationType:"POP"}},q):q}function Xw(){let n=aC(),e=Lw(n)?`${n.status} ${n.statusText}`:n instanceof Error?n.message:JSON.stringify(n),i=n instanceof Error?n.stack:null,r="rgba(200,200,200, 0.5)",o={padding:"0.5rem",backgroundColor:r},l={padding:"2px 4px",backgroundColor:r},p=null;return console.error("Error handled by React Router default ErrorBoundary:",n),p=S.createElement(S.Fragment,null,S.createElement("p",null," Hey developer "),S.createElement("p",null,"You can provide a way better UX than this when your app throws errors by providing your own ",S.createElement("code",{style:l},"ErrorBoundary")," or"," ",S.createElement("code",{style:l},"errorElement")," prop on your route.")),S.createElement(S.Fragment,null,S.createElement("h2",null,"Unexpected Application Error!"),S.createElement("h3",{style:{fontStyle:"italic"}},e),i?S.createElement("pre",{style:o},i):null,p)}var Qw=S.createElement(Xw,null),k2=class extends S.Component{constructor(n){super(n),this.state={location:n.location,revalidation:n.revalidation,error:n.error}}static getDerivedStateFromError(n){return{error:n}}static getDerivedStateFromProps(n,e){return e.location!==n.location||e.revalidation!=="idle"&&n.revalidation==="idle"?{error:n.error,location:n.location,revalidation:n.revalidation}:{error:n.error!==void 0?n.error:e.error,location:e.location,revalidation:n.revalidation||e.revalidation}}componentDidCatch(n,e){this.props.onError?this.props.onError(n,e):console.error("React Router caught the following error during render",n)}render(){let n=this.state.error;if(this.context&&typeof n=="object"&&n&&"digest"in n&&typeof n.digest=="string"){const i=Gw(n.digest);i&&(n=i)}let e=n!==void 0?S.createElement(qn.Provider,{value:this.props.routeContext},S.createElement(hf.Provider,{value:n,children:this.props.component})):this.props.children;return this.context?S.createElement(Jw,{error:n},e):e}};k2.contextType=Uw;var hm=new WeakMap;function Jw({children:n,error:e}){let{basename:i}=S.useContext(on);if(typeof e=="object"&&e&&"digest"in e&&typeof e.digest=="string"){let r=Yw(e.digest);if(r){let o=hm.get(e);if(o)throw o;let l=b2(r.location,i);if(v2&&!hm.get(e))if(l.isExternal||r.reloadDocument)window.location.href=l.absoluteURL||l.to;else{const p=Promise.resolve().then(()=>window.__reactRouterDataRouter.navigate(l.to,{replace:r.replace}));throw hm.set(e,p),p}return S.createElement("meta",{httpEquiv:"refresh",content:`0;url=${l.absoluteURL||l.to}`})}}return n}function $w({routeContext:n,match:e,children:i}){let r=S.useContext(ds);return r&&r.static&&r.staticContext&&(e.route.errorElement||e.route.ErrorBoundary)&&(r.staticContext._deepestRenderedBoundaryId=e.route.id),S.createElement(qn.Provider,{value:n},i)}function Zw(n,e=[],i=null,r=null,o=null){if(n==null){if(!i)return null;if(i.errors)n=i.matches;else if(e.length===0&&!i.initialized&&i.matches.length>0)n=i.matches;else return null}let l=n,p=i?.errors;if(p!=null){let O=l.findIndex(y=>y.route.id&&p?.[y.route.id]!==void 0);Je(O>=0,`Could not find a matching route for errors on route IDs: ${Object.keys(p).join(",")}`),l=l.slice(0,Math.min(l.length,O+1))}let m=!1,h=-1;if(i)for(let O=0;O<l.length;O++){let y=l[O];if((y.route.HydrateFallback||y.route.hydrateFallbackElement)&&(h=O),y.route.id){let{loaderData:v,errors:_}=i,k=y.route.loader&&!v.hasOwnProperty(y.route.id)&&(!_||_[y.route.id]===void 0);if(y.route.lazy||k){m=!0,h>=0?l=l.slice(0,h+1):l=[l[0]];break}}}let x=i&&r?(O,y)=>{r(O,{location:i.location,params:i.matches?.[0]?.params??{},unstable_pattern:Pw(i.matches),errorInfo:y})}:void 0;return l.reduceRight((O,y,v)=>{let _,k=!1,I=null,D=null;i&&(_=p&&y.route.id?p[y.route.id]:void 0,I=y.route.errorElement||Qw,m&&(h<0&&v===0?(E2("route-fallback",!1,"No `HydrateFallback` element provided to render during initial hydration"),k=!0,D=null):h===v&&(k=!0,D=y.route.hydrateFallbackElement||null)));let q=e.concat(l.slice(0,v+1)),z=()=>{let H;return _?H=I:k?H=D:y.route.Component?H=S.createElement(y.route.Component,null):y.route.element?H=y.route.element:H=O,S.createElement($w,{match:y,routeContext:{outlet:O,matches:q,isDataRoute:i!=null},children:H})};return i&&(y.route.ErrorBoundary||y.route.errorElement||v===0)?S.createElement(k2,{location:i.location,revalidation:i.revalidation,component:I,error:_,children:z(),routeContext:{outlet:null,matches:q,isDataRoute:!0},onError:x}):z()},null)}function xf(n){return`${n} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`}function eC(n){let e=S.useContext(ds);return Je(e,xf(n)),e}function tC(n){let e=S.useContext(wc);return Je(e,xf(n)),e}function nC(n){let e=S.useContext(qn);return Je(e,xf(n)),e}function gf(n){let e=nC(n),i=e.matches[e.matches.length-1];return Je(i.route.id,`${n} can only be used on routes that contain a unique "id"`),i.route.id}function iC(){return gf("useRouteId")}function aC(){let n=S.useContext(hf),e=tC("useRouteError"),i=gf("useRouteError");return n!==void 0?n:e.errors?.[i]}function rC(){let{router:n}=eC("useNavigate"),e=gf("useNavigate"),i=S.useRef(!1);return T2(()=>{i.current=!0}),S.useCallback(async(o,l={})=>{On(i.current,_2),i.current&&(typeof o=="number"?await n.navigate(o):await n.navigate(o,{fromRouteId:e,...l}))},[n,e])}var Ug={};function E2(n,e,i){!e&&!Ug[n]&&(Ug[n]=!0,On(!1,i))}S.memo(sC);function sC({routes:n,future:e,state:i,onError:r}){return N2(n,void 0,i,r,e)}function A2({to:n,replace:e,state:i,relative:r}){Je(ms(),"<Navigate> may be used only in the context of a <Router> component.");let{static:o}=S.useContext(on);On(!o,"<Navigate> must not be used on the initial render in a <StaticRouter>. This is a no-op, but you should modify your code so the <Navigate> is only ever rendered in response to some user interaction or state change.");let{matches:l}=S.useContext(qn),{pathname:p}=Hn(),m=Cc(),h=ff(n,mf(l),p,r==="path"),x=JSON.stringify(h);return S.useEffect(()=>{m(JSON.parse(x),{replace:e,state:i,relative:r})},[m,x,r,e,i]),null}function Tn(n){Je(!1,"A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.")}function oC({basename:n="/",children:e=null,location:i,navigationType:r="POP",navigator:o,static:l=!1,unstable_useTransitions:p}){Je(!ms(),"You cannot render a <Router> inside another <Router>. You should never have more than one in your app.");let m=n.replace(/^\/*/,"/"),h=S.useMemo(()=>({basename:m,navigator:o,static:l,unstable_useTransitions:p,future:{}}),[m,o,l,p]);typeof i=="string"&&(i=ps(i));let{pathname:x="/",search:O="",hash:y="",state:v=null,key:_="default"}=i,k=S.useMemo(()=>{let I=yi(x,m);return I==null?null:{location:{pathname:I,search:O,hash:y,state:v,key:_},navigationType:r}},[m,x,O,y,v,_,r]);return On(k!=null,`<Router basename="${m}"> is not able to match the URL "${x}${O}${y}" because it does not start with the basename, so the <Router> won't render anything.`),k==null?null:S.createElement(on.Provider,{value:h},S.createElement($o.Provider,{children:e,value:k}))}function uC({children:n,location:e}){return Kw(Pm(n),e)}function Pm(n,e=[]){let i=[];return S.Children.forEach(n,(r,o)=>{if(!S.isValidElement(r))return;let l=[...e,o];if(r.type===S.Fragment){i.push.apply(i,Pm(r.props.children,l));return}Je(r.type===Tn,`[${typeof r.type=="string"?r.type:r.type.name}] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>`),Je(!r.props.index||!r.props.children,"An index route cannot have child routes.");let p={id:r.props.id||l.join("-"),caseSensitive:r.props.caseSensitive,element:r.props.element,Component:r.props.Component,index:r.props.index,path:r.props.path,middleware:r.props.middleware,loader:r.props.loader,action:r.props.action,hydrateFallbackElement:r.props.hydrateFallbackElement,HydrateFallback:r.props.HydrateFallback,errorElement:r.props.errorElement,ErrorBoundary:r.props.ErrorBoundary,hasErrorBoundary:r.props.hasErrorBoundary===!0||r.props.ErrorBoundary!=null||r.props.errorElement!=null,shouldRevalidate:r.props.shouldRevalidate,handle:r.props.handle,lazy:r.props.lazy};r.props.children&&(p.children=Pm(r.props.children,l)),i.push(p)}),i}var Bl="get",Ul="application/x-www-form-urlencoded";function _c(n){return typeof HTMLElement<"u"&&n instanceof HTMLElement}function lC(n){return _c(n)&&n.tagName.toLowerCase()==="button"}function cC(n){return _c(n)&&n.tagName.toLowerCase()==="form"}function pC(n){return _c(n)&&n.tagName.toLowerCase()==="input"}function dC(n){return!!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey)}function mC(n,e){return n.button===0&&(!e||e==="_self")&&!dC(n)}var El=null;function fC(){if(El===null)try{new FormData(document.createElement("form"),0),El=!1}catch{El=!0}return El}var hC=new Set(["application/x-www-form-urlencoded","multipart/form-data","text/plain"]);function xm(n){return n!=null&&!hC.has(n)?(On(!1,`"${n}" is not a valid \`encType\` for \`<Form>\`/\`<fetcher.Form>\` and will default to "${Ul}"`),null):n}function xC(n,e){let i,r,o,l,p;if(cC(n)){let m=n.getAttribute("action");r=m?yi(m,e):null,i=n.getAttribute("method")||Bl,o=xm(n.getAttribute("enctype"))||Ul,l=new FormData(n)}else if(lC(n)||pC(n)&&(n.type==="submit"||n.type==="image")){let m=n.form;if(m==null)throw new Error('Cannot submit a <button> or <input type="submit"> without a <form>');let h=n.getAttribute("formaction")||m.getAttribute("action");if(r=h?yi(h,e):null,i=n.getAttribute("formmethod")||m.getAttribute("method")||Bl,o=xm(n.getAttribute("formenctype"))||xm(m.getAttribute("enctype"))||Ul,l=new FormData(m,n),!fC()){let{name:x,type:O,value:y}=n;if(O==="image"){let v=x?`${x}.`:"";l.append(`${v}x`,"0"),l.append(`${v}y`,"0")}else x&&l.append(x,y)}}else{if(_c(n))throw new Error('Cannot submit element that is not <form>, <button>, or <input type="submit|image">');i=Bl,r=null,o=Ul,p=n}return l&&o==="text/plain"&&(p=l,l=void 0),{action:r,method:i.toLowerCase(),encType:o,formData:l,body:p}}Object.getOwnPropertyNames(Object.prototype).sort().join("\0");function yf(n,e){if(n===!1||n===null||typeof n>"u")throw new Error(e)}function gC(n,e,i){let r=typeof n=="string"?new URL(n,typeof window>"u"?"server://singlefetch/":window.location.origin):n;return r.pathname==="/"?r.pathname=`_root.${i}`:e&&yi(r.pathname,e)==="/"?r.pathname=`${e.replace(/\/$/,"")}/_root.${i}`:r.pathname=`${r.pathname.replace(/\/$/,"")}.${i}`,r}async function yC(n,e){if(n.id in e)return e[n.id];try{let i=await import(n.module);return e[n.id]=i,i}catch(i){return console.error(`Error loading route module \`${n.module}\`, reloading page...`),console.error(i),window.__reactRouterContext&&window.__reactRouterContext.isSpaMode,window.location.reload(),new Promise(()=>{})}}function OC(n){return n==null?!1:n.href==null?n.rel==="preload"&&typeof n.imageSrcSet=="string"&&typeof n.imageSizes=="string":typeof n.rel=="string"&&typeof n.href=="string"}async function vC(n,e,i){let r=await Promise.all(n.map(async o=>{let l=e.routes[o.route.id];if(l){let p=await yC(l,i);return p.links?p.links():[]}return[]}));return CC(r.flat(1).filter(OC).filter(o=>o.rel==="stylesheet"||o.rel==="preload").map(o=>o.rel==="stylesheet"?{...o,rel:"prefetch",as:"style"}:{...o,rel:"prefetch"}))}function zg(n,e,i,r,o,l){let p=(h,x)=>i[x]?h.route.id!==i[x].route.id:!0,m=(h,x)=>i[x].pathname!==h.pathname||i[x].route.path?.endsWith("*")&&i[x].params["*"]!==h.params["*"];return l==="assets"?e.filter((h,x)=>p(h,x)||m(h,x)):l==="data"?e.filter((h,x)=>{let O=r.routes[h.route.id];if(!O||!O.hasLoader)return!1;if(p(h,x)||m(h,x))return!0;if(h.route.shouldRevalidate){let y=h.route.shouldRevalidate({currentUrl:new URL(o.pathname+o.search+o.hash,window.origin),currentParams:i[0]?.params||{},nextUrl:new URL(n,window.origin),nextParams:h.params,defaultShouldRevalidate:!0});if(typeof y=="boolean")return y}return!0}):[]}function bC(n,e,{includeHydrateFallback:i}={}){return SC(n.map(r=>{let o=e.routes[r.route.id];if(!o)return[];let l=[o.module];return o.clientActionModule&&(l=l.concat(o.clientActionModule)),o.clientLoaderModule&&(l=l.concat(o.clientLoaderModule)),i&&o.hydrateFallbackModule&&(l=l.concat(o.hydrateFallbackModule)),o.imports&&(l=l.concat(o.imports)),l}).flat(1))}function SC(n){return[...new Set(n)]}function wC(n){let e={},i=Object.keys(n).sort();for(let r of i)e[r]=n[r];return e}function CC(n,e){let i=new Set;return new Set(e),n.reduce((r,o)=>{let l=JSON.stringify(wC(o));return i.has(l)||(i.add(l),r.push({key:l,link:o})),r},[])}function j2(){let n=S.useContext(ds);return yf(n,"You must render this element inside a <DataRouterContext.Provider> element"),n}function _C(){let n=S.useContext(wc);return yf(n,"You must render this element inside a <DataRouterStateContext.Provider> element"),n}var Of=S.createContext(void 0);Of.displayName="FrameworkContext";function M2(){let n=S.useContext(Of);return yf(n,"You must render this element inside a <HydratedRouter> element"),n}function TC(n,e){let i=S.useContext(Of),[r,o]=S.useState(!1),[l,p]=S.useState(!1),{onFocus:m,onBlur:h,onMouseEnter:x,onMouseLeave:O,onTouchStart:y}=e,v=S.useRef(null);S.useEffect(()=>{if(n==="render"&&p(!0),n==="viewport"){let I=q=>{q.forEach(z=>{p(z.isIntersecting)})},D=new IntersectionObserver(I,{threshold:.5});return v.current&&D.observe(v.current),()=>{D.disconnect()}}},[n]),S.useEffect(()=>{if(r){let I=setTimeout(()=>{p(!0)},100);return()=>{clearTimeout(I)}}},[r]);let _=()=>{o(!0)},k=()=>{o(!1),p(!1)};return i?n!=="intent"?[l,v,{}]:[l,v,{onFocus:go(m,_),onBlur:go(h,k),onMouseEnter:go(x,_),onMouseLeave:go(O,k),onTouchStart:go(y,_)}]:[!1,v,{}]}function go(n,e){return i=>{n&&n(i),i.defaultPrevented||e(i)}}function NC({page:n,...e}){let{router:i}=j2(),r=S.useMemo(()=>x2(i.routes,n,i.basename),[i.routes,n,i.basename]);return r?S.createElement(EC,{page:n,matches:r,...e}):null}function kC(n){let{manifest:e,routeModules:i}=M2(),[r,o]=S.useState([]);return S.useEffect(()=>{let l=!1;return vC(n,e,i).then(p=>{l||o(p)}),()=>{l=!0}},[n,e,i]),r}function EC({page:n,matches:e,...i}){let r=Hn(),{manifest:o,routeModules:l}=M2(),{basename:p}=j2(),{loaderData:m,matches:h}=_C(),x=S.useMemo(()=>zg(n,e,h,o,r,"data"),[n,e,h,o,r]),O=S.useMemo(()=>zg(n,e,h,o,r,"assets"),[n,e,h,o,r]),y=S.useMemo(()=>{if(n===r.pathname+r.search+r.hash)return[];let k=new Set,I=!1;if(e.forEach(q=>{let z=o.routes[q.route.id];!z||!z.hasLoader||(!x.some(H=>H.route.id===q.route.id)&&q.route.id in m&&l[q.route.id]?.shouldRevalidate||z.hasClientLoader?I=!0:k.add(q.route.id))}),k.size===0)return[];let D=gC(n,p,"data");return I&&k.size>0&&D.searchParams.set("_routes",e.filter(q=>k.has(q.route.id)).map(q=>q.route.id).join(",")),[D.pathname+D.search]},[p,m,r,o,x,e,n,l]),v=S.useMemo(()=>bC(O,o),[O,o]),_=kC(O);return S.createElement(S.Fragment,null,y.map(k=>S.createElement("link",{key:k,rel:"prefetch",as:"fetch",href:k,...i})),v.map(k=>S.createElement("link",{key:k,rel:"modulepreload",href:k,...i})),_.map(({key:k,link:I})=>S.createElement("link",{key:k,nonce:i.nonce,...I})))}function AC(...n){return e=>{n.forEach(i=>{typeof i=="function"?i(e):i!=null&&(i.current=e)})}}var jC=typeof window<"u"&&typeof window.document<"u"&&typeof window.document.createElement<"u";try{jC&&(window.__reactRouterVersion="7.11.0")}catch{}function MC({basename:n,children:e,unstable_useTransitions:i,window:r}){let o=S.useRef();o.current==null&&(o.current=dw({window:r,v5Compat:!0}));let l=o.current,[p,m]=S.useState({action:l.action,location:l.location}),h=S.useCallback(x=>{i===!1?m(x):S.startTransition(()=>m(x))},[i]);return S.useLayoutEffect(()=>l.listen(h),[l,h]),S.createElement(oC,{basename:n,children:e,location:p.location,navigationType:p.action,navigator:l,unstable_useTransitions:i})}var R2=/^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,ht=S.forwardRef(function({onClick:e,discover:i="render",prefetch:r="none",relative:o,reloadDocument:l,replace:p,state:m,target:h,to:x,preventScrollReset:O,viewTransition:y,unstable_defaultShouldRevalidate:v,..._},k){let{basename:I,unstable_useTransitions:D}=S.useContext(on),q=typeof x=="string"&&R2.test(x),z=b2(x,I);x=z.to;let H=Vw(x,{relative:o}),[J,$,B]=TC(r,_),W=LC(x,{replace:p,state:m,target:h,preventScrollReset:O,relative:o,viewTransition:y,unstable_defaultShouldRevalidate:v,unstable_useTransitions:D});function ae(te){e&&e(te),te.defaultPrevented||W(te)}let ce=S.createElement("a",{..._,...B,href:z.absoluteURL||H,onClick:z.isExternal||l?e:ae,ref:AC(k,$),target:h,"data-discover":!q&&i==="render"?"true":void 0});return J&&!q?S.createElement(S.Fragment,null,ce,S.createElement(NC,{page:H})):ce});ht.displayName="Link";var RC=S.forwardRef(function({"aria-current":e="page",caseSensitive:i=!1,className:r="",end:o=!1,style:l,to:p,viewTransition:m,children:h,...x},O){let y=Zo(p,{relative:x.relative}),v=Hn(),_=S.useContext(wc),{navigator:k,basename:I}=S.useContext(on),D=_!=null&&FC(y)&&m===!0,q=k.encodeLocation?k.encodeLocation(y).pathname:y.pathname,z=v.pathname,H=_&&_.navigation&&_.navigation.location?_.navigation.location.pathname:null;i||(z=z.toLowerCase(),H=H?H.toLowerCase():null,q=q.toLowerCase()),H&&I&&(H=yi(H,I)||H);const J=q!=="/"&&q.endsWith("/")?q.length-1:q.length;let $=z===q||!o&&z.startsWith(q)&&z.charAt(J)==="/",B=H!=null&&(H===q||!o&&H.startsWith(q)&&H.charAt(q.length)==="/"),W={isActive:$,isPending:B,isTransitioning:D},ae=$?e:void 0,ce;typeof r=="function"?ce=r(W):ce=[r,$?"active":null,B?"pending":null,D?"transitioning":null].filter(Boolean).join(" ");let te=typeof l=="function"?l(W):l;return S.createElement(ht,{...x,"aria-current":ae,className:ce,ref:O,style:te,to:p,viewTransition:m},typeof h=="function"?h(W):h)});RC.displayName="NavLink";var DC=S.forwardRef(({discover:n="render",fetcherKey:e,navigate:i,reloadDocument:r,replace:o,state:l,method:p=Bl,action:m,onSubmit:h,relative:x,preventScrollReset:O,viewTransition:y,unstable_defaultShouldRevalidate:v,..._},k)=>{let{unstable_useTransitions:I}=S.useContext(on),D=UC(),q=zC(m,{relative:x}),z=p.toLowerCase()==="get"?"get":"post",H=typeof m=="string"&&R2.test(m),J=$=>{if(h&&h($),$.defaultPrevented)return;$.preventDefault();let B=$.nativeEvent.submitter,W=B?.getAttribute("formmethod")||p,ae=()=>D(B||$.currentTarget,{fetcherKey:e,method:W,navigate:i,replace:o,state:l,relative:x,preventScrollReset:O,viewTransition:y,unstable_defaultShouldRevalidate:v});I&&i!==!1?S.startTransition(()=>ae()):ae()};return S.createElement("form",{ref:k,method:z,action:q,onSubmit:r?h:J,..._,"data-discover":!H&&n==="render"?"true":void 0})});DC.displayName="Form";function IC(n){return`${n} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`}function D2(n){let e=S.useContext(ds);return Je(e,IC(n)),e}function LC(n,{target:e,replace:i,state:r,preventScrollReset:o,relative:l,viewTransition:p,unstable_defaultShouldRevalidate:m,unstable_useTransitions:h}={}){let x=Cc(),O=Hn(),y=Zo(n,{relative:l});return S.useCallback(v=>{if(mC(v,e)){v.preventDefault();let _=i!==void 0?i:Bo(O)===Bo(y),k=()=>x(n,{replace:_,state:r,preventScrollReset:o,relative:l,viewTransition:p,unstable_defaultShouldRevalidate:m});h?S.startTransition(()=>k()):k()}},[O,x,y,i,r,e,n,o,l,p,m,h])}var PC=0,BC=()=>`__${String(++PC)}__`;function UC(){let{router:n}=D2("useSubmit"),{basename:e}=S.useContext(on),i=iC(),r=n.fetch,o=n.navigate;return S.useCallback(async(l,p={})=>{let{action:m,method:h,encType:x,formData:O,body:y}=xC(l,e);if(p.navigate===!1){let v=p.fetcherKey||BC();await r(v,i,p.action||m,{unstable_defaultShouldRevalidate:p.unstable_defaultShouldRevalidate,preventScrollReset:p.preventScrollReset,formData:O,body:y,formMethod:p.method||h,formEncType:p.encType||x,flushSync:p.flushSync})}else await o(p.action||m,{unstable_defaultShouldRevalidate:p.unstable_defaultShouldRevalidate,preventScrollReset:p.preventScrollReset,formData:O,body:y,formMethod:p.method||h,formEncType:p.encType||x,replace:p.replace,state:p.state,fromRouteId:i,flushSync:p.flushSync,viewTransition:p.viewTransition})},[r,o,e,i])}function zC(n,{relative:e}={}){let{basename:i}=S.useContext(on),r=S.useContext(qn);Je(r,"useFormAction must be used inside a RouteContext");let[o]=r.matches.slice(-1),l={...Zo(n||".",{relative:e})},p=Hn();if(n==null){l.search=p.search;let m=new URLSearchParams(l.search),h=m.getAll("index");if(h.some(O=>O==="")){m.delete("index"),h.filter(y=>y).forEach(y=>m.append("index",y));let O=m.toString();l.search=O?`?${O}`:""}}return(!n||n===".")&&o.route.index&&(l.search=l.search?l.search.replace(/^\?/,"?index&"):"?index"),i!=="/"&&(l.pathname=l.pathname==="/"?i:hi([i,l.pathname])),Bo(l)}function FC(n,{relative:e}={}){let i=S.useContext(w2);Je(i!=null,"`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?");let{basename:r}=D2("useViewTransitionState"),o=Zo(n,{relative:e});if(!i.isTransitioning)return!1;let l=yi(i.currentLocation.pathname,r)||i.currentLocation.pathname,p=yi(i.nextLocation.pathname,r)||i.nextLocation.pathname;return Gl(o.pathname,p)!=null||Gl(o.pathname,l)!=null}const qC=()=>{};var Fg={};const I2={NODE_ADMIN:!1,SDK_VERSION:"${JSCORE_VERSION}"};const G=function(n,e){if(!n)throw fs(e)},fs=function(n){return new Error("Firebase Database ("+I2.SDK_VERSION+") INTERNAL ASSERT FAILED: "+n)};const L2=function(n){const e=[];let i=0;for(let r=0;r<n.length;r++){let o=n.charCodeAt(r);o<128?e[i++]=o:o<2048?(e[i++]=o>>6|192,e[i++]=o&63|128):(o&64512)===55296&&r+1<n.length&&(n.charCodeAt(r+1)&64512)===56320?(o=65536+((o&1023)<<10)+(n.charCodeAt(++r)&1023),e[i++]=o>>18|240,e[i++]=o>>12&63|128,e[i++]=o>>6&63|128,e[i++]=o&63|128):(e[i++]=o>>12|224,e[i++]=o>>6&63|128,e[i++]=o&63|128)}return e},HC=function(n){const e=[];let i=0,r=0;for(;i<n.length;){const o=n[i++];if(o<128)e[r++]=String.fromCharCode(o);else if(o>191&&o<224){const l=n[i++];e[r++]=String.fromCharCode((o&31)<<6|l&63)}else if(o>239&&o<365){const l=n[i++],p=n[i++],m=n[i++],h=((o&7)<<18|(l&63)<<12|(p&63)<<6|m&63)-65536;e[r++]=String.fromCharCode(55296+(h>>10)),e[r++]=String.fromCharCode(56320+(h&1023))}else{const l=n[i++],p=n[i++];e[r++]=String.fromCharCode((o&15)<<12|(l&63)<<6|p&63)}}return e.join("")},vf={byteToCharMap_:null,charToByteMap_:null,byteToCharMapWebSafe_:null,charToByteMapWebSafe_:null,ENCODED_VALS_BASE:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",get ENCODED_VALS(){return this.ENCODED_VALS_BASE+"+/="},get ENCODED_VALS_WEBSAFE(){return this.ENCODED_VALS_BASE+"-_."},HAS_NATIVE_SUPPORT:typeof atob=="function",encodeByteArray(n,e){if(!Array.isArray(n))throw Error("encodeByteArray takes an array as a parameter");this.init_();const i=e?this.byteToCharMapWebSafe_:this.byteToCharMap_,r=[];for(let o=0;o<n.length;o+=3){const l=n[o],p=o+1<n.length,m=p?n[o+1]:0,h=o+2<n.length,x=h?n[o+2]:0,O=l>>2,y=(l&3)<<4|m>>4;let v=(m&15)<<2|x>>6,_=x&63;h||(_=64,p||(v=64)),r.push(i[O],i[y],i[v],i[_])}return r.join("")},encodeString(n,e){return this.HAS_NATIVE_SUPPORT&&!e?btoa(n):this.encodeByteArray(L2(n),e)},decodeString(n,e){return this.HAS_NATIVE_SUPPORT&&!e?atob(n):HC(this.decodeStringToByteArray(n,e))},decodeStringToByteArray(n,e){this.init_();const i=e?this.charToByteMapWebSafe_:this.charToByteMap_,r=[];for(let o=0;o<n.length;){const l=i[n.charAt(o++)],m=o<n.length?i[n.charAt(o)]:0;++o;const x=o<n.length?i[n.charAt(o)]:64;++o;const y=o<n.length?i[n.charAt(o)]:64;if(++o,l==null||m==null||x==null||y==null)throw new YC;const v=l<<2|m>>4;if(r.push(v),x!==64){const _=m<<4&240|x>>2;if(r.push(_),y!==64){const k=x<<6&192|y;r.push(k)}}}return r},init_(){if(!this.byteToCharMap_){this.byteToCharMap_={},this.charToByteMap_={},this.byteToCharMapWebSafe_={},this.charToByteMapWebSafe_={};for(let n=0;n<this.ENCODED_VALS.length;n++)this.byteToCharMap_[n]=this.ENCODED_VALS.charAt(n),this.charToByteMap_[this.byteToCharMap_[n]]=n,this.byteToCharMapWebSafe_[n]=this.ENCODED_VALS_WEBSAFE.charAt(n),this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[n]]=n,n>=this.ENCODED_VALS_BASE.length&&(this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(n)]=n,this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(n)]=n)}}};class YC extends Error{constructor(){super(...arguments),this.name="DecodeBase64StringError"}}const P2=function(n){const e=L2(n);return vf.encodeByteArray(e,!0)},Vl=function(n){return P2(n).replace(/\./g,"")},Wl=function(n){try{return vf.decodeString(n,!0)}catch(e){console.error("base64Decode failed: ",e)}return null};function GC(n){return B2(void 0,n)}function B2(n,e){if(!(e instanceof Object))return e;switch(e.constructor){case Date:const i=e;return new Date(i.getTime());case Object:n===void 0&&(n={});break;case Array:n=[];break;default:return e}for(const i in e)!e.hasOwnProperty(i)||!VC(i)||(n[i]=B2(n[i],e[i]));return n}function VC(n){return n!=="__proto__"}function WC(){if(typeof self<"u")return self;if(typeof window<"u")return window;if(typeof global<"u")return global;throw new Error("Unable to locate global object.")}const KC=()=>WC().__FIREBASE_DEFAULTS__,XC=()=>{if(typeof process>"u"||typeof Fg>"u")return;const n=Fg.__FIREBASE_DEFAULTS__;if(n)return JSON.parse(n)},QC=()=>{if(typeof document>"u")return;let n;try{n=document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/)}catch{return}const e=n&&Wl(n[1]);return e&&JSON.parse(e)},bf=()=>{try{return qC()||KC()||XC()||QC()}catch(n){console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${n}`);return}},U2=n=>bf()?.emulatorHosts?.[n],z2=n=>{const e=U2(n);if(!e)return;const i=e.lastIndexOf(":");if(i<=0||i+1===e.length)throw new Error(`Invalid host ${e} with no separate hostname and port!`);const r=parseInt(e.substring(i+1),10);return e[0]==="["?[e.substring(1,i-1),r]:[e.substring(0,i),r]},F2=()=>bf()?.config,q2=n=>bf()?.[`_${n}`];class Pn{constructor(){this.reject=()=>{},this.resolve=()=>{},this.promise=new Promise((e,i)=>{this.resolve=e,this.reject=i})}wrapCallback(e){return(i,r)=>{i?this.reject(i):this.resolve(r),typeof e=="function"&&(this.promise.catch(()=>{}),e.length===1?e(i):e(i,r))}}}function fa(n){try{return(n.startsWith("http://")||n.startsWith("https://")?new URL(n).hostname:n).endsWith(".cloudworkstations.dev")}catch{return!1}}async function Sf(n){return(await fetch(n,{credentials:"include"})).ok}function H2(n,e){if(n.uid)throw new Error('The "uid" field is no longer supported by mockUserToken. Please use "sub" instead for Firebase Auth User ID.');const i={alg:"none",type:"JWT"},r=e||"demo-project",o=n.iat||0,l=n.sub||n.user_id;if(!l)throw new Error("mockUserToken must contain 'sub' or 'user_id' field!");const p={iss:`https://securetoken.google.com/${r}`,aud:r,iat:o,exp:o+3600,auth_time:o,sub:l,user_id:l,firebase:{sign_in_provider:"custom",identities:{}},...n};return[Vl(JSON.stringify(i)),Vl(JSON.stringify(p)),""].join(".")}const ko={};function JC(){const n={prod:[],emulator:[]};for(const e of Object.keys(ko))ko[e]?n.emulator.push(e):n.prod.push(e);return n}function $C(n){let e=document.getElementById(n),i=!1;return e||(e=document.createElement("div"),e.setAttribute("id",n),i=!0),{created:i,element:e}}let qg=!1;function wf(n,e){if(typeof window>"u"||typeof document>"u"||!fa(window.location.host)||ko[n]===e||ko[n]||qg)return;ko[n]=e;function i(v){return`__firebase__banner__${v}`}const r="__firebase__banner",l=JC().prod.length>0;function p(){const v=document.getElementById(r);v&&v.remove()}function m(v){v.style.display="flex",v.style.background="#7faaf0",v.style.position="fixed",v.style.bottom="5px",v.style.left="5px",v.style.padding=".5em",v.style.borderRadius="5px",v.style.alignItems="center"}function h(v,_){v.setAttribute("width","24"),v.setAttribute("id",_),v.setAttribute("height","24"),v.setAttribute("viewBox","0 0 24 24"),v.setAttribute("fill","none"),v.style.marginLeft="-6px"}function x(){const v=document.createElement("span");return v.style.cursor="pointer",v.style.marginLeft="16px",v.style.fontSize="24px",v.innerHTML=" &times;",v.onclick=()=>{qg=!0,p()},v}function O(v,_){v.setAttribute("id",_),v.innerText="Learn more",v.href="https://firebase.google.com/docs/studio/preview-apps#preview-backend",v.setAttribute("target","__blank"),v.style.paddingLeft="5px",v.style.textDecoration="underline"}function y(){const v=$C(r),_=i("text"),k=document.getElementById(_)||document.createElement("span"),I=i("learnmore"),D=document.getElementById(I)||document.createElement("a"),q=i("preprendIcon"),z=document.getElementById(q)||document.createElementNS("http://www.w3.org/2000/svg","svg");if(v.created){const H=v.element;m(H),O(D,I);const J=x();h(z,q),H.append(z,k,D,J),document.body.appendChild(H)}l?(k.innerText="Preview backend disconnected.",z.innerHTML=`<g clip-path="url(#clip0_6013_33858)">
<path d="M4.8 17.6L12 5.6L19.2 17.6H4.8ZM6.91667 16.4H17.0833L12 7.93333L6.91667 16.4ZM12 15.6C12.1667 15.6 12.3056 15.5444 12.4167 15.4333C12.5389 15.3111 12.6 15.1667 12.6 15C12.6 14.8333 12.5389 14.6944 12.4167 14.5833C12.3056 14.4611 12.1667 14.4 12 14.4C11.8333 14.4 11.6889 14.4611 11.5667 14.5833C11.4556 14.6944 11.4 14.8333 11.4 15C11.4 15.1667 11.4556 15.3111 11.5667 15.4333C11.6889 15.5444 11.8333 15.6 12 15.6ZM11.4 13.6H12.6V10.4H11.4V13.6Z" fill="#212121"/>
</g>
<defs>
<clipPath id="clip0_6013_33858">
<rect width="24" height="24" fill="white"/>
</clipPath>
</defs>`):(z.innerHTML=`<g clip-path="url(#clip0_6083_34804)">
<path d="M11.4 15.2H12.6V11.2H11.4V15.2ZM12 10C12.1667 10 12.3056 9.94444 12.4167 9.83333C12.5389 9.71111 12.6 9.56667 12.6 9.4C12.6 9.23333 12.5389 9.09444 12.4167 8.98333C12.3056 8.86111 12.1667 8.8 12 8.8C11.8333 8.8 11.6889 8.86111 11.5667 8.98333C11.4556 9.09444 11.4 9.23333 11.4 9.4C11.4 9.56667 11.4556 9.71111 11.5667 9.83333C11.6889 9.94444 11.8333 10 12 10ZM12 18.4C11.1222 18.4 10.2944 18.2333 9.51667 17.9C8.73889 17.5667 8.05556 17.1111 7.46667 16.5333C6.88889 15.9444 6.43333 15.2611 6.1 14.4833C5.76667 13.7056 5.6 12.8778 5.6 12C5.6 11.1111 5.76667 10.2833 6.1 9.51667C6.43333 8.73889 6.88889 8.06111 7.46667 7.48333C8.05556 6.89444 8.73889 6.43333 9.51667 6.1C10.2944 5.76667 11.1222 5.6 12 5.6C12.8889 5.6 13.7167 5.76667 14.4833 6.1C15.2611 6.43333 15.9389 6.89444 16.5167 7.48333C17.1056 8.06111 17.5667 8.73889 17.9 9.51667C18.2333 10.2833 18.4 11.1111 18.4 12C18.4 12.8778 18.2333 13.7056 17.9 14.4833C17.5667 15.2611 17.1056 15.9444 16.5167 16.5333C15.9389 17.1111 15.2611 17.5667 14.4833 17.9C13.7167 18.2333 12.8889 18.4 12 18.4ZM12 17.2C13.4444 17.2 14.6722 16.6944 15.6833 15.6833C16.6944 14.6722 17.2 13.4444 17.2 12C17.2 10.5556 16.6944 9.32778 15.6833 8.31667C14.6722 7.30555 13.4444 6.8 12 6.8C10.5556 6.8 9.32778 7.30555 8.31667 8.31667C7.30556 9.32778 6.8 10.5556 6.8 12C6.8 13.4444 7.30556 14.6722 8.31667 15.6833C9.32778 16.6944 10.5556 17.2 12 17.2Z" fill="#212121"/>
</g>
<defs>
<clipPath id="clip0_6083_34804">
<rect width="24" height="24" fill="white"/>
</clipPath>
</defs>`,k.innerText="Preview backend running in this workspace."),k.setAttribute("id",_)}document.readyState==="loading"?window.addEventListener("DOMContentLoaded",y):y()}function Lt(){return typeof navigator<"u"&&typeof navigator.userAgent=="string"?navigator.userAgent:""}function Cf(){return typeof window<"u"&&!!(window.cordova||window.phonegap||window.PhoneGap)&&/ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(Lt())}function ZC(){return typeof navigator<"u"&&navigator.userAgent==="Cloudflare-Workers"}function e5(){const n=typeof chrome=="object"?chrome.runtime:typeof browser=="object"?browser.runtime:void 0;return typeof n=="object"&&n.id!==void 0}function Y2(){return typeof navigator=="object"&&navigator.product==="ReactNative"}function t5(){const n=Lt();return n.indexOf("MSIE ")>=0||n.indexOf("Trident/")>=0}function n5(){return I2.NODE_ADMIN===!0}function i5(){try{return typeof indexedDB=="object"}catch{return!1}}function a5(){return new Promise((n,e)=>{try{let i=!0;const r="validate-browser-context-for-indexeddb-analytics-module",o=self.indexedDB.open(r);o.onsuccess=()=>{o.result.close(),i||self.indexedDB.deleteDatabase(r),n(!0)},o.onupgradeneeded=()=>{i=!1},o.onerror=()=>{e(o.error?.message||"")}}catch(i){e(i)}})}const r5="FirebaseError";class Si extends Error{constructor(e,i,r){super(i),this.code=e,this.customData=r,this.name=r5,Object.setPrototypeOf(this,Si.prototype),Error.captureStackTrace&&Error.captureStackTrace(this,eu.prototype.create)}}class eu{constructor(e,i,r){this.service=e,this.serviceName=i,this.errors=r}create(e,...i){const r=i[0]||{},o=`${this.service}/${e}`,l=this.errors[e],p=l?s5(l,r):"Error",m=`${this.serviceName}: ${p} (${o}).`;return new Si(o,m,r)}}function s5(n,e){return n.replace(o5,(i,r)=>{const o=e[r];return o!=null?String(o):`<${r}?>`})}const o5=/\{\$([^}]+)}/g;function Uo(n){return JSON.parse(n)}function xt(n){return JSON.stringify(n)}const G2=function(n){let e={},i={},r={},o="";try{const l=n.split(".");e=Uo(Wl(l[0])||""),i=Uo(Wl(l[1])||""),o=l[2],r=i.d||{},delete i.d}catch{}return{header:e,claims:i,data:r,signature:o}},u5=function(n){const e=G2(n),i=e.claims;return!!i&&typeof i=="object"&&i.hasOwnProperty("iat")},l5=function(n){const e=G2(n).claims;return typeof e=="object"&&e.admin===!0};function Yn(n,e){return Object.prototype.hasOwnProperty.call(n,e)}function is(n,e){if(Object.prototype.hasOwnProperty.call(n,e))return n[e]}function Kl(n){for(const e in n)if(Object.prototype.hasOwnProperty.call(n,e))return!1;return!0}function Xl(n,e,i){const r={};for(const o in n)Object.prototype.hasOwnProperty.call(n,o)&&(r[o]=e.call(i,n[o],o,n));return r}function Ga(n,e){if(n===e)return!0;const i=Object.keys(n),r=Object.keys(e);for(const o of i){if(!r.includes(o))return!1;const l=n[o],p=e[o];if(Hg(l)&&Hg(p)){if(!Ga(l,p))return!1}else if(l!==p)return!1}for(const o of r)if(!i.includes(o))return!1;return!0}function Hg(n){return n!==null&&typeof n=="object"}function hs(n){const e=[];for(const[i,r]of Object.entries(n))Array.isArray(r)?r.forEach(o=>{e.push(encodeURIComponent(i)+"="+encodeURIComponent(o))}):e.push(encodeURIComponent(i)+"="+encodeURIComponent(r));return e.length?"&"+e.join("&"):""}function Co(n){const e={};return n.replace(/^\?/,"").split("&").forEach(r=>{if(r){const[o,l]=r.split("=");e[decodeURIComponent(o)]=decodeURIComponent(l)}}),e}function _o(n){const e=n.indexOf("?");if(!e)return"";const i=n.indexOf("#",e);return n.substring(e,i>0?i:void 0)}class c5{constructor(){this.chain_=[],this.buf_=[],this.W_=[],this.pad_=[],this.inbuf_=0,this.total_=0,this.blockSize=512/8,this.pad_[0]=128;for(let e=1;e<this.blockSize;++e)this.pad_[e]=0;this.reset()}reset(){this.chain_[0]=1732584193,this.chain_[1]=4023233417,this.chain_[2]=2562383102,this.chain_[3]=271733878,this.chain_[4]=3285377520,this.inbuf_=0,this.total_=0}compress_(e,i){i||(i=0);const r=this.W_;if(typeof e=="string")for(let y=0;y<16;y++)r[y]=e.charCodeAt(i)<<24|e.charCodeAt(i+1)<<16|e.charCodeAt(i+2)<<8|e.charCodeAt(i+3),i+=4;else for(let y=0;y<16;y++)r[y]=e[i]<<24|e[i+1]<<16|e[i+2]<<8|e[i+3],i+=4;for(let y=16;y<80;y++){const v=r[y-3]^r[y-8]^r[y-14]^r[y-16];r[y]=(v<<1|v>>>31)&4294967295}let o=this.chain_[0],l=this.chain_[1],p=this.chain_[2],m=this.chain_[3],h=this.chain_[4],x,O;for(let y=0;y<80;y++){y<40?y<20?(x=m^l&(p^m),O=1518500249):(x=l^p^m,O=1859775393):y<60?(x=l&p|m&(l|p),O=2400959708):(x=l^p^m,O=3395469782);const v=(o<<5|o>>>27)+x+h+O+r[y]&4294967295;h=m,m=p,p=(l<<30|l>>>2)&4294967295,l=o,o=v}this.chain_[0]=this.chain_[0]+o&4294967295,this.chain_[1]=this.chain_[1]+l&4294967295,this.chain_[2]=this.chain_[2]+p&4294967295,this.chain_[3]=this.chain_[3]+m&4294967295,this.chain_[4]=this.chain_[4]+h&4294967295}update(e,i){if(e==null)return;i===void 0&&(i=e.length);const r=i-this.blockSize;let o=0;const l=this.buf_;let p=this.inbuf_;for(;o<i;){if(p===0)for(;o<=r;)this.compress_(e,o),o+=this.blockSize;if(typeof e=="string"){for(;o<i;)if(l[p]=e.charCodeAt(o),++p,++o,p===this.blockSize){this.compress_(l),p=0;break}}else for(;o<i;)if(l[p]=e[o],++p,++o,p===this.blockSize){this.compress_(l),p=0;break}}this.inbuf_=p,this.total_+=i}digest(){const e=[];let i=this.total_*8;this.inbuf_<56?this.update(this.pad_,56-this.inbuf_):this.update(this.pad_,this.blockSize-(this.inbuf_-56));for(let o=this.blockSize-1;o>=56;o--)this.buf_[o]=i&255,i/=256;this.compress_(this.buf_);let r=0;for(let o=0;o<5;o++)for(let l=24;l>=0;l-=8)e[r]=this.chain_[o]>>l&255,++r;return e}}function p5(n,e){const i=new d5(n,e);return i.subscribe.bind(i)}class d5{constructor(e,i){this.observers=[],this.unsubscribes=[],this.observerCount=0,this.task=Promise.resolve(),this.finalized=!1,this.onNoObservers=i,this.task.then(()=>{e(this)}).catch(r=>{this.error(r)})}next(e){this.forEachObserver(i=>{i.next(e)})}error(e){this.forEachObserver(i=>{i.error(e)}),this.close(e)}complete(){this.forEachObserver(e=>{e.complete()}),this.close()}subscribe(e,i,r){let o;if(e===void 0&&i===void 0&&r===void 0)throw new Error("Missing Observer.");m5(e,["next","error","complete"])?o=e:o={next:e,error:i,complete:r},o.next===void 0&&(o.next=gm),o.error===void 0&&(o.error=gm),o.complete===void 0&&(o.complete=gm);const l=this.unsubscribeOne.bind(this,this.observers.length);return this.finalized&&this.task.then(()=>{try{this.finalError?o.error(this.finalError):o.complete()}catch{}}),this.observers.push(o),l}unsubscribeOne(e){this.observers===void 0||this.observers[e]===void 0||(delete this.observers[e],this.observerCount-=1,this.observerCount===0&&this.onNoObservers!==void 0&&this.onNoObservers(this))}forEachObserver(e){if(!this.finalized)for(let i=0;i<this.observers.length;i++)this.sendOne(i,e)}sendOne(e,i){this.task.then(()=>{if(this.observers!==void 0&&this.observers[e]!==void 0)try{i(this.observers[e])}catch(r){typeof console<"u"&&console.error&&console.error(r)}})}close(e){this.finalized||(this.finalized=!0,e!==void 0&&(this.finalError=e),this.task.then(()=>{this.observers=void 0,this.onNoObservers=void 0}))}}function m5(n,e){if(typeof n!="object"||n===null)return!1;for(const i of e)if(i in n&&typeof n[i]=="function")return!0;return!1}function gm(){}function as(n,e){return`${n} failed: ${e} argument `}const f5=function(n){const e=[];let i=0;for(let r=0;r<n.length;r++){let o=n.charCodeAt(r);if(o>=55296&&o<=56319){const l=o-55296;r++,G(r<n.length,"Surrogate pair missing trail surrogate.");const p=n.charCodeAt(r)-56320;o=65536+(l<<10)+p}o<128?e[i++]=o:o<2048?(e[i++]=o>>6|192,e[i++]=o&63|128):o<65536?(e[i++]=o>>12|224,e[i++]=o>>6&63|128,e[i++]=o&63|128):(e[i++]=o>>18|240,e[i++]=o>>12&63|128,e[i++]=o>>6&63|128,e[i++]=o&63|128)}return e},Tc=function(n){let e=0;for(let i=0;i<n.length;i++){const r=n.charCodeAt(i);r<128?e++:r<2048?e+=2:r>=55296&&r<=56319?(e+=4,i++):e+=3}return e};function at(n){return n&&n._delegate?n._delegate:n}class la{constructor(e,i,r){this.name=e,this.instanceFactory=i,this.type=r,this.multipleInstances=!1,this.serviceProps={},this.instantiationMode="LAZY",this.onInstanceCreated=null}setInstantiationMode(e){return this.instantiationMode=e,this}setMultipleInstances(e){return this.multipleInstances=e,this}setServiceProps(e){return this.serviceProps=e,this}setInstanceCreatedCallback(e){return this.onInstanceCreated=e,this}}const Ba="[DEFAULT]";class h5{constructor(e,i){this.name=e,this.container=i,this.component=null,this.instances=new Map,this.instancesDeferred=new Map,this.instancesOptions=new Map,this.onInitCallbacks=new Map}get(e){const i=this.normalizeInstanceIdentifier(e);if(!this.instancesDeferred.has(i)){const r=new Pn;if(this.instancesDeferred.set(i,r),this.isInitialized(i)||this.shouldAutoInitialize())try{const o=this.getOrInitializeService({instanceIdentifier:i});o&&r.resolve(o)}catch{}}return this.instancesDeferred.get(i).promise}getImmediate(e){const i=this.normalizeInstanceIdentifier(e?.identifier),r=e?.optional??!1;if(this.isInitialized(i)||this.shouldAutoInitialize())try{return this.getOrInitializeService({instanceIdentifier:i})}catch(o){if(r)return null;throw o}else{if(r)return null;throw Error(`Service ${this.name} is not available`)}}getComponent(){return this.component}setComponent(e){if(e.name!==this.name)throw Error(`Mismatching Component ${e.name} for Provider ${this.name}.`);if(this.component)throw Error(`Component for ${this.name} has already been provided`);if(this.component=e,!!this.shouldAutoInitialize()){if(g5(e))try{this.getOrInitializeService({instanceIdentifier:Ba})}catch{}for(const[i,r]of this.instancesDeferred.entries()){const o=this.normalizeInstanceIdentifier(i);try{const l=this.getOrInitializeService({instanceIdentifier:o});r.resolve(l)}catch{}}}}clearInstance(e=Ba){this.instancesDeferred.delete(e),this.instancesOptions.delete(e),this.instances.delete(e)}async delete(){const e=Array.from(this.instances.values());await Promise.all([...e.filter(i=>"INTERNAL"in i).map(i=>i.INTERNAL.delete()),...e.filter(i=>"_delete"in i).map(i=>i._delete())])}isComponentSet(){return this.component!=null}isInitialized(e=Ba){return this.instances.has(e)}getOptions(e=Ba){return this.instancesOptions.get(e)||{}}initialize(e={}){const{options:i={}}=e,r=this.normalizeInstanceIdentifier(e.instanceIdentifier);if(this.isInitialized(r))throw Error(`${this.name}(${r}) has already been initialized`);if(!this.isComponentSet())throw Error(`Component ${this.name} has not been registered yet`);const o=this.getOrInitializeService({instanceIdentifier:r,options:i});for(const[l,p]of this.instancesDeferred.entries()){const m=this.normalizeInstanceIdentifier(l);r===m&&p.resolve(o)}return o}onInit(e,i){const r=this.normalizeInstanceIdentifier(i),o=this.onInitCallbacks.get(r)??new Set;o.add(e),this.onInitCallbacks.set(r,o);const l=this.instances.get(r);return l&&e(l,r),()=>{o.delete(e)}}invokeOnInitCallbacks(e,i){const r=this.onInitCallbacks.get(i);if(r)for(const o of r)try{o(e,i)}catch{}}getOrInitializeService({instanceIdentifier:e,options:i={}}){let r=this.instances.get(e);if(!r&&this.component&&(r=this.component.instanceFactory(this.container,{instanceIdentifier:x5(e),options:i}),this.instances.set(e,r),this.instancesOptions.set(e,i),this.invokeOnInitCallbacks(r,e),this.component.onInstanceCreated))try{this.component.onInstanceCreated(this.container,e,r)}catch{}return r||null}normalizeInstanceIdentifier(e=Ba){return this.component?this.component.multipleInstances?e:Ba:e}shouldAutoInitialize(){return!!this.component&&this.component.instantiationMode!=="EXPLICIT"}}function x5(n){return n===Ba?void 0:n}function g5(n){return n.instantiationMode==="EAGER"}class y5{constructor(e){this.name=e,this.providers=new Map}addComponent(e){const i=this.getProvider(e.name);if(i.isComponentSet())throw new Error(`Component ${e.name} has already been registered with ${this.name}`);i.setComponent(e)}addOrOverwriteComponent(e){this.getProvider(e.name).isComponentSet()&&this.providers.delete(e.name),this.addComponent(e)}getProvider(e){if(this.providers.has(e))return this.providers.get(e);const i=new h5(e,this);return this.providers.set(e,i),i}getProviders(){return Array.from(this.providers.values())}}var He;(function(n){n[n.DEBUG=0]="DEBUG",n[n.VERBOSE=1]="VERBOSE",n[n.INFO=2]="INFO",n[n.WARN=3]="WARN",n[n.ERROR=4]="ERROR",n[n.SILENT=5]="SILENT"})(He||(He={}));const O5={debug:He.DEBUG,verbose:He.VERBOSE,info:He.INFO,warn:He.WARN,error:He.ERROR,silent:He.SILENT},v5=He.INFO,b5={[He.DEBUG]:"log",[He.VERBOSE]:"log",[He.INFO]:"info",[He.WARN]:"warn",[He.ERROR]:"error"},S5=(n,e,...i)=>{if(e<n.logLevel)return;const r=new Date().toISOString(),o=b5[e];if(o)console[o](`[${r}]  ${n.name}:`,...i);else throw new Error(`Attempted to log a message with an invalid logType (value: ${e})`)};class _f{constructor(e){this.name=e,this._logLevel=v5,this._logHandler=S5,this._userLogHandler=null}get logLevel(){return this._logLevel}set logLevel(e){if(!(e in He))throw new TypeError(`Invalid value "${e}" assigned to \`logLevel\``);this._logLevel=e}setLogLevel(e){this._logLevel=typeof e=="string"?O5[e]:e}get logHandler(){return this._logHandler}set logHandler(e){if(typeof e!="function")throw new TypeError("Value assigned to `logHandler` must be a function");this._logHandler=e}get userLogHandler(){return this._userLogHandler}set userLogHandler(e){this._userLogHandler=e}debug(...e){this._userLogHandler&&this._userLogHandler(this,He.DEBUG,...e),this._logHandler(this,He.DEBUG,...e)}log(...e){this._userLogHandler&&this._userLogHandler(this,He.VERBOSE,...e),this._logHandler(this,He.VERBOSE,...e)}info(...e){this._userLogHandler&&this._userLogHandler(this,He.INFO,...e),this._logHandler(this,He.INFO,...e)}warn(...e){this._userLogHandler&&this._userLogHandler(this,He.WARN,...e),this._logHandler(this,He.WARN,...e)}error(...e){this._userLogHandler&&this._userLogHandler(this,He.ERROR,...e),this._logHandler(this,He.ERROR,...e)}}const w5=(n,e)=>e.some(i=>n instanceof i);let Yg,Gg;function C5(){return Yg||(Yg=[IDBDatabase,IDBObjectStore,IDBIndex,IDBCursor,IDBTransaction])}function _5(){return Gg||(Gg=[IDBCursor.prototype.advance,IDBCursor.prototype.continue,IDBCursor.prototype.continuePrimaryKey])}const V2=new WeakMap,Bm=new WeakMap,W2=new WeakMap,ym=new WeakMap,Tf=new WeakMap;function T5(n){const e=new Promise((i,r)=>{const o=()=>{n.removeEventListener("success",l),n.removeEventListener("error",p)},l=()=>{i(aa(n.result)),o()},p=()=>{r(n.error),o()};n.addEventListener("success",l),n.addEventListener("error",p)});return e.then(i=>{i instanceof IDBCursor&&V2.set(i,n)}).catch(()=>{}),Tf.set(e,n),e}function N5(n){if(Bm.has(n))return;const e=new Promise((i,r)=>{const o=()=>{n.removeEventListener("complete",l),n.removeEventListener("error",p),n.removeEventListener("abort",p)},l=()=>{i(),o()},p=()=>{r(n.error||new DOMException("AbortError","AbortError")),o()};n.addEventListener("complete",l),n.addEventListener("error",p),n.addEventListener("abort",p)});Bm.set(n,e)}let Um={get(n,e,i){if(n instanceof IDBTransaction){if(e==="done")return Bm.get(n);if(e==="objectStoreNames")return n.objectStoreNames||W2.get(n);if(e==="store")return i.objectStoreNames[1]?void 0:i.objectStore(i.objectStoreNames[0])}return aa(n[e])},set(n,e,i){return n[e]=i,!0},has(n,e){return n instanceof IDBTransaction&&(e==="done"||e==="store")?!0:e in n}};function k5(n){Um=n(Um)}function E5(n){return n===IDBDatabase.prototype.transaction&&!("objectStoreNames"in IDBTransaction.prototype)?function(e,...i){const r=n.call(Om(this),e,...i);return W2.set(r,e.sort?e.sort():[e]),aa(r)}:_5().includes(n)?function(...e){return n.apply(Om(this),e),aa(V2.get(this))}:function(...e){return aa(n.apply(Om(this),e))}}function A5(n){return typeof n=="function"?E5(n):(n instanceof IDBTransaction&&N5(n),w5(n,C5())?new Proxy(n,Um):n)}function aa(n){if(n instanceof IDBRequest)return T5(n);if(ym.has(n))return ym.get(n);const e=A5(n);return e!==n&&(ym.set(n,e),Tf.set(e,n)),e}const Om=n=>Tf.get(n);function j5(n,e,{blocked:i,upgrade:r,blocking:o,terminated:l}={}){const p=indexedDB.open(n,e),m=aa(p);return r&&p.addEventListener("upgradeneeded",h=>{r(aa(p.result),h.oldVersion,h.newVersion,aa(p.transaction),h)}),i&&p.addEventListener("blocked",h=>i(h.oldVersion,h.newVersion,h)),m.then(h=>{l&&h.addEventListener("close",()=>l()),o&&h.addEventListener("versionchange",x=>o(x.oldVersion,x.newVersion,x))}).catch(()=>{}),m}const M5=["get","getKey","getAll","getAllKeys","count"],R5=["put","add","delete","clear"],vm=new Map;function Vg(n,e){if(!(n instanceof IDBDatabase&&!(e in n)&&typeof e=="string"))return;if(vm.get(e))return vm.get(e);const i=e.replace(/FromIndex$/,""),r=e!==i,o=R5.includes(i);if(!(i in(r?IDBIndex:IDBObjectStore).prototype)||!(o||M5.includes(i)))return;const l=async function(p,...m){const h=this.transaction(p,o?"readwrite":"readonly");let x=h.store;return r&&(x=x.index(m.shift())),(await Promise.all([x[i](...m),o&&h.done]))[0]};return vm.set(e,l),l}k5(n=>({...n,get:(e,i,r)=>Vg(e,i)||n.get(e,i,r),has:(e,i)=>!!Vg(e,i)||n.has(e,i)}));class D5{constructor(e){this.container=e}getPlatformInfoString(){return this.container.getProviders().map(i=>{if(I5(i)){const r=i.getImmediate();return`${r.library}/${r.version}`}else return null}).filter(i=>i).join(" ")}}function I5(n){return n.getComponent()?.type==="VERSION"}const zm="@firebase/app",Wg="0.14.6";const Oi=new _f("@firebase/app"),L5="@firebase/app-compat",P5="@firebase/analytics-compat",B5="@firebase/analytics",U5="@firebase/app-check-compat",z5="@firebase/app-check",F5="@firebase/auth",q5="@firebase/auth-compat",H5="@firebase/database",Y5="@firebase/data-connect",G5="@firebase/database-compat",V5="@firebase/functions",W5="@firebase/functions-compat",K5="@firebase/installations",X5="@firebase/installations-compat",Q5="@firebase/messaging",J5="@firebase/messaging-compat",$5="@firebase/performance",Z5="@firebase/performance-compat",e4="@firebase/remote-config",t4="@firebase/remote-config-compat",n4="@firebase/storage",i4="@firebase/storage-compat",a4="@firebase/firestore",r4="@firebase/ai",s4="@firebase/firestore-compat",o4="firebase",u4="12.6.0";const Fm="[DEFAULT]",l4={[zm]:"fire-core",[L5]:"fire-core-compat",[B5]:"fire-analytics",[P5]:"fire-analytics-compat",[z5]:"fire-app-check",[U5]:"fire-app-check-compat",[F5]:"fire-auth",[q5]:"fire-auth-compat",[H5]:"fire-rtdb",[Y5]:"fire-data-connect",[G5]:"fire-rtdb-compat",[V5]:"fire-fn",[W5]:"fire-fn-compat",[K5]:"fire-iid",[X5]:"fire-iid-compat",[Q5]:"fire-fcm",[J5]:"fire-fcm-compat",[$5]:"fire-perf",[Z5]:"fire-perf-compat",[e4]:"fire-rc",[t4]:"fire-rc-compat",[n4]:"fire-gcs",[i4]:"fire-gcs-compat",[a4]:"fire-fst",[s4]:"fire-fst-compat",[r4]:"fire-vertex","fire-js":"fire-js",[o4]:"fire-js-all"};const Ql=new Map,c4=new Map,qm=new Map;function Kg(n,e){try{n.container.addComponent(e)}catch(i){Oi.debug(`Component ${e.name} failed to register with FirebaseApp ${n.name}`,i)}}function Va(n){const e=n.name;if(qm.has(e))return Oi.debug(`There were multiple attempts to register component ${e}.`),!1;qm.set(e,n);for(const i of Ql.values())Kg(i,n);for(const i of c4.values())Kg(i,n);return!0}function Nc(n,e){const i=n.container.getProvider("heartbeat").getImmediate({optional:!0});return i&&i.triggerHeartbeat(),n.container.getProvider(e)}function Vt(n){return n==null?!1:n.settings!==void 0}const p4={"no-app":"No Firebase App '{$appName}' has been created - call initializeApp() first","bad-app-name":"Illegal App name: '{$appName}'","duplicate-app":"Firebase App named '{$appName}' already exists with different options or config","app-deleted":"Firebase App named '{$appName}' already deleted","server-app-deleted":"Firebase Server App has been deleted","no-options":"Need to provide options, when not being deployed to hosting via source.","invalid-app-argument":"firebase.{$appName}() takes either no argument or a Firebase App instance.","invalid-log-argument":"First argument to `onLog` must be null or a function.","idb-open":"Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.","idb-get":"Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.","idb-set":"Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.","idb-delete":"Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}.","finalization-registry-not-supported":"FirebaseServerApp deleteOnDeref field defined but the JS runtime does not support FinalizationRegistry.","invalid-server-app-environment":"FirebaseServerApp is not for use in browser environments."},ra=new eu("app","Firebase",p4);class d4{constructor(e,i,r){this._isDeleted=!1,this._options={...e},this._config={...i},this._name=i.name,this._automaticDataCollectionEnabled=i.automaticDataCollectionEnabled,this._container=r,this.container.addComponent(new la("app",()=>this,"PUBLIC"))}get automaticDataCollectionEnabled(){return this.checkDestroyed(),this._automaticDataCollectionEnabled}set automaticDataCollectionEnabled(e){this.checkDestroyed(),this._automaticDataCollectionEnabled=e}get name(){return this.checkDestroyed(),this._name}get options(){return this.checkDestroyed(),this._options}get config(){return this.checkDestroyed(),this._config}get container(){return this._container}get isDeleted(){return this._isDeleted}set isDeleted(e){this._isDeleted=e}checkDestroyed(){if(this.isDeleted)throw ra.create("app-deleted",{appName:this._name})}}const er=u4;function K2(n,e={}){let i=n;typeof e!="object"&&(e={name:e});const r={name:Fm,automaticDataCollectionEnabled:!0,...e},o=r.name;if(typeof o!="string"||!o)throw ra.create("bad-app-name",{appName:String(o)});if(i||(i=F2()),!i)throw ra.create("no-options");const l=Ql.get(o);if(l){if(Ga(i,l.options)&&Ga(r,l.config))return l;throw ra.create("duplicate-app",{appName:o})}const p=new y5(o);for(const h of qm.values())p.addComponent(h);const m=new d4(i,r,p);return Ql.set(o,m),m}function Nf(n=Fm){const e=Ql.get(n);if(!e&&n===Fm&&F2())return K2();if(!e)throw ra.create("no-app",{appName:n});return e}function Un(n,e,i){let r=l4[n]??n;i&&(r+=`-${i}`);const o=r.match(/\s|\//),l=e.match(/\s|\//);if(o||l){const p=[`Unable to register library "${r}" with version "${e}":`];o&&p.push(`library name "${r}" contains illegal characters (whitespace or "/")`),o&&l&&p.push("and"),l&&p.push(`version name "${e}" contains illegal characters (whitespace or "/")`),Oi.warn(p.join(" "));return}Va(new la(`${r}-version`,()=>({library:r,version:e}),"VERSION"))}const m4="firebase-heartbeat-database",f4=1,zo="firebase-heartbeat-store";let bm=null;function X2(){return bm||(bm=j5(m4,f4,{upgrade:(n,e)=>{switch(e){case 0:try{n.createObjectStore(zo)}catch(i){console.warn(i)}}}}).catch(n=>{throw ra.create("idb-open",{originalErrorMessage:n.message})})),bm}async function h4(n){try{const i=(await X2()).transaction(zo),r=await i.objectStore(zo).get(Q2(n));return await i.done,r}catch(e){if(e instanceof Si)Oi.warn(e.message);else{const i=ra.create("idb-get",{originalErrorMessage:e?.message});Oi.warn(i.message)}}}async function Xg(n,e){try{const r=(await X2()).transaction(zo,"readwrite");await r.objectStore(zo).put(e,Q2(n)),await r.done}catch(i){if(i instanceof Si)Oi.warn(i.message);else{const r=ra.create("idb-set",{originalErrorMessage:i?.message});Oi.warn(r.message)}}}function Q2(n){return`${n.name}!${n.options.appId}`}const x4=1024,g4=30;class y4{constructor(e){this.container=e,this._heartbeatsCache=null;const i=this.container.getProvider("app").getImmediate();this._storage=new v4(i),this._heartbeatsCachePromise=this._storage.read().then(r=>(this._heartbeatsCache=r,r))}async triggerHeartbeat(){try{const i=this.container.getProvider("platform-logger").getImmediate().getPlatformInfoString(),r=Qg();if(this._heartbeatsCache?.heartbeats==null&&(this._heartbeatsCache=await this._heartbeatsCachePromise,this._heartbeatsCache?.heartbeats==null)||this._heartbeatsCache.lastSentHeartbeatDate===r||this._heartbeatsCache.heartbeats.some(o=>o.date===r))return;if(this._heartbeatsCache.heartbeats.push({date:r,agent:i}),this._heartbeatsCache.heartbeats.length>g4){const o=b4(this._heartbeatsCache.heartbeats);this._heartbeatsCache.heartbeats.splice(o,1)}return this._storage.overwrite(this._heartbeatsCache)}catch(e){Oi.warn(e)}}async getHeartbeatsHeader(){try{if(this._heartbeatsCache===null&&await this._heartbeatsCachePromise,this._heartbeatsCache?.heartbeats==null||this._heartbeatsCache.heartbeats.length===0)return"";const e=Qg(),{heartbeatsToSend:i,unsentEntries:r}=O4(this._heartbeatsCache.heartbeats),o=Vl(JSON.stringify({version:2,heartbeats:i}));return this._heartbeatsCache.lastSentHeartbeatDate=e,r.length>0?(this._heartbeatsCache.heartbeats=r,await this._storage.overwrite(this._heartbeatsCache)):(this._heartbeatsCache.heartbeats=[],this._storage.overwrite(this._heartbeatsCache)),o}catch(e){return Oi.warn(e),""}}}function Qg(){return new Date().toISOString().substring(0,10)}function O4(n,e=x4){const i=[];let r=n.slice();for(const o of n){const l=i.find(p=>p.agent===o.agent);if(l){if(l.dates.push(o.date),Jg(i)>e){l.dates.pop();break}}else if(i.push({agent:o.agent,dates:[o.date]}),Jg(i)>e){i.pop();break}r=r.slice(1)}return{heartbeatsToSend:i,unsentEntries:r}}class v4{constructor(e){this.app=e,this._canUseIndexedDBPromise=this.runIndexedDBEnvironmentCheck()}async runIndexedDBEnvironmentCheck(){return i5()?a5().then(()=>!0).catch(()=>!1):!1}async read(){if(await this._canUseIndexedDBPromise){const i=await h4(this.app);return i?.heartbeats?i:{heartbeats:[]}}else return{heartbeats:[]}}async overwrite(e){if(await this._canUseIndexedDBPromise){const r=await this.read();return Xg(this.app,{lastSentHeartbeatDate:e.lastSentHeartbeatDate??r.lastSentHeartbeatDate,heartbeats:e.heartbeats})}else return}async add(e){if(await this._canUseIndexedDBPromise){const r=await this.read();return Xg(this.app,{lastSentHeartbeatDate:e.lastSentHeartbeatDate??r.lastSentHeartbeatDate,heartbeats:[...r.heartbeats,...e.heartbeats]})}else return}}function Jg(n){return Vl(JSON.stringify({version:2,heartbeats:n})).length}function b4(n){if(n.length===0)return-1;let e=0,i=n[0].date;for(let r=1;r<n.length;r++)n[r].date<i&&(i=n[r].date,e=r);return e}function S4(n){Va(new la("platform-logger",e=>new D5(e),"PRIVATE")),Va(new la("heartbeat",e=>new y4(e),"PRIVATE")),Un(zm,Wg,n),Un(zm,Wg,"esm2020"),Un("fire-js","")}S4("");var w4="firebase",C4="12.7.0";Un(w4,C4,"app");function J2(){return{"dependent-sdk-initialized-before-auth":"Another Firebase SDK was initialized and is trying to use Auth before Auth is initialized. Please be sure to call `initializeAuth` or `getAuth` before starting any other Firebase SDK."}}const _4=J2,$2=new eu("auth","Firebase",J2());const Jl=new _f("@firebase/auth");function T4(n,...e){Jl.logLevel<=He.WARN&&Jl.warn(`Auth (${er}): ${n}`,...e)}function zl(n,...e){Jl.logLevel<=He.ERROR&&Jl.error(`Auth (${er}): ${n}`,...e)}function vn(n,...e){throw Ef(n,...e)}function An(n,...e){return Ef(n,...e)}function kf(n,e,i){const r={..._4(),[e]:i};return new eu("auth","Firebase",r).create(e,{appName:n.name})}function xi(n){return kf(n,"operation-not-supported-in-this-environment","Operations that alter the current user are not supported in conjunction with FirebaseServerApp")}function N4(n,e,i){const r=i;if(!(e instanceof r))throw r.name!==e.constructor.name&&vn(n,"argument-error"),kf(n,"argument-error",`Type of ${e.constructor.name} does not match expected instance.Did you pass a reference from a different Auth SDK?`)}function Ef(n,...e){if(typeof n!="string"){const i=e[0],r=[...e.slice(1)];return r[0]&&(r[0].appName=n.name),n._errorFactory.create(i,...r)}return $2.create(n,...e)}function ue(n,e,...i){if(!n)throw Ef(e,...i)}function di(n){const e="INTERNAL ASSERTION FAILED: "+n;throw zl(e),new Error(e)}function vi(n,e){n||di(e)}function Hm(){return typeof self<"u"&&self.location?.href||""}function k4(){return $g()==="http:"||$g()==="https:"}function $g(){return typeof self<"u"&&self.location?.protocol||null}function E4(){return typeof navigator<"u"&&navigator&&"onLine"in navigator&&typeof navigator.onLine=="boolean"&&(k4()||e5()||"connection"in navigator)?navigator.onLine:!0}function A4(){if(typeof navigator>"u")return null;const n=navigator;return n.languages&&n.languages[0]||n.language||null}class tu{constructor(e,i){this.shortDelay=e,this.longDelay=i,vi(i>e,"Short delay should be less than long delay!"),this.isMobile=Cf()||Y2()}get(){return E4()?this.isMobile?this.longDelay:this.shortDelay:Math.min(5e3,this.shortDelay)}}function Af(n,e){vi(n.emulator,"Emulator should always be set here");const{url:i}=n.emulator;return e?`${i}${e.startsWith("/")?e.slice(1):e}`:i}class Z2{static initialize(e,i,r){this.fetchImpl=e,i&&(this.headersImpl=i),r&&(this.responseImpl=r)}static fetch(){if(this.fetchImpl)return this.fetchImpl;if(typeof self<"u"&&"fetch"in self)return self.fetch;if(typeof globalThis<"u"&&globalThis.fetch)return globalThis.fetch;if(typeof fetch<"u")return fetch;di("Could not find fetch implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill")}static headers(){if(this.headersImpl)return this.headersImpl;if(typeof self<"u"&&"Headers"in self)return self.Headers;if(typeof globalThis<"u"&&globalThis.Headers)return globalThis.Headers;if(typeof Headers<"u")return Headers;di("Could not find Headers implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill")}static response(){if(this.responseImpl)return this.responseImpl;if(typeof self<"u"&&"Response"in self)return self.Response;if(typeof globalThis<"u"&&globalThis.Response)return globalThis.Response;if(typeof Response<"u")return Response;di("Could not find Response implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill")}}const j4={CREDENTIAL_MISMATCH:"custom-token-mismatch",MISSING_CUSTOM_TOKEN:"internal-error",INVALID_IDENTIFIER:"invalid-email",MISSING_CONTINUE_URI:"internal-error",INVALID_PASSWORD:"wrong-password",MISSING_PASSWORD:"missing-password",INVALID_LOGIN_CREDENTIALS:"invalid-credential",EMAIL_EXISTS:"email-already-in-use",PASSWORD_LOGIN_DISABLED:"operation-not-allowed",INVALID_IDP_RESPONSE:"invalid-credential",INVALID_PENDING_TOKEN:"invalid-credential",FEDERATED_USER_ID_ALREADY_LINKED:"credential-already-in-use",MISSING_REQ_TYPE:"internal-error",EMAIL_NOT_FOUND:"user-not-found",RESET_PASSWORD_EXCEED_LIMIT:"too-many-requests",EXPIRED_OOB_CODE:"expired-action-code",INVALID_OOB_CODE:"invalid-action-code",MISSING_OOB_CODE:"internal-error",CREDENTIAL_TOO_OLD_LOGIN_AGAIN:"requires-recent-login",INVALID_ID_TOKEN:"invalid-user-token",TOKEN_EXPIRED:"user-token-expired",USER_NOT_FOUND:"user-token-expired",TOO_MANY_ATTEMPTS_TRY_LATER:"too-many-requests",PASSWORD_DOES_NOT_MEET_REQUIREMENTS:"password-does-not-meet-requirements",INVALID_CODE:"invalid-verification-code",INVALID_SESSION_INFO:"invalid-verification-id",INVALID_TEMPORARY_PROOF:"invalid-credential",MISSING_SESSION_INFO:"missing-verification-id",SESSION_EXPIRED:"code-expired",MISSING_ANDROID_PACKAGE_NAME:"missing-android-pkg-name",UNAUTHORIZED_DOMAIN:"unauthorized-continue-uri",INVALID_OAUTH_CLIENT_ID:"invalid-oauth-client-id",ADMIN_ONLY_OPERATION:"admin-restricted-operation",INVALID_MFA_PENDING_CREDENTIAL:"invalid-multi-factor-session",MFA_ENROLLMENT_NOT_FOUND:"multi-factor-info-not-found",MISSING_MFA_ENROLLMENT_ID:"missing-multi-factor-info",MISSING_MFA_PENDING_CREDENTIAL:"missing-multi-factor-session",SECOND_FACTOR_EXISTS:"second-factor-already-in-use",SECOND_FACTOR_LIMIT_EXCEEDED:"maximum-second-factor-count-exceeded",BLOCKING_FUNCTION_ERROR_RESPONSE:"internal-error",RECAPTCHA_NOT_ENABLED:"recaptcha-not-enabled",MISSING_RECAPTCHA_TOKEN:"missing-recaptcha-token",INVALID_RECAPTCHA_TOKEN:"invalid-recaptcha-token",INVALID_RECAPTCHA_ACTION:"invalid-recaptcha-action",MISSING_CLIENT_TYPE:"missing-client-type",MISSING_RECAPTCHA_VERSION:"missing-recaptcha-version",INVALID_RECAPTCHA_VERSION:"invalid-recaptcha-version",INVALID_REQ_TYPE:"invalid-req-type"};const M4=["/v1/accounts:signInWithCustomToken","/v1/accounts:signInWithEmailLink","/v1/accounts:signInWithIdp","/v1/accounts:signInWithPassword","/v1/accounts:signInWithPhoneNumber","/v1/token"],R4=new tu(3e4,6e4);function ha(n,e){return n.tenantId&&!e.tenantId?{...e,tenantId:n.tenantId}:e}async function wi(n,e,i,r,o={}){return eO(n,o,async()=>{let l={},p={};r&&(e==="GET"?p=r:l={body:JSON.stringify(r)});const m=hs({key:n.config.apiKey,...p}).slice(1),h=await n._getAdditionalHeaders();h["Content-Type"]="application/json",n.languageCode&&(h["X-Firebase-Locale"]=n.languageCode);const x={method:e,headers:h,...l};return ZC()||(x.referrerPolicy="no-referrer"),n.emulatorConfig&&fa(n.emulatorConfig.host)&&(x.credentials="include"),Z2.fetch()(await tO(n,n.config.apiHost,i,m),x)})}async function eO(n,e,i){n._canInitEmulator=!1;const r={...j4,...e};try{const o=new I4(n),l=await Promise.race([i(),o.promise]);o.clearNetworkTimeout();const p=await l.json();if("needConfirmation"in p)throw Al(n,"account-exists-with-different-credential",p);if(l.ok&&!("errorMessage"in p))return p;{const m=l.ok?p.errorMessage:p.error.message,[h,x]=m.split(" : ");if(h==="FEDERATED_USER_ID_ALREADY_LINKED")throw Al(n,"credential-already-in-use",p);if(h==="EMAIL_EXISTS")throw Al(n,"email-already-in-use",p);if(h==="USER_DISABLED")throw Al(n,"user-disabled",p);const O=r[h]||h.toLowerCase().replace(/[_\s]+/g,"-");if(x)throw kf(n,O,x);vn(n,O)}}catch(o){if(o instanceof Si)throw o;vn(n,"network-request-failed",{message:String(o)})}}async function nu(n,e,i,r,o={}){const l=await wi(n,e,i,r,o);return"mfaPendingCredential"in l&&vn(n,"multi-factor-auth-required",{_serverResponse:l}),l}async function tO(n,e,i,r){const o=`${e}${i}?${r}`,l=n,p=l.config.emulator?Af(n.config,o):`${n.config.apiScheme}://${o}`;return M4.includes(i)&&(await l._persistenceManagerAvailable,l._getPersistenceType()==="COOKIE")?l._getPersistence()._getFinalTarget(p).toString():p}function D4(n){switch(n){case"ENFORCE":return"ENFORCE";case"AUDIT":return"AUDIT";case"OFF":return"OFF";default:return"ENFORCEMENT_STATE_UNSPECIFIED"}}class I4{clearNetworkTimeout(){clearTimeout(this.timer)}constructor(e){this.auth=e,this.timer=null,this.promise=new Promise((i,r)=>{this.timer=setTimeout(()=>r(An(this.auth,"network-request-failed")),R4.get())})}}function Al(n,e,i){const r={appName:n.name};i.email&&(r.email=i.email),i.phoneNumber&&(r.phoneNumber=i.phoneNumber);const o=An(n,e,r);return o.customData._tokenResponse=i,o}function Zg(n){return n!==void 0&&n.enterprise!==void 0}class L4{constructor(e){if(this.siteKey="",this.recaptchaEnforcementState=[],e.recaptchaKey===void 0)throw new Error("recaptchaKey undefined");this.siteKey=e.recaptchaKey.split("/")[3],this.recaptchaEnforcementState=e.recaptchaEnforcementState}getProviderEnforcementState(e){if(!this.recaptchaEnforcementState||this.recaptchaEnforcementState.length===0)return null;for(const i of this.recaptchaEnforcementState)if(i.provider&&i.provider===e)return D4(i.enforcementState);return null}isProviderEnabled(e){return this.getProviderEnforcementState(e)==="ENFORCE"||this.getProviderEnforcementState(e)==="AUDIT"}isAnyProviderEnabled(){return this.isProviderEnabled("EMAIL_PASSWORD_PROVIDER")||this.isProviderEnabled("PHONE_PROVIDER")}}async function P4(n,e){return wi(n,"GET","/v2/recaptchaConfig",ha(n,e))}async function B4(n,e){return wi(n,"POST","/v1/accounts:delete",e)}async function $l(n,e){return wi(n,"POST","/v1/accounts:lookup",e)}function Eo(n){if(n)try{const e=new Date(Number(n));if(!isNaN(e.getTime()))return e.toUTCString()}catch{}}async function U4(n,e=!1){const i=at(n),r=await i.getIdToken(e),o=jf(r);ue(o&&o.exp&&o.auth_time&&o.iat,i.auth,"internal-error");const l=typeof o.firebase=="object"?o.firebase:void 0,p=l?.sign_in_provider;return{claims:o,token:r,authTime:Eo(Sm(o.auth_time)),issuedAtTime:Eo(Sm(o.iat)),expirationTime:Eo(Sm(o.exp)),signInProvider:p||null,signInSecondFactor:l?.sign_in_second_factor||null}}function Sm(n){return Number(n)*1e3}function jf(n){const[e,i,r]=n.split(".");if(e===void 0||i===void 0||r===void 0)return zl("JWT malformed, contained fewer than 3 sections"),null;try{const o=Wl(i);return o?JSON.parse(o):(zl("Failed to decode base64 JWT payload"),null)}catch(o){return zl("Caught error parsing JWT payload as JSON",o?.toString()),null}}function ey(n){const e=jf(n);return ue(e,"internal-error"),ue(typeof e.exp<"u","internal-error"),ue(typeof e.iat<"u","internal-error"),Number(e.exp)-Number(e.iat)}async function rs(n,e,i=!1){if(i)return e;try{return await e}catch(r){throw r instanceof Si&&z4(r)&&n.auth.currentUser===n&&await n.auth.signOut(),r}}function z4({code:n}){return n==="auth/user-disabled"||n==="auth/user-token-expired"}class F4{constructor(e){this.user=e,this.isRunning=!1,this.timerId=null,this.errorBackoff=3e4}_start(){this.isRunning||(this.isRunning=!0,this.schedule())}_stop(){this.isRunning&&(this.isRunning=!1,this.timerId!==null&&clearTimeout(this.timerId))}getInterval(e){if(e){const i=this.errorBackoff;return this.errorBackoff=Math.min(this.errorBackoff*2,96e4),i}else{this.errorBackoff=3e4;const r=(this.user.stsTokenManager.expirationTime??0)-Date.now()-3e5;return Math.max(0,r)}}schedule(e=!1){if(!this.isRunning)return;const i=this.getInterval(e);this.timerId=setTimeout(async()=>{await this.iteration()},i)}async iteration(){try{await this.user.getIdToken(!0)}catch(e){e?.code==="auth/network-request-failed"&&this.schedule(!0);return}this.schedule()}}class Ym{constructor(e,i){this.createdAt=e,this.lastLoginAt=i,this._initializeTime()}_initializeTime(){this.lastSignInTime=Eo(this.lastLoginAt),this.creationTime=Eo(this.createdAt)}_copy(e){this.createdAt=e.createdAt,this.lastLoginAt=e.lastLoginAt,this._initializeTime()}toJSON(){return{createdAt:this.createdAt,lastLoginAt:this.lastLoginAt}}}async function Zl(n){const e=n.auth,i=await n.getIdToken(),r=await rs(n,$l(e,{idToken:i}));ue(r?.users.length,e,"internal-error");const o=r.users[0];n._notifyReloadListener(o);const l=o.providerUserInfo?.length?nO(o.providerUserInfo):[],p=H4(n.providerData,l),m=n.isAnonymous,h=!(n.email&&o.passwordHash)&&!p?.length,x=m?h:!1,O={uid:o.localId,displayName:o.displayName||null,photoURL:o.photoUrl||null,email:o.email||null,emailVerified:o.emailVerified||!1,phoneNumber:o.phoneNumber||null,tenantId:o.tenantId||null,providerData:p,metadata:new Ym(o.createdAt,o.lastLoginAt),isAnonymous:x};Object.assign(n,O)}async function q4(n){const e=at(n);await Zl(e),await e.auth._persistUserIfCurrent(e),e.auth._notifyListenersIfCurrent(e)}function H4(n,e){return[...n.filter(r=>!e.some(o=>o.providerId===r.providerId)),...e]}function nO(n){return n.map(({providerId:e,...i})=>({providerId:e,uid:i.rawId||"",displayName:i.displayName||null,email:i.email||null,phoneNumber:i.phoneNumber||null,photoURL:i.photoUrl||null}))}async function Y4(n,e){const i=await eO(n,{},async()=>{const r=hs({grant_type:"refresh_token",refresh_token:e}).slice(1),{tokenApiHost:o,apiKey:l}=n.config,p=await tO(n,o,"/v1/token",`key=${l}`),m=await n._getAdditionalHeaders();m["Content-Type"]="application/x-www-form-urlencoded";const h={method:"POST",headers:m,body:r};return n.emulatorConfig&&fa(n.emulatorConfig.host)&&(h.credentials="include"),Z2.fetch()(p,h)});return{accessToken:i.access_token,expiresIn:i.expires_in,refreshToken:i.refresh_token}}async function G4(n,e){return wi(n,"POST","/v2/accounts:revokeToken",ha(n,e))}class $r{constructor(){this.refreshToken=null,this.accessToken=null,this.expirationTime=null}get isExpired(){return!this.expirationTime||Date.now()>this.expirationTime-3e4}updateFromServerResponse(e){ue(e.idToken,"internal-error"),ue(typeof e.idToken<"u","internal-error"),ue(typeof e.refreshToken<"u","internal-error");const i="expiresIn"in e&&typeof e.expiresIn<"u"?Number(e.expiresIn):ey(e.idToken);this.updateTokensAndExpiration(e.idToken,e.refreshToken,i)}updateFromIdToken(e){ue(e.length!==0,"internal-error");const i=ey(e);this.updateTokensAndExpiration(e,null,i)}async getToken(e,i=!1){return!i&&this.accessToken&&!this.isExpired?this.accessToken:(ue(this.refreshToken,e,"user-token-expired"),this.refreshToken?(await this.refresh(e,this.refreshToken),this.accessToken):null)}clearRefreshToken(){this.refreshToken=null}async refresh(e,i){const{accessToken:r,refreshToken:o,expiresIn:l}=await Y4(e,i);this.updateTokensAndExpiration(r,o,Number(l))}updateTokensAndExpiration(e,i,r){this.refreshToken=i||null,this.accessToken=e||null,this.expirationTime=Date.now()+r*1e3}static fromJSON(e,i){const{refreshToken:r,accessToken:o,expirationTime:l}=i,p=new $r;return r&&(ue(typeof r=="string","internal-error",{appName:e}),p.refreshToken=r),o&&(ue(typeof o=="string","internal-error",{appName:e}),p.accessToken=o),l&&(ue(typeof l=="number","internal-error",{appName:e}),p.expirationTime=l),p}toJSON(){return{refreshToken:this.refreshToken,accessToken:this.accessToken,expirationTime:this.expirationTime}}_assign(e){this.accessToken=e.accessToken,this.refreshToken=e.refreshToken,this.expirationTime=e.expirationTime}_clone(){return Object.assign(new $r,this.toJSON())}_performRefresh(){return di("not implemented")}}function $i(n,e){ue(typeof n=="string"||typeof n>"u","internal-error",{appName:e})}class kn{constructor({uid:e,auth:i,stsTokenManager:r,...o}){this.providerId="firebase",this.proactiveRefresh=new F4(this),this.reloadUserInfo=null,this.reloadListener=null,this.uid=e,this.auth=i,this.stsTokenManager=r,this.accessToken=r.accessToken,this.displayName=o.displayName||null,this.email=o.email||null,this.emailVerified=o.emailVerified||!1,this.phoneNumber=o.phoneNumber||null,this.photoURL=o.photoURL||null,this.isAnonymous=o.isAnonymous||!1,this.tenantId=o.tenantId||null,this.providerData=o.providerData?[...o.providerData]:[],this.metadata=new Ym(o.createdAt||void 0,o.lastLoginAt||void 0)}async getIdToken(e){const i=await rs(this,this.stsTokenManager.getToken(this.auth,e));return ue(i,this.auth,"internal-error"),this.accessToken!==i&&(this.accessToken=i,await this.auth._persistUserIfCurrent(this),this.auth._notifyListenersIfCurrent(this)),i}getIdTokenResult(e){return U4(this,e)}reload(){return q4(this)}_assign(e){this!==e&&(ue(this.uid===e.uid,this.auth,"internal-error"),this.displayName=e.displayName,this.photoURL=e.photoURL,this.email=e.email,this.emailVerified=e.emailVerified,this.phoneNumber=e.phoneNumber,this.isAnonymous=e.isAnonymous,this.tenantId=e.tenantId,this.providerData=e.providerData.map(i=>({...i})),this.metadata._copy(e.metadata),this.stsTokenManager._assign(e.stsTokenManager))}_clone(e){const i=new kn({...this,auth:e,stsTokenManager:this.stsTokenManager._clone()});return i.metadata._copy(this.metadata),i}_onReload(e){ue(!this.reloadListener,this.auth,"internal-error"),this.reloadListener=e,this.reloadUserInfo&&(this._notifyReloadListener(this.reloadUserInfo),this.reloadUserInfo=null)}_notifyReloadListener(e){this.reloadListener?this.reloadListener(e):this.reloadUserInfo=e}_startProactiveRefresh(){this.proactiveRefresh._start()}_stopProactiveRefresh(){this.proactiveRefresh._stop()}async _updateTokensIfNecessary(e,i=!1){let r=!1;e.idToken&&e.idToken!==this.stsTokenManager.accessToken&&(this.stsTokenManager.updateFromServerResponse(e),r=!0),i&&await Zl(this),await this.auth._persistUserIfCurrent(this),r&&this.auth._notifyListenersIfCurrent(this)}async delete(){if(Vt(this.auth.app))return Promise.reject(xi(this.auth));const e=await this.getIdToken();return await rs(this,B4(this.auth,{idToken:e})),this.stsTokenManager.clearRefreshToken(),this.auth.signOut()}toJSON(){return{uid:this.uid,email:this.email||void 0,emailVerified:this.emailVerified,displayName:this.displayName||void 0,isAnonymous:this.isAnonymous,photoURL:this.photoURL||void 0,phoneNumber:this.phoneNumber||void 0,tenantId:this.tenantId||void 0,providerData:this.providerData.map(e=>({...e})),stsTokenManager:this.stsTokenManager.toJSON(),_redirectEventId:this._redirectEventId,...this.metadata.toJSON(),apiKey:this.auth.config.apiKey,appName:this.auth.name}}get refreshToken(){return this.stsTokenManager.refreshToken||""}static _fromJSON(e,i){const r=i.displayName??void 0,o=i.email??void 0,l=i.phoneNumber??void 0,p=i.photoURL??void 0,m=i.tenantId??void 0,h=i._redirectEventId??void 0,x=i.createdAt??void 0,O=i.lastLoginAt??void 0,{uid:y,emailVerified:v,isAnonymous:_,providerData:k,stsTokenManager:I}=i;ue(y&&I,e,"internal-error");const D=$r.fromJSON(this.name,I);ue(typeof y=="string",e,"internal-error"),$i(r,e.name),$i(o,e.name),ue(typeof v=="boolean",e,"internal-error"),ue(typeof _=="boolean",e,"internal-error"),$i(l,e.name),$i(p,e.name),$i(m,e.name),$i(h,e.name),$i(x,e.name),$i(O,e.name);const q=new kn({uid:y,auth:e,email:o,emailVerified:v,displayName:r,isAnonymous:_,photoURL:p,phoneNumber:l,tenantId:m,stsTokenManager:D,createdAt:x,lastLoginAt:O});return k&&Array.isArray(k)&&(q.providerData=k.map(z=>({...z}))),h&&(q._redirectEventId=h),q}static async _fromIdTokenResponse(e,i,r=!1){const o=new $r;o.updateFromServerResponse(i);const l=new kn({uid:i.localId,auth:e,stsTokenManager:o,isAnonymous:r});return await Zl(l),l}static async _fromGetAccountInfoResponse(e,i,r){const o=i.users[0];ue(o.localId!==void 0,"internal-error");const l=o.providerUserInfo!==void 0?nO(o.providerUserInfo):[],p=!(o.email&&o.passwordHash)&&!l?.length,m=new $r;m.updateFromIdToken(r);const h=new kn({uid:o.localId,auth:e,stsTokenManager:m,isAnonymous:p}),x={uid:o.localId,displayName:o.displayName||null,photoURL:o.photoUrl||null,email:o.email||null,emailVerified:o.emailVerified||!1,phoneNumber:o.phoneNumber||null,tenantId:o.tenantId||null,providerData:l,metadata:new Ym(o.createdAt,o.lastLoginAt),isAnonymous:!(o.email&&o.passwordHash)&&!l?.length};return Object.assign(h,x),h}}const ty=new Map;function mi(n){vi(n instanceof Function,"Expected a class definition");let e=ty.get(n);return e?(vi(e instanceof n,"Instance stored in cache mismatched with class"),e):(e=new n,ty.set(n,e),e)}class iO{constructor(){this.type="NONE",this.storage={}}async _isAvailable(){return!0}async _set(e,i){this.storage[e]=i}async _get(e){const i=this.storage[e];return i===void 0?null:i}async _remove(e){delete this.storage[e]}_addListener(e,i){}_removeListener(e,i){}}iO.type="NONE";const ny=iO;function Fl(n,e,i){return`firebase:${n}:${e}:${i}`}class Zr{constructor(e,i,r){this.persistence=e,this.auth=i,this.userKey=r;const{config:o,name:l}=this.auth;this.fullUserKey=Fl(this.userKey,o.apiKey,l),this.fullPersistenceKey=Fl("persistence",o.apiKey,l),this.boundEventHandler=i._onStorageEvent.bind(i),this.persistence._addListener(this.fullUserKey,this.boundEventHandler)}setCurrentUser(e){return this.persistence._set(this.fullUserKey,e.toJSON())}async getCurrentUser(){const e=await this.persistence._get(this.fullUserKey);if(!e)return null;if(typeof e=="string"){const i=await $l(this.auth,{idToken:e}).catch(()=>{});return i?kn._fromGetAccountInfoResponse(this.auth,i,e):null}return kn._fromJSON(this.auth,e)}removeCurrentUser(){return this.persistence._remove(this.fullUserKey)}savePersistenceForRedirect(){return this.persistence._set(this.fullPersistenceKey,this.persistence.type)}async setPersistence(e){if(this.persistence===e)return;const i=await this.getCurrentUser();if(await this.removeCurrentUser(),this.persistence=e,i)return this.setCurrentUser(i)}delete(){this.persistence._removeListener(this.fullUserKey,this.boundEventHandler)}static async create(e,i,r="authUser"){if(!i.length)return new Zr(mi(ny),e,r);const o=(await Promise.all(i.map(async x=>{if(await x._isAvailable())return x}))).filter(x=>x);let l=o[0]||mi(ny);const p=Fl(r,e.config.apiKey,e.name);let m=null;for(const x of i)try{const O=await x._get(p);if(O){let y;if(typeof O=="string"){const v=await $l(e,{idToken:O}).catch(()=>{});if(!v)break;y=await kn._fromGetAccountInfoResponse(e,v,O)}else y=kn._fromJSON(e,O);x!==l&&(m=y),l=x;break}}catch{}const h=o.filter(x=>x._shouldAllowMigration);return!l._shouldAllowMigration||!h.length?new Zr(l,e,r):(l=h[0],m&&await l._set(p,m.toJSON()),await Promise.all(i.map(async x=>{if(x!==l)try{await x._remove(p)}catch{}})),new Zr(l,e,r))}}function iy(n){const e=n.toLowerCase();if(e.includes("opera/")||e.includes("opr/")||e.includes("opios/"))return"Opera";if(oO(e))return"IEMobile";if(e.includes("msie")||e.includes("trident/"))return"IE";if(e.includes("edge/"))return"Edge";if(aO(e))return"Firefox";if(e.includes("silk/"))return"Silk";if(lO(e))return"Blackberry";if(cO(e))return"Webos";if(rO(e))return"Safari";if((e.includes("chrome/")||sO(e))&&!e.includes("edge/"))return"Chrome";if(uO(e))return"Android";{const i=/([a-zA-Z\d\.]+)\/[a-zA-Z\d\.]*$/,r=n.match(i);if(r?.length===2)return r[1]}return"Other"}function aO(n=Lt()){return/firefox\//i.test(n)}function rO(n=Lt()){const e=n.toLowerCase();return e.includes("safari/")&&!e.includes("chrome/")&&!e.includes("crios/")&&!e.includes("android")}function sO(n=Lt()){return/crios\//i.test(n)}function oO(n=Lt()){return/iemobile/i.test(n)}function uO(n=Lt()){return/android/i.test(n)}function lO(n=Lt()){return/blackberry/i.test(n)}function cO(n=Lt()){return/webos/i.test(n)}function Mf(n=Lt()){return/iphone|ipad|ipod/i.test(n)||/macintosh/i.test(n)&&/mobile/i.test(n)}function V4(n=Lt()){return Mf(n)&&!!window.navigator?.standalone}function W4(){return t5()&&document.documentMode===10}function pO(n=Lt()){return Mf(n)||uO(n)||cO(n)||lO(n)||/windows phone/i.test(n)||oO(n)}function dO(n,e=[]){let i;switch(n){case"Browser":i=iy(Lt());break;case"Worker":i=`${iy(Lt())}-${n}`;break;default:i=n}const r=e.length?e.join(","):"FirebaseCore-web";return`${i}/JsCore/${er}/${r}`}class K4{constructor(e){this.auth=e,this.queue=[]}pushCallback(e,i){const r=l=>new Promise((p,m)=>{try{const h=e(l);p(h)}catch(h){m(h)}});r.onAbort=i,this.queue.push(r);const o=this.queue.length-1;return()=>{this.queue[o]=()=>Promise.resolve()}}async runMiddleware(e){if(this.auth.currentUser===e)return;const i=[];try{for(const r of this.queue)await r(e),r.onAbort&&i.push(r.onAbort)}catch(r){i.reverse();for(const o of i)try{o()}catch{}throw this.auth._errorFactory.create("login-blocked",{originalMessage:r?.message})}}}async function X4(n,e={}){return wi(n,"GET","/v2/passwordPolicy",ha(n,e))}const Q4=6;class J4{constructor(e){const i=e.customStrengthOptions;this.customStrengthOptions={},this.customStrengthOptions.minPasswordLength=i.minPasswordLength??Q4,i.maxPasswordLength&&(this.customStrengthOptions.maxPasswordLength=i.maxPasswordLength),i.containsLowercaseCharacter!==void 0&&(this.customStrengthOptions.containsLowercaseLetter=i.containsLowercaseCharacter),i.containsUppercaseCharacter!==void 0&&(this.customStrengthOptions.containsUppercaseLetter=i.containsUppercaseCharacter),i.containsNumericCharacter!==void 0&&(this.customStrengthOptions.containsNumericCharacter=i.containsNumericCharacter),i.containsNonAlphanumericCharacter!==void 0&&(this.customStrengthOptions.containsNonAlphanumericCharacter=i.containsNonAlphanumericCharacter),this.enforcementState=e.enforcementState,this.enforcementState==="ENFORCEMENT_STATE_UNSPECIFIED"&&(this.enforcementState="OFF"),this.allowedNonAlphanumericCharacters=e.allowedNonAlphanumericCharacters?.join("")??"",this.forceUpgradeOnSignin=e.forceUpgradeOnSignin??!1,this.schemaVersion=e.schemaVersion}validatePassword(e){const i={isValid:!0,passwordPolicy:this};return this.validatePasswordLengthOptions(e,i),this.validatePasswordCharacterOptions(e,i),i.isValid&&(i.isValid=i.meetsMinPasswordLength??!0),i.isValid&&(i.isValid=i.meetsMaxPasswordLength??!0),i.isValid&&(i.isValid=i.containsLowercaseLetter??!0),i.isValid&&(i.isValid=i.containsUppercaseLetter??!0),i.isValid&&(i.isValid=i.containsNumericCharacter??!0),i.isValid&&(i.isValid=i.containsNonAlphanumericCharacter??!0),i}validatePasswordLengthOptions(e,i){const r=this.customStrengthOptions.minPasswordLength,o=this.customStrengthOptions.maxPasswordLength;r&&(i.meetsMinPasswordLength=e.length>=r),o&&(i.meetsMaxPasswordLength=e.length<=o)}validatePasswordCharacterOptions(e,i){this.updatePasswordCharacterOptionsStatuses(i,!1,!1,!1,!1);let r;for(let o=0;o<e.length;o++)r=e.charAt(o),this.updatePasswordCharacterOptionsStatuses(i,r>="a"&&r<="z",r>="A"&&r<="Z",r>="0"&&r<="9",this.allowedNonAlphanumericCharacters.includes(r))}updatePasswordCharacterOptionsStatuses(e,i,r,o,l){this.customStrengthOptions.containsLowercaseLetter&&(e.containsLowercaseLetter||(e.containsLowercaseLetter=i)),this.customStrengthOptions.containsUppercaseLetter&&(e.containsUppercaseLetter||(e.containsUppercaseLetter=r)),this.customStrengthOptions.containsNumericCharacter&&(e.containsNumericCharacter||(e.containsNumericCharacter=o)),this.customStrengthOptions.containsNonAlphanumericCharacter&&(e.containsNonAlphanumericCharacter||(e.containsNonAlphanumericCharacter=l))}}class $4{constructor(e,i,r,o){this.app=e,this.heartbeatServiceProvider=i,this.appCheckServiceProvider=r,this.config=o,this.currentUser=null,this.emulatorConfig=null,this.operations=Promise.resolve(),this.authStateSubscription=new ay(this),this.idTokenSubscription=new ay(this),this.beforeStateQueue=new K4(this),this.redirectUser=null,this.isProactiveRefreshEnabled=!1,this.EXPECTED_PASSWORD_POLICY_SCHEMA_VERSION=1,this._canInitEmulator=!0,this._isInitialized=!1,this._deleted=!1,this._initializationPromise=null,this._popupRedirectResolver=null,this._errorFactory=$2,this._agentRecaptchaConfig=null,this._tenantRecaptchaConfigs={},this._projectPasswordPolicy=null,this._tenantPasswordPolicies={},this._resolvePersistenceManagerAvailable=void 0,this.lastNotifiedUid=void 0,this.languageCode=null,this.tenantId=null,this.settings={appVerificationDisabledForTesting:!1},this.frameworks=[],this.name=e.name,this.clientVersion=o.sdkClientVersion,this._persistenceManagerAvailable=new Promise(l=>this._resolvePersistenceManagerAvailable=l)}_initializeWithPersistence(e,i){return i&&(this._popupRedirectResolver=mi(i)),this._initializationPromise=this.queue(async()=>{if(!this._deleted&&(this.persistenceManager=await Zr.create(this,e),this._resolvePersistenceManagerAvailable?.(),!this._deleted)){if(this._popupRedirectResolver?._shouldInitProactively)try{await this._popupRedirectResolver._initialize(this)}catch{}await this.initializeCurrentUser(i),this.lastNotifiedUid=this.currentUser?.uid||null,!this._deleted&&(this._isInitialized=!0)}}),this._initializationPromise}async _onStorageEvent(){if(this._deleted)return;const e=await this.assertedPersistence.getCurrentUser();if(!(!this.currentUser&&!e)){if(this.currentUser&&e&&this.currentUser.uid===e.uid){this._currentUser._assign(e),await this.currentUser.getIdToken();return}await this._updateCurrentUser(e,!0)}}async initializeCurrentUserFromIdToken(e){try{const i=await $l(this,{idToken:e}),r=await kn._fromGetAccountInfoResponse(this,i,e);await this.directlySetCurrentUser(r)}catch(i){console.warn("FirebaseServerApp could not login user with provided authIdToken: ",i),await this.directlySetCurrentUser(null)}}async initializeCurrentUser(e){if(Vt(this.app)){const l=this.app.settings.authIdToken;return l?new Promise(p=>{setTimeout(()=>this.initializeCurrentUserFromIdToken(l).then(p,p))}):this.directlySetCurrentUser(null)}const i=await this.assertedPersistence.getCurrentUser();let r=i,o=!1;if(e&&this.config.authDomain){await this.getOrInitRedirectPersistenceManager();const l=this.redirectUser?._redirectEventId,p=r?._redirectEventId,m=await this.tryRedirectSignIn(e);(!l||l===p)&&m?.user&&(r=m.user,o=!0)}if(!r)return this.directlySetCurrentUser(null);if(!r._redirectEventId){if(o)try{await this.beforeStateQueue.runMiddleware(r)}catch(l){r=i,this._popupRedirectResolver._overrideRedirectResult(this,()=>Promise.reject(l))}return r?this.reloadAndSetCurrentUserOrClear(r):this.directlySetCurrentUser(null)}return ue(this._popupRedirectResolver,this,"argument-error"),await this.getOrInitRedirectPersistenceManager(),this.redirectUser&&this.redirectUser._redirectEventId===r._redirectEventId?this.directlySetCurrentUser(r):this.reloadAndSetCurrentUserOrClear(r)}async tryRedirectSignIn(e){let i=null;try{i=await this._popupRedirectResolver._completeRedirectFn(this,e,!0)}catch{await this._setRedirectUser(null)}return i}async reloadAndSetCurrentUserOrClear(e){try{await Zl(e)}catch(i){if(i?.code!=="auth/network-request-failed")return this.directlySetCurrentUser(null)}return this.directlySetCurrentUser(e)}useDeviceLanguage(){this.languageCode=A4()}async _delete(){this._deleted=!0}async updateCurrentUser(e){if(Vt(this.app))return Promise.reject(xi(this));const i=e?at(e):null;return i&&ue(i.auth.config.apiKey===this.config.apiKey,this,"invalid-user-token"),this._updateCurrentUser(i&&i._clone(this))}async _updateCurrentUser(e,i=!1){if(!this._deleted)return e&&ue(this.tenantId===e.tenantId,this,"tenant-id-mismatch"),i||await this.beforeStateQueue.runMiddleware(e),this.queue(async()=>{await this.directlySetCurrentUser(e),this.notifyAuthListeners()})}async signOut(){return Vt(this.app)?Promise.reject(xi(this)):(await this.beforeStateQueue.runMiddleware(null),(this.redirectPersistenceManager||this._popupRedirectResolver)&&await this._setRedirectUser(null),this._updateCurrentUser(null,!0))}setPersistence(e){return Vt(this.app)?Promise.reject(xi(this)):this.queue(async()=>{await this.assertedPersistence.setPersistence(mi(e))})}_getRecaptchaConfig(){return this.tenantId==null?this._agentRecaptchaConfig:this._tenantRecaptchaConfigs[this.tenantId]}async validatePassword(e){this._getPasswordPolicyInternal()||await this._updatePasswordPolicy();const i=this._getPasswordPolicyInternal();return i.schemaVersion!==this.EXPECTED_PASSWORD_POLICY_SCHEMA_VERSION?Promise.reject(this._errorFactory.create("unsupported-password-policy-schema-version",{})):i.validatePassword(e)}_getPasswordPolicyInternal(){return this.tenantId===null?this._projectPasswordPolicy:this._tenantPasswordPolicies[this.tenantId]}async _updatePasswordPolicy(){const e=await X4(this),i=new J4(e);this.tenantId===null?this._projectPasswordPolicy=i:this._tenantPasswordPolicies[this.tenantId]=i}_getPersistenceType(){return this.assertedPersistence.persistence.type}_getPersistence(){return this.assertedPersistence.persistence}_updateErrorMap(e){this._errorFactory=new eu("auth","Firebase",e())}onAuthStateChanged(e,i,r){return this.registerStateListener(this.authStateSubscription,e,i,r)}beforeAuthStateChanged(e,i){return this.beforeStateQueue.pushCallback(e,i)}onIdTokenChanged(e,i,r){return this.registerStateListener(this.idTokenSubscription,e,i,r)}authStateReady(){return new Promise((e,i)=>{if(this.currentUser)e();else{const r=this.onAuthStateChanged(()=>{r(),e()},i)}})}async revokeAccessToken(e){if(this.currentUser){const i=await this.currentUser.getIdToken(),r={providerId:"apple.com",tokenType:"ACCESS_TOKEN",token:e,idToken:i};this.tenantId!=null&&(r.tenantId=this.tenantId),await G4(this,r)}}toJSON(){return{apiKey:this.config.apiKey,authDomain:this.config.authDomain,appName:this.name,currentUser:this._currentUser?.toJSON()}}async _setRedirectUser(e,i){const r=await this.getOrInitRedirectPersistenceManager(i);return e===null?r.removeCurrentUser():r.setCurrentUser(e)}async getOrInitRedirectPersistenceManager(e){if(!this.redirectPersistenceManager){const i=e&&mi(e)||this._popupRedirectResolver;ue(i,this,"argument-error"),this.redirectPersistenceManager=await Zr.create(this,[mi(i._redirectPersistence)],"redirectUser"),this.redirectUser=await this.redirectPersistenceManager.getCurrentUser()}return this.redirectPersistenceManager}async _redirectUserForId(e){return this._isInitialized&&await this.queue(async()=>{}),this._currentUser?._redirectEventId===e?this._currentUser:this.redirectUser?._redirectEventId===e?this.redirectUser:null}async _persistUserIfCurrent(e){if(e===this.currentUser)return this.queue(async()=>this.directlySetCurrentUser(e))}_notifyListenersIfCurrent(e){e===this.currentUser&&this.notifyAuthListeners()}_key(){return`${this.config.authDomain}:${this.config.apiKey}:${this.name}`}_startProactiveRefresh(){this.isProactiveRefreshEnabled=!0,this.currentUser&&this._currentUser._startProactiveRefresh()}_stopProactiveRefresh(){this.isProactiveRefreshEnabled=!1,this.currentUser&&this._currentUser._stopProactiveRefresh()}get _currentUser(){return this.currentUser}notifyAuthListeners(){if(!this._isInitialized)return;this.idTokenSubscription.next(this.currentUser);const e=this.currentUser?.uid??null;this.lastNotifiedUid!==e&&(this.lastNotifiedUid=e,this.authStateSubscription.next(this.currentUser))}registerStateListener(e,i,r,o){if(this._deleted)return()=>{};const l=typeof i=="function"?i:i.next.bind(i);let p=!1;const m=this._isInitialized?Promise.resolve():this._initializationPromise;if(ue(m,this,"internal-error"),m.then(()=>{p||l(this.currentUser)}),typeof i=="function"){const h=e.addObserver(i,r,o);return()=>{p=!0,h()}}else{const h=e.addObserver(i);return()=>{p=!0,h()}}}async directlySetCurrentUser(e){this.currentUser&&this.currentUser!==e&&this._currentUser._stopProactiveRefresh(),e&&this.isProactiveRefreshEnabled&&e._startProactiveRefresh(),this.currentUser=e,e?await this.assertedPersistence.setCurrentUser(e):await this.assertedPersistence.removeCurrentUser()}queue(e){return this.operations=this.operations.then(e,e),this.operations}get assertedPersistence(){return ue(this.persistenceManager,this,"internal-error"),this.persistenceManager}_logFramework(e){!e||this.frameworks.includes(e)||(this.frameworks.push(e),this.frameworks.sort(),this.clientVersion=dO(this.config.clientPlatform,this._getFrameworks()))}_getFrameworks(){return this.frameworks}async _getAdditionalHeaders(){const e={"X-Client-Version":this.clientVersion};this.app.options.appId&&(e["X-Firebase-gmpid"]=this.app.options.appId);const i=await this.heartbeatServiceProvider.getImmediate({optional:!0})?.getHeartbeatsHeader();i&&(e["X-Firebase-Client"]=i);const r=await this._getAppCheckToken();return r&&(e["X-Firebase-AppCheck"]=r),e}async _getAppCheckToken(){if(Vt(this.app)&&this.app.settings.appCheckToken)return this.app.settings.appCheckToken;const e=await this.appCheckServiceProvider.getImmediate({optional:!0})?.getToken();return e?.error&&T4(`Error while retrieving App Check token: ${e.error}`),e?.token}}function xa(n){return at(n)}class ay{constructor(e){this.auth=e,this.observer=null,this.addObserver=p5(i=>this.observer=i)}get next(){return ue(this.observer,this.auth,"internal-error"),this.observer.next.bind(this.observer)}}let kc={async loadJS(){throw new Error("Unable to load external scripts")},recaptchaV2Script:"",recaptchaEnterpriseScript:"",gapiScript:""};function Z4(n){kc=n}function mO(n){return kc.loadJS(n)}function e_(){return kc.recaptchaEnterpriseScript}function t_(){return kc.gapiScript}function n_(n){return`__${n}${Math.floor(Math.random()*1e6)}`}class i_{constructor(){this.enterprise=new a_}ready(e){e()}execute(e,i){return Promise.resolve("token")}render(e,i){return""}}class a_{ready(e){e()}execute(e,i){return Promise.resolve("token")}render(e,i){return""}}const r_="recaptcha-enterprise",fO="NO_RECAPTCHA";class s_{constructor(e){this.type=r_,this.auth=xa(e)}async verify(e="verify",i=!1){async function r(l){if(!i){if(l.tenantId==null&&l._agentRecaptchaConfig!=null)return l._agentRecaptchaConfig.siteKey;if(l.tenantId!=null&&l._tenantRecaptchaConfigs[l.tenantId]!==void 0)return l._tenantRecaptchaConfigs[l.tenantId].siteKey}return new Promise(async(p,m)=>{P4(l,{clientType:"CLIENT_TYPE_WEB",version:"RECAPTCHA_ENTERPRISE"}).then(h=>{if(h.recaptchaKey===void 0)m(new Error("recaptcha Enterprise site key undefined"));else{const x=new L4(h);return l.tenantId==null?l._agentRecaptchaConfig=x:l._tenantRecaptchaConfigs[l.tenantId]=x,p(x.siteKey)}}).catch(h=>{m(h)})})}function o(l,p,m){const h=window.grecaptcha;Zg(h)?h.enterprise.ready(()=>{h.enterprise.execute(l,{action:e}).then(x=>{p(x)}).catch(()=>{p(fO)})}):m(Error("No reCAPTCHA enterprise script loaded."))}return this.auth.settings.appVerificationDisabledForTesting?new i_().execute("siteKey",{action:"verify"}):new Promise((l,p)=>{r(this.auth).then(m=>{if(!i&&Zg(window.grecaptcha))o(m,l,p);else{if(typeof window>"u"){p(new Error("RecaptchaVerifier is only supported in browser"));return}let h=e_();h.length!==0&&(h+=m),mO(h).then(()=>{o(m,l,p)}).catch(x=>{p(x)})}}).catch(m=>{p(m)})})}}async function ry(n,e,i,r=!1,o=!1){const l=new s_(n);let p;if(o)p=fO;else try{p=await l.verify(i)}catch{p=await l.verify(i,!0)}const m={...e};if(i==="mfaSmsEnrollment"||i==="mfaSmsSignIn"){if("phoneEnrollmentInfo"in m){const h=m.phoneEnrollmentInfo.phoneNumber,x=m.phoneEnrollmentInfo.recaptchaToken;Object.assign(m,{phoneEnrollmentInfo:{phoneNumber:h,recaptchaToken:x,captchaResponse:p,clientType:"CLIENT_TYPE_WEB",recaptchaVersion:"RECAPTCHA_ENTERPRISE"}})}else if("phoneSignInInfo"in m){const h=m.phoneSignInInfo.recaptchaToken;Object.assign(m,{phoneSignInInfo:{recaptchaToken:h,captchaResponse:p,clientType:"CLIENT_TYPE_WEB",recaptchaVersion:"RECAPTCHA_ENTERPRISE"}})}return m}return r?Object.assign(m,{captchaResp:p}):Object.assign(m,{captchaResponse:p}),Object.assign(m,{clientType:"CLIENT_TYPE_WEB"}),Object.assign(m,{recaptchaVersion:"RECAPTCHA_ENTERPRISE"}),m}async function Gm(n,e,i,r,o){if(n._getRecaptchaConfig()?.isProviderEnabled("EMAIL_PASSWORD_PROVIDER")){const l=await ry(n,e,i,i==="getOobCode");return r(n,l)}else return r(n,e).catch(async l=>{if(l.code==="auth/missing-recaptcha-token"){console.log(`${i} is protected by reCAPTCHA Enterprise for this project. Automatically triggering the reCAPTCHA flow and restarting the flow.`);const p=await ry(n,e,i,i==="getOobCode");return r(n,p)}else return Promise.reject(l)})}function o_(n,e){const i=Nc(n,"auth");if(i.isInitialized()){const o=i.getImmediate(),l=i.getOptions();if(Ga(l,e??{}))return o;vn(o,"already-initialized")}return i.initialize({options:e})}function u_(n,e){const i=e?.persistence||[],r=(Array.isArray(i)?i:[i]).map(mi);e?.errorMap&&n._updateErrorMap(e.errorMap),n._initializeWithPersistence(r,e?.popupRedirectResolver)}function l_(n,e,i){const r=xa(n);ue(/^https?:\/\//.test(e),r,"invalid-emulator-scheme");const o=!1,l=hO(e),{host:p,port:m}=c_(e),h=m===null?"":`:${m}`,x={url:`${l}//${p}${h}/`},O=Object.freeze({host:p,port:m,protocol:l.replace(":",""),options:Object.freeze({disableWarnings:o})});if(!r._canInitEmulator){ue(r.config.emulator&&r.emulatorConfig,r,"emulator-config-failed"),ue(Ga(x,r.config.emulator)&&Ga(O,r.emulatorConfig),r,"emulator-config-failed");return}r.config.emulator=x,r.emulatorConfig=O,r.settings.appVerificationDisabledForTesting=!0,fa(p)?(Sf(`${l}//${p}${h}`),wf("Auth",!0)):p_()}function hO(n){const e=n.indexOf(":");return e<0?"":n.substr(0,e+1)}function c_(n){const e=hO(n),i=/(\/\/)?([^?#/]+)/.exec(n.substr(e.length));if(!i)return{host:"",port:null};const r=i[2].split("@").pop()||"",o=/^(\[[^\]]+\])(:|$)/.exec(r);if(o){const l=o[1];return{host:l,port:sy(r.substr(l.length+1))}}else{const[l,p]=r.split(":");return{host:l,port:sy(p)}}}function sy(n){if(!n)return null;const e=Number(n);return isNaN(e)?null:e}function p_(){function n(){const e=document.createElement("p"),i=e.style;e.innerText="Running in emulator mode. Do not use with production credentials.",i.position="fixed",i.width="100%",i.backgroundColor="#ffffff",i.border=".1em solid #000000",i.color="#b50000",i.bottom="0px",i.left="0px",i.margin="0px",i.zIndex="10000",i.textAlign="center",e.classList.add("firebase-emulator-warning"),document.body.appendChild(e)}typeof console<"u"&&typeof console.info=="function"&&console.info("WARNING: You are using the Auth Emulator, which is intended for local testing only.  Do not use with production credentials."),typeof window<"u"&&typeof document<"u"&&(document.readyState==="loading"?window.addEventListener("DOMContentLoaded",n):n())}class Rf{constructor(e,i){this.providerId=e,this.signInMethod=i}toJSON(){return di("not implemented")}_getIdTokenResponse(e){return di("not implemented")}_linkToIdToken(e,i){return di("not implemented")}_getReauthenticationResolver(e){return di("not implemented")}}async function d_(n,e){return wi(n,"POST","/v1/accounts:signUp",e)}async function m_(n,e){return nu(n,"POST","/v1/accounts:signInWithPassword",ha(n,e))}async function f_(n,e){return nu(n,"POST","/v1/accounts:signInWithEmailLink",ha(n,e))}async function h_(n,e){return nu(n,"POST","/v1/accounts:signInWithEmailLink",ha(n,e))}class Fo extends Rf{constructor(e,i,r,o=null){super("password",r),this._email=e,this._password=i,this._tenantId=o}static _fromEmailAndPassword(e,i){return new Fo(e,i,"password")}static _fromEmailAndCode(e,i,r=null){return new Fo(e,i,"emailLink",r)}toJSON(){return{email:this._email,password:this._password,signInMethod:this.signInMethod,tenantId:this._tenantId}}static fromJSON(e){const i=typeof e=="string"?JSON.parse(e):e;if(i?.email&&i?.password){if(i.signInMethod==="password")return this._fromEmailAndPassword(i.email,i.password);if(i.signInMethod==="emailLink")return this._fromEmailAndCode(i.email,i.password,i.tenantId)}return null}async _getIdTokenResponse(e){switch(this.signInMethod){case"password":const i={returnSecureToken:!0,email:this._email,password:this._password,clientType:"CLIENT_TYPE_WEB"};return Gm(e,i,"signInWithPassword",m_);case"emailLink":return f_(e,{email:this._email,oobCode:this._password});default:vn(e,"internal-error")}}async _linkToIdToken(e,i){switch(this.signInMethod){case"password":const r={idToken:i,returnSecureToken:!0,email:this._email,password:this._password,clientType:"CLIENT_TYPE_WEB"};return Gm(e,r,"signUpPassword",d_);case"emailLink":return h_(e,{idToken:i,email:this._email,oobCode:this._password});default:vn(e,"internal-error")}}_getReauthenticationResolver(e){return this._getIdTokenResponse(e)}}async function es(n,e){return nu(n,"POST","/v1/accounts:signInWithIdp",ha(n,e))}const x_="http://localhost";class Wa extends Rf{constructor(){super(...arguments),this.pendingToken=null}static _fromParams(e){const i=new Wa(e.providerId,e.signInMethod);return e.idToken||e.accessToken?(e.idToken&&(i.idToken=e.idToken),e.accessToken&&(i.accessToken=e.accessToken),e.nonce&&!e.pendingToken&&(i.nonce=e.nonce),e.pendingToken&&(i.pendingToken=e.pendingToken)):e.oauthToken&&e.oauthTokenSecret?(i.accessToken=e.oauthToken,i.secret=e.oauthTokenSecret):vn("argument-error"),i}toJSON(){return{idToken:this.idToken,accessToken:this.accessToken,secret:this.secret,nonce:this.nonce,pendingToken:this.pendingToken,providerId:this.providerId,signInMethod:this.signInMethod}}static fromJSON(e){const i=typeof e=="string"?JSON.parse(e):e,{providerId:r,signInMethod:o,...l}=i;if(!r||!o)return null;const p=new Wa(r,o);return p.idToken=l.idToken||void 0,p.accessToken=l.accessToken||void 0,p.secret=l.secret,p.nonce=l.nonce,p.pendingToken=l.pendingToken||null,p}_getIdTokenResponse(e){const i=this.buildRequest();return es(e,i)}_linkToIdToken(e,i){const r=this.buildRequest();return r.idToken=i,es(e,r)}_getReauthenticationResolver(e){const i=this.buildRequest();return i.autoCreate=!1,es(e,i)}buildRequest(){const e={requestUri:x_,returnSecureToken:!0};if(this.pendingToken)e.pendingToken=this.pendingToken;else{const i={};this.idToken&&(i.id_token=this.idToken),this.accessToken&&(i.access_token=this.accessToken),this.secret&&(i.oauth_token_secret=this.secret),i.providerId=this.providerId,this.nonce&&!this.pendingToken&&(i.nonce=this.nonce),e.postBody=hs(i)}return e}}function g_(n){switch(n){case"recoverEmail":return"RECOVER_EMAIL";case"resetPassword":return"PASSWORD_RESET";case"signIn":return"EMAIL_SIGNIN";case"verifyEmail":return"VERIFY_EMAIL";case"verifyAndChangeEmail":return"VERIFY_AND_CHANGE_EMAIL";case"revertSecondFactorAddition":return"REVERT_SECOND_FACTOR_ADDITION";default:return null}}function y_(n){const e=Co(_o(n)).link,i=e?Co(_o(e)).deep_link_id:null,r=Co(_o(n)).deep_link_id;return(r?Co(_o(r)).link:null)||r||i||e||n}class Df{constructor(e){const i=Co(_o(e)),r=i.apiKey??null,o=i.oobCode??null,l=g_(i.mode??null);ue(r&&o&&l,"argument-error"),this.apiKey=r,this.operation=l,this.code=o,this.continueUrl=i.continueUrl??null,this.languageCode=i.lang??null,this.tenantId=i.tenantId??null}static parseLink(e){const i=y_(e);try{return new Df(i)}catch{return null}}}class xs{constructor(){this.providerId=xs.PROVIDER_ID}static credential(e,i){return Fo._fromEmailAndPassword(e,i)}static credentialWithLink(e,i){const r=Df.parseLink(i);return ue(r,"argument-error"),Fo._fromEmailAndCode(e,r.code,r.tenantId)}}xs.PROVIDER_ID="password";xs.EMAIL_PASSWORD_SIGN_IN_METHOD="password";xs.EMAIL_LINK_SIGN_IN_METHOD="emailLink";class If{constructor(e){this.providerId=e,this.defaultLanguageCode=null,this.customParameters={}}setDefaultLanguage(e){this.defaultLanguageCode=e}setCustomParameters(e){return this.customParameters=e,this}getCustomParameters(){return this.customParameters}}class iu extends If{constructor(){super(...arguments),this.scopes=[]}addScope(e){return this.scopes.includes(e)||this.scopes.push(e),this}getScopes(){return[...this.scopes]}}class Zi extends iu{constructor(){super("facebook.com")}static credential(e){return Wa._fromParams({providerId:Zi.PROVIDER_ID,signInMethod:Zi.FACEBOOK_SIGN_IN_METHOD,accessToken:e})}static credentialFromResult(e){return Zi.credentialFromTaggedObject(e)}static credentialFromError(e){return Zi.credentialFromTaggedObject(e.customData||{})}static credentialFromTaggedObject({_tokenResponse:e}){if(!e||!("oauthAccessToken"in e)||!e.oauthAccessToken)return null;try{return Zi.credential(e.oauthAccessToken)}catch{return null}}}Zi.FACEBOOK_SIGN_IN_METHOD="facebook.com";Zi.PROVIDER_ID="facebook.com";class pi extends iu{constructor(){super("google.com"),this.addScope("profile")}static credential(e,i){return Wa._fromParams({providerId:pi.PROVIDER_ID,signInMethod:pi.GOOGLE_SIGN_IN_METHOD,idToken:e,accessToken:i})}static credentialFromResult(e){return pi.credentialFromTaggedObject(e)}static credentialFromError(e){return pi.credentialFromTaggedObject(e.customData||{})}static credentialFromTaggedObject({_tokenResponse:e}){if(!e)return null;const{oauthIdToken:i,oauthAccessToken:r}=e;if(!i&&!r)return null;try{return pi.credential(i,r)}catch{return null}}}pi.GOOGLE_SIGN_IN_METHOD="google.com";pi.PROVIDER_ID="google.com";class ea extends iu{constructor(){super("github.com")}static credential(e){return Wa._fromParams({providerId:ea.PROVIDER_ID,signInMethod:ea.GITHUB_SIGN_IN_METHOD,accessToken:e})}static credentialFromResult(e){return ea.credentialFromTaggedObject(e)}static credentialFromError(e){return ea.credentialFromTaggedObject(e.customData||{})}static credentialFromTaggedObject({_tokenResponse:e}){if(!e||!("oauthAccessToken"in e)||!e.oauthAccessToken)return null;try{return ea.credential(e.oauthAccessToken)}catch{return null}}}ea.GITHUB_SIGN_IN_METHOD="github.com";ea.PROVIDER_ID="github.com";class ta extends iu{constructor(){super("twitter.com")}static credential(e,i){return Wa._fromParams({providerId:ta.PROVIDER_ID,signInMethod:ta.TWITTER_SIGN_IN_METHOD,oauthToken:e,oauthTokenSecret:i})}static credentialFromResult(e){return ta.credentialFromTaggedObject(e)}static credentialFromError(e){return ta.credentialFromTaggedObject(e.customData||{})}static credentialFromTaggedObject({_tokenResponse:e}){if(!e)return null;const{oauthAccessToken:i,oauthTokenSecret:r}=e;if(!i||!r)return null;try{return ta.credential(i,r)}catch{return null}}}ta.TWITTER_SIGN_IN_METHOD="twitter.com";ta.PROVIDER_ID="twitter.com";async function O_(n,e){return nu(n,"POST","/v1/accounts:signUp",ha(n,e))}class Ka{constructor(e){this.user=e.user,this.providerId=e.providerId,this._tokenResponse=e._tokenResponse,this.operationType=e.operationType}static async _fromIdTokenResponse(e,i,r,o=!1){const l=await kn._fromIdTokenResponse(e,r,o),p=oy(r);return new Ka({user:l,providerId:p,_tokenResponse:r,operationType:i})}static async _forOperation(e,i,r){await e._updateTokensIfNecessary(r,!0);const o=oy(r);return new Ka({user:e,providerId:o,_tokenResponse:r,operationType:i})}}function oy(n){return n.providerId?n.providerId:"phoneNumber"in n?"phone":null}class ec extends Si{constructor(e,i,r,o){super(i.code,i.message),this.operationType=r,this.user=o,Object.setPrototypeOf(this,ec.prototype),this.customData={appName:e.name,tenantId:e.tenantId??void 0,_serverResponse:i.customData._serverResponse,operationType:r}}static _fromErrorAndOperation(e,i,r,o){return new ec(e,i,r,o)}}function xO(n,e,i,r){return(e==="reauthenticate"?i._getReauthenticationResolver(n):i._getIdTokenResponse(n)).catch(l=>{throw l.code==="auth/multi-factor-auth-required"?ec._fromErrorAndOperation(n,l,e,r):l})}async function v_(n,e,i=!1){const r=await rs(n,e._linkToIdToken(n.auth,await n.getIdToken()),i);return Ka._forOperation(n,"link",r)}async function b_(n,e,i=!1){const{auth:r}=n;if(Vt(r.app))return Promise.reject(xi(r));const o="reauthenticate";try{const l=await rs(n,xO(r,o,e,n),i);ue(l.idToken,r,"internal-error");const p=jf(l.idToken);ue(p,r,"internal-error");const{sub:m}=p;return ue(n.uid===m,r,"user-mismatch"),Ka._forOperation(n,o,l)}catch(l){throw l?.code==="auth/user-not-found"&&vn(r,"user-mismatch"),l}}async function gO(n,e,i=!1){if(Vt(n.app))return Promise.reject(xi(n));const r="signIn",o=await xO(n,r,e),l=await Ka._fromIdTokenResponse(n,r,o);return i||await n._updateCurrentUser(l.user),l}async function S_(n,e){return gO(xa(n),e)}async function yO(n){const e=xa(n);e._getPasswordPolicyInternal()&&await e._updatePasswordPolicy()}async function w_(n,e,i){if(Vt(n.app))return Promise.reject(xi(n));const r=xa(n),p=await Gm(r,{returnSecureToken:!0,email:e,password:i,clientType:"CLIENT_TYPE_WEB"},"signUpPassword",O_).catch(h=>{throw h.code==="auth/password-does-not-meet-requirements"&&yO(n),h}),m=await Ka._fromIdTokenResponse(r,"signIn",p);return await r._updateCurrentUser(m.user),m}function C_(n,e,i){return Vt(n.app)?Promise.reject(xi(n)):S_(at(n),xs.credential(e,i)).catch(async r=>{throw r.code==="auth/password-does-not-meet-requirements"&&yO(n),r})}async function __(n,e){return wi(n,"POST","/v1/accounts:update",e)}async function OO(n,{displayName:e,photoURL:i}){if(e===void 0&&i===void 0)return;const r=at(n),l={idToken:await r.getIdToken(),displayName:e,photoUrl:i,returnSecureToken:!0},p=await rs(r,__(r.auth,l));r.displayName=p.displayName||null,r.photoURL=p.photoUrl||null;const m=r.providerData.find(({providerId:h})=>h==="password");m&&(m.displayName=r.displayName,m.photoURL=r.photoURL),await r._updateTokensIfNecessary(p)}function T_(n,e,i,r){return at(n).onIdTokenChanged(e,i,r)}function N_(n,e,i){return at(n).beforeAuthStateChanged(e,i)}function k_(n,e,i,r){return at(n).onAuthStateChanged(e,i,r)}function E_(n){return at(n).signOut()}const tc="__sak";class vO{constructor(e,i){this.storageRetriever=e,this.type=i}_isAvailable(){try{return this.storage?(this.storage.setItem(tc,"1"),this.storage.removeItem(tc),Promise.resolve(!0)):Promise.resolve(!1)}catch{return Promise.resolve(!1)}}_set(e,i){return this.storage.setItem(e,JSON.stringify(i)),Promise.resolve()}_get(e){const i=this.storage.getItem(e);return Promise.resolve(i?JSON.parse(i):null)}_remove(e){return this.storage.removeItem(e),Promise.resolve()}get storage(){return this.storageRetriever()}}const A_=1e3,j_=10;class bO extends vO{constructor(){super(()=>window.localStorage,"LOCAL"),this.boundEventHandler=(e,i)=>this.onStorageEvent(e,i),this.listeners={},this.localCache={},this.pollTimer=null,this.fallbackToPolling=pO(),this._shouldAllowMigration=!0}forAllChangedKeys(e){for(const i of Object.keys(this.listeners)){const r=this.storage.getItem(i),o=this.localCache[i];r!==o&&e(i,o,r)}}onStorageEvent(e,i=!1){if(!e.key){this.forAllChangedKeys((p,m,h)=>{this.notifyListeners(p,h)});return}const r=e.key;i?this.detachListener():this.stopPolling();const o=()=>{const p=this.storage.getItem(r);!i&&this.localCache[r]===p||this.notifyListeners(r,p)},l=this.storage.getItem(r);W4()&&l!==e.newValue&&e.newValue!==e.oldValue?setTimeout(o,j_):o()}notifyListeners(e,i){this.localCache[e]=i;const r=this.listeners[e];if(r)for(const o of Array.from(r))o(i&&JSON.parse(i))}startPolling(){this.stopPolling(),this.pollTimer=setInterval(()=>{this.forAllChangedKeys((e,i,r)=>{this.onStorageEvent(new StorageEvent("storage",{key:e,oldValue:i,newValue:r}),!0)})},A_)}stopPolling(){this.pollTimer&&(clearInterval(this.pollTimer),this.pollTimer=null)}attachListener(){window.addEventListener("storage",this.boundEventHandler)}detachListener(){window.removeEventListener("storage",this.boundEventHandler)}_addListener(e,i){Object.keys(this.listeners).length===0&&(this.fallbackToPolling?this.startPolling():this.attachListener()),this.listeners[e]||(this.listeners[e]=new Set,this.localCache[e]=this.storage.getItem(e)),this.listeners[e].add(i)}_removeListener(e,i){this.listeners[e]&&(this.listeners[e].delete(i),this.listeners[e].size===0&&delete this.listeners[e]),Object.keys(this.listeners).length===0&&(this.detachListener(),this.stopPolling())}async _set(e,i){await super._set(e,i),this.localCache[e]=JSON.stringify(i)}async _get(e){const i=await super._get(e);return this.localCache[e]=JSON.stringify(i),i}async _remove(e){await super._remove(e),delete this.localCache[e]}}bO.type="LOCAL";const M_=bO;class SO extends vO{constructor(){super(()=>window.sessionStorage,"SESSION")}_addListener(e,i){}_removeListener(e,i){}}SO.type="SESSION";const wO=SO;function R_(n){return Promise.all(n.map(async e=>{try{return{fulfilled:!0,value:await e}}catch(i){return{fulfilled:!1,reason:i}}}))}class Ec{constructor(e){this.eventTarget=e,this.handlersMap={},this.boundEventHandler=this.handleEvent.bind(this)}static _getInstance(e){const i=this.receivers.find(o=>o.isListeningto(e));if(i)return i;const r=new Ec(e);return this.receivers.push(r),r}isListeningto(e){return this.eventTarget===e}async handleEvent(e){const i=e,{eventId:r,eventType:o,data:l}=i.data,p=this.handlersMap[o];if(!p?.size)return;i.ports[0].postMessage({status:"ack",eventId:r,eventType:o});const m=Array.from(p).map(async x=>x(i.origin,l)),h=await R_(m);i.ports[0].postMessage({status:"done",eventId:r,eventType:o,response:h})}_subscribe(e,i){Object.keys(this.handlersMap).length===0&&this.eventTarget.addEventListener("message",this.boundEventHandler),this.handlersMap[e]||(this.handlersMap[e]=new Set),this.handlersMap[e].add(i)}_unsubscribe(e,i){this.handlersMap[e]&&i&&this.handlersMap[e].delete(i),(!i||this.handlersMap[e].size===0)&&delete this.handlersMap[e],Object.keys(this.handlersMap).length===0&&this.eventTarget.removeEventListener("message",this.boundEventHandler)}}Ec.receivers=[];function Lf(n="",e=10){let i="";for(let r=0;r<e;r++)i+=Math.floor(Math.random()*10);return n+i}class D_{constructor(e){this.target=e,this.handlers=new Set}removeMessageHandler(e){e.messageChannel&&(e.messageChannel.port1.removeEventListener("message",e.onMessage),e.messageChannel.port1.close()),this.handlers.delete(e)}async _send(e,i,r=50){const o=typeof MessageChannel<"u"?new MessageChannel:null;if(!o)throw new Error("connection_unavailable");let l,p;return new Promise((m,h)=>{const x=Lf("",20);o.port1.start();const O=setTimeout(()=>{h(new Error("unsupported_event"))},r);p={messageChannel:o,onMessage(y){const v=y;if(v.data.eventId===x)switch(v.data.status){case"ack":clearTimeout(O),l=setTimeout(()=>{h(new Error("timeout"))},3e3);break;case"done":clearTimeout(l),m(v.data.response);break;default:clearTimeout(O),clearTimeout(l),h(new Error("invalid_response"));break}}},this.handlers.add(p),o.port1.addEventListener("message",p.onMessage),this.target.postMessage({eventType:e,eventId:x,data:i},[o.port2])}).finally(()=>{p&&this.removeMessageHandler(p)})}}function zn(){return window}function I_(n){zn().location.href=n}function CO(){return typeof zn().WorkerGlobalScope<"u"&&typeof zn().importScripts=="function"}async function L_(){if(!navigator?.serviceWorker)return null;try{return(await navigator.serviceWorker.ready).active}catch{return null}}function P_(){return navigator?.serviceWorker?.controller||null}function B_(){return CO()?self:null}const _O="firebaseLocalStorageDb",U_=1,nc="firebaseLocalStorage",TO="fbase_key";class au{constructor(e){this.request=e}toPromise(){return new Promise((e,i)=>{this.request.addEventListener("success",()=>{e(this.request.result)}),this.request.addEventListener("error",()=>{i(this.request.error)})})}}function Ac(n,e){return n.transaction([nc],e?"readwrite":"readonly").objectStore(nc)}function z_(){const n=indexedDB.deleteDatabase(_O);return new au(n).toPromise()}function Vm(){const n=indexedDB.open(_O,U_);return new Promise((e,i)=>{n.addEventListener("error",()=>{i(n.error)}),n.addEventListener("upgradeneeded",()=>{const r=n.result;try{r.createObjectStore(nc,{keyPath:TO})}catch(o){i(o)}}),n.addEventListener("success",async()=>{const r=n.result;r.objectStoreNames.contains(nc)?e(r):(r.close(),await z_(),e(await Vm()))})})}async function uy(n,e,i){const r=Ac(n,!0).put({[TO]:e,value:i});return new au(r).toPromise()}async function F_(n,e){const i=Ac(n,!1).get(e),r=await new au(i).toPromise();return r===void 0?null:r.value}function ly(n,e){const i=Ac(n,!0).delete(e);return new au(i).toPromise()}const q_=800,H_=3;class NO{constructor(){this.type="LOCAL",this._shouldAllowMigration=!0,this.listeners={},this.localCache={},this.pollTimer=null,this.pendingWrites=0,this.receiver=null,this.sender=null,this.serviceWorkerReceiverAvailable=!1,this.activeServiceWorker=null,this._workerInitializationPromise=this.initializeServiceWorkerMessaging().then(()=>{},()=>{})}async _openDb(){return this.db?this.db:(this.db=await Vm(),this.db)}async _withRetries(e){let i=0;for(;;)try{const r=await this._openDb();return await e(r)}catch(r){if(i++>H_)throw r;this.db&&(this.db.close(),this.db=void 0)}}async initializeServiceWorkerMessaging(){return CO()?this.initializeReceiver():this.initializeSender()}async initializeReceiver(){this.receiver=Ec._getInstance(B_()),this.receiver._subscribe("keyChanged",async(e,i)=>({keyProcessed:(await this._poll()).includes(i.key)})),this.receiver._subscribe("ping",async(e,i)=>["keyChanged"])}async initializeSender(){if(this.activeServiceWorker=await L_(),!this.activeServiceWorker)return;this.sender=new D_(this.activeServiceWorker);const e=await this.sender._send("ping",{},800);e&&e[0]?.fulfilled&&e[0]?.value.includes("keyChanged")&&(this.serviceWorkerReceiverAvailable=!0)}async notifyServiceWorker(e){if(!(!this.sender||!this.activeServiceWorker||P_()!==this.activeServiceWorker))try{await this.sender._send("keyChanged",{key:e},this.serviceWorkerReceiverAvailable?800:50)}catch{}}async _isAvailable(){try{if(!indexedDB)return!1;const e=await Vm();return await uy(e,tc,"1"),await ly(e,tc),!0}catch{}return!1}async _withPendingWrite(e){this.pendingWrites++;try{await e()}finally{this.pendingWrites--}}async _set(e,i){return this._withPendingWrite(async()=>(await this._withRetries(r=>uy(r,e,i)),this.localCache[e]=i,this.notifyServiceWorker(e)))}async _get(e){const i=await this._withRetries(r=>F_(r,e));return this.localCache[e]=i,i}async _remove(e){return this._withPendingWrite(async()=>(await this._withRetries(i=>ly(i,e)),delete this.localCache[e],this.notifyServiceWorker(e)))}async _poll(){const e=await this._withRetries(o=>{const l=Ac(o,!1).getAll();return new au(l).toPromise()});if(!e)return[];if(this.pendingWrites!==0)return[];const i=[],r=new Set;if(e.length!==0)for(const{fbase_key:o,value:l}of e)r.add(o),JSON.stringify(this.localCache[o])!==JSON.stringify(l)&&(this.notifyListeners(o,l),i.push(o));for(const o of Object.keys(this.localCache))this.localCache[o]&&!r.has(o)&&(this.notifyListeners(o,null),i.push(o));return i}notifyListeners(e,i){this.localCache[e]=i;const r=this.listeners[e];if(r)for(const o of Array.from(r))o(i)}startPolling(){this.stopPolling(),this.pollTimer=setInterval(async()=>this._poll(),q_)}stopPolling(){this.pollTimer&&(clearInterval(this.pollTimer),this.pollTimer=null)}_addListener(e,i){Object.keys(this.listeners).length===0&&this.startPolling(),this.listeners[e]||(this.listeners[e]=new Set,this._get(e)),this.listeners[e].add(i)}_removeListener(e,i){this.listeners[e]&&(this.listeners[e].delete(i),this.listeners[e].size===0&&delete this.listeners[e]),Object.keys(this.listeners).length===0&&this.stopPolling()}}NO.type="LOCAL";const Y_=NO;new tu(3e4,6e4);function kO(n,e){return e?mi(e):(ue(n._popupRedirectResolver,n,"argument-error"),n._popupRedirectResolver)}class Pf extends Rf{constructor(e){super("custom","custom"),this.params=e}_getIdTokenResponse(e){return es(e,this._buildIdpRequest())}_linkToIdToken(e,i){return es(e,this._buildIdpRequest(i))}_getReauthenticationResolver(e){return es(e,this._buildIdpRequest())}_buildIdpRequest(e){const i={requestUri:this.params.requestUri,sessionId:this.params.sessionId,postBody:this.params.postBody,tenantId:this.params.tenantId,pendingToken:this.params.pendingToken,returnSecureToken:!0,returnIdpCredential:!0};return e&&(i.idToken=e),i}}function G_(n){return gO(n.auth,new Pf(n),n.bypassAuthState)}function V_(n){const{auth:e,user:i}=n;return ue(i,e,"internal-error"),b_(i,new Pf(n),n.bypassAuthState)}async function W_(n){const{auth:e,user:i}=n;return ue(i,e,"internal-error"),v_(i,new Pf(n),n.bypassAuthState)}class EO{constructor(e,i,r,o,l=!1){this.auth=e,this.resolver=r,this.user=o,this.bypassAuthState=l,this.pendingPromise=null,this.eventManager=null,this.filter=Array.isArray(i)?i:[i]}execute(){return new Promise(async(e,i)=>{this.pendingPromise={resolve:e,reject:i};try{this.eventManager=await this.resolver._initialize(this.auth),await this.onExecution(),this.eventManager.registerConsumer(this)}catch(r){this.reject(r)}})}async onAuthEvent(e){const{urlResponse:i,sessionId:r,postBody:o,tenantId:l,error:p,type:m}=e;if(p){this.reject(p);return}const h={auth:this.auth,requestUri:i,sessionId:r,tenantId:l||void 0,postBody:o||void 0,user:this.user,bypassAuthState:this.bypassAuthState};try{this.resolve(await this.getIdpTask(m)(h))}catch(x){this.reject(x)}}onError(e){this.reject(e)}getIdpTask(e){switch(e){case"signInViaPopup":case"signInViaRedirect":return G_;case"linkViaPopup":case"linkViaRedirect":return W_;case"reauthViaPopup":case"reauthViaRedirect":return V_;default:vn(this.auth,"internal-error")}}resolve(e){vi(this.pendingPromise,"Pending promise was never set"),this.pendingPromise.resolve(e),this.unregisterAndCleanUp()}reject(e){vi(this.pendingPromise,"Pending promise was never set"),this.pendingPromise.reject(e),this.unregisterAndCleanUp()}unregisterAndCleanUp(){this.eventManager&&this.eventManager.unregisterConsumer(this),this.pendingPromise=null,this.cleanUp()}}const K_=new tu(2e3,1e4);async function X_(n,e,i){if(Vt(n.app))return Promise.reject(An(n,"operation-not-supported-in-this-environment"));const r=xa(n);N4(n,e,If);const o=kO(r,i);return new za(r,"signInViaPopup",e,o).executeNotNull()}class za extends EO{constructor(e,i,r,o,l){super(e,i,o,l),this.provider=r,this.authWindow=null,this.pollId=null,za.currentPopupAction&&za.currentPopupAction.cancel(),za.currentPopupAction=this}async executeNotNull(){const e=await this.execute();return ue(e,this.auth,"internal-error"),e}async onExecution(){vi(this.filter.length===1,"Popup operations only handle one event");const e=Lf();this.authWindow=await this.resolver._openPopup(this.auth,this.provider,this.filter[0],e),this.authWindow.associatedEvent=e,this.resolver._originValidation(this.auth).catch(i=>{this.reject(i)}),this.resolver._isIframeWebStorageSupported(this.auth,i=>{i||this.reject(An(this.auth,"web-storage-unsupported"))}),this.pollUserCancellation()}get eventId(){return this.authWindow?.associatedEvent||null}cancel(){this.reject(An(this.auth,"cancelled-popup-request"))}cleanUp(){this.authWindow&&this.authWindow.close(),this.pollId&&window.clearTimeout(this.pollId),this.authWindow=null,this.pollId=null,za.currentPopupAction=null}pollUserCancellation(){const e=()=>{if(this.authWindow?.window?.closed){this.pollId=window.setTimeout(()=>{this.pollId=null,this.reject(An(this.auth,"popup-closed-by-user"))},8e3);return}this.pollId=window.setTimeout(e,K_.get())};e()}}za.currentPopupAction=null;const Q_="pendingRedirect",ql=new Map;class J_ extends EO{constructor(e,i,r=!1){super(e,["signInViaRedirect","linkViaRedirect","reauthViaRedirect","unknown"],i,void 0,r),this.eventId=null}async execute(){let e=ql.get(this.auth._key());if(!e){try{const r=await $_(this.resolver,this.auth)?await super.execute():null;e=()=>Promise.resolve(r)}catch(i){e=()=>Promise.reject(i)}ql.set(this.auth._key(),e)}return this.bypassAuthState||ql.set(this.auth._key(),()=>Promise.resolve(null)),e()}async onAuthEvent(e){if(e.type==="signInViaRedirect")return super.onAuthEvent(e);if(e.type==="unknown"){this.resolve(null);return}if(e.eventId){const i=await this.auth._redirectUserForId(e.eventId);if(i)return this.user=i,super.onAuthEvent(e);this.resolve(null)}}async onExecution(){}cleanUp(){}}async function $_(n,e){const i=tT(e),r=eT(n);if(!await r._isAvailable())return!1;const o=await r._get(i)==="true";return await r._remove(i),o}function Z_(n,e){ql.set(n._key(),e)}function eT(n){return mi(n._redirectPersistence)}function tT(n){return Fl(Q_,n.config.apiKey,n.name)}async function nT(n,e,i=!1){if(Vt(n.app))return Promise.reject(xi(n));const r=xa(n),o=kO(r,e),p=await new J_(r,o,i).execute();return p&&!i&&(delete p.user._redirectEventId,await r._persistUserIfCurrent(p.user),await r._setRedirectUser(null,e)),p}const iT=600*1e3;class aT{constructor(e){this.auth=e,this.cachedEventUids=new Set,this.consumers=new Set,this.queuedRedirectEvent=null,this.hasHandledPotentialRedirect=!1,this.lastProcessedEventTime=Date.now()}registerConsumer(e){this.consumers.add(e),this.queuedRedirectEvent&&this.isEventForConsumer(this.queuedRedirectEvent,e)&&(this.sendToConsumer(this.queuedRedirectEvent,e),this.saveEventToCache(this.queuedRedirectEvent),this.queuedRedirectEvent=null)}unregisterConsumer(e){this.consumers.delete(e)}onEvent(e){if(this.hasEventBeenHandled(e))return!1;let i=!1;return this.consumers.forEach(r=>{this.isEventForConsumer(e,r)&&(i=!0,this.sendToConsumer(e,r),this.saveEventToCache(e))}),this.hasHandledPotentialRedirect||!rT(e)||(this.hasHandledPotentialRedirect=!0,i||(this.queuedRedirectEvent=e,i=!0)),i}sendToConsumer(e,i){if(e.error&&!AO(e)){const r=e.error.code?.split("auth/")[1]||"internal-error";i.onError(An(this.auth,r))}else i.onAuthEvent(e)}isEventForConsumer(e,i){const r=i.eventId===null||!!e.eventId&&e.eventId===i.eventId;return i.filter.includes(e.type)&&r}hasEventBeenHandled(e){return Date.now()-this.lastProcessedEventTime>=iT&&this.cachedEventUids.clear(),this.cachedEventUids.has(cy(e))}saveEventToCache(e){this.cachedEventUids.add(cy(e)),this.lastProcessedEventTime=Date.now()}}function cy(n){return[n.type,n.eventId,n.sessionId,n.tenantId].filter(e=>e).join("-")}function AO({type:n,error:e}){return n==="unknown"&&e?.code==="auth/no-auth-event"}function rT(n){switch(n.type){case"signInViaRedirect":case"linkViaRedirect":case"reauthViaRedirect":return!0;case"unknown":return AO(n);default:return!1}}async function sT(n,e={}){return wi(n,"GET","/v1/projects",e)}const oT=/^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/,uT=/^https?/;async function lT(n){if(n.config.emulator)return;const{authorizedDomains:e}=await sT(n);for(const i of e)try{if(cT(i))return}catch{}vn(n,"unauthorized-domain")}function cT(n){const e=Hm(),{protocol:i,hostname:r}=new URL(e);if(n.startsWith("chrome-extension://")){const p=new URL(n);return p.hostname===""&&r===""?i==="chrome-extension:"&&n.replace("chrome-extension://","")===e.replace("chrome-extension://",""):i==="chrome-extension:"&&p.hostname===r}if(!uT.test(i))return!1;if(oT.test(n))return r===n;const o=n.replace(/\./g,"\\.");return new RegExp("^(.+\\."+o+"|"+o+")$","i").test(r)}const pT=new tu(3e4,6e4);function py(){const n=zn().___jsl;if(n?.H){for(const e of Object.keys(n.H))if(n.H[e].r=n.H[e].r||[],n.H[e].L=n.H[e].L||[],n.H[e].r=[...n.H[e].L],n.CP)for(let i=0;i<n.CP.length;i++)n.CP[i]=null}}function dT(n){return new Promise((e,i)=>{function r(){py(),gapi.load("gapi.iframes",{callback:()=>{e(gapi.iframes.getContext())},ontimeout:()=>{py(),i(An(n,"network-request-failed"))},timeout:pT.get()})}if(zn().gapi?.iframes?.Iframe)e(gapi.iframes.getContext());else if(zn().gapi?.load)r();else{const o=n_("iframefcb");return zn()[o]=()=>{gapi.load?r():i(An(n,"network-request-failed"))},mO(`${t_()}?onload=${o}`).catch(l=>i(l))}}).catch(e=>{throw Hl=null,e})}let Hl=null;function mT(n){return Hl=Hl||dT(n),Hl}const fT=new tu(5e3,15e3),hT="__/auth/iframe",xT="emulator/auth/iframe",gT={style:{position:"absolute",top:"-100px",width:"1px",height:"1px"},"aria-hidden":"true",tabindex:"-1"},yT=new Map([["identitytoolkit.googleapis.com","p"],["staging-identitytoolkit.sandbox.googleapis.com","s"],["test-identitytoolkit.sandbox.googleapis.com","t"]]);function OT(n){const e=n.config;ue(e.authDomain,n,"auth-domain-config-required");const i=e.emulator?Af(e,xT):`https://${n.config.authDomain}/${hT}`,r={apiKey:e.apiKey,appName:n.name,v:er},o=yT.get(n.config.apiHost);o&&(r.eid=o);const l=n._getFrameworks();return l.length&&(r.fw=l.join(",")),`${i}?${hs(r).slice(1)}`}async function vT(n){const e=await mT(n),i=zn().gapi;return ue(i,n,"internal-error"),e.open({where:document.body,url:OT(n),messageHandlersFilter:i.iframes.CROSS_ORIGIN_IFRAMES_FILTER,attributes:gT,dontclear:!0},r=>new Promise(async(o,l)=>{await r.restyle({setHideOnLeave:!1});const p=An(n,"network-request-failed"),m=zn().setTimeout(()=>{l(p)},fT.get());function h(){zn().clearTimeout(m),o(r)}r.ping(h).then(h,()=>{l(p)})}))}const bT={location:"yes",resizable:"yes",statusbar:"yes",toolbar:"no"},ST=500,wT=600,CT="_blank",_T="http://localhost";class dy{constructor(e){this.window=e,this.associatedEvent=null}close(){if(this.window)try{this.window.close()}catch{}}}function TT(n,e,i,r=ST,o=wT){const l=Math.max((window.screen.availHeight-o)/2,0).toString(),p=Math.max((window.screen.availWidth-r)/2,0).toString();let m="";const h={...bT,width:r.toString(),height:o.toString(),top:l,left:p},x=Lt().toLowerCase();i&&(m=sO(x)?CT:i),aO(x)&&(e=e||_T,h.scrollbars="yes");const O=Object.entries(h).reduce((v,[_,k])=>`${v}${_}=${k},`,"");if(V4(x)&&m!=="_self")return NT(e||"",m),new dy(null);const y=window.open(e||"",m,O);ue(y,n,"popup-blocked");try{y.focus()}catch{}return new dy(y)}function NT(n,e){const i=document.createElement("a");i.href=n,i.target=e;const r=document.createEvent("MouseEvent");r.initMouseEvent("click",!0,!0,window,1,0,0,0,0,!1,!1,!1,!1,1,null),i.dispatchEvent(r)}const kT="__/auth/handler",ET="emulator/auth/handler",AT=encodeURIComponent("fac");async function my(n,e,i,r,o,l){ue(n.config.authDomain,n,"auth-domain-config-required"),ue(n.config.apiKey,n,"invalid-api-key");const p={apiKey:n.config.apiKey,appName:n.name,authType:i,redirectUrl:r,v:er,eventId:o};if(e instanceof If){e.setDefaultLanguage(n.languageCode),p.providerId=e.providerId||"",Kl(e.getCustomParameters())||(p.customParameters=JSON.stringify(e.getCustomParameters()));for(const[O,y]of Object.entries({}))p[O]=y}if(e instanceof iu){const O=e.getScopes().filter(y=>y!=="");O.length>0&&(p.scopes=O.join(","))}n.tenantId&&(p.tid=n.tenantId);const m=p;for(const O of Object.keys(m))m[O]===void 0&&delete m[O];const h=await n._getAppCheckToken(),x=h?`#${AT}=${encodeURIComponent(h)}`:"";return`${jT(n)}?${hs(m).slice(1)}${x}`}function jT({config:n}){return n.emulator?Af(n,ET):`https://${n.authDomain}/${kT}`}const wm="webStorageSupport";class MT{constructor(){this.eventManagers={},this.iframes={},this.originValidationPromises={},this._redirectPersistence=wO,this._completeRedirectFn=nT,this._overrideRedirectResult=Z_}async _openPopup(e,i,r,o){vi(this.eventManagers[e._key()]?.manager,"_initialize() not called before _openPopup()");const l=await my(e,i,r,Hm(),o);return TT(e,l,Lf())}async _openRedirect(e,i,r,o){await this._originValidation(e);const l=await my(e,i,r,Hm(),o);return I_(l),new Promise(()=>{})}_initialize(e){const i=e._key();if(this.eventManagers[i]){const{manager:o,promise:l}=this.eventManagers[i];return o?Promise.resolve(o):(vi(l,"If manager is not set, promise should be"),l)}const r=this.initAndGetManager(e);return this.eventManagers[i]={promise:r},r.catch(()=>{delete this.eventManagers[i]}),r}async initAndGetManager(e){const i=await vT(e),r=new aT(e);return i.register("authEvent",o=>(ue(o?.authEvent,e,"invalid-auth-event"),{status:r.onEvent(o.authEvent)?"ACK":"ERROR"}),gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER),this.eventManagers[e._key()]={manager:r},this.iframes[e._key()]=i,r}_isIframeWebStorageSupported(e,i){this.iframes[e._key()].send(wm,{type:wm},o=>{const l=o?.[0]?.[wm];l!==void 0&&i(!!l),vn(e,"internal-error")},gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER)}_originValidation(e){const i=e._key();return this.originValidationPromises[i]||(this.originValidationPromises[i]=lT(e)),this.originValidationPromises[i]}get _shouldInitProactively(){return pO()||rO()||Mf()}}const RT=MT;var fy="@firebase/auth",hy="1.12.0";class DT{constructor(e){this.auth=e,this.internalListeners=new Map}getUid(){return this.assertAuthConfigured(),this.auth.currentUser?.uid||null}async getToken(e){return this.assertAuthConfigured(),await this.auth._initializationPromise,this.auth.currentUser?{accessToken:await this.auth.currentUser.getIdToken(e)}:null}addAuthTokenListener(e){if(this.assertAuthConfigured(),this.internalListeners.has(e))return;const i=this.auth.onIdTokenChanged(r=>{e(r?.stsTokenManager.accessToken||null)});this.internalListeners.set(e,i),this.updateProactiveRefresh()}removeAuthTokenListener(e){this.assertAuthConfigured();const i=this.internalListeners.get(e);i&&(this.internalListeners.delete(e),i(),this.updateProactiveRefresh())}assertAuthConfigured(){ue(this.auth._initializationPromise,"dependent-sdk-initialized-before-auth")}updateProactiveRefresh(){this.internalListeners.size>0?this.auth._startProactiveRefresh():this.auth._stopProactiveRefresh()}}function IT(n){switch(n){case"Node":return"node";case"ReactNative":return"rn";case"Worker":return"webworker";case"Cordova":return"cordova";case"WebExtension":return"web-extension";default:return}}function LT(n){Va(new la("auth",(e,{options:i})=>{const r=e.getProvider("app").getImmediate(),o=e.getProvider("heartbeat"),l=e.getProvider("app-check-internal"),{apiKey:p,authDomain:m}=r.options;ue(p&&!p.includes(":"),"invalid-api-key",{appName:r.name});const h={apiKey:p,authDomain:m,clientPlatform:n,apiHost:"identitytoolkit.googleapis.com",tokenApiHost:"securetoken.googleapis.com",apiScheme:"https",sdkClientVersion:dO(n)},x=new $4(r,o,l,h);return u_(x,i),x},"PUBLIC").setInstantiationMode("EXPLICIT").setInstanceCreatedCallback((e,i,r)=>{e.getProvider("auth-internal").initialize()})),Va(new la("auth-internal",e=>{const i=xa(e.getProvider("auth").getImmediate());return(r=>new DT(r))(i)},"PRIVATE").setInstantiationMode("EXPLICIT")),Un(fy,hy,IT(n)),Un(fy,hy,"esm2020")}const PT=300,BT=q2("authIdTokenMaxAge")||PT;let xy=null;const UT=n=>async e=>{const i=e&&await e.getIdTokenResult(),r=i&&(new Date().getTime()-Date.parse(i.issuedAtTime))/1e3;if(r&&r>BT)return;const o=i?.token;xy!==o&&(xy=o,await fetch(n,{method:o?"POST":"DELETE",headers:o?{Authorization:`Bearer ${o}`}:{}}))};function zT(n=Nf()){const e=Nc(n,"auth");if(e.isInitialized())return e.getImmediate();const i=o_(n,{popupRedirectResolver:RT,persistence:[Y_,M_,wO]}),r=q2("authTokenSyncURL");if(r&&typeof isSecureContext=="boolean"&&isSecureContext){const l=new URL(r,location.origin);if(location.origin===l.origin){const p=UT(l.toString());N_(i,p,()=>p(i.currentUser)),T_(i,m=>p(m))}}const o=U2("auth");return o&&l_(i,`http://${o}`),i}function FT(){return document.getElementsByTagName("head")?.[0]??document}Z4({loadJS(n){return new Promise((e,i)=>{const r=document.createElement("script");r.setAttribute("src",n),r.onload=e,r.onerror=o=>{const l=An("internal-error");l.customData=o,i(l)},r.type="text/javascript",r.charset="UTF-8",FT().appendChild(r)})},gapiScript:"https://apis.google.com/js/api.js",recaptchaV2Script:"https://www.google.com/recaptcha/api.js",recaptchaEnterpriseScript:"https://www.google.com/recaptcha/enterprise.js?render="});LT("Browser");var gy={};const yy="@firebase/database",Oy="1.1.0";let jO="";function qT(n){jO=n}class HT{constructor(e){this.domStorage_=e,this.prefix_="firebase:"}set(e,i){i==null?this.domStorage_.removeItem(this.prefixedName_(e)):this.domStorage_.setItem(this.prefixedName_(e),xt(i))}get(e){const i=this.domStorage_.getItem(this.prefixedName_(e));return i==null?null:Uo(i)}remove(e){this.domStorage_.removeItem(this.prefixedName_(e))}prefixedName_(e){return this.prefix_+e}toString(){return this.domStorage_.toString()}}class YT{constructor(){this.cache_={},this.isInMemoryStorage=!0}set(e,i){i==null?delete this.cache_[e]:this.cache_[e]=i}get(e){return Yn(this.cache_,e)?this.cache_[e]:null}remove(e){delete this.cache_[e]}}const MO=function(n){try{if(typeof window<"u"&&typeof window[n]<"u"){const e=window[n];return e.setItem("firebase:sentinel","cache"),e.removeItem("firebase:sentinel"),new HT(e)}}catch{}return new YT},Fa=MO("localStorage"),GT=MO("sessionStorage");const ts=new _f("@firebase/database"),VT=(function(){let n=1;return function(){return n++}})(),RO=function(n){const e=f5(n),i=new c5;i.update(e);const r=i.digest();return vf.encodeByteArray(r)},ru=function(...n){let e="";for(let i=0;i<n.length;i++){const r=n[i];Array.isArray(r)||r&&typeof r=="object"&&typeof r.length=="number"?e+=ru.apply(null,r):typeof r=="object"?e+=xt(r):e+=r,e+=" "}return e};let Ao=null,vy=!0;const WT=function(n,e){G(!0,"Can't turn on custom loggers persistently."),ts.logLevel=He.VERBOSE,Ao=ts.log.bind(ts)},bt=function(...n){if(vy===!0&&(vy=!1,Ao===null&&GT.get("logging_enabled")===!0&&WT()),Ao){const e=ru.apply(null,n);Ao(e)}},su=function(n){return function(...e){bt(n,...e)}},Wm=function(...n){const e="FIREBASE INTERNAL ERROR: "+ru(...n);ts.error(e)},bi=function(...n){const e=`FIREBASE FATAL ERROR: ${ru(...n)}`;throw ts.error(e),new Error(e)},It=function(...n){const e="FIREBASE WARNING: "+ru(...n);ts.warn(e)},KT=function(){typeof window<"u"&&window.location&&window.location.protocol&&window.location.protocol.indexOf("https:")!==-1&&It("Insecure Firebase access from a secure page. Please use https in calls to new Firebase().")},jc=function(n){return typeof n=="number"&&(n!==n||n===Number.POSITIVE_INFINITY||n===Number.NEGATIVE_INFINITY)},XT=function(n){if(document.readyState==="complete")n();else{let e=!1;const i=function(){if(!document.body){setTimeout(i,Math.floor(10));return}e||(e=!0,n())};document.addEventListener?(document.addEventListener("DOMContentLoaded",i,!1),window.addEventListener("load",i,!1)):document.attachEvent&&(document.attachEvent("onreadystatechange",()=>{document.readyState==="complete"&&i()}),window.attachEvent("onload",i))}},ss="[MIN_NAME]",Xa="[MAX_NAME]",tr=function(n,e){if(n===e)return 0;if(n===ss||e===Xa)return-1;if(e===ss||n===Xa)return 1;{const i=by(n),r=by(e);return i!==null?r!==null?i-r===0?n.length-e.length:i-r:-1:r!==null?1:n<e?-1:1}},QT=function(n,e){return n===e?0:n<e?-1:1},yo=function(n,e){if(e&&n in e)return e[n];throw new Error("Missing required key ("+n+") in object: "+xt(e))},Bf=function(n){if(typeof n!="object"||n===null)return xt(n);const e=[];for(const r in n)e.push(r);e.sort();let i="{";for(let r=0;r<e.length;r++)r!==0&&(i+=","),i+=xt(e[r]),i+=":",i+=Bf(n[e[r]]);return i+="}",i},DO=function(n,e){const i=n.length;if(i<=e)return[n];const r=[];for(let o=0;o<i;o+=e)o+e>i?r.push(n.substring(o,i)):r.push(n.substring(o,o+e));return r};function St(n,e){for(const i in n)n.hasOwnProperty(i)&&e(i,n[i])}const IO=function(n){G(!jc(n),"Invalid JSON number");const e=11,i=52,r=(1<<e-1)-1;let o,l,p,m,h;n===0?(l=0,p=0,o=1/n===-1/0?1:0):(o=n<0,n=Math.abs(n),n>=Math.pow(2,1-r)?(m=Math.min(Math.floor(Math.log(n)/Math.LN2),r),l=m+r,p=Math.round(n*Math.pow(2,i-m)-Math.pow(2,i))):(l=0,p=Math.round(n/Math.pow(2,1-r-i))));const x=[];for(h=i;h;h-=1)x.push(p%2?1:0),p=Math.floor(p/2);for(h=e;h;h-=1)x.push(l%2?1:0),l=Math.floor(l/2);x.push(o?1:0),x.reverse();const O=x.join("");let y="";for(h=0;h<64;h+=8){let v=parseInt(O.substr(h,8),2).toString(16);v.length===1&&(v="0"+v),y=y+v}return y.toLowerCase()},JT=function(){return!!(typeof window=="object"&&window.chrome&&window.chrome.extension&&!/^chrome/.test(window.location.href))},$T=function(){return typeof Windows=="object"&&typeof Windows.UI=="object"};function ZT(n,e){let i="Unknown Error";n==="too_big"?i="The data requested exceeds the maximum size that can be accessed with a single request.":n==="permission_denied"?i="Client doesn't have permission to access the desired data.":n==="unavailable"&&(i="The service is unavailable");const r=new Error(n+" at "+e._path.toString()+": "+i);return r.code=n.toUpperCase(),r}const eN=new RegExp("^-?(0*)\\d{1,10}$"),tN=-2147483648,nN=2147483647,by=function(n){if(eN.test(n)){const e=Number(n);if(e>=tN&&e<=nN)return e}return null},gs=function(n){try{n()}catch(e){setTimeout(()=>{const i=e.stack||"";throw It("Exception was thrown by user callback.",i),e},Math.floor(0))}},iN=function(){return(typeof window=="object"&&window.navigator&&window.navigator.userAgent||"").search(/googlebot|google webmaster tools|bingbot|yahoo! slurp|baiduspider|yandexbot|duckduckbot/i)>=0},jo=function(n,e){const i=setTimeout(n,e);return typeof i=="number"&&typeof Deno<"u"&&Deno.unrefTimer?Deno.unrefTimer(i):typeof i=="object"&&i.unref&&i.unref(),i};class aN{constructor(e,i){this.appCheckProvider=i,this.appName=e.name,Vt(e)&&e.settings.appCheckToken&&(this.serverAppAppCheckToken=e.settings.appCheckToken),this.appCheck=i?.getImmediate({optional:!0}),this.appCheck||i?.get().then(r=>this.appCheck=r)}getToken(e){if(this.serverAppAppCheckToken){if(e)throw new Error("Attempted reuse of `FirebaseServerApp.appCheckToken` after previous usage failed.");return Promise.resolve({token:this.serverAppAppCheckToken})}return this.appCheck?this.appCheck.getToken(e):new Promise((i,r)=>{setTimeout(()=>{this.appCheck?this.getToken(e).then(i,r):i(null)},0)})}addTokenChangeListener(e){this.appCheckProvider?.get().then(i=>i.addTokenListener(e))}notifyForInvalidToken(){It(`Provided AppCheck credentials for the app named "${this.appName}" are invalid. This usually indicates your app was not initialized correctly.`)}}class rN{constructor(e,i,r){this.appName_=e,this.firebaseOptions_=i,this.authProvider_=r,this.auth_=null,this.auth_=r.getImmediate({optional:!0}),this.auth_||r.onInit(o=>this.auth_=o)}getToken(e){return this.auth_?this.auth_.getToken(e).catch(i=>i&&i.code==="auth/token-not-initialized"?(bt("Got auth/token-not-initialized error.  Treating as null token."),null):Promise.reject(i)):new Promise((i,r)=>{setTimeout(()=>{this.auth_?this.getToken(e).then(i,r):i(null)},0)})}addTokenChangeListener(e){this.auth_?this.auth_.addAuthTokenListener(e):this.authProvider_.get().then(i=>i.addAuthTokenListener(e))}removeTokenChangeListener(e){this.authProvider_.get().then(i=>i.removeAuthTokenListener(e))}notifyForInvalidToken(){let e='Provided authentication credentials for the app named "'+this.appName_+'" are invalid. This usually indicates your app was not initialized correctly. ';"credential"in this.firebaseOptions_?e+='Make sure the "credential" property provided to initializeApp() is authorized to access the specified "databaseURL" and is from the correct project.':"serviceAccount"in this.firebaseOptions_?e+='Make sure the "serviceAccount" property provided to initializeApp() is authorized to access the specified "databaseURL" and is from the correct project.':e+='Make sure the "apiKey" and "databaseURL" properties provided to initializeApp() match the values provided for your app at https://console.firebase.google.com/.',It(e)}}class Yl{constructor(e){this.accessToken=e}getToken(e){return Promise.resolve({accessToken:this.accessToken})}addTokenChangeListener(e){e(this.accessToken)}removeTokenChangeListener(e){}notifyForInvalidToken(){}}Yl.OWNER="owner";const Uf="5",LO="v",PO="s",BO="r",UO="f",zO=/(console\.firebase|firebase-console-\w+\.corp|firebase\.corp)\.google\.com/,FO="ls",qO="p",Km="ac",HO="websocket",YO="long_polling";class GO{constructor(e,i,r,o,l=!1,p="",m=!1,h=!1,x=null){this.secure=i,this.namespace=r,this.webSocketOnly=o,this.nodeAdmin=l,this.persistenceKey=p,this.includeNamespaceInQueryParams=m,this.isUsingEmulator=h,this.emulatorOptions=x,this._host=e.toLowerCase(),this._domain=this._host.substr(this._host.indexOf(".")+1),this.internalHost=Fa.get("host:"+e)||this._host}isCacheableHost(){return this.internalHost.substr(0,2)==="s-"}isCustomHost(){return this._domain!=="firebaseio.com"&&this._domain!=="firebaseio-demo.com"}get host(){return this._host}set host(e){e!==this.internalHost&&(this.internalHost=e,this.isCacheableHost()&&Fa.set("host:"+this._host,this.internalHost))}toString(){let e=this.toURLString();return this.persistenceKey&&(e+="<"+this.persistenceKey+">"),e}toURLString(){const e=this.secure?"https://":"http://",i=this.includeNamespaceInQueryParams?`?ns=${this.namespace}`:"";return`${e}${this.host}/${i}`}}function sN(n){return n.host!==n.internalHost||n.isCustomHost()||n.includeNamespaceInQueryParams}function VO(n,e,i){G(typeof e=="string","typeof type must == string"),G(typeof i=="object","typeof params must == object");let r;if(e===HO)r=(n.secure?"wss://":"ws://")+n.internalHost+"/.ws?";else if(e===YO)r=(n.secure?"https://":"http://")+n.internalHost+"/.lp?";else throw new Error("Unknown connection type: "+e);sN(n)&&(i.ns=n.namespace);const o=[];return St(i,(l,p)=>{o.push(l+"="+p)}),r+o.join("&")}class oN{constructor(){this.counters_={}}incrementCounter(e,i=1){Yn(this.counters_,e)||(this.counters_[e]=0),this.counters_[e]+=i}get(){return GC(this.counters_)}}const Cm={},_m={};function zf(n){const e=n.toString();return Cm[e]||(Cm[e]=new oN),Cm[e]}function uN(n,e){const i=n.toString();return _m[i]||(_m[i]=e()),_m[i]}class lN{constructor(e){this.onMessage_=e,this.pendingResponses=[],this.currentResponseNum=0,this.closeAfterResponse=-1,this.onClose=null}closeAfter(e,i){this.closeAfterResponse=e,this.onClose=i,this.closeAfterResponse<this.currentResponseNum&&(this.onClose(),this.onClose=null)}handleResponse(e,i){for(this.pendingResponses[e]=i;this.pendingResponses[this.currentResponseNum];){const r=this.pendingResponses[this.currentResponseNum];delete this.pendingResponses[this.currentResponseNum];for(let o=0;o<r.length;++o)r[o]&&gs(()=>{this.onMessage_(r[o])});if(this.currentResponseNum===this.closeAfterResponse){this.onClose&&(this.onClose(),this.onClose=null);break}this.currentResponseNum++}}}const Sy="start",cN="close",pN="pLPCommand",dN="pRTLPCB",WO="id",KO="pw",XO="ser",mN="cb",fN="seg",hN="ts",xN="d",gN="dframe",QO=1870,JO=30,yN=QO-JO,ON=25e3,vN=3e4;class Qr{constructor(e,i,r,o,l,p,m){this.connId=e,this.repoInfo=i,this.applicationId=r,this.appCheckToken=o,this.authToken=l,this.transportSessionId=p,this.lastSessionId=m,this.bytesSent=0,this.bytesReceived=0,this.everConnected_=!1,this.log_=su(e),this.stats_=zf(i),this.urlFn=h=>(this.appCheckToken&&(h[Km]=this.appCheckToken),VO(i,YO,h))}open(e,i){this.curSegmentNum=0,this.onDisconnect_=i,this.myPacketOrderer=new lN(e),this.isClosed_=!1,this.connectTimeoutTimer_=setTimeout(()=>{this.log_("Timed out trying to connect."),this.onClosed_(),this.connectTimeoutTimer_=null},Math.floor(vN)),XT(()=>{if(this.isClosed_)return;this.scriptTagHolder=new Ff((...l)=>{const[p,m,h,x,O]=l;if(this.incrementIncomingBytes_(l),!!this.scriptTagHolder)if(this.connectTimeoutTimer_&&(clearTimeout(this.connectTimeoutTimer_),this.connectTimeoutTimer_=null),this.everConnected_=!0,p===Sy)this.id=m,this.password=h;else if(p===cN)m?(this.scriptTagHolder.sendNewPolls=!1,this.myPacketOrderer.closeAfter(m,()=>{this.onClosed_()})):this.onClosed_();else throw new Error("Unrecognized command received: "+p)},(...l)=>{const[p,m]=l;this.incrementIncomingBytes_(l),this.myPacketOrderer.handleResponse(p,m)},()=>{this.onClosed_()},this.urlFn);const r={};r[Sy]="t",r[XO]=Math.floor(Math.random()*1e8),this.scriptTagHolder.uniqueCallbackIdentifier&&(r[mN]=this.scriptTagHolder.uniqueCallbackIdentifier),r[LO]=Uf,this.transportSessionId&&(r[PO]=this.transportSessionId),this.lastSessionId&&(r[FO]=this.lastSessionId),this.applicationId&&(r[qO]=this.applicationId),this.appCheckToken&&(r[Km]=this.appCheckToken),typeof location<"u"&&location.hostname&&zO.test(location.hostname)&&(r[BO]=UO);const o=this.urlFn(r);this.log_("Connecting via long-poll to "+o),this.scriptTagHolder.addTag(o,()=>{})})}start(){this.scriptTagHolder.startLongPoll(this.id,this.password),this.addDisconnectPingFrame(this.id,this.password)}static forceAllow(){Qr.forceAllow_=!0}static forceDisallow(){Qr.forceDisallow_=!0}static isAvailable(){return Qr.forceAllow_?!0:!Qr.forceDisallow_&&typeof document<"u"&&document.createElement!=null&&!JT()&&!$T()}markConnectionHealthy(){}shutdown_(){this.isClosed_=!0,this.scriptTagHolder&&(this.scriptTagHolder.close(),this.scriptTagHolder=null),this.myDisconnFrame&&(document.body.removeChild(this.myDisconnFrame),this.myDisconnFrame=null),this.connectTimeoutTimer_&&(clearTimeout(this.connectTimeoutTimer_),this.connectTimeoutTimer_=null)}onClosed_(){this.isClosed_||(this.log_("Longpoll is closing itself"),this.shutdown_(),this.onDisconnect_&&(this.onDisconnect_(this.everConnected_),this.onDisconnect_=null))}close(){this.isClosed_||(this.log_("Longpoll is being closed."),this.shutdown_())}send(e){const i=xt(e);this.bytesSent+=i.length,this.stats_.incrementCounter("bytes_sent",i.length);const r=P2(i),o=DO(r,yN);for(let l=0;l<o.length;l++)this.scriptTagHolder.enqueueSegment(this.curSegmentNum,o.length,o[l]),this.curSegmentNum++}addDisconnectPingFrame(e,i){this.myDisconnFrame=document.createElement("iframe");const r={};r[gN]="t",r[WO]=e,r[KO]=i,this.myDisconnFrame.src=this.urlFn(r),this.myDisconnFrame.style.display="none",document.body.appendChild(this.myDisconnFrame)}incrementIncomingBytes_(e){const i=xt(e).length;this.bytesReceived+=i,this.stats_.incrementCounter("bytes_received",i)}}class Ff{constructor(e,i,r,o){this.onDisconnect=r,this.urlFn=o,this.outstandingRequests=new Set,this.pendingSegs=[],this.currentSerial=Math.floor(Math.random()*1e8),this.sendNewPolls=!0;{this.uniqueCallbackIdentifier=VT(),window[pN+this.uniqueCallbackIdentifier]=e,window[dN+this.uniqueCallbackIdentifier]=i,this.myIFrame=Ff.createIFrame_();let l="";this.myIFrame.src&&this.myIFrame.src.substr(0,11)==="javascript:"&&(l='<script>document.domain="'+document.domain+'";<\/script>');const p="<html><body>"+l+"</body></html>";try{this.myIFrame.doc.open(),this.myIFrame.doc.write(p),this.myIFrame.doc.close()}catch(m){bt("frame writing exception"),m.stack&&bt(m.stack),bt(m)}}}static createIFrame_(){const e=document.createElement("iframe");if(e.style.display="none",document.body){document.body.appendChild(e);try{e.contentWindow.document||bt("No IE domain setting required")}catch{const r=document.domain;e.src="javascript:void((function(){document.open();document.domain='"+r+"';document.close();})())"}}else throw"Document body has not initialized. Wait to initialize Firebase until after the document is ready.";return e.contentDocument?e.doc=e.contentDocument:e.contentWindow?e.doc=e.contentWindow.document:e.document&&(e.doc=e.document),e}close(){this.alive=!1,this.myIFrame&&(this.myIFrame.doc.body.textContent="",setTimeout(()=>{this.myIFrame!==null&&(document.body.removeChild(this.myIFrame),this.myIFrame=null)},Math.floor(0)));const e=this.onDisconnect;e&&(this.onDisconnect=null,e())}startLongPoll(e,i){for(this.myID=e,this.myPW=i,this.alive=!0;this.newRequest_(););}newRequest_(){if(this.alive&&this.sendNewPolls&&this.outstandingRequests.size<(this.pendingSegs.length>0?2:1)){this.currentSerial++;const e={};e[WO]=this.myID,e[KO]=this.myPW,e[XO]=this.currentSerial;let i=this.urlFn(e),r="",o=0;for(;this.pendingSegs.length>0&&this.pendingSegs[0].d.length+JO+r.length<=QO;){const p=this.pendingSegs.shift();r=r+"&"+fN+o+"="+p.seg+"&"+hN+o+"="+p.ts+"&"+xN+o+"="+p.d,o++}return i=i+r,this.addLongPollTag_(i,this.currentSerial),!0}else return!1}enqueueSegment(e,i,r){this.pendingSegs.push({seg:e,ts:i,d:r}),this.alive&&this.newRequest_()}addLongPollTag_(e,i){this.outstandingRequests.add(i);const r=()=>{this.outstandingRequests.delete(i),this.newRequest_()},o=setTimeout(r,Math.floor(ON)),l=()=>{clearTimeout(o),r()};this.addTag(e,l)}addTag(e,i){setTimeout(()=>{try{if(!this.sendNewPolls)return;const r=this.myIFrame.doc.createElement("script");r.type="text/javascript",r.async=!0,r.src=e,r.onload=r.onreadystatechange=function(){const o=r.readyState;(!o||o==="loaded"||o==="complete")&&(r.onload=r.onreadystatechange=null,r.parentNode&&r.parentNode.removeChild(r),i())},r.onerror=()=>{bt("Long-poll script failed to load: "+e),this.sendNewPolls=!1,this.close()},this.myIFrame.doc.body.appendChild(r)}catch{}},Math.floor(1))}}const bN=16384,SN=45e3;let ic=null;typeof MozWebSocket<"u"?ic=MozWebSocket:typeof WebSocket<"u"&&(ic=WebSocket);class Nn{constructor(e,i,r,o,l,p,m){this.connId=e,this.applicationId=r,this.appCheckToken=o,this.authToken=l,this.keepaliveTimer=null,this.frames=null,this.totalFrames=0,this.bytesSent=0,this.bytesReceived=0,this.log_=su(this.connId),this.stats_=zf(i),this.connURL=Nn.connectionURL_(i,p,m,o,r),this.nodeAdmin=i.nodeAdmin}static connectionURL_(e,i,r,o,l){const p={};return p[LO]=Uf,typeof location<"u"&&location.hostname&&zO.test(location.hostname)&&(p[BO]=UO),i&&(p[PO]=i),r&&(p[FO]=r),o&&(p[Km]=o),l&&(p[qO]=l),VO(e,HO,p)}open(e,i){this.onDisconnect=i,this.onMessage=e,this.log_("Websocket connecting to "+this.connURL),this.everConnected_=!1,Fa.set("previous_websocket_failure",!0);try{let r;n5(),this.mySock=new ic(this.connURL,[],r)}catch(r){this.log_("Error instantiating WebSocket.");const o=r.message||r.data;o&&this.log_(o),this.onClosed_();return}this.mySock.onopen=()=>{this.log_("Websocket connected."),this.everConnected_=!0},this.mySock.onclose=()=>{this.log_("Websocket connection was disconnected."),this.mySock=null,this.onClosed_()},this.mySock.onmessage=r=>{this.handleIncomingFrame(r)},this.mySock.onerror=r=>{this.log_("WebSocket error.  Closing connection.");const o=r.message||r.data;o&&this.log_(o),this.onClosed_()}}start(){}static forceDisallow(){Nn.forceDisallow_=!0}static isAvailable(){let e=!1;if(typeof navigator<"u"&&navigator.userAgent){const i=/Android ([0-9]{0,}\.[0-9]{0,})/,r=navigator.userAgent.match(i);r&&r.length>1&&parseFloat(r[1])<4.4&&(e=!0)}return!e&&ic!==null&&!Nn.forceDisallow_}static previouslyFailed(){return Fa.isInMemoryStorage||Fa.get("previous_websocket_failure")===!0}markConnectionHealthy(){Fa.remove("previous_websocket_failure")}appendFrame_(e){if(this.frames.push(e),this.frames.length===this.totalFrames){const i=this.frames.join("");this.frames=null;const r=Uo(i);this.onMessage(r)}}handleNewFrameCount_(e){this.totalFrames=e,this.frames=[]}extractFrameCount_(e){if(G(this.frames===null,"We already have a frame buffer"),e.length<=6){const i=Number(e);if(!isNaN(i))return this.handleNewFrameCount_(i),null}return this.handleNewFrameCount_(1),e}handleIncomingFrame(e){if(this.mySock===null)return;const i=e.data;if(this.bytesReceived+=i.length,this.stats_.incrementCounter("bytes_received",i.length),this.resetKeepAlive(),this.frames!==null)this.appendFrame_(i);else{const r=this.extractFrameCount_(i);r!==null&&this.appendFrame_(r)}}send(e){this.resetKeepAlive();const i=xt(e);this.bytesSent+=i.length,this.stats_.incrementCounter("bytes_sent",i.length);const r=DO(i,bN);r.length>1&&this.sendString_(String(r.length));for(let o=0;o<r.length;o++)this.sendString_(r[o])}shutdown_(){this.isClosed_=!0,this.keepaliveTimer&&(clearInterval(this.keepaliveTimer),this.keepaliveTimer=null),this.mySock&&(this.mySock.close(),this.mySock=null)}onClosed_(){this.isClosed_||(this.log_("WebSocket is closing itself"),this.shutdown_(),this.onDisconnect&&(this.onDisconnect(this.everConnected_),this.onDisconnect=null))}close(){this.isClosed_||(this.log_("WebSocket is being closed"),this.shutdown_())}resetKeepAlive(){clearInterval(this.keepaliveTimer),this.keepaliveTimer=setInterval(()=>{this.mySock&&this.sendString_("0"),this.resetKeepAlive()},Math.floor(SN))}sendString_(e){try{this.mySock.send(e)}catch(i){this.log_("Exception thrown from WebSocket.send():",i.message||i.data,"Closing connection."),setTimeout(this.onClosed_.bind(this),0)}}}Nn.responsesRequiredToBeHealthy=2;Nn.healthyTimeout=3e4;class qo{static get ALL_TRANSPORTS(){return[Qr,Nn]}static get IS_TRANSPORT_INITIALIZED(){return this.globalTransportInitialized_}constructor(e){this.initTransports_(e)}initTransports_(e){const i=Nn&&Nn.isAvailable();let r=i&&!Nn.previouslyFailed();if(e.webSocketOnly&&(i||It("wss:// URL used, but browser isn't known to support websockets.  Trying anyway."),r=!0),r)this.transports_=[Nn];else{const o=this.transports_=[];for(const l of qo.ALL_TRANSPORTS)l&&l.isAvailable()&&o.push(l);qo.globalTransportInitialized_=!0}}initialTransport(){if(this.transports_.length>0)return this.transports_[0];throw new Error("No transports available")}upgradeTransport(){return this.transports_.length>1?this.transports_[1]:null}}qo.globalTransportInitialized_=!1;const wN=6e4,CN=5e3,_N=10*1024,TN=100*1024,Tm="t",wy="d",NN="s",Cy="r",kN="e",_y="o",Ty="a",Ny="n",ky="p",EN="h";class AN{constructor(e,i,r,o,l,p,m,h,x,O){this.id=e,this.repoInfo_=i,this.applicationId_=r,this.appCheckToken_=o,this.authToken_=l,this.onMessage_=p,this.onReady_=m,this.onDisconnect_=h,this.onKill_=x,this.lastSessionId=O,this.connectionCount=0,this.pendingDataMessages=[],this.state_=0,this.log_=su("c:"+this.id+":"),this.transportManager_=new qo(i),this.log_("Connection created"),this.start_()}start_(){const e=this.transportManager_.initialTransport();this.conn_=new e(this.nextTransportId_(),this.repoInfo_,this.applicationId_,this.appCheckToken_,this.authToken_,null,this.lastSessionId),this.primaryResponsesRequired_=e.responsesRequiredToBeHealthy||0;const i=this.connReceiver_(this.conn_),r=this.disconnReceiver_(this.conn_);this.tx_=this.conn_,this.rx_=this.conn_,this.secondaryConn_=null,this.isHealthy_=!1,setTimeout(()=>{this.conn_&&this.conn_.open(i,r)},Math.floor(0));const o=e.healthyTimeout||0;o>0&&(this.healthyTimeout_=jo(()=>{this.healthyTimeout_=null,this.isHealthy_||(this.conn_&&this.conn_.bytesReceived>TN?(this.log_("Connection exceeded healthy timeout but has received "+this.conn_.bytesReceived+" bytes.  Marking connection healthy."),this.isHealthy_=!0,this.conn_.markConnectionHealthy()):this.conn_&&this.conn_.bytesSent>_N?this.log_("Connection exceeded healthy timeout but has sent "+this.conn_.bytesSent+" bytes.  Leaving connection alive."):(this.log_("Closing unhealthy connection after timeout."),this.close()))},Math.floor(o)))}nextTransportId_(){return"c:"+this.id+":"+this.connectionCount++}disconnReceiver_(e){return i=>{e===this.conn_?this.onConnectionLost_(i):e===this.secondaryConn_?(this.log_("Secondary connection lost."),this.onSecondaryConnectionLost_()):this.log_("closing an old connection")}}connReceiver_(e){return i=>{this.state_!==2&&(e===this.rx_?this.onPrimaryMessageReceived_(i):e===this.secondaryConn_?this.onSecondaryMessageReceived_(i):this.log_("message on old connection"))}}sendRequest(e){const i={t:"d",d:e};this.sendData_(i)}tryCleanupConnection(){this.tx_===this.secondaryConn_&&this.rx_===this.secondaryConn_&&(this.log_("cleaning up and promoting a connection: "+this.secondaryConn_.connId),this.conn_=this.secondaryConn_,this.secondaryConn_=null)}onSecondaryControl_(e){if(Tm in e){const i=e[Tm];i===Ty?this.upgradeIfSecondaryHealthy_():i===Cy?(this.log_("Got a reset on secondary, closing it"),this.secondaryConn_.close(),(this.tx_===this.secondaryConn_||this.rx_===this.secondaryConn_)&&this.close()):i===_y&&(this.log_("got pong on secondary."),this.secondaryResponsesRequired_--,this.upgradeIfSecondaryHealthy_())}}onSecondaryMessageReceived_(e){const i=yo("t",e),r=yo("d",e);if(i==="c")this.onSecondaryControl_(r);else if(i==="d")this.pendingDataMessages.push(r);else throw new Error("Unknown protocol layer: "+i)}upgradeIfSecondaryHealthy_(){this.secondaryResponsesRequired_<=0?(this.log_("Secondary connection is healthy."),this.isHealthy_=!0,this.secondaryConn_.markConnectionHealthy(),this.proceedWithUpgrade_()):(this.log_("sending ping on secondary."),this.secondaryConn_.send({t:"c",d:{t:ky,d:{}}}))}proceedWithUpgrade_(){this.secondaryConn_.start(),this.log_("sending client ack on secondary"),this.secondaryConn_.send({t:"c",d:{t:Ty,d:{}}}),this.log_("Ending transmission on primary"),this.conn_.send({t:"c",d:{t:Ny,d:{}}}),this.tx_=this.secondaryConn_,this.tryCleanupConnection()}onPrimaryMessageReceived_(e){const i=yo("t",e),r=yo("d",e);i==="c"?this.onControl_(r):i==="d"&&this.onDataMessage_(r)}onDataMessage_(e){this.onPrimaryResponse_(),this.onMessage_(e)}onPrimaryResponse_(){this.isHealthy_||(this.primaryResponsesRequired_--,this.primaryResponsesRequired_<=0&&(this.log_("Primary connection is healthy."),this.isHealthy_=!0,this.conn_.markConnectionHealthy()))}onControl_(e){const i=yo(Tm,e);if(wy in e){const r=e[wy];if(i===EN){const o={...r};this.repoInfo_.isUsingEmulator&&(o.h=this.repoInfo_.host),this.onHandshake_(o)}else if(i===Ny){this.log_("recvd end transmission on primary"),this.rx_=this.secondaryConn_;for(let o=0;o<this.pendingDataMessages.length;++o)this.onDataMessage_(this.pendingDataMessages[o]);this.pendingDataMessages=[],this.tryCleanupConnection()}else i===NN?this.onConnectionShutdown_(r):i===Cy?this.onReset_(r):i===kN?Wm("Server Error: "+r):i===_y?(this.log_("got pong on primary."),this.onPrimaryResponse_(),this.sendPingOnPrimaryIfNecessary_()):Wm("Unknown control packet command: "+i)}}onHandshake_(e){const i=e.ts,r=e.v,o=e.h;this.sessionId=e.s,this.repoInfo_.host=o,this.state_===0&&(this.conn_.start(),this.onConnectionEstablished_(this.conn_,i),Uf!==r&&It("Protocol version mismatch detected"),this.tryStartUpgrade_())}tryStartUpgrade_(){const e=this.transportManager_.upgradeTransport();e&&this.startUpgrade_(e)}startUpgrade_(e){this.secondaryConn_=new e(this.nextTransportId_(),this.repoInfo_,this.applicationId_,this.appCheckToken_,this.authToken_,this.sessionId),this.secondaryResponsesRequired_=e.responsesRequiredToBeHealthy||0;const i=this.connReceiver_(this.secondaryConn_),r=this.disconnReceiver_(this.secondaryConn_);this.secondaryConn_.open(i,r),jo(()=>{this.secondaryConn_&&(this.log_("Timed out trying to upgrade."),this.secondaryConn_.close())},Math.floor(wN))}onReset_(e){this.log_("Reset packet received.  New host: "+e),this.repoInfo_.host=e,this.state_===1?this.close():(this.closeConnections_(),this.start_())}onConnectionEstablished_(e,i){this.log_("Realtime connection established."),this.conn_=e,this.state_=1,this.onReady_&&(this.onReady_(i,this.sessionId),this.onReady_=null),this.primaryResponsesRequired_===0?(this.log_("Primary connection is healthy."),this.isHealthy_=!0):jo(()=>{this.sendPingOnPrimaryIfNecessary_()},Math.floor(CN))}sendPingOnPrimaryIfNecessary_(){!this.isHealthy_&&this.state_===1&&(this.log_("sending ping on primary."),this.sendData_({t:"c",d:{t:ky,d:{}}}))}onSecondaryConnectionLost_(){const e=this.secondaryConn_;this.secondaryConn_=null,(this.tx_===e||this.rx_===e)&&this.close()}onConnectionLost_(e){this.conn_=null,!e&&this.state_===0?(this.log_("Realtime connection failed."),this.repoInfo_.isCacheableHost()&&(Fa.remove("host:"+this.repoInfo_.host),this.repoInfo_.internalHost=this.repoInfo_.host)):this.state_===1&&this.log_("Realtime connection lost."),this.close()}onConnectionShutdown_(e){this.log_("Connection shutdown command received. Shutting down..."),this.onKill_&&(this.onKill_(e),this.onKill_=null),this.onDisconnect_=null,this.close()}sendData_(e){if(this.state_!==1)throw"Connection is not connected";this.tx_.send(e)}close(){this.state_!==2&&(this.log_("Closing realtime connection."),this.state_=2,this.closeConnections_(),this.onDisconnect_&&(this.onDisconnect_(),this.onDisconnect_=null))}closeConnections_(){this.log_("Shutting down all connections"),this.conn_&&(this.conn_.close(),this.conn_=null),this.secondaryConn_&&(this.secondaryConn_.close(),this.secondaryConn_=null),this.healthyTimeout_&&(clearTimeout(this.healthyTimeout_),this.healthyTimeout_=null)}}class $O{put(e,i,r,o){}merge(e,i,r,o){}refreshAuthToken(e){}refreshAppCheckToken(e){}onDisconnectPut(e,i,r){}onDisconnectMerge(e,i,r){}onDisconnectCancel(e,i){}reportStats(e){}}class ZO{constructor(e){this.allowedEvents_=e,this.listeners_={},G(Array.isArray(e)&&e.length>0,"Requires a non-empty array")}trigger(e,...i){if(Array.isArray(this.listeners_[e])){const r=[...this.listeners_[e]];for(let o=0;o<r.length;o++)r[o].callback.apply(r[o].context,i)}}on(e,i,r){this.validateEventType_(e),this.listeners_[e]=this.listeners_[e]||[],this.listeners_[e].push({callback:i,context:r});const o=this.getInitialEvent(e);o&&i.apply(r,o)}off(e,i,r){this.validateEventType_(e);const o=this.listeners_[e]||[];for(let l=0;l<o.length;l++)if(o[l].callback===i&&(!r||r===o[l].context)){o.splice(l,1);return}}validateEventType_(e){G(this.allowedEvents_.find(i=>i===e),"Unknown event: "+e)}}class ac extends ZO{static getInstance(){return new ac}constructor(){super(["online"]),this.online_=!0,typeof window<"u"&&typeof window.addEventListener<"u"&&!Cf()&&(window.addEventListener("online",()=>{this.online_||(this.online_=!0,this.trigger("online",!0))},!1),window.addEventListener("offline",()=>{this.online_&&(this.online_=!1,this.trigger("online",!1))},!1))}getInitialEvent(e){return G(e==="online","Unknown event type: "+e),[this.online_]}currentlyOnline(){return this.online_}}const Ey=32,Ay=768;class Be{constructor(e,i){if(i===void 0){this.pieces_=e.split("/");let r=0;for(let o=0;o<this.pieces_.length;o++)this.pieces_[o].length>0&&(this.pieces_[r]=this.pieces_[o],r++);this.pieces_.length=r,this.pieceNum_=0}else this.pieces_=e,this.pieceNum_=i}toString(){let e="";for(let i=this.pieceNum_;i<this.pieces_.length;i++)this.pieces_[i]!==""&&(e+="/"+this.pieces_[i]);return e||"/"}}function Me(){return new Be("")}function Oe(n){return n.pieceNum_>=n.pieces_.length?null:n.pieces_[n.pieceNum_]}function ca(n){return n.pieces_.length-n.pieceNum_}function Ve(n){let e=n.pieceNum_;return e<n.pieces_.length&&e++,new Be(n.pieces_,e)}function qf(n){return n.pieceNum_<n.pieces_.length?n.pieces_[n.pieces_.length-1]:null}function jN(n){let e="";for(let i=n.pieceNum_;i<n.pieces_.length;i++)n.pieces_[i]!==""&&(e+="/"+encodeURIComponent(String(n.pieces_[i])));return e||"/"}function Ho(n,e=0){return n.pieces_.slice(n.pieceNum_+e)}function ev(n){if(n.pieceNum_>=n.pieces_.length)return null;const e=[];for(let i=n.pieceNum_;i<n.pieces_.length-1;i++)e.push(n.pieces_[i]);return new Be(e,0)}function $e(n,e){const i=[];for(let r=n.pieceNum_;r<n.pieces_.length;r++)i.push(n.pieces_[r]);if(e instanceof Be)for(let r=e.pieceNum_;r<e.pieces_.length;r++)i.push(e.pieces_[r]);else{const r=e.split("/");for(let o=0;o<r.length;o++)r[o].length>0&&i.push(r[o])}return new Be(i,0)}function ve(n){return n.pieceNum_>=n.pieces_.length}function Dt(n,e){const i=Oe(n),r=Oe(e);if(i===null)return e;if(i===r)return Dt(Ve(n),Ve(e));throw new Error("INTERNAL ERROR: innerPath ("+e+") is not within outerPath ("+n+")")}function MN(n,e){const i=Ho(n,0),r=Ho(e,0);for(let o=0;o<i.length&&o<r.length;o++){const l=tr(i[o],r[o]);if(l!==0)return l}return i.length===r.length?0:i.length<r.length?-1:1}function Hf(n,e){if(ca(n)!==ca(e))return!1;for(let i=n.pieceNum_,r=e.pieceNum_;i<=n.pieces_.length;i++,r++)if(n.pieces_[i]!==e.pieces_[r])return!1;return!0}function yn(n,e){let i=n.pieceNum_,r=e.pieceNum_;if(ca(n)>ca(e))return!1;for(;i<n.pieces_.length;){if(n.pieces_[i]!==e.pieces_[r])return!1;++i,++r}return!0}class RN{constructor(e,i){this.errorPrefix_=i,this.parts_=Ho(e,0),this.byteLength_=Math.max(1,this.parts_.length);for(let r=0;r<this.parts_.length;r++)this.byteLength_+=Tc(this.parts_[r]);tv(this)}}function DN(n,e){n.parts_.length>0&&(n.byteLength_+=1),n.parts_.push(e),n.byteLength_+=Tc(e),tv(n)}function IN(n){const e=n.parts_.pop();n.byteLength_-=Tc(e),n.parts_.length>0&&(n.byteLength_-=1)}function tv(n){if(n.byteLength_>Ay)throw new Error(n.errorPrefix_+"has a key path longer than "+Ay+" bytes ("+n.byteLength_+").");if(n.parts_.length>Ey)throw new Error(n.errorPrefix_+"path specified exceeds the maximum depth that can be written ("+Ey+") or object contains a cycle "+Ua(n))}function Ua(n){return n.parts_.length===0?"":"in property '"+n.parts_.join(".")+"'"}class Yf extends ZO{static getInstance(){return new Yf}constructor(){super(["visible"]);let e,i;typeof document<"u"&&typeof document.addEventListener<"u"&&(typeof document.hidden<"u"?(i="visibilitychange",e="hidden"):typeof document.mozHidden<"u"?(i="mozvisibilitychange",e="mozHidden"):typeof document.msHidden<"u"?(i="msvisibilitychange",e="msHidden"):typeof document.webkitHidden<"u"&&(i="webkitvisibilitychange",e="webkitHidden")),this.visible_=!0,i&&document.addEventListener(i,()=>{const r=!document[e];r!==this.visible_&&(this.visible_=r,this.trigger("visible",r))},!1)}getInitialEvent(e){return G(e==="visible","Unknown event type: "+e),[this.visible_]}}const Oo=1e3,LN=300*1e3,jy=30*1e3,PN=1.3,BN=3e4,UN="server_kill",My=3;class gi extends $O{constructor(e,i,r,o,l,p,m,h){if(super(),this.repoInfo_=e,this.applicationId_=i,this.onDataUpdate_=r,this.onConnectStatus_=o,this.onServerInfoUpdate_=l,this.authTokenProvider_=p,this.appCheckTokenProvider_=m,this.authOverride_=h,this.id=gi.nextPersistentConnectionId_++,this.log_=su("p:"+this.id+":"),this.interruptReasons_={},this.listens=new Map,this.outstandingPuts_=[],this.outstandingGets_=[],this.outstandingPutCount_=0,this.outstandingGetCount_=0,this.onDisconnectRequestQueue_=[],this.connected_=!1,this.reconnectDelay_=Oo,this.maxReconnectDelay_=LN,this.securityDebugCallback_=null,this.lastSessionId=null,this.establishConnectionTimer_=null,this.visible_=!1,this.requestCBHash_={},this.requestNumber_=0,this.realtime_=null,this.authToken_=null,this.appCheckToken_=null,this.forceTokenRefresh_=!1,this.invalidAuthTokenCount_=0,this.invalidAppCheckTokenCount_=0,this.firstConnection_=!0,this.lastConnectionAttemptTime_=null,this.lastConnectionEstablishedTime_=null,h)throw new Error("Auth override specified in options, but not supported on non Node.js platforms");Yf.getInstance().on("visible",this.onVisible_,this),e.host.indexOf("fblocal")===-1&&ac.getInstance().on("online",this.onOnline_,this)}sendRequest(e,i,r){const o=++this.requestNumber_,l={r:o,a:e,b:i};this.log_(xt(l)),G(this.connected_,"sendRequest call when we're not connected not allowed."),this.realtime_.sendRequest(l),r&&(this.requestCBHash_[o]=r)}get(e){this.initConnection_();const i=new Pn,o={action:"g",request:{p:e._path.toString(),q:e._queryObject},onComplete:p=>{const m=p.d;p.s==="ok"?i.resolve(m):i.reject(m)}};this.outstandingGets_.push(o),this.outstandingGetCount_++;const l=this.outstandingGets_.length-1;return this.connected_&&this.sendGet_(l),i.promise}listen(e,i,r,o){this.initConnection_();const l=e._queryIdentifier,p=e._path.toString();this.log_("Listen called for "+p+" "+l),this.listens.has(p)||this.listens.set(p,new Map),G(e._queryParams.isDefault()||!e._queryParams.loadsAllData(),"listen() called for non-default but complete query"),G(!this.listens.get(p).has(l),"listen() called twice for same path/queryId.");const m={onComplete:o,hashFn:i,query:e,tag:r};this.listens.get(p).set(l,m),this.connected_&&this.sendListen_(m)}sendGet_(e){const i=this.outstandingGets_[e];this.sendRequest("g",i.request,r=>{delete this.outstandingGets_[e],this.outstandingGetCount_--,this.outstandingGetCount_===0&&(this.outstandingGets_=[]),i.onComplete&&i.onComplete(r)})}sendListen_(e){const i=e.query,r=i._path.toString(),o=i._queryIdentifier;this.log_("Listen on "+r+" for "+o);const l={p:r},p="q";e.tag&&(l.q=i._queryObject,l.t=e.tag),l.h=e.hashFn(),this.sendRequest(p,l,m=>{const h=m.d,x=m.s;gi.warnOnListenWarnings_(h,i),(this.listens.get(r)&&this.listens.get(r).get(o))===e&&(this.log_("listen response",m),x!=="ok"&&this.removeListen_(r,o),e.onComplete&&e.onComplete(x,h))})}static warnOnListenWarnings_(e,i){if(e&&typeof e=="object"&&Yn(e,"w")){const r=is(e,"w");if(Array.isArray(r)&&~r.indexOf("no_index")){const o='".indexOn": "'+i._queryParams.getIndex().toString()+'"',l=i._path.toString();It(`Using an unspecified index. Your data will be downloaded and filtered on the client. Consider adding ${o} at ${l} to your security rules for better performance.`)}}}refreshAuthToken(e){this.authToken_=e,this.log_("Auth token refreshed"),this.authToken_?this.tryAuth():this.connected_&&this.sendRequest("unauth",{},()=>{}),this.reduceReconnectDelayIfAdminCredential_(e)}reduceReconnectDelayIfAdminCredential_(e){(e&&e.length===40||l5(e))&&(this.log_("Admin auth credential detected.  Reducing max reconnect time."),this.maxReconnectDelay_=jy)}refreshAppCheckToken(e){this.appCheckToken_=e,this.log_("App check token refreshed"),this.appCheckToken_?this.tryAppCheck():this.connected_&&this.sendRequest("unappeck",{},()=>{})}tryAuth(){if(this.connected_&&this.authToken_){const e=this.authToken_,i=u5(e)?"auth":"gauth",r={cred:e};this.authOverride_===null?r.noauth=!0:typeof this.authOverride_=="object"&&(r.authvar=this.authOverride_),this.sendRequest(i,r,o=>{const l=o.s,p=o.d||"error";this.authToken_===e&&(l==="ok"?this.invalidAuthTokenCount_=0:this.onAuthRevoked_(l,p))})}}tryAppCheck(){this.connected_&&this.appCheckToken_&&this.sendRequest("appcheck",{token:this.appCheckToken_},e=>{const i=e.s,r=e.d||"error";i==="ok"?this.invalidAppCheckTokenCount_=0:this.onAppCheckRevoked_(i,r)})}unlisten(e,i){const r=e._path.toString(),o=e._queryIdentifier;this.log_("Unlisten called for "+r+" "+o),G(e._queryParams.isDefault()||!e._queryParams.loadsAllData(),"unlisten() called for non-default but complete query"),this.removeListen_(r,o)&&this.connected_&&this.sendUnlisten_(r,o,e._queryObject,i)}sendUnlisten_(e,i,r,o){this.log_("Unlisten on "+e+" for "+i);const l={p:e},p="n";o&&(l.q=r,l.t=o),this.sendRequest(p,l)}onDisconnectPut(e,i,r){this.initConnection_(),this.connected_?this.sendOnDisconnect_("o",e,i,r):this.onDisconnectRequestQueue_.push({pathString:e,action:"o",data:i,onComplete:r})}onDisconnectMerge(e,i,r){this.initConnection_(),this.connected_?this.sendOnDisconnect_("om",e,i,r):this.onDisconnectRequestQueue_.push({pathString:e,action:"om",data:i,onComplete:r})}onDisconnectCancel(e,i){this.initConnection_(),this.connected_?this.sendOnDisconnect_("oc",e,null,i):this.onDisconnectRequestQueue_.push({pathString:e,action:"oc",data:null,onComplete:i})}sendOnDisconnect_(e,i,r,o){const l={p:i,d:r};this.log_("onDisconnect "+e,l),this.sendRequest(e,l,p=>{o&&setTimeout(()=>{o(p.s,p.d)},Math.floor(0))})}put(e,i,r,o){this.putInternal("p",e,i,r,o)}merge(e,i,r,o){this.putInternal("m",e,i,r,o)}putInternal(e,i,r,o,l){this.initConnection_();const p={p:i,d:r};l!==void 0&&(p.h=l),this.outstandingPuts_.push({action:e,request:p,onComplete:o}),this.outstandingPutCount_++;const m=this.outstandingPuts_.length-1;this.connected_?this.sendPut_(m):this.log_("Buffering put: "+i)}sendPut_(e){const i=this.outstandingPuts_[e].action,r=this.outstandingPuts_[e].request,o=this.outstandingPuts_[e].onComplete;this.outstandingPuts_[e].queued=this.connected_,this.sendRequest(i,r,l=>{this.log_(i+" response",l),delete this.outstandingPuts_[e],this.outstandingPutCount_--,this.outstandingPutCount_===0&&(this.outstandingPuts_=[]),o&&o(l.s,l.d)})}reportStats(e){if(this.connected_){const i={c:e};this.log_("reportStats",i),this.sendRequest("s",i,r=>{if(r.s!=="ok"){const l=r.d;this.log_("reportStats","Error sending stats: "+l)}})}}onDataMessage_(e){if("r"in e){this.log_("from server: "+xt(e));const i=e.r,r=this.requestCBHash_[i];r&&(delete this.requestCBHash_[i],r(e.b))}else{if("error"in e)throw"A server-side error has occurred: "+e.error;"a"in e&&this.onDataPush_(e.a,e.b)}}onDataPush_(e,i){this.log_("handleServerMessage",e,i),e==="d"?this.onDataUpdate_(i.p,i.d,!1,i.t):e==="m"?this.onDataUpdate_(i.p,i.d,!0,i.t):e==="c"?this.onListenRevoked_(i.p,i.q):e==="ac"?this.onAuthRevoked_(i.s,i.d):e==="apc"?this.onAppCheckRevoked_(i.s,i.d):e==="sd"?this.onSecurityDebugPacket_(i):Wm("Unrecognized action received from server: "+xt(e)+`
Are you using the latest client?`)}onReady_(e,i){this.log_("connection ready"),this.connected_=!0,this.lastConnectionEstablishedTime_=new Date().getTime(),this.handleTimestamp_(e),this.lastSessionId=i,this.firstConnection_&&this.sendConnectStats_(),this.restoreState_(),this.firstConnection_=!1,this.onConnectStatus_(!0)}scheduleConnect_(e){G(!this.realtime_,"Scheduling a connect when we're already connected/ing?"),this.establishConnectionTimer_&&clearTimeout(this.establishConnectionTimer_),this.establishConnectionTimer_=setTimeout(()=>{this.establishConnectionTimer_=null,this.establishConnection_()},Math.floor(e))}initConnection_(){!this.realtime_&&this.firstConnection_&&this.scheduleConnect_(0)}onVisible_(e){e&&!this.visible_&&this.reconnectDelay_===this.maxReconnectDelay_&&(this.log_("Window became visible.  Reducing delay."),this.reconnectDelay_=Oo,this.realtime_||this.scheduleConnect_(0)),this.visible_=e}onOnline_(e){e?(this.log_("Browser went online."),this.reconnectDelay_=Oo,this.realtime_||this.scheduleConnect_(0)):(this.log_("Browser went offline.  Killing connection."),this.realtime_&&this.realtime_.close())}onRealtimeDisconnect_(){if(this.log_("data client disconnected"),this.connected_=!1,this.realtime_=null,this.cancelSentTransactions_(),this.requestCBHash_={},this.shouldReconnect_()){this.visible_?this.lastConnectionEstablishedTime_&&(new Date().getTime()-this.lastConnectionEstablishedTime_>BN&&(this.reconnectDelay_=Oo),this.lastConnectionEstablishedTime_=null):(this.log_("Window isn't visible.  Delaying reconnect."),this.reconnectDelay_=this.maxReconnectDelay_,this.lastConnectionAttemptTime_=new Date().getTime());const e=Math.max(0,new Date().getTime()-this.lastConnectionAttemptTime_);let i=Math.max(0,this.reconnectDelay_-e);i=Math.random()*i,this.log_("Trying to reconnect in "+i+"ms"),this.scheduleConnect_(i),this.reconnectDelay_=Math.min(this.maxReconnectDelay_,this.reconnectDelay_*PN)}this.onConnectStatus_(!1)}async establishConnection_(){if(this.shouldReconnect_()){this.log_("Making a connection attempt"),this.lastConnectionAttemptTime_=new Date().getTime(),this.lastConnectionEstablishedTime_=null;const e=this.onDataMessage_.bind(this),i=this.onReady_.bind(this),r=this.onRealtimeDisconnect_.bind(this),o=this.id+":"+gi.nextConnectionId_++,l=this.lastSessionId;let p=!1,m=null;const h=function(){m?m.close():(p=!0,r())},x=function(y){G(m,"sendRequest call when we're not connected not allowed."),m.sendRequest(y)};this.realtime_={close:h,sendRequest:x};const O=this.forceTokenRefresh_;this.forceTokenRefresh_=!1;try{const[y,v]=await Promise.all([this.authTokenProvider_.getToken(O),this.appCheckTokenProvider_.getToken(O)]);p?bt("getToken() completed but was canceled"):(bt("getToken() completed. Creating connection."),this.authToken_=y&&y.accessToken,this.appCheckToken_=v&&v.token,m=new AN(o,this.repoInfo_,this.applicationId_,this.appCheckToken_,this.authToken_,e,i,r,_=>{It(_+" ("+this.repoInfo_.toString()+")"),this.interrupt(UN)},l))}catch(y){this.log_("Failed to get token: "+y),p||(this.repoInfo_.nodeAdmin&&It(y),h())}}}interrupt(e){bt("Interrupting connection for reason: "+e),this.interruptReasons_[e]=!0,this.realtime_?this.realtime_.close():(this.establishConnectionTimer_&&(clearTimeout(this.establishConnectionTimer_),this.establishConnectionTimer_=null),this.connected_&&this.onRealtimeDisconnect_())}resume(e){bt("Resuming connection for reason: "+e),delete this.interruptReasons_[e],Kl(this.interruptReasons_)&&(this.reconnectDelay_=Oo,this.realtime_||this.scheduleConnect_(0))}handleTimestamp_(e){const i=e-new Date().getTime();this.onServerInfoUpdate_({serverTimeOffset:i})}cancelSentTransactions_(){for(let e=0;e<this.outstandingPuts_.length;e++){const i=this.outstandingPuts_[e];i&&"h"in i.request&&i.queued&&(i.onComplete&&i.onComplete("disconnect"),delete this.outstandingPuts_[e],this.outstandingPutCount_--)}this.outstandingPutCount_===0&&(this.outstandingPuts_=[])}onListenRevoked_(e,i){let r;i?r=i.map(l=>Bf(l)).join("$"):r="default";const o=this.removeListen_(e,r);o&&o.onComplete&&o.onComplete("permission_denied")}removeListen_(e,i){const r=new Be(e).toString();let o;if(this.listens.has(r)){const l=this.listens.get(r);o=l.get(i),l.delete(i),l.size===0&&this.listens.delete(r)}else o=void 0;return o}onAuthRevoked_(e,i){bt("Auth token revoked: "+e+"/"+i),this.authToken_=null,this.forceTokenRefresh_=!0,this.realtime_.close(),(e==="invalid_token"||e==="permission_denied")&&(this.invalidAuthTokenCount_++,this.invalidAuthTokenCount_>=My&&(this.reconnectDelay_=jy,this.authTokenProvider_.notifyForInvalidToken()))}onAppCheckRevoked_(e,i){bt("App check token revoked: "+e+"/"+i),this.appCheckToken_=null,this.forceTokenRefresh_=!0,(e==="invalid_token"||e==="permission_denied")&&(this.invalidAppCheckTokenCount_++,this.invalidAppCheckTokenCount_>=My&&this.appCheckTokenProvider_.notifyForInvalidToken())}onSecurityDebugPacket_(e){this.securityDebugCallback_?this.securityDebugCallback_(e):"msg"in e&&console.log("FIREBASE: "+e.msg.replace(`
`,`
FIREBASE: `))}restoreState_(){this.tryAuth(),this.tryAppCheck();for(const e of this.listens.values())for(const i of e.values())this.sendListen_(i);for(let e=0;e<this.outstandingPuts_.length;e++)this.outstandingPuts_[e]&&this.sendPut_(e);for(;this.onDisconnectRequestQueue_.length;){const e=this.onDisconnectRequestQueue_.shift();this.sendOnDisconnect_(e.action,e.pathString,e.data,e.onComplete)}for(let e=0;e<this.outstandingGets_.length;e++)this.outstandingGets_[e]&&this.sendGet_(e)}sendConnectStats_(){const e={};let i="js";e["sdk."+i+"."+jO.replace(/\./g,"-")]=1,Cf()?e["framework.cordova"]=1:Y2()&&(e["framework.reactnative"]=1),this.reportStats(e)}shouldReconnect_(){const e=ac.getInstance().currentlyOnline();return Kl(this.interruptReasons_)&&e}}gi.nextPersistentConnectionId_=0;gi.nextConnectionId_=0;class be{constructor(e,i){this.name=e,this.node=i}static Wrap(e,i){return new be(e,i)}}class Mc{getCompare(){return this.compare.bind(this)}indexedValueChanged(e,i){const r=new be(ss,e),o=new be(ss,i);return this.compare(r,o)!==0}minPost(){return be.MIN}}let jl;class nv extends Mc{static get __EMPTY_NODE(){return jl}static set __EMPTY_NODE(e){jl=e}compare(e,i){return tr(e.name,i.name)}isDefinedOn(e){throw fs("KeyIndex.isDefinedOn not expected to be called.")}indexedValueChanged(e,i){return!1}minPost(){return be.MIN}maxPost(){return new be(Xa,jl)}makePost(e,i){return G(typeof e=="string","KeyIndex indexValue must always be a string."),new be(e,jl)}toString(){return".key"}}const ns=new nv;class Ml{constructor(e,i,r,o,l=null){this.isReverse_=o,this.resultGenerator_=l,this.nodeStack_=[];let p=1;for(;!e.isEmpty();)if(e=e,p=i?r(e.key,i):1,o&&(p*=-1),p<0)this.isReverse_?e=e.left:e=e.right;else if(p===0){this.nodeStack_.push(e);break}else this.nodeStack_.push(e),this.isReverse_?e=e.right:e=e.left}getNext(){if(this.nodeStack_.length===0)return null;let e=this.nodeStack_.pop(),i;if(this.resultGenerator_?i=this.resultGenerator_(e.key,e.value):i={key:e.key,value:e.value},this.isReverse_)for(e=e.left;!e.isEmpty();)this.nodeStack_.push(e),e=e.right;else for(e=e.right;!e.isEmpty();)this.nodeStack_.push(e),e=e.left;return i}hasNext(){return this.nodeStack_.length>0}peek(){if(this.nodeStack_.length===0)return null;const e=this.nodeStack_[this.nodeStack_.length-1];return this.resultGenerator_?this.resultGenerator_(e.key,e.value):{key:e.key,value:e.value}}}class vt{constructor(e,i,r,o,l){this.key=e,this.value=i,this.color=r??vt.RED,this.left=o??Wt.EMPTY_NODE,this.right=l??Wt.EMPTY_NODE}copy(e,i,r,o,l){return new vt(e??this.key,i??this.value,r??this.color,o??this.left,l??this.right)}count(){return this.left.count()+1+this.right.count()}isEmpty(){return!1}inorderTraversal(e){return this.left.inorderTraversal(e)||!!e(this.key,this.value)||this.right.inorderTraversal(e)}reverseTraversal(e){return this.right.reverseTraversal(e)||e(this.key,this.value)||this.left.reverseTraversal(e)}min_(){return this.left.isEmpty()?this:this.left.min_()}minKey(){return this.min_().key}maxKey(){return this.right.isEmpty()?this.key:this.right.maxKey()}insert(e,i,r){let o=this;const l=r(e,o.key);return l<0?o=o.copy(null,null,null,o.left.insert(e,i,r),null):l===0?o=o.copy(null,i,null,null,null):o=o.copy(null,null,null,null,o.right.insert(e,i,r)),o.fixUp_()}removeMin_(){if(this.left.isEmpty())return Wt.EMPTY_NODE;let e=this;return!e.left.isRed_()&&!e.left.left.isRed_()&&(e=e.moveRedLeft_()),e=e.copy(null,null,null,e.left.removeMin_(),null),e.fixUp_()}remove(e,i){let r,o;if(r=this,i(e,r.key)<0)!r.left.isEmpty()&&!r.left.isRed_()&&!r.left.left.isRed_()&&(r=r.moveRedLeft_()),r=r.copy(null,null,null,r.left.remove(e,i),null);else{if(r.left.isRed_()&&(r=r.rotateRight_()),!r.right.isEmpty()&&!r.right.isRed_()&&!r.right.left.isRed_()&&(r=r.moveRedRight_()),i(e,r.key)===0){if(r.right.isEmpty())return Wt.EMPTY_NODE;o=r.right.min_(),r=r.copy(o.key,o.value,null,null,r.right.removeMin_())}r=r.copy(null,null,null,null,r.right.remove(e,i))}return r.fixUp_()}isRed_(){return this.color}fixUp_(){let e=this;return e.right.isRed_()&&!e.left.isRed_()&&(e=e.rotateLeft_()),e.left.isRed_()&&e.left.left.isRed_()&&(e=e.rotateRight_()),e.left.isRed_()&&e.right.isRed_()&&(e=e.colorFlip_()),e}moveRedLeft_(){let e=this.colorFlip_();return e.right.left.isRed_()&&(e=e.copy(null,null,null,null,e.right.rotateRight_()),e=e.rotateLeft_(),e=e.colorFlip_()),e}moveRedRight_(){let e=this.colorFlip_();return e.left.left.isRed_()&&(e=e.rotateRight_(),e=e.colorFlip_()),e}rotateLeft_(){const e=this.copy(null,null,vt.RED,null,this.right.left);return this.right.copy(null,null,this.color,e,null)}rotateRight_(){const e=this.copy(null,null,vt.RED,this.left.right,null);return this.left.copy(null,null,this.color,null,e)}colorFlip_(){const e=this.left.copy(null,null,!this.left.color,null,null),i=this.right.copy(null,null,!this.right.color,null,null);return this.copy(null,null,!this.color,e,i)}checkMaxDepth_(){const e=this.check_();return Math.pow(2,e)<=this.count()+1}check_(){if(this.isRed_()&&this.left.isRed_())throw new Error("Red node has red child("+this.key+","+this.value+")");if(this.right.isRed_())throw new Error("Right child of ("+this.key+","+this.value+") is red");const e=this.left.check_();if(e!==this.right.check_())throw new Error("Black depths differ");return e+(this.isRed_()?0:1)}}vt.RED=!0;vt.BLACK=!1;class zN{copy(e,i,r,o,l){return this}insert(e,i,r){return new vt(e,i,null)}remove(e,i){return this}count(){return 0}isEmpty(){return!0}inorderTraversal(e){return!1}reverseTraversal(e){return!1}minKey(){return null}maxKey(){return null}check_(){return 0}isRed_(){return!1}}class Wt{constructor(e,i=Wt.EMPTY_NODE){this.comparator_=e,this.root_=i}insert(e,i){return new Wt(this.comparator_,this.root_.insert(e,i,this.comparator_).copy(null,null,vt.BLACK,null,null))}remove(e){return new Wt(this.comparator_,this.root_.remove(e,this.comparator_).copy(null,null,vt.BLACK,null,null))}get(e){let i,r=this.root_;for(;!r.isEmpty();){if(i=this.comparator_(e,r.key),i===0)return r.value;i<0?r=r.left:i>0&&(r=r.right)}return null}getPredecessorKey(e){let i,r=this.root_,o=null;for(;!r.isEmpty();)if(i=this.comparator_(e,r.key),i===0){if(r.left.isEmpty())return o?o.key:null;for(r=r.left;!r.right.isEmpty();)r=r.right;return r.key}else i<0?r=r.left:i>0&&(o=r,r=r.right);throw new Error("Attempted to find predecessor key for a nonexistent key.  What gives?")}isEmpty(){return this.root_.isEmpty()}count(){return this.root_.count()}minKey(){return this.root_.minKey()}maxKey(){return this.root_.maxKey()}inorderTraversal(e){return this.root_.inorderTraversal(e)}reverseTraversal(e){return this.root_.reverseTraversal(e)}getIterator(e){return new Ml(this.root_,null,this.comparator_,!1,e)}getIteratorFrom(e,i){return new Ml(this.root_,e,this.comparator_,!1,i)}getReverseIteratorFrom(e,i){return new Ml(this.root_,e,this.comparator_,!0,i)}getReverseIterator(e){return new Ml(this.root_,null,this.comparator_,!0,e)}}Wt.EMPTY_NODE=new zN;function FN(n,e){return tr(n.name,e.name)}function Gf(n,e){return tr(n,e)}let Xm;function qN(n){Xm=n}const iv=function(n){return typeof n=="number"?"number:"+IO(n):"string:"+n},av=function(n){if(n.isLeafNode()){const e=n.val();G(typeof e=="string"||typeof e=="number"||typeof e=="object"&&Yn(e,".sv"),"Priority must be a string or number.")}else G(n===Xm||n.isEmpty(),"priority of unexpected type.");G(n===Xm||n.getPriority().isEmpty(),"Priority nodes can't have a priority of their own.")};let Ry;class Ot{static set __childrenNodeConstructor(e){Ry=e}static get __childrenNodeConstructor(){return Ry}constructor(e,i=Ot.__childrenNodeConstructor.EMPTY_NODE){this.value_=e,this.priorityNode_=i,this.lazyHash_=null,G(this.value_!==void 0&&this.value_!==null,"LeafNode shouldn't be created with null/undefined value."),av(this.priorityNode_)}isLeafNode(){return!0}getPriority(){return this.priorityNode_}updatePriority(e){return new Ot(this.value_,e)}getImmediateChild(e){return e===".priority"?this.priorityNode_:Ot.__childrenNodeConstructor.EMPTY_NODE}getChild(e){return ve(e)?this:Oe(e)===".priority"?this.priorityNode_:Ot.__childrenNodeConstructor.EMPTY_NODE}hasChild(){return!1}getPredecessorChildName(e,i){return null}updateImmediateChild(e,i){return e===".priority"?this.updatePriority(i):i.isEmpty()&&e!==".priority"?this:Ot.__childrenNodeConstructor.EMPTY_NODE.updateImmediateChild(e,i).updatePriority(this.priorityNode_)}updateChild(e,i){const r=Oe(e);return r===null?i:i.isEmpty()&&r!==".priority"?this:(G(r!==".priority"||ca(e)===1,".priority must be the last token in a path"),this.updateImmediateChild(r,Ot.__childrenNodeConstructor.EMPTY_NODE.updateChild(Ve(e),i)))}isEmpty(){return!1}numChildren(){return 0}forEachChild(e,i){return!1}val(e){return e&&!this.getPriority().isEmpty()?{".value":this.getValue(),".priority":this.getPriority().val()}:this.getValue()}hash(){if(this.lazyHash_===null){let e="";this.priorityNode_.isEmpty()||(e+="priority:"+iv(this.priorityNode_.val())+":");const i=typeof this.value_;e+=i+":",i==="number"?e+=IO(this.value_):e+=this.value_,this.lazyHash_=RO(e)}return this.lazyHash_}getValue(){return this.value_}compareTo(e){return e===Ot.__childrenNodeConstructor.EMPTY_NODE?1:e instanceof Ot.__childrenNodeConstructor?-1:(G(e.isLeafNode(),"Unknown node type"),this.compareToLeafNode_(e))}compareToLeafNode_(e){const i=typeof e.value_,r=typeof this.value_,o=Ot.VALUE_TYPE_ORDER.indexOf(i),l=Ot.VALUE_TYPE_ORDER.indexOf(r);return G(o>=0,"Unknown leaf type: "+i),G(l>=0,"Unknown leaf type: "+r),o===l?r==="object"?0:this.value_<e.value_?-1:this.value_===e.value_?0:1:l-o}withIndex(){return this}isIndexed(){return!0}equals(e){if(e===this)return!0;if(e.isLeafNode()){const i=e;return this.value_===i.value_&&this.priorityNode_.equals(i.priorityNode_)}else return!1}}Ot.VALUE_TYPE_ORDER=["object","boolean","number","string"];let rv,sv;function HN(n){rv=n}function YN(n){sv=n}class GN extends Mc{compare(e,i){const r=e.node.getPriority(),o=i.node.getPriority(),l=r.compareTo(o);return l===0?tr(e.name,i.name):l}isDefinedOn(e){return!e.getPriority().isEmpty()}indexedValueChanged(e,i){return!e.getPriority().equals(i.getPriority())}minPost(){return be.MIN}maxPost(){return new be(Xa,new Ot("[PRIORITY-POST]",sv))}makePost(e,i){const r=rv(e);return new be(i,new Ot("[PRIORITY-POST]",r))}toString(){return".priority"}}const Ze=new GN;const VN=Math.log(2);class WN{constructor(e){const i=l=>parseInt(Math.log(l)/VN,10),r=l=>parseInt(Array(l+1).join("1"),2);this.count=i(e+1),this.current_=this.count-1;const o=r(this.count);this.bits_=e+1&o}nextBitIsOne(){const e=!(this.bits_&1<<this.current_);return this.current_--,e}}const rc=function(n,e,i,r){n.sort(e);const o=function(h,x){const O=x-h;let y,v;if(O===0)return null;if(O===1)return y=n[h],v=i?i(y):y,new vt(v,y.node,vt.BLACK,null,null);{const _=parseInt(O/2,10)+h,k=o(h,_),I=o(_+1,x);return y=n[_],v=i?i(y):y,new vt(v,y.node,vt.BLACK,k,I)}},l=function(h){let x=null,O=null,y=n.length;const v=function(k,I){const D=y-k,q=y;y-=k;const z=o(D+1,q),H=n[D],J=i?i(H):H;_(new vt(J,H.node,I,null,z))},_=function(k){x?(x.left=k,x=k):(O=k,x=k)};for(let k=0;k<h.count;++k){const I=h.nextBitIsOne(),D=Math.pow(2,h.count-(k+1));I?v(D,vt.BLACK):(v(D,vt.BLACK),v(D,vt.RED))}return O},p=new WN(n.length),m=l(p);return new Wt(r||e,m)};let Nm;const Kr={};class fi{static get Default(){return G(Kr&&Ze,"ChildrenNode.ts has not been loaded"),Nm=Nm||new fi({".priority":Kr},{".priority":Ze}),Nm}constructor(e,i){this.indexes_=e,this.indexSet_=i}get(e){const i=is(this.indexes_,e);if(!i)throw new Error("No index defined for "+e);return i instanceof Wt?i:null}hasIndex(e){return Yn(this.indexSet_,e.toString())}addIndex(e,i){G(e!==ns,"KeyIndex always exists and isn't meant to be added to the IndexMap.");const r=[];let o=!1;const l=i.getIterator(be.Wrap);let p=l.getNext();for(;p;)o=o||e.isDefinedOn(p.node),r.push(p),p=l.getNext();let m;o?m=rc(r,e.getCompare()):m=Kr;const h=e.toString(),x={...this.indexSet_};x[h]=e;const O={...this.indexes_};return O[h]=m,new fi(O,x)}addToIndexes(e,i){const r=Xl(this.indexes_,(o,l)=>{const p=is(this.indexSet_,l);if(G(p,"Missing index implementation for "+l),o===Kr)if(p.isDefinedOn(e.node)){const m=[],h=i.getIterator(be.Wrap);let x=h.getNext();for(;x;)x.name!==e.name&&m.push(x),x=h.getNext();return m.push(e),rc(m,p.getCompare())}else return Kr;else{const m=i.get(e.name);let h=o;return m&&(h=h.remove(new be(e.name,m))),h.insert(e,e.node)}});return new fi(r,this.indexSet_)}removeFromIndexes(e,i){const r=Xl(this.indexes_,o=>{if(o===Kr)return o;{const l=i.get(e.name);return l?o.remove(new be(e.name,l)):o}});return new fi(r,this.indexSet_)}}let vo;class le{static get EMPTY_NODE(){return vo||(vo=new le(new Wt(Gf),null,fi.Default))}constructor(e,i,r){this.children_=e,this.priorityNode_=i,this.indexMap_=r,this.lazyHash_=null,this.priorityNode_&&av(this.priorityNode_),this.children_.isEmpty()&&G(!this.priorityNode_||this.priorityNode_.isEmpty(),"An empty node cannot have a priority")}isLeafNode(){return!1}getPriority(){return this.priorityNode_||vo}updatePriority(e){return this.children_.isEmpty()?this:new le(this.children_,e,this.indexMap_)}getImmediateChild(e){if(e===".priority")return this.getPriority();{const i=this.children_.get(e);return i===null?vo:i}}getChild(e){const i=Oe(e);return i===null?this:this.getImmediateChild(i).getChild(Ve(e))}hasChild(e){return this.children_.get(e)!==null}updateImmediateChild(e,i){if(G(i,"We should always be passing snapshot nodes"),e===".priority")return this.updatePriority(i);{const r=new be(e,i);let o,l;i.isEmpty()?(o=this.children_.remove(e),l=this.indexMap_.removeFromIndexes(r,this.children_)):(o=this.children_.insert(e,i),l=this.indexMap_.addToIndexes(r,this.children_));const p=o.isEmpty()?vo:this.priorityNode_;return new le(o,p,l)}}updateChild(e,i){const r=Oe(e);if(r===null)return i;{G(Oe(e)!==".priority"||ca(e)===1,".priority must be the last token in a path");const o=this.getImmediateChild(r).updateChild(Ve(e),i);return this.updateImmediateChild(r,o)}}isEmpty(){return this.children_.isEmpty()}numChildren(){return this.children_.count()}val(e){if(this.isEmpty())return null;const i={};let r=0,o=0,l=!0;if(this.forEachChild(Ze,(p,m)=>{i[p]=m.val(e),r++,l&&le.INTEGER_REGEXP_.test(p)?o=Math.max(o,Number(p)):l=!1}),!e&&l&&o<2*r){const p=[];for(const m in i)p[m]=i[m];return p}else return e&&!this.getPriority().isEmpty()&&(i[".priority"]=this.getPriority().val()),i}hash(){if(this.lazyHash_===null){let e="";this.getPriority().isEmpty()||(e+="priority:"+iv(this.getPriority().val())+":"),this.forEachChild(Ze,(i,r)=>{const o=r.hash();o!==""&&(e+=":"+i+":"+o)}),this.lazyHash_=e===""?"":RO(e)}return this.lazyHash_}getPredecessorChildName(e,i,r){const o=this.resolveIndex_(r);if(o){const l=o.getPredecessorKey(new be(e,i));return l?l.name:null}else return this.children_.getPredecessorKey(e)}getFirstChildName(e){const i=this.resolveIndex_(e);if(i){const r=i.minKey();return r&&r.name}else return this.children_.minKey()}getFirstChild(e){const i=this.getFirstChildName(e);return i?new be(i,this.children_.get(i)):null}getLastChildName(e){const i=this.resolveIndex_(e);if(i){const r=i.maxKey();return r&&r.name}else return this.children_.maxKey()}getLastChild(e){const i=this.getLastChildName(e);return i?new be(i,this.children_.get(i)):null}forEachChild(e,i){const r=this.resolveIndex_(e);return r?r.inorderTraversal(o=>i(o.name,o.node)):this.children_.inorderTraversal(i)}getIterator(e){return this.getIteratorFrom(e.minPost(),e)}getIteratorFrom(e,i){const r=this.resolveIndex_(i);if(r)return r.getIteratorFrom(e,o=>o);{const o=this.children_.getIteratorFrom(e.name,be.Wrap);let l=o.peek();for(;l!=null&&i.compare(l,e)<0;)o.getNext(),l=o.peek();return o}}getReverseIterator(e){return this.getReverseIteratorFrom(e.maxPost(),e)}getReverseIteratorFrom(e,i){const r=this.resolveIndex_(i);if(r)return r.getReverseIteratorFrom(e,o=>o);{const o=this.children_.getReverseIteratorFrom(e.name,be.Wrap);let l=o.peek();for(;l!=null&&i.compare(l,e)>0;)o.getNext(),l=o.peek();return o}}compareTo(e){return this.isEmpty()?e.isEmpty()?0:-1:e.isLeafNode()||e.isEmpty()?1:e===ou?-1:0}withIndex(e){if(e===ns||this.indexMap_.hasIndex(e))return this;{const i=this.indexMap_.addIndex(e,this.children_);return new le(this.children_,this.priorityNode_,i)}}isIndexed(e){return e===ns||this.indexMap_.hasIndex(e)}equals(e){if(e===this)return!0;if(e.isLeafNode())return!1;{const i=e;if(this.getPriority().equals(i.getPriority()))if(this.children_.count()===i.children_.count()){const r=this.getIterator(Ze),o=i.getIterator(Ze);let l=r.getNext(),p=o.getNext();for(;l&&p;){if(l.name!==p.name||!l.node.equals(p.node))return!1;l=r.getNext(),p=o.getNext()}return l===null&&p===null}else return!1;else return!1}}resolveIndex_(e){return e===ns?null:this.indexMap_.get(e.toString())}}le.INTEGER_REGEXP_=/^(0|[1-9]\d*)$/;class KN extends le{constructor(){super(new Wt(Gf),le.EMPTY_NODE,fi.Default)}compareTo(e){return e===this?0:1}equals(e){return e===this}getPriority(){return this}getImmediateChild(e){return le.EMPTY_NODE}isEmpty(){return!1}}const ou=new KN;Object.defineProperties(be,{MIN:{value:new be(ss,le.EMPTY_NODE)},MAX:{value:new be(Xa,ou)}});nv.__EMPTY_NODE=le.EMPTY_NODE;Ot.__childrenNodeConstructor=le;qN(ou);YN(ou);const XN=!0;function nt(n,e=null){if(n===null)return le.EMPTY_NODE;if(typeof n=="object"&&".priority"in n&&(e=n[".priority"]),G(e===null||typeof e=="string"||typeof e=="number"||typeof e=="object"&&".sv"in e,"Invalid priority type found: "+typeof e),typeof n=="object"&&".value"in n&&n[".value"]!==null&&(n=n[".value"]),typeof n!="object"||".sv"in n){const i=n;return new Ot(i,nt(e))}if(!(n instanceof Array)&&XN){const i=[];let r=!1;if(St(n,(p,m)=>{if(p.substring(0,1)!=="."){const h=nt(m);h.isEmpty()||(r=r||!h.getPriority().isEmpty(),i.push(new be(p,h)))}}),i.length===0)return le.EMPTY_NODE;const l=rc(i,FN,p=>p.name,Gf);if(r){const p=rc(i,Ze.getCompare());return new le(l,nt(e),new fi({".priority":p},{".priority":Ze}))}else return new le(l,nt(e),fi.Default)}else{let i=le.EMPTY_NODE;return St(n,(r,o)=>{if(Yn(n,r)&&r.substring(0,1)!=="."){const l=nt(o);(l.isLeafNode()||!l.isEmpty())&&(i=i.updateImmediateChild(r,l))}}),i.updatePriority(nt(e))}}HN(nt);class QN extends Mc{constructor(e){super(),this.indexPath_=e,G(!ve(e)&&Oe(e)!==".priority","Can't create PathIndex with empty path or .priority key")}extractChild(e){return e.getChild(this.indexPath_)}isDefinedOn(e){return!e.getChild(this.indexPath_).isEmpty()}compare(e,i){const r=this.extractChild(e.node),o=this.extractChild(i.node),l=r.compareTo(o);return l===0?tr(e.name,i.name):l}makePost(e,i){const r=nt(e),o=le.EMPTY_NODE.updateChild(this.indexPath_,r);return new be(i,o)}maxPost(){const e=le.EMPTY_NODE.updateChild(this.indexPath_,ou);return new be(Xa,e)}toString(){return Ho(this.indexPath_,0).join("/")}}class JN extends Mc{compare(e,i){const r=e.node.compareTo(i.node);return r===0?tr(e.name,i.name):r}isDefinedOn(e){return!0}indexedValueChanged(e,i){return!e.equals(i)}minPost(){return be.MIN}maxPost(){return be.MAX}makePost(e,i){const r=nt(e);return new be(i,r)}toString(){return".value"}}const $N=new JN;function ov(n){return{type:"value",snapshotNode:n}}function os(n,e){return{type:"child_added",snapshotNode:e,childName:n}}function Yo(n,e){return{type:"child_removed",snapshotNode:e,childName:n}}function Go(n,e,i){return{type:"child_changed",snapshotNode:e,childName:n,oldSnap:i}}function ZN(n,e){return{type:"child_moved",snapshotNode:e,childName:n}}class Vf{constructor(e){this.index_=e}updateChild(e,i,r,o,l,p){G(e.isIndexed(this.index_),"A node must be indexed if only a child is updated");const m=e.getImmediateChild(i);return m.getChild(o).equals(r.getChild(o))&&m.isEmpty()===r.isEmpty()||(p!=null&&(r.isEmpty()?e.hasChild(i)?p.trackChildChange(Yo(i,m)):G(e.isLeafNode(),"A child remove without an old child only makes sense on a leaf node"):m.isEmpty()?p.trackChildChange(os(i,r)):p.trackChildChange(Go(i,r,m))),e.isLeafNode()&&r.isEmpty())?e:e.updateImmediateChild(i,r).withIndex(this.index_)}updateFullNode(e,i,r){return r!=null&&(e.isLeafNode()||e.forEachChild(Ze,(o,l)=>{i.hasChild(o)||r.trackChildChange(Yo(o,l))}),i.isLeafNode()||i.forEachChild(Ze,(o,l)=>{if(e.hasChild(o)){const p=e.getImmediateChild(o);p.equals(l)||r.trackChildChange(Go(o,l,p))}else r.trackChildChange(os(o,l))})),i.withIndex(this.index_)}updatePriority(e,i){return e.isEmpty()?le.EMPTY_NODE:e.updatePriority(i)}filtersNodes(){return!1}getIndexedFilter(){return this}getIndex(){return this.index_}}class Vo{constructor(e){this.indexedFilter_=new Vf(e.getIndex()),this.index_=e.getIndex(),this.startPost_=Vo.getStartPost_(e),this.endPost_=Vo.getEndPost_(e),this.startIsInclusive_=!e.startAfterSet_,this.endIsInclusive_=!e.endBeforeSet_}getStartPost(){return this.startPost_}getEndPost(){return this.endPost_}matches(e){const i=this.startIsInclusive_?this.index_.compare(this.getStartPost(),e)<=0:this.index_.compare(this.getStartPost(),e)<0,r=this.endIsInclusive_?this.index_.compare(e,this.getEndPost())<=0:this.index_.compare(e,this.getEndPost())<0;return i&&r}updateChild(e,i,r,o,l,p){return this.matches(new be(i,r))||(r=le.EMPTY_NODE),this.indexedFilter_.updateChild(e,i,r,o,l,p)}updateFullNode(e,i,r){i.isLeafNode()&&(i=le.EMPTY_NODE);let o=i.withIndex(this.index_);o=o.updatePriority(le.EMPTY_NODE);const l=this;return i.forEachChild(Ze,(p,m)=>{l.matches(new be(p,m))||(o=o.updateImmediateChild(p,le.EMPTY_NODE))}),this.indexedFilter_.updateFullNode(e,o,r)}updatePriority(e,i){return e}filtersNodes(){return!0}getIndexedFilter(){return this.indexedFilter_}getIndex(){return this.index_}static getStartPost_(e){if(e.hasStart()){const i=e.getIndexStartName();return e.getIndex().makePost(e.getIndexStartValue(),i)}else return e.getIndex().minPost()}static getEndPost_(e){if(e.hasEnd()){const i=e.getIndexEndName();return e.getIndex().makePost(e.getIndexEndValue(),i)}else return e.getIndex().maxPost()}}class ek{constructor(e){this.withinDirectionalStart=i=>this.reverse_?this.withinEndPost(i):this.withinStartPost(i),this.withinDirectionalEnd=i=>this.reverse_?this.withinStartPost(i):this.withinEndPost(i),this.withinStartPost=i=>{const r=this.index_.compare(this.rangedFilter_.getStartPost(),i);return this.startIsInclusive_?r<=0:r<0},this.withinEndPost=i=>{const r=this.index_.compare(i,this.rangedFilter_.getEndPost());return this.endIsInclusive_?r<=0:r<0},this.rangedFilter_=new Vo(e),this.index_=e.getIndex(),this.limit_=e.getLimit(),this.reverse_=!e.isViewFromLeft(),this.startIsInclusive_=!e.startAfterSet_,this.endIsInclusive_=!e.endBeforeSet_}updateChild(e,i,r,o,l,p){return this.rangedFilter_.matches(new be(i,r))||(r=le.EMPTY_NODE),e.getImmediateChild(i).equals(r)?e:e.numChildren()<this.limit_?this.rangedFilter_.getIndexedFilter().updateChild(e,i,r,o,l,p):this.fullLimitUpdateChild_(e,i,r,l,p)}updateFullNode(e,i,r){let o;if(i.isLeafNode()||i.isEmpty())o=le.EMPTY_NODE.withIndex(this.index_);else if(this.limit_*2<i.numChildren()&&i.isIndexed(this.index_)){o=le.EMPTY_NODE.withIndex(this.index_);let l;this.reverse_?l=i.getReverseIteratorFrom(this.rangedFilter_.getEndPost(),this.index_):l=i.getIteratorFrom(this.rangedFilter_.getStartPost(),this.index_);let p=0;for(;l.hasNext()&&p<this.limit_;){const m=l.getNext();if(this.withinDirectionalStart(m))if(this.withinDirectionalEnd(m))o=o.updateImmediateChild(m.name,m.node),p++;else break;else continue}}else{o=i.withIndex(this.index_),o=o.updatePriority(le.EMPTY_NODE);let l;this.reverse_?l=o.getReverseIterator(this.index_):l=o.getIterator(this.index_);let p=0;for(;l.hasNext();){const m=l.getNext();p<this.limit_&&this.withinDirectionalStart(m)&&this.withinDirectionalEnd(m)?p++:o=o.updateImmediateChild(m.name,le.EMPTY_NODE)}}return this.rangedFilter_.getIndexedFilter().updateFullNode(e,o,r)}updatePriority(e,i){return e}filtersNodes(){return!0}getIndexedFilter(){return this.rangedFilter_.getIndexedFilter()}getIndex(){return this.index_}fullLimitUpdateChild_(e,i,r,o,l){let p;if(this.reverse_){const y=this.index_.getCompare();p=(v,_)=>y(_,v)}else p=this.index_.getCompare();const m=e;G(m.numChildren()===this.limit_,"");const h=new be(i,r),x=this.reverse_?m.getFirstChild(this.index_):m.getLastChild(this.index_),O=this.rangedFilter_.matches(h);if(m.hasChild(i)){const y=m.getImmediateChild(i);let v=o.getChildAfterChild(this.index_,x,this.reverse_);for(;v!=null&&(v.name===i||m.hasChild(v.name));)v=o.getChildAfterChild(this.index_,v,this.reverse_);const _=v==null?1:p(v,h);if(O&&!r.isEmpty()&&_>=0)return l?.trackChildChange(Go(i,r,y)),m.updateImmediateChild(i,r);{l?.trackChildChange(Yo(i,y));const I=m.updateImmediateChild(i,le.EMPTY_NODE);return v!=null&&this.rangedFilter_.matches(v)?(l?.trackChildChange(os(v.name,v.node)),I.updateImmediateChild(v.name,v.node)):I}}else return r.isEmpty()?e:O&&p(x,h)>=0?(l!=null&&(l.trackChildChange(Yo(x.name,x.node)),l.trackChildChange(os(i,r))),m.updateImmediateChild(i,r).updateImmediateChild(x.name,le.EMPTY_NODE)):e}}class Wf{constructor(){this.limitSet_=!1,this.startSet_=!1,this.startNameSet_=!1,this.startAfterSet_=!1,this.endSet_=!1,this.endNameSet_=!1,this.endBeforeSet_=!1,this.limit_=0,this.viewFrom_="",this.indexStartValue_=null,this.indexStartName_="",this.indexEndValue_=null,this.indexEndName_="",this.index_=Ze}hasStart(){return this.startSet_}isViewFromLeft(){return this.viewFrom_===""?this.startSet_:this.viewFrom_==="l"}getIndexStartValue(){return G(this.startSet_,"Only valid if start has been set"),this.indexStartValue_}getIndexStartName(){return G(this.startSet_,"Only valid if start has been set"),this.startNameSet_?this.indexStartName_:ss}hasEnd(){return this.endSet_}getIndexEndValue(){return G(this.endSet_,"Only valid if end has been set"),this.indexEndValue_}getIndexEndName(){return G(this.endSet_,"Only valid if end has been set"),this.endNameSet_?this.indexEndName_:Xa}hasLimit(){return this.limitSet_}hasAnchoredLimit(){return this.limitSet_&&this.viewFrom_!==""}getLimit(){return G(this.limitSet_,"Only valid if limit has been set"),this.limit_}getIndex(){return this.index_}loadsAllData(){return!(this.startSet_||this.endSet_||this.limitSet_)}isDefault(){return this.loadsAllData()&&this.index_===Ze}copy(){const e=new Wf;return e.limitSet_=this.limitSet_,e.limit_=this.limit_,e.startSet_=this.startSet_,e.startAfterSet_=this.startAfterSet_,e.indexStartValue_=this.indexStartValue_,e.startNameSet_=this.startNameSet_,e.indexStartName_=this.indexStartName_,e.endSet_=this.endSet_,e.endBeforeSet_=this.endBeforeSet_,e.indexEndValue_=this.indexEndValue_,e.endNameSet_=this.endNameSet_,e.indexEndName_=this.indexEndName_,e.index_=this.index_,e.viewFrom_=this.viewFrom_,e}}function tk(n){return n.loadsAllData()?new Vf(n.getIndex()):n.hasLimit()?new ek(n):new Vo(n)}function Dy(n){const e={};if(n.isDefault())return e;let i;if(n.index_===Ze?i="$priority":n.index_===$N?i="$value":n.index_===ns?i="$key":(G(n.index_ instanceof QN,"Unrecognized index type!"),i=n.index_.toString()),e.orderBy=xt(i),n.startSet_){const r=n.startAfterSet_?"startAfter":"startAt";e[r]=xt(n.indexStartValue_),n.startNameSet_&&(e[r]+=","+xt(n.indexStartName_))}if(n.endSet_){const r=n.endBeforeSet_?"endBefore":"endAt";e[r]=xt(n.indexEndValue_),n.endNameSet_&&(e[r]+=","+xt(n.indexEndName_))}return n.limitSet_&&(n.isViewFromLeft()?e.limitToFirst=n.limit_:e.limitToLast=n.limit_),e}function Iy(n){const e={};if(n.startSet_&&(e.sp=n.indexStartValue_,n.startNameSet_&&(e.sn=n.indexStartName_),e.sin=!n.startAfterSet_),n.endSet_&&(e.ep=n.indexEndValue_,n.endNameSet_&&(e.en=n.indexEndName_),e.ein=!n.endBeforeSet_),n.limitSet_){e.l=n.limit_;let i=n.viewFrom_;i===""&&(n.isViewFromLeft()?i="l":i="r"),e.vf=i}return n.index_!==Ze&&(e.i=n.index_.toString()),e}class sc extends $O{reportStats(e){throw new Error("Method not implemented.")}static getListenId_(e,i){return i!==void 0?"tag$"+i:(G(e._queryParams.isDefault(),"should have a tag if it's not a default query."),e._path.toString())}constructor(e,i,r,o){super(),this.repoInfo_=e,this.onDataUpdate_=i,this.authTokenProvider_=r,this.appCheckTokenProvider_=o,this.log_=su("p:rest:"),this.listens_={}}listen(e,i,r,o){const l=e._path.toString();this.log_("Listen called for "+l+" "+e._queryIdentifier);const p=sc.getListenId_(e,r),m={};this.listens_[p]=m;const h=Dy(e._queryParams);this.restRequest_(l+".json",h,(x,O)=>{let y=O;if(x===404&&(y=null,x=null),x===null&&this.onDataUpdate_(l,y,!1,r),is(this.listens_,p)===m){let v;x?x===401?v="permission_denied":v="rest_error:"+x:v="ok",o(v,null)}})}unlisten(e,i){const r=sc.getListenId_(e,i);delete this.listens_[r]}get(e){const i=Dy(e._queryParams),r=e._path.toString(),o=new Pn;return this.restRequest_(r+".json",i,(l,p)=>{let m=p;l===404&&(m=null,l=null),l===null?(this.onDataUpdate_(r,m,!1,null),o.resolve(m)):o.reject(new Error(m))}),o.promise}refreshAuthToken(e){}restRequest_(e,i={},r){return i.format="export",Promise.all([this.authTokenProvider_.getToken(!1),this.appCheckTokenProvider_.getToken(!1)]).then(([o,l])=>{o&&o.accessToken&&(i.auth=o.accessToken),l&&l.token&&(i.ac=l.token);const p=(this.repoInfo_.secure?"https://":"http://")+this.repoInfo_.host+e+"?ns="+this.repoInfo_.namespace+hs(i);this.log_("Sending REST request for "+p);const m=new XMLHttpRequest;m.onreadystatechange=()=>{if(r&&m.readyState===4){this.log_("REST Response for "+p+" received. status:",m.status,"response:",m.responseText);let h=null;if(m.status>=200&&m.status<300){try{h=Uo(m.responseText)}catch{It("Failed to parse JSON response for "+p+": "+m.responseText)}r(null,h)}else m.status!==401&&m.status!==404&&It("Got unsuccessful REST response for "+p+" Status: "+m.status),r(m.status);r=null}},m.open("GET",p,!0),m.send()})}}class nk{constructor(){this.rootNode_=le.EMPTY_NODE}getNode(e){return this.rootNode_.getChild(e)}updateSnapshot(e,i){this.rootNode_=this.rootNode_.updateChild(e,i)}}function oc(){return{value:null,children:new Map}}function ys(n,e,i){if(ve(e))n.value=i,n.children.clear();else if(n.value!==null)n.value=n.value.updateChild(e,i);else{const r=Oe(e);n.children.has(r)||n.children.set(r,oc());const o=n.children.get(r);e=Ve(e),ys(o,e,i)}}function Qm(n,e){if(ve(e))return n.value=null,n.children.clear(),!0;if(n.value!==null){if(n.value.isLeafNode())return!1;{const i=n.value;return n.value=null,i.forEachChild(Ze,(r,o)=>{ys(n,new Be(r),o)}),Qm(n,e)}}else if(n.children.size>0){const i=Oe(e);return e=Ve(e),n.children.has(i)&&Qm(n.children.get(i),e)&&n.children.delete(i),n.children.size===0}else return!0}function Jm(n,e,i){n.value!==null?i(e,n.value):ik(n,(r,o)=>{const l=new Be(e.toString()+"/"+r);Jm(o,l,i)})}function ik(n,e){n.children.forEach((i,r)=>{e(r,i)})}class ak{constructor(e){this.collection_=e,this.last_=null}get(){const e=this.collection_.get(),i={...e};return this.last_&&St(this.last_,(r,o)=>{i[r]=i[r]-o}),this.last_=e,i}}const Ly=10*1e3,rk=30*1e3,sk=300*1e3;class ok{constructor(e,i){this.server_=i,this.statsToReport_={},this.statsListener_=new ak(e);const r=Ly+(rk-Ly)*Math.random();jo(this.reportStats_.bind(this),Math.floor(r))}reportStats_(){const e=this.statsListener_.get(),i={};let r=!1;St(e,(o,l)=>{l>0&&Yn(this.statsToReport_,o)&&(i[o]=l,r=!0)}),r&&this.server_.reportStats(i),jo(this.reportStats_.bind(this),Math.floor(Math.random()*2*sk))}}var En;(function(n){n[n.OVERWRITE=0]="OVERWRITE",n[n.MERGE=1]="MERGE",n[n.ACK_USER_WRITE=2]="ACK_USER_WRITE",n[n.LISTEN_COMPLETE=3]="LISTEN_COMPLETE"})(En||(En={}));function Kf(){return{fromUser:!0,fromServer:!1,queryId:null,tagged:!1}}function Xf(){return{fromUser:!1,fromServer:!0,queryId:null,tagged:!1}}function Qf(n){return{fromUser:!1,fromServer:!0,queryId:n,tagged:!0}}class uc{constructor(e,i,r){this.path=e,this.affectedTree=i,this.revert=r,this.type=En.ACK_USER_WRITE,this.source=Kf()}operationForChild(e){if(ve(this.path)){if(this.affectedTree.value!=null)return G(this.affectedTree.children.isEmpty(),"affectedTree should not have overlapping affected paths."),this;{const i=this.affectedTree.subtree(new Be(e));return new uc(Me(),i,this.revert)}}else return G(Oe(this.path)===e,"operationForChild called for unrelated child."),new uc(Ve(this.path),this.affectedTree,this.revert)}}class Wo{constructor(e,i){this.source=e,this.path=i,this.type=En.LISTEN_COMPLETE}operationForChild(e){return ve(this.path)?new Wo(this.source,Me()):new Wo(this.source,Ve(this.path))}}class Qa{constructor(e,i,r){this.source=e,this.path=i,this.snap=r,this.type=En.OVERWRITE}operationForChild(e){return ve(this.path)?new Qa(this.source,Me(),this.snap.getImmediateChild(e)):new Qa(this.source,Ve(this.path),this.snap)}}class us{constructor(e,i,r){this.source=e,this.path=i,this.children=r,this.type=En.MERGE}operationForChild(e){if(ve(this.path)){const i=this.children.subtree(new Be(e));return i.isEmpty()?null:i.value?new Qa(this.source,Me(),i.value):new us(this.source,Me(),i)}else return G(Oe(this.path)===e,"Can't get a merge for a child not on the path of the operation"),new us(this.source,Ve(this.path),this.children)}toString(){return"Operation("+this.path+": "+this.source.toString()+" merge: "+this.children.toString()+")"}}class pa{constructor(e,i,r){this.node_=e,this.fullyInitialized_=i,this.filtered_=r}isFullyInitialized(){return this.fullyInitialized_}isFiltered(){return this.filtered_}isCompleteForPath(e){if(ve(e))return this.isFullyInitialized()&&!this.filtered_;const i=Oe(e);return this.isCompleteForChild(i)}isCompleteForChild(e){return this.isFullyInitialized()&&!this.filtered_||this.node_.hasChild(e)}getNode(){return this.node_}}class uk{constructor(e){this.query_=e,this.index_=this.query_._queryParams.getIndex()}}function lk(n,e,i,r){const o=[],l=[];return e.forEach(p=>{p.type==="child_changed"&&n.index_.indexedValueChanged(p.oldSnap,p.snapshotNode)&&l.push(ZN(p.childName,p.snapshotNode))}),bo(n,o,"child_removed",e,r,i),bo(n,o,"child_added",e,r,i),bo(n,o,"child_moved",l,r,i),bo(n,o,"child_changed",e,r,i),bo(n,o,"value",e,r,i),o}function bo(n,e,i,r,o,l){const p=r.filter(m=>m.type===i);p.sort((m,h)=>pk(n,m,h)),p.forEach(m=>{const h=ck(n,m,l);o.forEach(x=>{x.respondsTo(m.type)&&e.push(x.createEvent(h,n.query_))})})}function ck(n,e,i){return e.type==="value"||e.type==="child_removed"||(e.prevName=i.getPredecessorChildName(e.childName,e.snapshotNode,n.index_)),e}function pk(n,e,i){if(e.childName==null||i.childName==null)throw fs("Should only compare child_ events.");const r=new be(e.childName,e.snapshotNode),o=new be(i.childName,i.snapshotNode);return n.index_.compare(r,o)}function Rc(n,e){return{eventCache:n,serverCache:e}}function Mo(n,e,i,r){return Rc(new pa(e,i,r),n.serverCache)}function uv(n,e,i,r){return Rc(n.eventCache,new pa(e,i,r))}function lc(n){return n.eventCache.isFullyInitialized()?n.eventCache.getNode():null}function Ja(n){return n.serverCache.isFullyInitialized()?n.serverCache.getNode():null}let km;const dk=()=>(km||(km=new Wt(QT)),km);class We{static fromObject(e){let i=new We(null);return St(e,(r,o)=>{i=i.set(new Be(r),o)}),i}constructor(e,i=dk()){this.value=e,this.children=i}isEmpty(){return this.value===null&&this.children.isEmpty()}findRootMostMatchingPathAndValue(e,i){if(this.value!=null&&i(this.value))return{path:Me(),value:this.value};if(ve(e))return null;{const r=Oe(e),o=this.children.get(r);if(o!==null){const l=o.findRootMostMatchingPathAndValue(Ve(e),i);return l!=null?{path:$e(new Be(r),l.path),value:l.value}:null}else return null}}findRootMostValueAndPath(e){return this.findRootMostMatchingPathAndValue(e,()=>!0)}subtree(e){if(ve(e))return this;{const i=Oe(e),r=this.children.get(i);return r!==null?r.subtree(Ve(e)):new We(null)}}set(e,i){if(ve(e))return new We(i,this.children);{const r=Oe(e),l=(this.children.get(r)||new We(null)).set(Ve(e),i),p=this.children.insert(r,l);return new We(this.value,p)}}remove(e){if(ve(e))return this.children.isEmpty()?new We(null):new We(null,this.children);{const i=Oe(e),r=this.children.get(i);if(r){const o=r.remove(Ve(e));let l;return o.isEmpty()?l=this.children.remove(i):l=this.children.insert(i,o),this.value===null&&l.isEmpty()?new We(null):new We(this.value,l)}else return this}}get(e){if(ve(e))return this.value;{const i=Oe(e),r=this.children.get(i);return r?r.get(Ve(e)):null}}setTree(e,i){if(ve(e))return i;{const r=Oe(e),l=(this.children.get(r)||new We(null)).setTree(Ve(e),i);let p;return l.isEmpty()?p=this.children.remove(r):p=this.children.insert(r,l),new We(this.value,p)}}fold(e){return this.fold_(Me(),e)}fold_(e,i){const r={};return this.children.inorderTraversal((o,l)=>{r[o]=l.fold_($e(e,o),i)}),i(e,this.value,r)}findOnPath(e,i){return this.findOnPath_(e,Me(),i)}findOnPath_(e,i,r){const o=this.value?r(i,this.value):!1;if(o)return o;if(ve(e))return null;{const l=Oe(e),p=this.children.get(l);return p?p.findOnPath_(Ve(e),$e(i,l),r):null}}foreachOnPath(e,i){return this.foreachOnPath_(e,Me(),i)}foreachOnPath_(e,i,r){if(ve(e))return this;{this.value&&r(i,this.value);const o=Oe(e),l=this.children.get(o);return l?l.foreachOnPath_(Ve(e),$e(i,o),r):new We(null)}}foreach(e){this.foreach_(Me(),e)}foreach_(e,i){this.children.inorderTraversal((r,o)=>{o.foreach_($e(e,r),i)}),this.value&&i(e,this.value)}foreachChild(e){this.children.inorderTraversal((i,r)=>{r.value&&e(i,r.value)})}}class jn{constructor(e){this.writeTree_=e}static empty(){return new jn(new We(null))}}function Ro(n,e,i){if(ve(e))return new jn(new We(i));{const r=n.writeTree_.findRootMostValueAndPath(e);if(r!=null){const o=r.path;let l=r.value;const p=Dt(o,e);return l=l.updateChild(p,i),new jn(n.writeTree_.set(o,l))}else{const o=new We(i),l=n.writeTree_.setTree(e,o);return new jn(l)}}}function $m(n,e,i){let r=n;return St(i,(o,l)=>{r=Ro(r,$e(e,o),l)}),r}function Py(n,e){if(ve(e))return jn.empty();{const i=n.writeTree_.setTree(e,new We(null));return new jn(i)}}function Zm(n,e){return nr(n,e)!=null}function nr(n,e){const i=n.writeTree_.findRootMostValueAndPath(e);return i!=null?n.writeTree_.get(i.path).getChild(Dt(i.path,e)):null}function By(n){const e=[],i=n.writeTree_.value;return i!=null?i.isLeafNode()||i.forEachChild(Ze,(r,o)=>{e.push(new be(r,o))}):n.writeTree_.children.inorderTraversal((r,o)=>{o.value!=null&&e.push(new be(r,o.value))}),e}function sa(n,e){if(ve(e))return n;{const i=nr(n,e);return i!=null?new jn(new We(i)):new jn(n.writeTree_.subtree(e))}}function ef(n){return n.writeTree_.isEmpty()}function ls(n,e){return lv(Me(),n.writeTree_,e)}function lv(n,e,i){if(e.value!=null)return i.updateChild(n,e.value);{let r=null;return e.children.inorderTraversal((o,l)=>{o===".priority"?(G(l.value!==null,"Priority writes must always be leaf nodes"),r=l.value):i=lv($e(n,o),l,i)}),!i.getChild(n).isEmpty()&&r!==null&&(i=i.updateChild($e(n,".priority"),r)),i}}function Dc(n,e){return mv(e,n)}function mk(n,e,i,r,o){G(r>n.lastWriteId,"Stacking an older write on top of newer ones"),o===void 0&&(o=!0),n.allWrites.push({path:e,snap:i,writeId:r,visible:o}),o&&(n.visibleWrites=Ro(n.visibleWrites,e,i)),n.lastWriteId=r}function fk(n,e,i,r){G(r>n.lastWriteId,"Stacking an older merge on top of newer ones"),n.allWrites.push({path:e,children:i,writeId:r,visible:!0}),n.visibleWrites=$m(n.visibleWrites,e,i),n.lastWriteId=r}function hk(n,e){for(let i=0;i<n.allWrites.length;i++){const r=n.allWrites[i];if(r.writeId===e)return r}return null}function xk(n,e){const i=n.allWrites.findIndex(m=>m.writeId===e);G(i>=0,"removeWrite called with nonexistent writeId.");const r=n.allWrites[i];n.allWrites.splice(i,1);let o=r.visible,l=!1,p=n.allWrites.length-1;for(;o&&p>=0;){const m=n.allWrites[p];m.visible&&(p>=i&&gk(m,r.path)?o=!1:yn(r.path,m.path)&&(l=!0)),p--}if(o){if(l)return yk(n),!0;if(r.snap)n.visibleWrites=Py(n.visibleWrites,r.path);else{const m=r.children;St(m,h=>{n.visibleWrites=Py(n.visibleWrites,$e(r.path,h))})}return!0}else return!1}function gk(n,e){if(n.snap)return yn(n.path,e);for(const i in n.children)if(n.children.hasOwnProperty(i)&&yn($e(n.path,i),e))return!0;return!1}function yk(n){n.visibleWrites=cv(n.allWrites,Ok,Me()),n.allWrites.length>0?n.lastWriteId=n.allWrites[n.allWrites.length-1].writeId:n.lastWriteId=-1}function Ok(n){return n.visible}function cv(n,e,i){let r=jn.empty();for(let o=0;o<n.length;++o){const l=n[o];if(e(l)){const p=l.path;let m;if(l.snap)yn(i,p)?(m=Dt(i,p),r=Ro(r,m,l.snap)):yn(p,i)&&(m=Dt(p,i),r=Ro(r,Me(),l.snap.getChild(m)));else if(l.children){if(yn(i,p))m=Dt(i,p),r=$m(r,m,l.children);else if(yn(p,i))if(m=Dt(p,i),ve(m))r=$m(r,Me(),l.children);else{const h=is(l.children,Oe(m));if(h){const x=h.getChild(Ve(m));r=Ro(r,Me(),x)}}}else throw fs("WriteRecord should have .snap or .children")}}return r}function pv(n,e,i,r,o){if(!r&&!o){const l=nr(n.visibleWrites,e);if(l!=null)return l;{const p=sa(n.visibleWrites,e);if(ef(p))return i;if(i==null&&!Zm(p,Me()))return null;{const m=i||le.EMPTY_NODE;return ls(p,m)}}}else{const l=sa(n.visibleWrites,e);if(!o&&ef(l))return i;if(!o&&i==null&&!Zm(l,Me()))return null;{const p=function(x){return(x.visible||o)&&(!r||!~r.indexOf(x.writeId))&&(yn(x.path,e)||yn(e,x.path))},m=cv(n.allWrites,p,e),h=i||le.EMPTY_NODE;return ls(m,h)}}}function vk(n,e,i){let r=le.EMPTY_NODE;const o=nr(n.visibleWrites,e);if(o)return o.isLeafNode()||o.forEachChild(Ze,(l,p)=>{r=r.updateImmediateChild(l,p)}),r;if(i){const l=sa(n.visibleWrites,e);return i.forEachChild(Ze,(p,m)=>{const h=ls(sa(l,new Be(p)),m);r=r.updateImmediateChild(p,h)}),By(l).forEach(p=>{r=r.updateImmediateChild(p.name,p.node)}),r}else{const l=sa(n.visibleWrites,e);return By(l).forEach(p=>{r=r.updateImmediateChild(p.name,p.node)}),r}}function bk(n,e,i,r,o){G(r||o,"Either existingEventSnap or existingServerSnap must exist");const l=$e(e,i);if(Zm(n.visibleWrites,l))return null;{const p=sa(n.visibleWrites,l);return ef(p)?o.getChild(i):ls(p,o.getChild(i))}}function Sk(n,e,i,r){const o=$e(e,i),l=nr(n.visibleWrites,o);if(l!=null)return l;if(r.isCompleteForChild(i)){const p=sa(n.visibleWrites,o);return ls(p,r.getNode().getImmediateChild(i))}else return null}function wk(n,e){return nr(n.visibleWrites,e)}function Ck(n,e,i,r,o,l,p){let m;const h=sa(n.visibleWrites,e),x=nr(h,Me());if(x!=null)m=x;else if(i!=null)m=ls(h,i);else return[];if(m=m.withIndex(p),!m.isEmpty()&&!m.isLeafNode()){const O=[],y=p.getCompare(),v=l?m.getReverseIteratorFrom(r,p):m.getIteratorFrom(r,p);let _=v.getNext();for(;_&&O.length<o;)y(_,r)!==0&&O.push(_),_=v.getNext();return O}else return[]}function _k(){return{visibleWrites:jn.empty(),allWrites:[],lastWriteId:-1}}function cc(n,e,i,r){return pv(n.writeTree,n.treePath,e,i,r)}function Jf(n,e){return vk(n.writeTree,n.treePath,e)}function Uy(n,e,i,r){return bk(n.writeTree,n.treePath,e,i,r)}function pc(n,e){return wk(n.writeTree,$e(n.treePath,e))}function Tk(n,e,i,r,o,l){return Ck(n.writeTree,n.treePath,e,i,r,o,l)}function $f(n,e,i){return Sk(n.writeTree,n.treePath,e,i)}function dv(n,e){return mv($e(n.treePath,e),n.writeTree)}function mv(n,e){return{treePath:n,writeTree:e}}class Nk{constructor(){this.changeMap=new Map}trackChildChange(e){const i=e.type,r=e.childName;G(i==="child_added"||i==="child_changed"||i==="child_removed","Only child changes supported for tracking"),G(r!==".priority","Only non-priority child changes can be tracked.");const o=this.changeMap.get(r);if(o){const l=o.type;if(i==="child_added"&&l==="child_removed")this.changeMap.set(r,Go(r,e.snapshotNode,o.snapshotNode));else if(i==="child_removed"&&l==="child_added")this.changeMap.delete(r);else if(i==="child_removed"&&l==="child_changed")this.changeMap.set(r,Yo(r,o.oldSnap));else if(i==="child_changed"&&l==="child_added")this.changeMap.set(r,os(r,e.snapshotNode));else if(i==="child_changed"&&l==="child_changed")this.changeMap.set(r,Go(r,e.snapshotNode,o.oldSnap));else throw fs("Illegal combination of changes: "+e+" occurred after "+o)}else this.changeMap.set(r,e)}getChanges(){return Array.from(this.changeMap.values())}}class kk{getCompleteChild(e){return null}getChildAfterChild(e,i,r){return null}}const fv=new kk;class Zf{constructor(e,i,r=null){this.writes_=e,this.viewCache_=i,this.optCompleteServerCache_=r}getCompleteChild(e){const i=this.viewCache_.eventCache;if(i.isCompleteForChild(e))return i.getNode().getImmediateChild(e);{const r=this.optCompleteServerCache_!=null?new pa(this.optCompleteServerCache_,!0,!1):this.viewCache_.serverCache;return $f(this.writes_,e,r)}}getChildAfterChild(e,i,r){const o=this.optCompleteServerCache_!=null?this.optCompleteServerCache_:Ja(this.viewCache_),l=Tk(this.writes_,o,i,1,r,e);return l.length===0?null:l[0]}}function Ek(n){return{filter:n}}function Ak(n,e){G(e.eventCache.getNode().isIndexed(n.filter.getIndex()),"Event snap not indexed"),G(e.serverCache.getNode().isIndexed(n.filter.getIndex()),"Server snap not indexed")}function jk(n,e,i,r,o){const l=new Nk;let p,m;if(i.type===En.OVERWRITE){const x=i;x.source.fromUser?p=tf(n,e,x.path,x.snap,r,o,l):(G(x.source.fromServer,"Unknown source."),m=x.source.tagged||e.serverCache.isFiltered()&&!ve(x.path),p=dc(n,e,x.path,x.snap,r,o,m,l))}else if(i.type===En.MERGE){const x=i;x.source.fromUser?p=Rk(n,e,x.path,x.children,r,o,l):(G(x.source.fromServer,"Unknown source."),m=x.source.tagged||e.serverCache.isFiltered(),p=nf(n,e,x.path,x.children,r,o,m,l))}else if(i.type===En.ACK_USER_WRITE){const x=i;x.revert?p=Lk(n,e,x.path,r,o,l):p=Dk(n,e,x.path,x.affectedTree,r,o,l)}else if(i.type===En.LISTEN_COMPLETE)p=Ik(n,e,i.path,r,l);else throw fs("Unknown operation type: "+i.type);const h=l.getChanges();return Mk(e,p,h),{viewCache:p,changes:h}}function Mk(n,e,i){const r=e.eventCache;if(r.isFullyInitialized()){const o=r.getNode().isLeafNode()||r.getNode().isEmpty(),l=lc(n);(i.length>0||!n.eventCache.isFullyInitialized()||o&&!r.getNode().equals(l)||!r.getNode().getPriority().equals(l.getPriority()))&&i.push(ov(lc(e)))}}function hv(n,e,i,r,o,l){const p=e.eventCache;if(pc(r,i)!=null)return e;{let m,h;if(ve(i))if(G(e.serverCache.isFullyInitialized(),"If change path is empty, we must have complete server data"),e.serverCache.isFiltered()){const x=Ja(e),O=x instanceof le?x:le.EMPTY_NODE,y=Jf(r,O);m=n.filter.updateFullNode(e.eventCache.getNode(),y,l)}else{const x=cc(r,Ja(e));m=n.filter.updateFullNode(e.eventCache.getNode(),x,l)}else{const x=Oe(i);if(x===".priority"){G(ca(i)===1,"Can't have a priority with additional path components");const O=p.getNode();h=e.serverCache.getNode();const y=Uy(r,i,O,h);y!=null?m=n.filter.updatePriority(O,y):m=p.getNode()}else{const O=Ve(i);let y;if(p.isCompleteForChild(x)){h=e.serverCache.getNode();const v=Uy(r,i,p.getNode(),h);v!=null?y=p.getNode().getImmediateChild(x).updateChild(O,v):y=p.getNode().getImmediateChild(x)}else y=$f(r,x,e.serverCache);y!=null?m=n.filter.updateChild(p.getNode(),x,y,O,o,l):m=p.getNode()}}return Mo(e,m,p.isFullyInitialized()||ve(i),n.filter.filtersNodes())}}function dc(n,e,i,r,o,l,p,m){const h=e.serverCache;let x;const O=p?n.filter:n.filter.getIndexedFilter();if(ve(i))x=O.updateFullNode(h.getNode(),r,null);else if(O.filtersNodes()&&!h.isFiltered()){const _=h.getNode().updateChild(i,r);x=O.updateFullNode(h.getNode(),_,null)}else{const _=Oe(i);if(!h.isCompleteForPath(i)&&ca(i)>1)return e;const k=Ve(i),D=h.getNode().getImmediateChild(_).updateChild(k,r);_===".priority"?x=O.updatePriority(h.getNode(),D):x=O.updateChild(h.getNode(),_,D,k,fv,null)}const y=uv(e,x,h.isFullyInitialized()||ve(i),O.filtersNodes()),v=new Zf(o,y,l);return hv(n,y,i,o,v,m)}function tf(n,e,i,r,o,l,p){const m=e.eventCache;let h,x;const O=new Zf(o,e,l);if(ve(i))x=n.filter.updateFullNode(e.eventCache.getNode(),r,p),h=Mo(e,x,!0,n.filter.filtersNodes());else{const y=Oe(i);if(y===".priority")x=n.filter.updatePriority(e.eventCache.getNode(),r),h=Mo(e,x,m.isFullyInitialized(),m.isFiltered());else{const v=Ve(i),_=m.getNode().getImmediateChild(y);let k;if(ve(v))k=r;else{const I=O.getCompleteChild(y);I!=null?qf(v)===".priority"&&I.getChild(ev(v)).isEmpty()?k=I:k=I.updateChild(v,r):k=le.EMPTY_NODE}if(_.equals(k))h=e;else{const I=n.filter.updateChild(m.getNode(),y,k,v,O,p);h=Mo(e,I,m.isFullyInitialized(),n.filter.filtersNodes())}}}return h}function zy(n,e){return n.eventCache.isCompleteForChild(e)}function Rk(n,e,i,r,o,l,p){let m=e;return r.foreach((h,x)=>{const O=$e(i,h);zy(e,Oe(O))&&(m=tf(n,m,O,x,o,l,p))}),r.foreach((h,x)=>{const O=$e(i,h);zy(e,Oe(O))||(m=tf(n,m,O,x,o,l,p))}),m}function Fy(n,e,i){return i.foreach((r,o)=>{e=e.updateChild(r,o)}),e}function nf(n,e,i,r,o,l,p,m){if(e.serverCache.getNode().isEmpty()&&!e.serverCache.isFullyInitialized())return e;let h=e,x;ve(i)?x=r:x=new We(null).setTree(i,r);const O=e.serverCache.getNode();return x.children.inorderTraversal((y,v)=>{if(O.hasChild(y)){const _=e.serverCache.getNode().getImmediateChild(y),k=Fy(n,_,v);h=dc(n,h,new Be(y),k,o,l,p,m)}}),x.children.inorderTraversal((y,v)=>{const _=!e.serverCache.isCompleteForChild(y)&&v.value===null;if(!O.hasChild(y)&&!_){const k=e.serverCache.getNode().getImmediateChild(y),I=Fy(n,k,v);h=dc(n,h,new Be(y),I,o,l,p,m)}}),h}function Dk(n,e,i,r,o,l,p){if(pc(o,i)!=null)return e;const m=e.serverCache.isFiltered(),h=e.serverCache;if(r.value!=null){if(ve(i)&&h.isFullyInitialized()||h.isCompleteForPath(i))return dc(n,e,i,h.getNode().getChild(i),o,l,m,p);if(ve(i)){let x=new We(null);return h.getNode().forEachChild(ns,(O,y)=>{x=x.set(new Be(O),y)}),nf(n,e,i,x,o,l,m,p)}else return e}else{let x=new We(null);return r.foreach((O,y)=>{const v=$e(i,O);h.isCompleteForPath(v)&&(x=x.set(O,h.getNode().getChild(v)))}),nf(n,e,i,x,o,l,m,p)}}function Ik(n,e,i,r,o){const l=e.serverCache,p=uv(e,l.getNode(),l.isFullyInitialized()||ve(i),l.isFiltered());return hv(n,p,i,r,fv,o)}function Lk(n,e,i,r,o,l){let p;if(pc(r,i)!=null)return e;{const m=new Zf(r,e,o),h=e.eventCache.getNode();let x;if(ve(i)||Oe(i)===".priority"){let O;if(e.serverCache.isFullyInitialized())O=cc(r,Ja(e));else{const y=e.serverCache.getNode();G(y instanceof le,"serverChildren would be complete if leaf node"),O=Jf(r,y)}O=O,x=n.filter.updateFullNode(h,O,l)}else{const O=Oe(i);let y=$f(r,O,e.serverCache);y==null&&e.serverCache.isCompleteForChild(O)&&(y=h.getImmediateChild(O)),y!=null?x=n.filter.updateChild(h,O,y,Ve(i),m,l):e.eventCache.getNode().hasChild(O)?x=n.filter.updateChild(h,O,le.EMPTY_NODE,Ve(i),m,l):x=h,x.isEmpty()&&e.serverCache.isFullyInitialized()&&(p=cc(r,Ja(e)),p.isLeafNode()&&(x=n.filter.updateFullNode(x,p,l)))}return p=e.serverCache.isFullyInitialized()||pc(r,Me())!=null,Mo(e,x,p,n.filter.filtersNodes())}}class Pk{constructor(e,i){this.query_=e,this.eventRegistrations_=[];const r=this.query_._queryParams,o=new Vf(r.getIndex()),l=tk(r);this.processor_=Ek(l);const p=i.serverCache,m=i.eventCache,h=o.updateFullNode(le.EMPTY_NODE,p.getNode(),null),x=l.updateFullNode(le.EMPTY_NODE,m.getNode(),null),O=new pa(h,p.isFullyInitialized(),o.filtersNodes()),y=new pa(x,m.isFullyInitialized(),l.filtersNodes());this.viewCache_=Rc(y,O),this.eventGenerator_=new uk(this.query_)}get query(){return this.query_}}function Bk(n){return n.viewCache_.serverCache.getNode()}function Uk(n){return lc(n.viewCache_)}function zk(n,e){const i=Ja(n.viewCache_);return i&&(n.query._queryParams.loadsAllData()||!ve(e)&&!i.getImmediateChild(Oe(e)).isEmpty())?i.getChild(e):null}function qy(n){return n.eventRegistrations_.length===0}function Fk(n,e){n.eventRegistrations_.push(e)}function Hy(n,e,i){const r=[];if(i){G(e==null,"A cancel should cancel all event registrations.");const o=n.query._path;n.eventRegistrations_.forEach(l=>{const p=l.createCancelEvent(i,o);p&&r.push(p)})}if(e){let o=[];for(let l=0;l<n.eventRegistrations_.length;++l){const p=n.eventRegistrations_[l];if(!p.matches(e))o.push(p);else if(e.hasAnyCallback()){o=o.concat(n.eventRegistrations_.slice(l+1));break}}n.eventRegistrations_=o}else n.eventRegistrations_=[];return r}function Yy(n,e,i,r){e.type===En.MERGE&&e.source.queryId!==null&&(G(Ja(n.viewCache_),"We should always have a full cache before handling merges"),G(lc(n.viewCache_),"Missing event cache, even though we have a server cache"));const o=n.viewCache_,l=jk(n.processor_,o,e,i,r);return Ak(n.processor_,l.viewCache),G(l.viewCache.serverCache.isFullyInitialized()||!o.serverCache.isFullyInitialized(),"Once a server snap is complete, it should never go back"),n.viewCache_=l.viewCache,xv(n,l.changes,l.viewCache.eventCache.getNode(),null)}function qk(n,e){const i=n.viewCache_.eventCache,r=[];return i.getNode().isLeafNode()||i.getNode().forEachChild(Ze,(l,p)=>{r.push(os(l,p))}),i.isFullyInitialized()&&r.push(ov(i.getNode())),xv(n,r,i.getNode(),e)}function xv(n,e,i,r){const o=r?[r]:n.eventRegistrations_;return lk(n.eventGenerator_,e,i,o)}let mc;class gv{constructor(){this.views=new Map}}function Hk(n){G(!mc,"__referenceConstructor has already been defined"),mc=n}function Yk(){return G(mc,"Reference.ts has not been loaded"),mc}function Gk(n){return n.views.size===0}function eh(n,e,i,r){const o=e.source.queryId;if(o!==null){const l=n.views.get(o);return G(l!=null,"SyncTree gave us an op for an invalid query."),Yy(l,e,i,r)}else{let l=[];for(const p of n.views.values())l=l.concat(Yy(p,e,i,r));return l}}function yv(n,e,i,r,o){const l=e._queryIdentifier,p=n.views.get(l);if(!p){let m=cc(i,o?r:null),h=!1;m?h=!0:r instanceof le?(m=Jf(i,r),h=!1):(m=le.EMPTY_NODE,h=!1);const x=Rc(new pa(m,h,!1),new pa(r,o,!1));return new Pk(e,x)}return p}function Vk(n,e,i,r,o,l){const p=yv(n,e,r,o,l);return n.views.has(e._queryIdentifier)||n.views.set(e._queryIdentifier,p),Fk(p,i),qk(p,i)}function Wk(n,e,i,r){const o=e._queryIdentifier,l=[];let p=[];const m=da(n);if(o==="default")for(const[h,x]of n.views.entries())p=p.concat(Hy(x,i,r)),qy(x)&&(n.views.delete(h),x.query._queryParams.loadsAllData()||l.push(x.query));else{const h=n.views.get(o);h&&(p=p.concat(Hy(h,i,r)),qy(h)&&(n.views.delete(o),h.query._queryParams.loadsAllData()||l.push(h.query)))}return m&&!da(n)&&l.push(new(Yk())(e._repo,e._path)),{removed:l,events:p}}function Ov(n){const e=[];for(const i of n.views.values())i.query._queryParams.loadsAllData()||e.push(i);return e}function oa(n,e){let i=null;for(const r of n.views.values())i=i||zk(r,e);return i}function vv(n,e){if(e._queryParams.loadsAllData())return Ic(n);{const r=e._queryIdentifier;return n.views.get(r)}}function bv(n,e){return vv(n,e)!=null}function da(n){return Ic(n)!=null}function Ic(n){for(const e of n.views.values())if(e.query._queryParams.loadsAllData())return e;return null}let fc;function Kk(n){G(!fc,"__referenceConstructor has already been defined"),fc=n}function Xk(){return G(fc,"Reference.ts has not been loaded"),fc}let Qk=1;class Gy{constructor(e){this.listenProvider_=e,this.syncPointTree_=new We(null),this.pendingWriteTree_=_k(),this.tagToQueryMap=new Map,this.queryToTagMap=new Map}}function Sv(n,e,i,r,o){return mk(n.pendingWriteTree_,e,i,r,o),o?Os(n,new Qa(Kf(),e,i)):[]}function Jk(n,e,i,r){fk(n.pendingWriteTree_,e,i,r);const o=We.fromObject(i);return Os(n,new us(Kf(),e,o))}function ia(n,e,i=!1){const r=hk(n.pendingWriteTree_,e);if(xk(n.pendingWriteTree_,e)){let l=new We(null);return r.snap!=null?l=l.set(Me(),!0):St(r.children,p=>{l=l.set(new Be(p),!0)}),Os(n,new uc(r.path,l,i))}else return[]}function uu(n,e,i){return Os(n,new Qa(Xf(),e,i))}function $k(n,e,i){const r=We.fromObject(i);return Os(n,new us(Xf(),e,r))}function Zk(n,e){return Os(n,new Wo(Xf(),e))}function eE(n,e,i){const r=nh(n,i);if(r){const o=ih(r),l=o.path,p=o.queryId,m=Dt(l,e),h=new Wo(Qf(p),m);return ah(n,l,h)}else return[]}function hc(n,e,i,r,o=!1){const l=e._path,p=n.syncPointTree_.get(l);let m=[];if(p&&(e._queryIdentifier==="default"||bv(p,e))){const h=Wk(p,e,i,r);Gk(p)&&(n.syncPointTree_=n.syncPointTree_.remove(l));const x=h.removed;if(m=h.events,!o){const O=x.findIndex(v=>v._queryParams.loadsAllData())!==-1,y=n.syncPointTree_.findOnPath(l,(v,_)=>da(_));if(O&&!y){const v=n.syncPointTree_.subtree(l);if(!v.isEmpty()){const _=iE(v);for(let k=0;k<_.length;++k){const I=_[k],D=I.query,q=Tv(n,I);n.listenProvider_.startListening(Do(D),Ko(n,D),q.hashFn,q.onComplete)}}}!y&&x.length>0&&!r&&(O?n.listenProvider_.stopListening(Do(e),null):x.forEach(v=>{const _=n.queryToTagMap.get(Lc(v));n.listenProvider_.stopListening(Do(v),_)}))}aE(n,x)}return m}function wv(n,e,i,r){const o=nh(n,r);if(o!=null){const l=ih(o),p=l.path,m=l.queryId,h=Dt(p,e),x=new Qa(Qf(m),h,i);return ah(n,p,x)}else return[]}function tE(n,e,i,r){const o=nh(n,r);if(o){const l=ih(o),p=l.path,m=l.queryId,h=Dt(p,e),x=We.fromObject(i),O=new us(Qf(m),h,x);return ah(n,p,O)}else return[]}function af(n,e,i,r=!1){const o=e._path;let l=null,p=!1;n.syncPointTree_.foreachOnPath(o,(v,_)=>{const k=Dt(v,o);l=l||oa(_,k),p=p||da(_)});let m=n.syncPointTree_.get(o);m?(p=p||da(m),l=l||oa(m,Me())):(m=new gv,n.syncPointTree_=n.syncPointTree_.set(o,m));let h;l!=null?h=!0:(h=!1,l=le.EMPTY_NODE,n.syncPointTree_.subtree(o).foreachChild((_,k)=>{const I=oa(k,Me());I&&(l=l.updateImmediateChild(_,I))}));const x=bv(m,e);if(!x&&!e._queryParams.loadsAllData()){const v=Lc(e);G(!n.queryToTagMap.has(v),"View does not exist, but we have a tag");const _=rE();n.queryToTagMap.set(v,_),n.tagToQueryMap.set(_,v)}const O=Dc(n.pendingWriteTree_,o);let y=Vk(m,e,i,O,l,h);if(!x&&!p&&!r){const v=vv(m,e);y=y.concat(sE(n,e,v))}return y}function th(n,e,i){const o=n.pendingWriteTree_,l=n.syncPointTree_.findOnPath(e,(p,m)=>{const h=Dt(p,e),x=oa(m,h);if(x)return x});return pv(o,e,l,i,!0)}function nE(n,e){const i=e._path;let r=null;n.syncPointTree_.foreachOnPath(i,(x,O)=>{const y=Dt(x,i);r=r||oa(O,y)});let o=n.syncPointTree_.get(i);o?r=r||oa(o,Me()):(o=new gv,n.syncPointTree_=n.syncPointTree_.set(i,o));const l=r!=null,p=l?new pa(r,!0,!1):null,m=Dc(n.pendingWriteTree_,e._path),h=yv(o,e,m,l?p.getNode():le.EMPTY_NODE,l);return Uk(h)}function Os(n,e){return Cv(e,n.syncPointTree_,null,Dc(n.pendingWriteTree_,Me()))}function Cv(n,e,i,r){if(ve(n.path))return _v(n,e,i,r);{const o=e.get(Me());i==null&&o!=null&&(i=oa(o,Me()));let l=[];const p=Oe(n.path),m=n.operationForChild(p),h=e.children.get(p);if(h&&m){const x=i?i.getImmediateChild(p):null,O=dv(r,p);l=l.concat(Cv(m,h,x,O))}return o&&(l=l.concat(eh(o,n,r,i))),l}}function _v(n,e,i,r){const o=e.get(Me());i==null&&o!=null&&(i=oa(o,Me()));let l=[];return e.children.inorderTraversal((p,m)=>{const h=i?i.getImmediateChild(p):null,x=dv(r,p),O=n.operationForChild(p);O&&(l=l.concat(_v(O,m,h,x)))}),o&&(l=l.concat(eh(o,n,r,i))),l}function Tv(n,e){const i=e.query,r=Ko(n,i);return{hashFn:()=>(Bk(e)||le.EMPTY_NODE).hash(),onComplete:o=>{if(o==="ok")return r?eE(n,i._path,r):Zk(n,i._path);{const l=ZT(o,i);return hc(n,i,null,l)}}}}function Ko(n,e){const i=Lc(e);return n.queryToTagMap.get(i)}function Lc(n){return n._path.toString()+"$"+n._queryIdentifier}function nh(n,e){return n.tagToQueryMap.get(e)}function ih(n){const e=n.indexOf("$");return G(e!==-1&&e<n.length-1,"Bad queryKey."),{queryId:n.substr(e+1),path:new Be(n.substr(0,e))}}function ah(n,e,i){const r=n.syncPointTree_.get(e);G(r,"Missing sync point for query tag that we're tracking");const o=Dc(n.pendingWriteTree_,e);return eh(r,i,o,null)}function iE(n){return n.fold((e,i,r)=>{if(i&&da(i))return[Ic(i)];{let o=[];return i&&(o=Ov(i)),St(r,(l,p)=>{o=o.concat(p)}),o}})}function Do(n){return n._queryParams.loadsAllData()&&!n._queryParams.isDefault()?new(Xk())(n._repo,n._path):n}function aE(n,e){for(let i=0;i<e.length;++i){const r=e[i];if(!r._queryParams.loadsAllData()){const o=Lc(r),l=n.queryToTagMap.get(o);n.queryToTagMap.delete(o),n.tagToQueryMap.delete(l)}}}function rE(){return Qk++}function sE(n,e,i){const r=e._path,o=Ko(n,e),l=Tv(n,i),p=n.listenProvider_.startListening(Do(e),o,l.hashFn,l.onComplete),m=n.syncPointTree_.subtree(r);if(o)G(!da(m.value),"If we're adding a query, it shouldn't be shadowed");else{const h=m.fold((x,O,y)=>{if(!ve(x)&&O&&da(O))return[Ic(O).query];{let v=[];return O&&(v=v.concat(Ov(O).map(_=>_.query))),St(y,(_,k)=>{v=v.concat(k)}),v}});for(let x=0;x<h.length;++x){const O=h[x];n.listenProvider_.stopListening(Do(O),Ko(n,O))}}return p}class rh{constructor(e){this.node_=e}getImmediateChild(e){const i=this.node_.getImmediateChild(e);return new rh(i)}node(){return this.node_}}class sh{constructor(e,i){this.syncTree_=e,this.path_=i}getImmediateChild(e){const i=$e(this.path_,e);return new sh(this.syncTree_,i)}node(){return th(this.syncTree_,this.path_)}}const oE=function(n){return n=n||{},n.timestamp=n.timestamp||new Date().getTime(),n},Vy=function(n,e,i){if(!n||typeof n!="object")return n;if(G(".sv"in n,"Unexpected leaf node or priority contents"),typeof n[".sv"]=="string")return uE(n[".sv"],e,i);if(typeof n[".sv"]=="object")return lE(n[".sv"],e);G(!1,"Unexpected server value: "+JSON.stringify(n,null,2))},uE=function(n,e,i){if(n==="timestamp")return i.timestamp;G(!1,"Unexpected server value: "+n)},lE=function(n,e,i){n.hasOwnProperty("increment")||G(!1,"Unexpected server value: "+JSON.stringify(n,null,2));const r=n.increment;typeof r!="number"&&G(!1,"Unexpected increment value: "+r);const o=e.node();if(G(o!==null&&typeof o<"u","Expected ChildrenNode.EMPTY_NODE for nulls"),!o.isLeafNode())return r;const p=o.getValue();return typeof p!="number"?r:p+r},Nv=function(n,e,i,r){return oh(e,new sh(i,n),r)},kv=function(n,e,i){return oh(n,new rh(e),i)};function oh(n,e,i){const r=n.getPriority().val(),o=Vy(r,e.getImmediateChild(".priority"),i);let l;if(n.isLeafNode()){const p=n,m=Vy(p.getValue(),e,i);return m!==p.getValue()||o!==p.getPriority().val()?new Ot(m,nt(o)):n}else{const p=n;return l=p,o!==p.getPriority().val()&&(l=l.updatePriority(new Ot(o))),p.forEachChild(Ze,(m,h)=>{const x=oh(h,e.getImmediateChild(m),i);x!==h&&(l=l.updateImmediateChild(m,x))}),l}}class uh{constructor(e="",i=null,r={children:{},childCount:0}){this.name=e,this.parent=i,this.node=r}}function lh(n,e){let i=e instanceof Be?e:new Be(e),r=n,o=Oe(i);for(;o!==null;){const l=is(r.node.children,o)||{children:{},childCount:0};r=new uh(o,r,l),i=Ve(i),o=Oe(i)}return r}function vs(n){return n.node.value}function Ev(n,e){n.node.value=e,rf(n)}function Av(n){return n.node.childCount>0}function cE(n){return vs(n)===void 0&&!Av(n)}function Pc(n,e){St(n.node.children,(i,r)=>{e(new uh(i,n,r))})}function jv(n,e,i,r){i&&e(n),Pc(n,o=>{jv(o,e,!0)})}function pE(n,e,i){let r=n.parent;for(;r!==null;){if(e(r))return!0;r=r.parent}return!1}function lu(n){return new Be(n.parent===null?n.name:lu(n.parent)+"/"+n.name)}function rf(n){n.parent!==null&&dE(n.parent,n.name,n)}function dE(n,e,i){const r=cE(i),o=Yn(n.node.children,e);r&&o?(delete n.node.children[e],n.node.childCount--,rf(n)):!r&&!o&&(n.node.children[e]=i.node,n.node.childCount++,rf(n))}const mE=/[\[\].#$\/\u0000-\u001F\u007F]/,fE=/[\[\].#$\u0000-\u001F\u007F]/,Em=10*1024*1024,ch=function(n){return typeof n=="string"&&n.length!==0&&!mE.test(n)},Mv=function(n){return typeof n=="string"&&n.length!==0&&!fE.test(n)},hE=function(n){return n&&(n=n.replace(/^\/*\.info(\/|$)/,"/")),Mv(n)},Rv=function(n){return n===null||typeof n=="string"||typeof n=="number"&&!jc(n)||n&&typeof n=="object"&&Yn(n,".sv")},xc=function(n,e,i,r){r&&e===void 0||Bc(as(n,"value"),e,i)},Bc=function(n,e,i){const r=i instanceof Be?new RN(i,n):i;if(e===void 0)throw new Error(n+"contains undefined "+Ua(r));if(typeof e=="function")throw new Error(n+"contains a function "+Ua(r)+" with contents = "+e.toString());if(jc(e))throw new Error(n+"contains "+e.toString()+" "+Ua(r));if(typeof e=="string"&&e.length>Em/3&&Tc(e)>Em)throw new Error(n+"contains a string greater than "+Em+" utf8 bytes "+Ua(r)+" ('"+e.substring(0,50)+"...')");if(e&&typeof e=="object"){let o=!1,l=!1;if(St(e,(p,m)=>{if(p===".value")o=!0;else if(p!==".priority"&&p!==".sv"&&(l=!0,!ch(p)))throw new Error(n+" contains an invalid key ("+p+") "+Ua(r)+`.  Keys must be non-empty strings and can't contain ".", "#", "$", "/", "[", or "]"`);DN(r,p),Bc(n,m,r),IN(r)}),o&&l)throw new Error(n+' contains ".value" child '+Ua(r)+" in addition to actual children.")}},xE=function(n,e){let i,r;for(i=0;i<e.length;i++){r=e[i];const l=Ho(r);for(let p=0;p<l.length;p++)if(!(l[p]===".priority"&&p===l.length-1)){if(!ch(l[p]))throw new Error(n+"contains an invalid key ("+l[p]+") in path "+r.toString()+`. Keys must be non-empty strings and can't contain ".", "#", "$", "/", "[", or "]"`)}}e.sort(MN);let o=null;for(i=0;i<e.length;i++){if(r=e[i],o!==null&&yn(o,r))throw new Error(n+"contains a path "+o.toString()+" that is ancestor of another path "+r.toString());o=r}},Dv=function(n,e,i,r){const o=as(n,"values");if(!(e&&typeof e=="object")||Array.isArray(e))throw new Error(o+" must be an object containing the children to replace.");const l=[];St(e,(p,m)=>{const h=new Be(p);if(Bc(o,m,$e(i,h)),qf(h)===".priority"&&!Rv(m))throw new Error(o+"contains an invalid value for '"+h.toString()+"', which must be a valid Firebase priority (a string, finite number, server value, or null).");l.push(h)}),xE(o,l)},gE=function(n,e,i){if(jc(e))throw new Error(as(n,"priority")+"is "+e.toString()+", but must be a valid Firebase priority (a string, finite number, server value, or null).");if(!Rv(e))throw new Error(as(n,"priority")+"must be a valid Firebase priority (a string, finite number, server value, or null).")},Iv=function(n,e,i,r){if(!Mv(i))throw new Error(as(n,e)+'was an invalid path = "'+i+`". Paths must be non-empty strings and can't contain ".", "#", "$", "[", or "]"`)},yE=function(n,e,i,r){i&&(i=i.replace(/^\/*\.info(\/|$)/,"/")),Iv(n,e,i)},qa=function(n,e){if(Oe(e)===".info")throw new Error(n+" failed = Can't modify data under /.info/")},OE=function(n,e){const i=e.path.toString();if(typeof e.repoInfo.host!="string"||e.repoInfo.host.length===0||!ch(e.repoInfo.namespace)&&e.repoInfo.host.split(":")[0]!=="localhost"||i.length!==0&&!hE(i))throw new Error(as(n,"url")+`must be a valid firebase URL and the path can't contain ".", "#", "$", "[", or "]".`)};class vE{constructor(){this.eventLists_=[],this.recursionDepth_=0}}function Uc(n,e){let i=null;for(let r=0;r<e.length;r++){const o=e[r],l=o.getPath();i!==null&&!Hf(l,i.path)&&(n.eventLists_.push(i),i=null),i===null&&(i={events:[],path:l}),i.events.push(o)}i&&n.eventLists_.push(i)}function Lv(n,e,i){Uc(n,i),Pv(n,r=>Hf(r,e))}function bn(n,e,i){Uc(n,i),Pv(n,r=>yn(r,e)||yn(e,r))}function Pv(n,e){n.recursionDepth_++;let i=!0;for(let r=0;r<n.eventLists_.length;r++){const o=n.eventLists_[r];if(o){const l=o.path;e(l)?(bE(n.eventLists_[r]),n.eventLists_[r]=null):i=!1}}i&&(n.eventLists_=[]),n.recursionDepth_--}function bE(n){for(let e=0;e<n.events.length;e++){const i=n.events[e];if(i!==null){n.events[e]=null;const r=i.getEventRunner();Ao&&bt("event: "+i.toString()),gs(r)}}}const SE="repo_interrupt",wE=25;class CE{constructor(e,i,r,o){this.repoInfo_=e,this.forceRestClient_=i,this.authTokenProvider_=r,this.appCheckProvider_=o,this.dataUpdateCount=0,this.statsListener_=null,this.eventQueue_=new vE,this.nextWriteId_=1,this.interceptServerDataCallback_=null,this.onDisconnect_=oc(),this.transactionQueueTree_=new uh,this.persistentConnection_=null,this.key=this.repoInfo_.toURLString()}toString(){return(this.repoInfo_.secure?"https://":"http://")+this.repoInfo_.host}}function _E(n,e,i){if(n.stats_=zf(n.repoInfo_),n.forceRestClient_||iN())n.server_=new sc(n.repoInfo_,(r,o,l,p)=>{Wy(n,r,o,l,p)},n.authTokenProvider_,n.appCheckProvider_),setTimeout(()=>Ky(n,!0),0);else{if(typeof i<"u"&&i!==null){if(typeof i!="object")throw new Error("Only objects are supported for option databaseAuthVariableOverride");try{xt(i)}catch(r){throw new Error("Invalid authOverride provided: "+r)}}n.persistentConnection_=new gi(n.repoInfo_,e,(r,o,l,p)=>{Wy(n,r,o,l,p)},r=>{Ky(n,r)},r=>{TE(n,r)},n.authTokenProvider_,n.appCheckProvider_,i),n.server_=n.persistentConnection_}n.authTokenProvider_.addTokenChangeListener(r=>{n.server_.refreshAuthToken(r)}),n.appCheckProvider_.addTokenChangeListener(r=>{n.server_.refreshAppCheckToken(r.token)}),n.statsReporter_=uN(n.repoInfo_,()=>new ok(n.stats_,n.server_)),n.infoData_=new nk,n.infoSyncTree_=new Gy({startListening:(r,o,l,p)=>{let m=[];const h=n.infoData_.getNode(r._path);return h.isEmpty()||(m=uu(n.infoSyncTree_,r._path,h),setTimeout(()=>{p("ok")},0)),m},stopListening:()=>{}}),ph(n,"connected",!1),n.serverSyncTree_=new Gy({startListening:(r,o,l,p)=>(n.server_.listen(r,l,o,(m,h)=>{const x=p(m,h);bn(n.eventQueue_,r._path,x)}),[]),stopListening:(r,o)=>{n.server_.unlisten(r,o)}})}function Bv(n){const i=n.infoData_.getNode(new Be(".info/serverTimeOffset")).val()||0;return new Date().getTime()+i}function zc(n){return oE({timestamp:Bv(n)})}function Wy(n,e,i,r,o){n.dataUpdateCount++;const l=new Be(e);i=n.interceptServerDataCallback_?n.interceptServerDataCallback_(e,i):i;let p=[];if(o)if(r){const h=Xl(i,x=>nt(x));p=tE(n.serverSyncTree_,l,h,o)}else{const h=nt(i);p=wv(n.serverSyncTree_,l,h,o)}else if(r){const h=Xl(i,x=>nt(x));p=$k(n.serverSyncTree_,l,h)}else{const h=nt(i);p=uu(n.serverSyncTree_,l,h)}let m=l;p.length>0&&(m=cs(n,l)),bn(n.eventQueue_,m,p)}function Ky(n,e){ph(n,"connected",e),e===!1&&AE(n)}function TE(n,e){St(e,(i,r)=>{ph(n,i,r)})}function ph(n,e,i){const r=new Be("/.info/"+e),o=nt(i);n.infoData_.updateSnapshot(r,o);const l=uu(n.infoSyncTree_,r,o);bn(n.eventQueue_,r,l)}function dh(n){return n.nextWriteId_++}function NE(n,e,i){const r=nE(n.serverSyncTree_,e);return r!=null?Promise.resolve(r):n.server_.get(e).then(o=>{const l=nt(o).withIndex(e._queryParams.getIndex());af(n.serverSyncTree_,e,i,!0);let p;if(e._queryParams.loadsAllData())p=uu(n.serverSyncTree_,e._path,l);else{const m=Ko(n.serverSyncTree_,e);p=wv(n.serverSyncTree_,e._path,l,m)}return bn(n.eventQueue_,e._path,p),hc(n.serverSyncTree_,e,i,null,!0),l},o=>(cu(n,"get for query "+xt(e)+" failed: "+o),Promise.reject(new Error(o))))}function kE(n,e,i,r,o){cu(n,"set",{path:e.toString(),value:i,priority:r});const l=zc(n),p=nt(i,r),m=th(n.serverSyncTree_,e),h=kv(p,m,l),x=dh(n),O=Sv(n.serverSyncTree_,e,h,x,!0);Uc(n.eventQueue_,O),n.server_.put(e.toString(),p.val(!0),(v,_)=>{const k=v==="ok";k||It("set at "+e+" failed: "+v);const I=ia(n.serverSyncTree_,x,!k);bn(n.eventQueue_,e,I),ma(n,o,v,_)});const y=fh(n,e);cs(n,y),bn(n.eventQueue_,y,[])}function EE(n,e,i,r){cu(n,"update",{path:e.toString(),value:i});let o=!0;const l=zc(n),p={};if(St(i,(m,h)=>{o=!1,p[m]=Nv($e(e,m),nt(h),n.serverSyncTree_,l)}),o)bt("update() called with empty data.  Don't do anything."),ma(n,r,"ok",void 0);else{const m=dh(n),h=Jk(n.serverSyncTree_,e,p,m);Uc(n.eventQueue_,h),n.server_.merge(e.toString(),i,(x,O)=>{const y=x==="ok";y||It("update at "+e+" failed: "+x);const v=ia(n.serverSyncTree_,m,!y),_=v.length>0?cs(n,e):e;bn(n.eventQueue_,_,v),ma(n,r,x,O)}),St(i,x=>{const O=fh(n,$e(e,x));cs(n,O)}),bn(n.eventQueue_,e,[])}}function AE(n){cu(n,"onDisconnectEvents");const e=zc(n),i=oc();Jm(n.onDisconnect_,Me(),(o,l)=>{const p=Nv(o,l,n.serverSyncTree_,e);ys(i,o,p)});let r=[];Jm(i,Me(),(o,l)=>{r=r.concat(uu(n.serverSyncTree_,o,l));const p=fh(n,o);cs(n,p)}),n.onDisconnect_=oc(),bn(n.eventQueue_,Me(),r)}function jE(n,e,i){n.server_.onDisconnectCancel(e.toString(),(r,o)=>{r==="ok"&&Qm(n.onDisconnect_,e),ma(n,i,r,o)})}function Xy(n,e,i,r){const o=nt(i);n.server_.onDisconnectPut(e.toString(),o.val(!0),(l,p)=>{l==="ok"&&ys(n.onDisconnect_,e,o),ma(n,r,l,p)})}function ME(n,e,i,r,o){const l=nt(i,r);n.server_.onDisconnectPut(e.toString(),l.val(!0),(p,m)=>{p==="ok"&&ys(n.onDisconnect_,e,l),ma(n,o,p,m)})}function RE(n,e,i,r){if(Kl(i)){bt("onDisconnect().update() called with empty data.  Don't do anything."),ma(n,r,"ok",void 0);return}n.server_.onDisconnectMerge(e.toString(),i,(o,l)=>{o==="ok"&&St(i,(p,m)=>{const h=nt(m);ys(n.onDisconnect_,$e(e,p),h)}),ma(n,r,o,l)})}function DE(n,e,i){let r;Oe(e._path)===".info"?r=af(n.infoSyncTree_,e,i):r=af(n.serverSyncTree_,e,i),Lv(n.eventQueue_,e._path,r)}function Uv(n,e,i){let r;Oe(e._path)===".info"?r=hc(n.infoSyncTree_,e,i):r=hc(n.serverSyncTree_,e,i),Lv(n.eventQueue_,e._path,r)}function IE(n){n.persistentConnection_&&n.persistentConnection_.interrupt(SE)}function cu(n,...e){let i="";n.persistentConnection_&&(i=n.persistentConnection_.id+":"),bt(i,...e)}function ma(n,e,i,r){e&&gs(()=>{if(i==="ok")e(null);else{const o=(i||"error").toUpperCase();let l=o;r&&(l+=": "+r);const p=new Error(l);p.code=o,e(p)}})}function zv(n,e,i){return th(n.serverSyncTree_,e,i)||le.EMPTY_NODE}function mh(n,e=n.transactionQueueTree_){if(e||Fc(n,e),vs(e)){const i=qv(n,e);G(i.length>0,"Sending zero length transaction queue"),i.every(o=>o.status===0)&&LE(n,lu(e),i)}else Av(e)&&Pc(e,i=>{mh(n,i)})}function LE(n,e,i){const r=i.map(x=>x.currentWriteId),o=zv(n,e,r);let l=o;const p=o.hash();for(let x=0;x<i.length;x++){const O=i[x];G(O.status===0,"tryToSendTransactionQueue_: items in queue should all be run."),O.status=1,O.retryCount++;const y=Dt(e,O.path);l=l.updateChild(y,O.currentOutputSnapshotRaw)}const m=l.val(!0),h=e;n.server_.put(h.toString(),m,x=>{cu(n,"transaction put response",{path:h.toString(),status:x});let O=[];if(x==="ok"){const y=[];for(let v=0;v<i.length;v++)i[v].status=2,O=O.concat(ia(n.serverSyncTree_,i[v].currentWriteId)),i[v].onComplete&&y.push(()=>i[v].onComplete(null,!0,i[v].currentOutputSnapshotResolved)),i[v].unwatcher();Fc(n,lh(n.transactionQueueTree_,e)),mh(n,n.transactionQueueTree_),bn(n.eventQueue_,e,O);for(let v=0;v<y.length;v++)gs(y[v])}else{if(x==="datastale")for(let y=0;y<i.length;y++)i[y].status===3?i[y].status=4:i[y].status=0;else{It("transaction at "+h.toString()+" failed: "+x);for(let y=0;y<i.length;y++)i[y].status=4,i[y].abortReason=x}cs(n,e)}},p)}function cs(n,e){const i=Fv(n,e),r=lu(i),o=qv(n,i);return PE(n,o,r),r}function PE(n,e,i){if(e.length===0)return;const r=[];let o=[];const p=e.filter(m=>m.status===0).map(m=>m.currentWriteId);for(let m=0;m<e.length;m++){const h=e[m],x=Dt(i,h.path);let O=!1,y;if(G(x!==null,"rerunTransactionsUnderNode_: relativePath should not be null."),h.status===4)O=!0,y=h.abortReason,o=o.concat(ia(n.serverSyncTree_,h.currentWriteId,!0));else if(h.status===0)if(h.retryCount>=wE)O=!0,y="maxretry",o=o.concat(ia(n.serverSyncTree_,h.currentWriteId,!0));else{const v=zv(n,h.path,p);h.currentInputSnapshot=v;const _=e[m].update(v.val());if(_!==void 0){Bc("transaction failed: Data returned ",_,h.path);let k=nt(_);typeof _=="object"&&_!=null&&Yn(_,".priority")||(k=k.updatePriority(v.getPriority()));const D=h.currentWriteId,q=zc(n),z=kv(k,v,q);h.currentOutputSnapshotRaw=k,h.currentOutputSnapshotResolved=z,h.currentWriteId=dh(n),p.splice(p.indexOf(D),1),o=o.concat(Sv(n.serverSyncTree_,h.path,z,h.currentWriteId,h.applyLocally)),o=o.concat(ia(n.serverSyncTree_,D,!0))}else O=!0,y="nodata",o=o.concat(ia(n.serverSyncTree_,h.currentWriteId,!0))}bn(n.eventQueue_,i,o),o=[],O&&(e[m].status=2,(function(v){setTimeout(v,Math.floor(0))})(e[m].unwatcher),e[m].onComplete&&(y==="nodata"?r.push(()=>e[m].onComplete(null,!1,e[m].currentInputSnapshot)):r.push(()=>e[m].onComplete(new Error(y),!1,null))))}Fc(n,n.transactionQueueTree_);for(let m=0;m<r.length;m++)gs(r[m]);mh(n,n.transactionQueueTree_)}function Fv(n,e){let i,r=n.transactionQueueTree_;for(i=Oe(e);i!==null&&vs(r)===void 0;)r=lh(r,i),e=Ve(e),i=Oe(e);return r}function qv(n,e){const i=[];return Hv(n,e,i),i.sort((r,o)=>r.order-o.order),i}function Hv(n,e,i){const r=vs(e);if(r)for(let o=0;o<r.length;o++)i.push(r[o]);Pc(e,o=>{Hv(n,o,i)})}function Fc(n,e){const i=vs(e);if(i){let r=0;for(let o=0;o<i.length;o++)i[o].status!==2&&(i[r]=i[o],r++);i.length=r,Ev(e,i.length>0?i:void 0)}Pc(e,r=>{Fc(n,r)})}function fh(n,e){const i=lu(Fv(n,e)),r=lh(n.transactionQueueTree_,e);return pE(r,o=>{Am(n,o)}),Am(n,r),jv(r,o=>{Am(n,o)}),i}function Am(n,e){const i=vs(e);if(i){const r=[];let o=[],l=-1;for(let p=0;p<i.length;p++)i[p].status===3||(i[p].status===1?(G(l===p-1,"All SENT items should be at beginning of queue."),l=p,i[p].status=3,i[p].abortReason="set"):(G(i[p].status===0,"Unexpected transaction status in abort"),i[p].unwatcher(),o=o.concat(ia(n.serverSyncTree_,i[p].currentWriteId,!0)),i[p].onComplete&&r.push(i[p].onComplete.bind(null,new Error("set"),!1,null))));l===-1?Ev(e,void 0):i.length=l+1,bn(n.eventQueue_,lu(e),o);for(let p=0;p<r.length;p++)gs(r[p])}}function BE(n){let e="";const i=n.split("/");for(let r=0;r<i.length;r++)if(i[r].length>0){let o=i[r];try{o=decodeURIComponent(o.replace(/\+/g," "))}catch{}e+="/"+o}return e}function UE(n){const e={};n.charAt(0)==="?"&&(n=n.substring(1));for(const i of n.split("&")){if(i.length===0)continue;const r=i.split("=");r.length===2?e[decodeURIComponent(r[0])]=decodeURIComponent(r[1]):It(`Invalid query segment '${i}' in query '${n}'`)}return e}const Qy=function(n,e){const i=zE(n),r=i.namespace;i.domain==="firebase.com"&&bi(i.host+" is no longer supported. Please use <YOUR FIREBASE>.firebaseio.com instead"),(!r||r==="undefined")&&i.domain!=="localhost"&&bi("Cannot parse Firebase url. Please use https://<YOUR FIREBASE>.firebaseio.com"),i.secure||KT();const o=i.scheme==="ws"||i.scheme==="wss";return{repoInfo:new GO(i.host,i.secure,r,o,e,"",r!==i.subdomain),path:new Be(i.pathString)}},zE=function(n){let e="",i="",r="",o="",l="",p=!0,m="https",h=443;if(typeof n=="string"){let x=n.indexOf("//");x>=0&&(m=n.substring(0,x-1),n=n.substring(x+2));let O=n.indexOf("/");O===-1&&(O=n.length);let y=n.indexOf("?");y===-1&&(y=n.length),e=n.substring(0,Math.min(O,y)),O<y&&(o=BE(n.substring(O,y)));const v=UE(n.substring(Math.min(n.length,y)));x=e.indexOf(":"),x>=0?(p=m==="https"||m==="wss",h=parseInt(e.substring(x+1),10)):x=e.length;const _=e.slice(0,x);if(_.toLowerCase()==="localhost")i="localhost";else if(_.split(".").length<=2)i=_;else{const k=e.indexOf(".");r=e.substring(0,k).toLowerCase(),i=e.substring(k+1),l=r}"ns"in v&&(l=v.ns)}return{host:e,port:h,domain:i,subdomain:r,secure:p,scheme:m,pathString:o,namespace:l}};const Jy="-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz",FE=(function(){let n=0;const e=[];return function(i){const r=i===n;n=i;let o;const l=new Array(8);for(o=7;o>=0;o--)l[o]=Jy.charAt(i%64),i=Math.floor(i/64);G(i===0,"Cannot push at time == 0");let p=l.join("");if(r){for(o=11;o>=0&&e[o]===63;o--)e[o]=0;e[o]++}else for(o=0;o<12;o++)e[o]=Math.floor(Math.random()*64);for(o=0;o<12;o++)p+=Jy.charAt(e[o]);return G(p.length===20,"nextPushId: Length should be 20."),p}})();class qE{constructor(e,i,r,o){this.eventType=e,this.eventRegistration=i,this.snapshot=r,this.prevName=o}getPath(){const e=this.snapshot.ref;return this.eventType==="value"?e._path:e.parent._path}getEventType(){return this.eventType}getEventRunner(){return this.eventRegistration.getEventRunner(this)}toString(){return this.getPath().toString()+":"+this.eventType+":"+xt(this.snapshot.exportVal())}}class HE{constructor(e,i,r){this.eventRegistration=e,this.error=i,this.path=r}getPath(){return this.path}getEventType(){return"cancel"}getEventRunner(){return this.eventRegistration.getEventRunner(this)}toString(){return this.path.toString()+":cancel"}}class Yv{constructor(e,i){this.snapshotCallback=e,this.cancelCallback=i}onValue(e,i){this.snapshotCallback.call(null,e,i)}onCancel(e){return G(this.hasCancelCallback,"Raising a cancel event on a listener with no cancel callback"),this.cancelCallback.call(null,e)}get hasCancelCallback(){return!!this.cancelCallback}matches(e){return this.snapshotCallback===e.snapshotCallback||this.snapshotCallback.userCallback!==void 0&&this.snapshotCallback.userCallback===e.snapshotCallback.userCallback&&this.snapshotCallback.context===e.snapshotCallback.context}}class YE{constructor(e,i){this._repo=e,this._path=i}cancel(){const e=new Pn;return jE(this._repo,this._path,e.wrapCallback(()=>{})),e.promise}remove(){qa("OnDisconnect.remove",this._path);const e=new Pn;return Xy(this._repo,this._path,null,e.wrapCallback(()=>{})),e.promise}set(e){qa("OnDisconnect.set",this._path),xc("OnDisconnect.set",e,this._path,!1);const i=new Pn;return Xy(this._repo,this._path,e,i.wrapCallback(()=>{})),i.promise}setWithPriority(e,i){qa("OnDisconnect.setWithPriority",this._path),xc("OnDisconnect.setWithPriority",e,this._path,!1),gE("OnDisconnect.setWithPriority",i);const r=new Pn;return ME(this._repo,this._path,e,i,r.wrapCallback(()=>{})),r.promise}update(e){qa("OnDisconnect.update",this._path),Dv("OnDisconnect.update",e,this._path);const i=new Pn;return RE(this._repo,this._path,e,i.wrapCallback(()=>{})),i.promise}}class hh{constructor(e,i,r,o){this._repo=e,this._path=i,this._queryParams=r,this._orderByCalled=o}get key(){return ve(this._path)?null:qf(this._path)}get ref(){return new Ci(this._repo,this._path)}get _queryIdentifier(){const e=Iy(this._queryParams),i=Bf(e);return i==="{}"?"default":i}get _queryObject(){return Iy(this._queryParams)}isEqual(e){if(e=at(e),!(e instanceof hh))return!1;const i=this._repo===e._repo,r=Hf(this._path,e._path),o=this._queryIdentifier===e._queryIdentifier;return i&&r&&o}toJSON(){return this.toString()}toString(){return this._repo.toString()+jN(this._path)}}class Ci extends hh{constructor(e,i){super(e,i,new Wf,!1)}get parent(){const e=ev(this._path);return e===null?null:new Ci(this._repo,e)}get root(){let e=this;for(;e.parent!==null;)e=e.parent;return e}}class Xo{constructor(e,i,r){this._node=e,this.ref=i,this._index=r}get priority(){return this._node.getPriority().val()}get key(){return this.ref.key}get size(){return this._node.numChildren()}child(e){const i=new Be(e),r=Qo(this.ref,e);return new Xo(this._node.getChild(i),r,Ze)}exists(){return!this._node.isEmpty()}exportVal(){return this._node.val(!0)}forEach(e){return this._node.isLeafNode()?!1:!!this._node.forEachChild(this._index,(r,o)=>e(new Xo(o,Qo(this.ref,r),Ze)))}hasChild(e){const i=new Be(e);return!this._node.getChild(i).isEmpty()}hasChildren(){return this._node.isLeafNode()?!1:!this._node.isEmpty()}toJSON(){return this.exportVal()}val(){return this._node.val()}}function se(n,e){return n=at(n),n._checkNotDeleted("ref"),e!==void 0?Qo(n._root,e):n._root}function Qo(n,e){return n=at(n),Oe(n._path)===null?yE("child","path",e):Iv("child","path",e),new Ci(n._repo,$e(n._path,e))}function GE(n){return n=at(n),new YE(n._repo,n._path)}function Gv(n,e){n=at(n),qa("push",n._path),xc("push",e,n._path,!0);const i=Bv(n._repo),r=FE(i),o=Qo(n,r),l=Qo(n,r);let p;return p=Promise.resolve(l),o.then=p.then.bind(p),o.catch=p.then.bind(p,void 0),o}function Fn(n){return qa("remove",n._path),sn(n,null)}function sn(n,e){n=at(n),qa("set",n._path),xc("set",e,n._path,!1);const i=new Pn;return kE(n._repo,n._path,e,null,i.wrapCallback(()=>{})),i.promise}function Pt(n,e){Dv("update",e,n._path);const i=new Pn;return EE(n._repo,n._path,e,i.wrapCallback(()=>{})),i.promise}function Et(n){n=at(n);const e=new Yv(()=>{}),i=new qc(e);return NE(n._repo,n,i).then(r=>new Xo(r,new Ci(n._repo,n._path),n._queryParams.getIndex()))}class qc{constructor(e){this.callbackContext=e}respondsTo(e){return e==="value"}createEvent(e,i){const r=i._queryParams.getIndex();return new qE("value",this,new Xo(e.snapshotNode,new Ci(i._repo,i._path),r))}getEventRunner(e){return e.getEventType()==="cancel"?()=>this.callbackContext.onCancel(e.error):()=>this.callbackContext.onValue(e.snapshot,null)}createCancelEvent(e,i){return this.callbackContext.hasCancelCallback?new HE(this,e,i):null}matches(e){return e instanceof qc?!e.callbackContext||!this.callbackContext?!0:e.callbackContext.matches(this.callbackContext):!1}hasAnyCallback(){return this.callbackContext!==null}}function VE(n,e,i,r,o){const l=new Yv(i,void 0),p=new qc(l);return DE(n._repo,n,p),()=>Uv(n._repo,n,p)}function Mn(n,e,i,r){return VE(n,"value",e)}function Gn(n,e,i){Uv(n._repo,n,null)}Hk(Ci);Kk(Ci);const WE="FIREBASE_DATABASE_EMULATOR_HOST",sf={};let KE=!1;function XE(n,e,i,r){const o=e.lastIndexOf(":"),l=e.substring(0,o),p=fa(l);n.repoInfo_=new GO(e,p,n.repoInfo_.namespace,n.repoInfo_.webSocketOnly,n.repoInfo_.nodeAdmin,n.repoInfo_.persistenceKey,n.repoInfo_.includeNamespaceInQueryParams,!0,i),r&&(n.authTokenProvider_=r)}function QE(n,e,i,r,o){let l=r||n.options.databaseURL;l===void 0&&(n.options.projectId||bi("Can't determine Firebase Database URL. Be sure to include  a Project ID when calling firebase.initializeApp()."),bt("Using default host for project ",n.options.projectId),l=`${n.options.projectId}-default-rtdb.firebaseio.com`);let p=Qy(l,o),m=p.repoInfo,h;typeof process<"u"&&gy&&(h=gy[WE]),h?(l=`http://${h}?ns=${m.namespace}`,p=Qy(l,o),m=p.repoInfo):p.repoInfo.secure;const x=new rN(n.name,n.options,e);OE("Invalid Firebase Database URL",p),ve(p.path)||bi("Database URL must point to the root of a Firebase Database (not including a child path).");const O=$E(m,n,x,new aN(n,i));return new ZE(O,n)}function JE(n,e){const i=sf[e];(!i||i[n.key]!==n)&&bi(`Database ${e}(${n.repoInfo_}) has already been deleted.`),IE(n),delete i[n.key]}function $E(n,e,i,r){let o=sf[e.name];o||(o={},sf[e.name]=o);let l=o[n.toURLString()];return l&&bi("Database initialized multiple times. Please make sure the format of the database URL matches with each database() call."),l=new CE(n,KE,i,r),o[n.toURLString()]=l,l}class ZE{constructor(e,i){this._repoInternal=e,this.app=i,this.type="database",this._instanceStarted=!1}get _repo(){return this._instanceStarted||(_E(this._repoInternal,this.app.options.appId,this.app.options.databaseAuthVariableOverride),this._instanceStarted=!0),this._repoInternal}get _root(){return this._rootInternal||(this._rootInternal=new Ci(this._repo,Me())),this._rootInternal}_delete(){return this._rootInternal!==null&&(JE(this._repo,this.app.name),this._repoInternal=null,this._rootInternal=null),Promise.resolve()}_checkNotDeleted(e){this._rootInternal===null&&bi("Cannot call "+e+" on a deleted database.")}}function eA(n=Nf(),e){const i=Nc(n,"database").getImmediate({identifier:e});if(!i._instanceStarted){const r=z2("database");r&&tA(i,...r)}return i}function tA(n,e,i,r={}){n=at(n),n._checkNotDeleted("useEmulator");const o=`${e}:${i}`,l=n._repoInternal;if(n._instanceStarted){if(o===n._repoInternal.repoInfo_.host&&Ga(r,l.repoInfo_.emulatorOptions))return;bi("connectDatabaseEmulator() cannot initialize or alter the emulator configuration after the database instance has started.")}let p;if(l.repoInfo_.nodeAdmin)r.mockUserToken&&bi('mockUserToken is not supported by the Admin SDK. For client access with mock users, please use the "firebase" package instead of "firebase-admin".'),p=new Yl(Yl.OWNER);else if(r.mockUserToken){const m=typeof r.mockUserToken=="string"?r.mockUserToken:H2(r.mockUserToken,n.app.options.projectId);p=new Yl(m)}fa(e)&&(Sf(e),wf("Database",!0)),XE(l,o,r,p)}function nA(n){qT(er),Va(new la("database",(e,{instanceIdentifier:i})=>{const r=e.getProvider("app").getImmediate(),o=e.getProvider("auth-internal"),l=e.getProvider("app-check-internal");return QE(r,o,l,i)},"PUBLIC").setMultipleInstances(!0)),Un(yy,Oy,n),Un(yy,Oy,"esm2020")}const iA={".sv":"timestamp"};function aA(){return iA}gi.prototype.simpleListen=function(n,e){this.sendRequest("q",{p:n},e)};gi.prototype.echo=function(n,e){this.sendRequest("echo",{d:n},e)};nA();const rA={apiKey:"AIzaSyBEngkGj-us_Jyf-D_or0H9qbEnySGqss0",authDomain:"valkry-ed5c2.firebaseapp.com",projectId:"valkry-ed5c2",storageBucket:"valkry-ed5c2.firebasestorage.app",messagingSenderId:"395028222152",appId:"1:395028222152:web:2d9cb122484ba888aa55fd",measurementId:"G-DWXGY75PBF",databaseURL:"https://valkry-ed5c2-default-rtdb.asia-southeast1.firebasedatabase.app"},Vv=K2(rA),Xr=zT(Vv),xh=new pi;xh.addScope("profile");xh.addScope("email");const oe=eA(Vv);async function Wv(n,e,i=null){const r=se(oe,`users/${n}/stats`),o=await Et(r);if(!o.exists()){const p={name:e,avatar:i,battles:0,wins:0,losses:0,draws:0,winRate:0,currentStreak:0,bestStreak:0,rating:1e3,rank:"Bronze",totalTimeSpent:0,fastestWin:null,createdAt:Date.now(),lastBattleAt:null};await sn(r,p);const m=se(oe,`leaderboard/${n}`);return await sn(m,{name:e,avatar:i,rating:1e3,wins:0,streak:0,updatedAt:Date.now()}),await Kv("player"),p}const l=o.val();if(i||e){const p={};if(i&&l.avatar!==i&&(p.avatar=i),e&&l.name!==e&&(p.name=e),Object.keys(p).length>0){await Pt(r,p);const m=se(oe,`leaderboard/${n}`);await Pt(m,p)}}return{...l,avatar:i||l.avatar,name:e||l.name}}async function sA(n,e){const i=se(oe,`users/${n}/stats`);await Pt(i,{avatar:e});const r=se(oe,`leaderboard/${n}`);await Pt(r,{avatar:e})}function oA(n,e){const i=se(oe,`users/${n}/stats`);return Mn(i,r=>{r.exists()&&e(r.val())}),()=>Gn(i)}function uA(n){return n>=2500?"Legendary":n>=2e3?"Master":n>=1600?"Diamond":n>=1400?"Platinum":n>=1200?"Gold":n>=1e3?"Silver":"Bronze"}async function lA(n,e,i,r=1e3){const o=se(oe,`users/${n}/stats`),l=await Et(o);if(!l.exists())return;const p=l.val(),m=1/(1+Math.pow(10,(r-p.rating)/400)),h=e?1:0,x=p.battles<30?40:20,O=Math.round(x*(h-m)),y=Math.max(0,p.rating+O),v=e?p.currentStreak+1:0,_=Math.max(p.bestStreak,v),k=p.battles+1,I=p.wins+(e?1:0),D=p.losses+(e?0:1),q=Math.round(I/k*100);let z=p.fastestWin;e&&i&&(!z||i<z)&&(z=i);const H={battles:k,wins:I,losses:D,winRate:q,rating:y,rank:uA(y),currentStreak:v,bestStreak:_,totalTimeSpent:p.totalTimeSpent+(i||0),fastestWin:z,lastBattleAt:Date.now()};return await Pt(o,H),await cA(n,p.name,y,I,v,p.avatar),H}async function cA(n,e,i,r,o,l=null){const p=se(oe,`leaderboard/${n}`);await sn(p,{name:e,avatar:l,rating:i,wins:r,streak:o,updatedAt:Date.now()})}async function pA(n=50){const e=se(oe,"leaderboard"),i=await Et(e);if(!i.exists())return[];const r=i.val(),o=Object.entries(r).map(([l,p])=>({id:l,...p}));return o.sort((l,p)=>p.rating-l.rating),o.slice(0,n).map((l,p)=>({...l,rank:p+1}))}function dA(n,e=50){const i=se(oe,"leaderboard");return Mn(i,r=>{if(r.exists()){const o=r.val(),l=Object.entries(o).map(([p,m])=>({id:p,...m}));l.sort((p,m)=>m.rating-p.rating),n(l.slice(0,e).map((p,m)=>({...p,rank:m+1})))}else n([])}),()=>Gn(i)}async function gh(){const n=se(oe,"globalStats"),e=await Et(n);return e.exists()?e.val():{totalPlayers:0,battlesToday:0,totalBattles:0}}async function Kv(n){const e=se(oe,"globalStats"),i=await Et(e),r=i.exists()?i.val():{totalPlayers:0,battlesToday:0,totalBattles:0,lastResetDate:null},o=new Date().toDateString();return r.lastResetDate!==o&&(r.battlesToday=0,r.lastResetDate=o),n==="player"?r.totalPlayers=(r.totalPlayers||0)+1:n==="battle"&&(r.battlesToday=(r.battlesToday||0)+1,r.totalBattles=(r.totalBattles||0)+1),await sn(e,r),r}async function mA(n){const e=se(oe,`users/${n}/achievements`),i=await Et(e);return i.exists()?i.val():{}}async function fA(n,e){const i=se(oe,`users/${n}/achievements`),r=await Et(i),o=r.exists()?r.val():{},l=[],p=[{id:"first_battle",name:"First Blood",desc:"Complete your first battle",check:()=>e.battles>=1},{id:"first_win",name:"Victory!",desc:"Win your first battle",check:()=>e.wins>=1},{id:"streak_3",name:"On Fire",desc:"Win 3 battles in a row",check:()=>e.bestStreak>=3},{id:"streak_5",name:"Unstoppable",desc:"Win 5 battles in a row",check:()=>e.bestStreak>=5},{id:"streak_10",name:"Legendary",desc:"Win 10 battles in a row",check:()=>e.bestStreak>=10},{id:"battles_10",name:"Veteran",desc:"Complete 10 battles",check:()=>e.battles>=10},{id:"battles_50",name:"Warrior",desc:"Complete 50 battles",check:()=>e.battles>=50},{id:"battles_100",name:"Champion",desc:"Complete 100 battles",check:()=>e.battles>=100},{id:"rating_1200",name:"Gold Rank",desc:"Reach 1200 rating",check:()=>e.rating>=1200},{id:"rating_1600",name:"Diamond Rank",desc:"Reach 1600 rating",check:()=>e.rating>=1600},{id:"rating_2000",name:"Master Rank",desc:"Reach 2000 rating",check:()=>e.rating>=2e3},{id:"speed_demon",name:"Speed Demon",desc:"Win a battle in under 60 seconds",check:()=>e.fastestWin&&e.fastestWin<60}];for(const m of p)!o[m.id]&&m.check()&&(o[m.id]={unlockedAt:Date.now(),name:m.name,desc:m.desc},l.push(m));return l.length>0&&await sn(i,o),{all:o,new:l}}const Xv=S.createContext(),hA=({children:n})=>{const[e,i]=S.useState(null),[r,o]=S.useState(!0),l=O=>({id:O.uid,name:O.displayName||O.email?.split("@")[0]||"Commander",email:O.email,avatar:O.photoURL,handle:O.email?.split("@")[0]||"nomad"});S.useEffect(()=>{const O=k_(Xr,y=>{if(y){const v=l(y);i(v),localStorage.setItem("valkry_user",JSON.stringify(v)),Wv(v.id,v.name,v.avatar)}else localStorage.removeItem("valkry_user"),i(null);o(!1)});return()=>O()},[]);const p=async()=>{try{return await X_(Xr,xh),{success:!0}}catch(O){return console.error("Google Auth Error:",O),{success:!1,error:O.message}}},m=async(O,y,v)=>{try{const _=await w_(Xr,O,y);return v&&await OO(_.user,{displayName:v}),{success:!0}}catch(_){console.error("Sign Up Error:",_);let k="Failed to create account";return _.code==="auth/email-already-in-use"?k="Email already in use":_.code==="auth/weak-password"?k="Password must be at least 6 characters":_.code==="auth/invalid-email"&&(k="Invalid email address"),{success:!1,error:k}}},h=async(O,y)=>{try{return await C_(Xr,O,y),{success:!0}}catch(v){console.error("Login Error:",v);let _="Failed to sign in";return v.code==="auth/user-not-found"?_="No account found with this email":v.code==="auth/wrong-password"?_="Incorrect password":v.code==="auth/invalid-email"?_="Invalid email address":v.code==="auth/invalid-credential"&&(_="Invalid email or password"),{success:!1,error:_}}},x=async()=>{try{await E_(Xr),localStorage.removeItem("valkry_user"),i(null)}catch(O){console.error("Logout Error:",O),localStorage.removeItem("valkry_user"),i(null)}};return f.jsx(Xv.Provider,{value:{user:e,loading:r,loginGoogle:p,loginWithEmail:h,signUpWithEmail:m,logout:x},children:!r&&n})},ga=()=>S.useContext(Xv);const xA=n=>n.replace(/([a-z0-9])([A-Z])/g,"$1-$2").toLowerCase(),gA=n=>n.replace(/^([A-Z])|[\s-_]+(\w)/g,(e,i,r)=>r?r.toUpperCase():i.toLowerCase()),$y=n=>{const e=gA(n);return e.charAt(0).toUpperCase()+e.slice(1)},Qv=(...n)=>n.filter((e,i,r)=>!!e&&e.trim()!==""&&r.indexOf(e)===i).join(" ").trim(),yA=n=>{for(const e in n)if(e.startsWith("aria-")||e==="role"||e==="title")return!0};var OA={xmlns:"http://www.w3.org/2000/svg",width:24,height:24,viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:2,strokeLinecap:"round",strokeLinejoin:"round"};const vA=S.forwardRef(({color:n="currentColor",size:e=24,strokeWidth:i=2,absoluteStrokeWidth:r,className:o="",children:l,iconNode:p,...m},h)=>S.createElement("svg",{ref:h,...OA,width:e,height:e,stroke:n,strokeWidth:r?Number(i)*24/Number(e):i,className:Qv("lucide",o),...!l&&!yA(m)&&{"aria-hidden":"true"},...m},[...p.map(([x,O])=>S.createElement(x,O)),...Array.isArray(l)?l:[l]]));const pe=(n,e)=>{const i=S.forwardRef(({className:r,...o},l)=>S.createElement(vA,{ref:l,iconNode:e,className:Qv(`lucide-${xA($y(n))}`,`lucide-${n}`,r),...o}));return i.displayName=$y(n),i};const bA=[["path",{d:"m12 19-7-7 7-7",key:"1l729n"}],["path",{d:"M19 12H5",key:"x3x0zl"}]],SA=pe("arrow-left",bA);const wA=[["path",{d:"M5 12h14",key:"1ays0h"}],["path",{d:"m12 5 7 7-7 7",key:"xquz4c"}]],gc=pe("arrow-right",wA);const CA=[["circle",{cx:"12",cy:"12",r:"4",key:"4exip2"}],["path",{d:"M16 8v5a3 3 0 0 0 6 0v-1a10 10 0 1 0-4 8",key:"7n84p3"}]],_A=pe("at-sign",CA);const TA=[["path",{d:"m15.477 12.89 1.515 8.526a.5.5 0 0 1-.81.47l-3.58-2.687a1 1 0 0 0-1.197 0l-3.586 2.686a.5.5 0 0 1-.81-.469l1.514-8.526",key:"1yiouv"}],["circle",{cx:"12",cy:"8",r:"6",key:"1vp47v"}]],Jv=pe("award",TA);const NA=[["path",{d:"M10.268 21a2 2 0 0 0 3.464 0",key:"vwvbt9"}],["path",{d:"M3.262 15.326A1 1 0 0 0 4 17h16a1 1 0 0 0 .74-1.673C19.41 13.956 18 12.499 18 8A6 6 0 0 0 6 8c0 4.499-1.411 5.956-2.738 7.326",key:"11g9vi"}]],Zy=pe("bell",NA);const kA=[["path",{d:"M13.997 4a2 2 0 0 1 1.76 1.05l.486.9A2 2 0 0 0 18.003 7H20a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V9a2 2 0 0 1 2-2h1.997a2 2 0 0 0 1.759-1.048l.489-.904A2 2 0 0 1 10.004 4z",key:"18u6gg"}],["circle",{cx:"12",cy:"13",r:"3",key:"1vg3eu"}]],EA=pe("camera",kA);const AA=[["path",{d:"M20 6 9 17l-5-5",key:"1gmf2c"}]],jA=pe("check",AA);const MA=[["path",{d:"m6 9 6 6 6-6",key:"qrunsl"}]],RA=pe("chevron-down",MA);const DA=[["path",{d:"m15 18-6-6 6-6",key:"1wnfg3"}]],IA=pe("chevron-left",DA);const LA=[["path",{d:"m9 18 6-6-6-6",key:"mthhwq"}]],e2=pe("chevron-right",LA);const PA=[["path",{d:"m11 17-5-5 5-5",key:"13zhaf"}],["path",{d:"m18 17-5-5 5-5",key:"h8a8et"}]],BA=pe("chevrons-left",PA);const UA=[["path",{d:"m6 17 5-5-5-5",key:"xnjwq"}],["path",{d:"m13 17 5-5-5-5",key:"17xmmf"}]],zA=pe("chevrons-right",UA);const FA=[["circle",{cx:"12",cy:"12",r:"10",key:"1mglay"}],["line",{x1:"12",x2:"12",y1:"8",y2:"12",key:"1pkeuh"}],["line",{x1:"12",x2:"12.01",y1:"16",y2:"16",key:"4dfq90"}]],qA=pe("circle-alert",FA);const HA=[["path",{d:"M21.801 10A10 10 0 1 1 17 3.335",key:"yps3ct"}],["path",{d:"m9 11 3 3L22 4",key:"1pflzl"}]],yc=pe("circle-check-big",HA);const YA=[["circle",{cx:"12",cy:"12",r:"10",key:"1mglay"}],["path",{d:"m15 9-6 6",key:"1uzhvr"}],["path",{d:"m9 9 6 6",key:"z0biqf"}]],GA=pe("circle-x",YA);const VA=[["path",{d:"m16 18 6-6-6-6",key:"eg8j8"}],["path",{d:"m8 6-6 6 6 6",key:"ppft3o"}]],WA=pe("code",VA);const KA=[["rect",{width:"14",height:"14",x:"8",y:"8",rx:"2",ry:"2",key:"17jyea"}],["path",{d:"M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2",key:"zix9uf"}]],$v=pe("copy",KA);const XA=[["path",{d:"M11.562 3.266a.5.5 0 0 1 .876 0L15.39 8.87a1 1 0 0 0 1.516.294L21.183 5.5a.5.5 0 0 1 .798.519l-2.834 10.246a1 1 0 0 1-.956.734H5.81a1 1 0 0 1-.957-.734L2.02 6.02a.5.5 0 0 1 .798-.519l4.276 3.664a1 1 0 0 0 1.516-.294z",key:"1vdc57"}],["path",{d:"M5 21h14",key:"11awu3"}]],QA=pe("crown",XA);const JA=[["path",{d:"M10.733 5.076a10.744 10.744 0 0 1 11.205 6.575 1 1 0 0 1 0 .696 10.747 10.747 0 0 1-1.444 2.49",key:"ct8e1f"}],["path",{d:"M14.084 14.158a3 3 0 0 1-4.242-4.242",key:"151rxh"}],["path",{d:"M17.479 17.499a10.75 10.75 0 0 1-15.417-5.151 1 1 0 0 1 0-.696 10.75 10.75 0 0 1 4.446-5.143",key:"13bj9a"}],["path",{d:"m2 2 20 20",key:"1ooewy"}]],$A=pe("eye-off",JA);const ZA=[["path",{d:"M2.062 12.348a1 1 0 0 1 0-.696 10.75 10.75 0 0 1 19.876 0 1 1 0 0 1 0 .696 10.75 10.75 0 0 1-19.876 0",key:"1nclc0"}],["circle",{cx:"12",cy:"12",r:"3",key:"1v7zrd"}]],Zv=pe("eye",ZA);const ej=[["path",{d:"M4 22V4a1 1 0 0 1 .4-.8A6 6 0 0 1 8 2c3 0 5 2 7.333 2q2 0 3.067-.8A1 1 0 0 1 20 4v10a1 1 0 0 1-.4.8A6 6 0 0 1 16 16c-3 0-5-2-8-2a6 6 0 0 0-4 1.528",key:"1jaruq"}]],tj=pe("flag",ej);const nj=[["path",{d:"M12 3q1 4 4 6.5t3 5.5a1 1 0 0 1-14 0 5 5 0 0 1 1-3 1 1 0 0 0 5 0c0-2-1.5-3-1.5-5q0-2 2.5-4",key:"1slcih"}]],eb=pe("flame",nj);const ij=[["path",{d:"M15 22v-4a4.8 4.8 0 0 0-1-3.5c3 0 6-2 6-5.5.08-1.25-.27-2.48-1-3.5.28-1.15.28-2.35 0-3.5 0 0-1 0-3 1.5-2.64-.5-5.36-.5-8 0C6 2 5 2 5 2c-.3 1.15-.3 2.35 0 3.5A5.403 5.403 0 0 0 4 9c0 3.5 3 5.5 6 5.5-.39.49-.68 1.05-.85 1.65-.17.6-.22 1.23-.15 1.85v4",key:"tonef"}],["path",{d:"M9 18c-4.51 2-5-2-7-2",key:"9comsn"}]],aj=pe("github",ij);const rj=[["circle",{cx:"12",cy:"12",r:"10",key:"1mglay"}],["path",{d:"M12 16v-4",key:"1dtifu"}],["path",{d:"M12 8h.01",key:"e9boi3"}]],sj=pe("info",rj);const oj=[["path",{d:"M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z",key:"c2jq9f"}],["rect",{width:"4",height:"12",x:"2",y:"9",key:"mk3on5"}],["circle",{cx:"4",cy:"4",r:"2",key:"bt5ra8"}]],uj=pe("linkedin",oj);const lj=[["rect",{width:"18",height:"11",x:"3",y:"11",rx:"2",ry:"2",key:"1w4ew1"}],["path",{d:"M7 11V7a5 5 0 0 1 10 0v4",key:"fwvmzm"}]],cj=pe("lock",lj);const pj=[["path",{d:"m10 17 5-5-5-5",key:"1bsop3"}],["path",{d:"M15 12H3",key:"6jk70r"}],["path",{d:"M15 3h4a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-4",key:"u53s6r"}]],dj=pe("log-in",pj);const mj=[["path",{d:"m16 17 5-5-5-5",key:"1bji2h"}],["path",{d:"M21 12H9",key:"dn1m92"}],["path",{d:"M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4",key:"1uf3rs"}]],fj=pe("log-out",mj);const hj=[["path",{d:"m22 7-8.991 5.727a2 2 0 0 1-2.009 0L2 7",key:"132q7q"}],["rect",{x:"2",y:"4",width:"20",height:"16",rx:"2",key:"izxlao"}]],tb=pe("mail",hj);const xj=[["path",{d:"M4 5h16",key:"1tepv9"}],["path",{d:"M4 12h16",key:"1lakjw"}],["path",{d:"M4 19h16",key:"1djgab"}]],gj=pe("menu",xj);const yj=[["path",{d:"M5 5a2 2 0 0 1 3.008-1.728l11.997 6.998a2 2 0 0 1 .003 3.458l-12 7A2 2 0 0 1 5 19z",key:"10ikf1"}]],nb=pe("play",yj);const Oj=[["path",{d:"M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8",key:"1357e3"}],["path",{d:"M3 3v5h5",key:"1xhq8a"}]],vj=pe("rotate-ccw",Oj);const bj=[["path",{d:"M15.2 3a2 2 0 0 1 1.4.6l3.8 3.8a2 2 0 0 1 .6 1.4V19a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2z",key:"1c8476"}],["path",{d:"M17 21v-7a1 1 0 0 0-1-1H8a1 1 0 0 0-1 1v7",key:"1ydtos"}],["path",{d:"M7 3v4a1 1 0 0 0 1 1h7",key:"t51u73"}]],Sj=pe("save",bj);const wj=[["path",{d:"m21 21-4.34-4.34",key:"14j7rj"}],["circle",{cx:"11",cy:"11",r:"8",key:"4ej97u"}]],yh=pe("search",wj);const Cj=[["polyline",{points:"14.5 17.5 3 6 3 3 6 3 17.5 14.5",key:"1hfsw2"}],["line",{x1:"13",x2:"19",y1:"19",y2:"13",key:"1vrmhu"}],["line",{x1:"16",x2:"20",y1:"16",y2:"20",key:"1bron3"}],["line",{x1:"19",x2:"21",y1:"21",y2:"19",key:"13pww6"}],["polyline",{points:"14.5 6.5 18 3 21 3 21 6 17.5 9.5",key:"hbey2j"}],["line",{x1:"5",x2:"9",y1:"14",y2:"18",key:"1hf58s"}],["line",{x1:"7",x2:"4",y1:"17",y2:"20",key:"pidxm4"}],["line",{x1:"3",x2:"5",y1:"19",y2:"21",key:"1pehsh"}]],Oc=pe("swords",Cj);const _j=[["circle",{cx:"12",cy:"12",r:"10",key:"1mglay"}],["circle",{cx:"12",cy:"12",r:"6",key:"1vlfrh"}],["circle",{cx:"12",cy:"12",r:"2",key:"1c9p78"}]],ib=pe("target",_j);const Tj=[["path",{d:"M10 11v6",key:"nco0om"}],["path",{d:"M14 11v6",key:"outv1u"}],["path",{d:"M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6",key:"miytrc"}],["path",{d:"M3 6h18",key:"d0wm0j"}],["path",{d:"M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2",key:"e791ji"}]],Nj=pe("trash-2",Tj);const kj=[["path",{d:"M16 7h6v6",key:"box55l"}],["path",{d:"m22 7-8.5 8.5-5-5L2 17",key:"1t1m79"}]],ab=pe("trending-up",kj);const Ej=[["path",{d:"m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3",key:"wmoenq"}],["path",{d:"M12 9v4",key:"juzpu7"}],["path",{d:"M12 17h.01",key:"p32p05"}]],Aj=pe("triangle-alert",Ej);const jj=[["path",{d:"M10 14.66v1.626a2 2 0 0 1-.976 1.696A5 5 0 0 0 7 21.978",key:"1n3hpd"}],["path",{d:"M14 14.66v1.626a2 2 0 0 0 .976 1.696A5 5 0 0 1 17 21.978",key:"rfe1zi"}],["path",{d:"M18 9h1.5a1 1 0 0 0 0-5H18",key:"7xy6bh"}],["path",{d:"M4 22h16",key:"57wxv0"}],["path",{d:"M6 9a6 6 0 0 0 12 0V3a1 1 0 0 0-1-1H7a1 1 0 0 0-1 1z",key:"1mhfuq"}],["path",{d:"M6 9H4.5a1 1 0 0 1 0-5H6",key:"tex48p"}]],of=pe("trophy",jj);const Mj=[["path",{d:"M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2",key:"1yyitq"}],["circle",{cx:"9",cy:"7",r:"4",key:"nufk8"}],["line",{x1:"19",x2:"19",y1:"8",y2:"14",key:"1bvyxn"}],["line",{x1:"22",x2:"16",y1:"11",y2:"11",key:"1shjgl"}]],vc=pe("user-plus",Mj);const Rj=[["path",{d:"M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2",key:"975kel"}],["circle",{cx:"12",cy:"7",r:"4",key:"17ys0d"}]],rb=pe("user",Rj);const Dj=[["path",{d:"M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2",key:"1yyitq"}],["path",{d:"M16 3.128a4 4 0 0 1 0 7.744",key:"16gr8j"}],["path",{d:"M22 21v-2a4 4 0 0 0-3-3.87",key:"kshegd"}],["circle",{cx:"9",cy:"7",r:"4",key:"nufk8"}]],Io=pe("users",Dj);const Ij=[["path",{d:"M18 6 6 18",key:"1bl5f8"}],["path",{d:"m6 6 12 12",key:"d8bk6v"}]],bc=pe("x",Ij);const Lj=[["path",{d:"M2.5 17a24.12 24.12 0 0 1 0-10 2 2 0 0 1 1.4-1.4 49.56 49.56 0 0 1 16.2 0A2 2 0 0 1 21.5 7a24.12 24.12 0 0 1 0 10 2 2 0 0 1-1.4 1.4 49.55 49.55 0 0 1-16.2 0A2 2 0 0 1 2.5 17",key:"1q2vi4"}],["path",{d:"m10 15 5-3-5-3z",key:"1jp15x"}]],Pj=pe("youtube",Lj);const Bj=[["path",{d:"M4 14a1 1 0 0 1-.78-1.63l9.9-10.2a.5.5 0 0 1 .86.46l-1.92 6.02A1 1 0 0 0 13 10h7a1 1 0 0 1 .78 1.63l-9.9 10.2a.5.5 0 0 1-.86-.46l1.92-6.02A1 1 0 0 0 11 14z",key:"1xq2db"}]],Uj=pe("zap",Bj),sb=({size:n="default"})=>{const e={small:16,default:20,large:28,hero:44},i=e[n]||e.default;return f.jsx(ht,{to:"/",style:{textDecoration:"none",display:"inline-block"},children:f.jsx("span",{style:{fontSize:i,fontWeight:500,letterSpacing:"-0.02em",color:"#FAFAFA",fontFamily:'-apple-system, BlinkMacSystemFont, "SF Pro Display", "Segoe UI", Roboto, sans-serif'},children:"Valkry"})})},zj=()=>{const{user:n,logout:e}=ga(),i=Hn(),[r,o]=S.useState(!1),l=[{to:"/",label:"Home"},{to:"/arena",label:"Arena"},{to:"/learn",label:"Learn"},{to:"/friends",label:"Friends"},{to:"/leaderboard",label:"Leaderboard"},{to:"/about",label:"About"}],p=m=>i.pathname===m;return f.jsxs("nav",{className:"navbar",children:[f.jsx(sb,{}),f.jsxs("div",{className:"nav-links",style:{display:"flex",alignItems:"center",gap:"28px"},children:[l.map(m=>f.jsx(ht,{to:m.to,className:`nav-link ${p(m.to)?"active":""}`,children:m.label},m.to)),n&&f.jsx(ht,{to:"/dashboard",className:`nav-link ${p("/dashboard")?"active":""}`,children:"Dashboard"})]}),f.jsxs("div",{style:{display:"flex",alignItems:"center",gap:"16px"},children:[n?f.jsxs(f.Fragment,{children:[f.jsx(ht,{to:"/profile",style:{textDecoration:"none"},children:f.jsxs("div",{style:{display:"flex",alignItems:"center",gap:"8px",padding:"6px 12px",background:"var(--bg-elevated)",borderRadius:"980px",border:"1px solid var(--border)",cursor:"pointer",transition:"border-color 0.2s"},children:[n.avatar?f.jsx("img",{src:n.avatar,alt:n.name,style:{width:"24px",height:"24px",borderRadius:"50%",objectFit:"cover"}}):f.jsx("div",{className:"avatar",style:{width:"24px",height:"24px",fontSize:"11px"},children:n.name?.charAt(0).toUpperCase()||"U"}),f.jsx("span",{style:{fontSize:"13px",color:"var(--text-secondary)"},children:n.name?.split(" ")[0]||"User"})]})}),f.jsx("button",{onClick:e,className:"btn btn-ghost",style:{padding:"8px"},title:"Sign out",children:f.jsx(fj,{size:16})})]}):f.jsx(ht,{to:"/signin",children:f.jsx("button",{className:"btn btn-primary",style:{padding:"8px 18px",fontSize:"13px"},children:"Sign In"})}),f.jsx("button",{onClick:()=>o(!r),className:"btn btn-ghost",style:{display:"none",padding:"8px"},children:r?f.jsx(bc,{size:20}):f.jsx(gj,{size:20})})]}),r&&f.jsxs("div",{style:{position:"absolute",top:"52px",left:0,right:0,background:"rgba(0, 0, 0, 0.95)",backdropFilter:"saturate(180%) blur(20px)",borderBottom:"1px solid var(--border)",padding:"16px 22px"},children:[l.map(m=>f.jsx(ht,{to:m.to,onClick:()=>o(!1),style:{display:"block",padding:"12px 0",fontSize:"15px",color:p(m.to)?"var(--text)":"var(--text-secondary)",borderBottom:"1px solid var(--border)"},children:m.label},m.to)),n&&f.jsx(ht,{to:"/dashboard",onClick:()=>o(!1),style:{display:"block",padding:"12px 0",fontSize:"15px",color:p("/dashboard")?"var(--text)":"var(--text-secondary)"},children:"Dashboard"})]})]})},Fj=JSON.parse(`[{"id":"easy1","title":"Add Two Numbers","description":"Return sum of two integers.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nint add(int a, int b) { return 0; }\\nint main() { cout << add(5, 3); return 0; }","expectedOutput":"8","testCases":[{"input":"5 3","expectedOutput":"8","explanation":"Basic addition: 5 + 3 = 8"},{"input":"0 0","expectedOutput":"0","explanation":"Edge case: both zeros"},{"input":"-5 5","expectedOutput":"0","explanation":"Edge case: negative + positive equals zero"},{"input":"-3 -7","expectedOutput":"-10","explanation":"Edge case: adding two negatives"},{"input":"1000000 1000000","expectedOutput":"2000000","explanation":"Large numbers addition"},{"input":"1 0","expectedOutput":"1","explanation":"Adding zero returns same number"},{"input":"2147483640 7","expectedOutput":"2147483647","explanation":"Near INT_MAX boundary"},{"input":"100 -100","expectedOutput":"0","explanation":"Opposite numbers cancel out"},{"input":"42 58","expectedOutput":"100","explanation":"Sum to round number"},{"input":"-1 1","expectedOutput":"0","explanation":"Small opposite numbers"}],"solution":"#include <iostream>\\nusing namespace std;\\nint add(int a, int b) { return a + b; }\\nint main() { cout << add(5, 3); return 0; }","explanation":{"approach":"Simply use the + operator to add two numbers.","analogy":"Like counting on fingers - combine both hands.","steps":["Return a + b"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"easy2","title":"Multiply Two Numbers","description":"Return product of two integers.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nint multiply(int a, int b) { return 0; }\\nint main() { cout << multiply(4, 7); return 0; }","expectedOutput":"28","testCases":[{"input":"4 7","expectedOutput":"28","explanation":"Basic multiplication: 4  7 = 28"},{"input":"0 5","expectedOutput":"0","explanation":"Edge case: multiply by zero"},{"input":"1 999","expectedOutput":"999","explanation":"Edge case: multiply by one"},{"input":"-3 4","expectedOutput":"-12","explanation":"Negative times positive"},{"input":"-5 -6","expectedOutput":"30","explanation":"Two negatives make positive"},{"input":"100 100","expectedOutput":"10000","explanation":"Square of 100"},{"input":"2 2147483647","expectedOutput":"4294967294","explanation":"Large number multiplication"},{"input":"11 11","expectedOutput":"121","explanation":"Square of 11"},{"input":"0 0","expectedOutput":"0","explanation":"Both zeros"},{"input":"25 4","expectedOutput":"100","explanation":"Product is round number"}],"solution":"#include <iostream>\\nusing namespace std;\\nint multiply(int a, int b) { return a * b; }\\nint main() { cout << multiply(4, 7); return 0; }","explanation":{"approach":"Use multiplication operator.","analogy":"4 groups of 7 items.","steps":["Return a * b"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"easy3","title":"Find Maximum of Two","description":"Return larger of two numbers.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nint maxOfTwo(int a, int b) { return 0; }\\nint main() { cout << maxOfTwo(10, 25); return 0; }","expectedOutput":"25","testCases":[{"input":"10 25","expectedOutput":"25","explanation":"Basic: 25 > 10"},{"input":"25 10","expectedOutput":"25","explanation":"Reversed order, same result"},{"input":"5 5","expectedOutput":"5","explanation":"Edge case: equal numbers"},{"input":"-10 -5","expectedOutput":"-5","explanation":"Negatives: -5 > -10"},{"input":"-100 0","expectedOutput":"0","explanation":"Zero vs negative"},{"input":"0 0","expectedOutput":"0","explanation":"Both zeros"},{"input":"2147483647 0","expectedOutput":"2147483647","explanation":"INT_MAX comparison"},{"input":"-2147483648 0","expectedOutput":"0","explanation":"INT_MIN comparison"},{"input":"1 2","expectedOutput":"2","explanation":"Consecutive numbers"},{"input":"999999 1000000","expectedOutput":"1000000","explanation":"Large close numbers"}],"solution":"#include <iostream>\\nusing namespace std;\\nint maxOfTwo(int a, int b) { return a > b ? a : b; }\\nint main() { cout << maxOfTwo(10, 25); return 0; }","explanation":{"approach":"Compare and return larger.","analogy":"Which is taller?","steps":["If a > b return a, else return b"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"easy4","title":"Absolute Value","description":"Return absolute value.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nint absolute(int n) { return 0; }\\nint main() { cout << absolute(-15); return 0; }","expectedOutput":"15","testCases":[{"input":"-15","expectedOutput":"15","explanation":"Basic: |-15| = 15"},{"input":"15","expectedOutput":"15","explanation":"Already positive stays same"},{"input":"0","expectedOutput":"0","explanation":"Edge case: |0| = 0"},{"input":"-1","expectedOutput":"1","explanation":"Smallest negative"},{"input":"1","expectedOutput":"1","explanation":"Smallest positive"},{"input":"-1000000","expectedOutput":"1000000","explanation":"Large negative"},{"input":"2147483647","expectedOutput":"2147483647","explanation":"INT_MAX stays same"},{"input":"-999","expectedOutput":"999","explanation":"Three digit negative"},{"input":"-42","expectedOutput":"42","explanation":"Random negative"},{"input":"100","expectedOutput":"100","explanation":"Round positive number"}],"solution":"#include <iostream>\\nusing namespace std;\\nint absolute(int n) { return n < 0 ? -n : n; }\\nint main() { cout << absolute(-15); return 0; }","explanation":{"approach":"If negative, negate it.","analogy":"Distance from zero is always positive.","steps":["If n < 0, return -n","Else return n"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"easy5","title":"Check Even or Odd","description":"Print 'Even' or 'Odd'.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid check(int n) {}\\nint main() { check(7); return 0; }","expectedOutput":"Odd","testCases":[{"input":"7","expectedOutput":"Odd","explanation":"7 is not divisible by 2"},{"input":"4","expectedOutput":"Even","explanation":"4  2 = 2, no remainder"},{"input":"0","expectedOutput":"Even","explanation":"Edge case: 0 is even"},{"input":"-2","expectedOutput":"Even","explanation":"Negative even number"},{"input":"-7","expectedOutput":"Odd","explanation":"Negative odd number"},{"input":"1","expectedOutput":"Odd","explanation":"Smallest positive odd"},{"input":"2","expectedOutput":"Even","explanation":"Smallest positive even"},{"input":"1000000","expectedOutput":"Even","explanation":"Large even number"},{"input":"999999","expectedOutput":"Odd","explanation":"Large odd number"},{"input":"2147483646","expectedOutput":"Even","explanation":"Near INT_MAX even"}],"solution":"#include <iostream>\\nusing namespace std;\\nvoid check(int n) { cout << (n % 2 == 0 ? \\"Even\\" : \\"Odd\\"); }\\nint main() { check(7); return 0; }","explanation":{"approach":"If divisible by 2, it's even.","analogy":"Can you split evenly into two groups?","steps":["Check n % 2","If 0, even; else odd"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"easy6","title":"Print Hello World","description":"Print Hello World.","difficulty":"EASY","category":"Basics","starterCode":"#include <iostream>\\nusing namespace std;\\nint main() { return 0; }","expectedOutput":"Hello World","testCases":[{"input":"","expectedOutput":"Hello World","explanation":"Standard output test"},{"input":"","expectedOutput":"Hello World","explanation":"No input required"},{"input":"","expectedOutput":"Hello World","explanation":"Exact string match"},{"input":"","expectedOutput":"Hello World","explanation":"Case sensitive check"},{"input":"","expectedOutput":"Hello World","explanation":"Space between words"},{"input":"","expectedOutput":"Hello World","explanation":"No trailing newline"},{"input":"","expectedOutput":"Hello World","explanation":"No leading spaces"},{"input":"","expectedOutput":"Hello World","explanation":"Consistent output"},{"input":"","expectedOutput":"Hello World","explanation":"First program tradition"},{"input":"","expectedOutput":"Hello World","explanation":"Basic cout usage"}],"solution":"#include <iostream>\\nusing namespace std;\\nint main() { cout << \\"Hello World\\"; return 0; }","explanation":{"approach":"Use cout to print.","analogy":"Your first program!","steps":["Use cout << \\"Hello World\\""],"complexity":"Time: O(1), Space: O(1)"}},{"id":"easy7","title":"Sum of Array","description":"Find sum of array elements.","difficulty":"EASY","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nint sum(int arr[], int n) { return 0; }\\nint main() { int a[] = {1,2,3,4,5}; cout << sum(a, 5); return 0; }","expectedOutput":"15","testCases":[{"input":"5\\n1 2 3 4 5","expectedOutput":"15","explanation":"Basic: 1+2+3+4+5 = 15"},{"input":"1\\n10","expectedOutput":"10","explanation":"Single element array"},{"input":"3\\n0 0 0","expectedOutput":"0","explanation":"All zeros"},{"input":"4\\n-1 -2 -3 -4","expectedOutput":"-10","explanation":"All negative numbers"},{"input":"3\\n-5 0 5","expectedOutput":"0","explanation":"Mixed: sum is zero"},{"input":"2\\n1000000 1000000","expectedOutput":"2000000","explanation":"Large numbers"},{"input":"6\\n1 1 1 1 1 1","expectedOutput":"6","explanation":"All same values"},{"input":"5\\n10 20 30 40 50","expectedOutput":"150","explanation":"Multiples of 10"},{"input":"3\\n100 -50 -50","expectedOutput":"0","explanation":"Positive equals negatives"},{"input":"4\\n7 3 5 9","expectedOutput":"24","explanation":"Random values"}],"solution":"#include <iostream>\\nusing namespace std;\\nint sum(int arr[], int n) { int s = 0; for(int i = 0; i < n; i++) s += arr[i]; return s; }\\nint main() { int a[] = {1,2,3,4,5}; cout << sum(a, 5); return 0; }","explanation":{"approach":"Loop through and add each element.","analogy":"Count all coins.","steps":["Init sum = 0","Add each element"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"easy8","title":"Find Array Maximum","description":"Find largest element.","difficulty":"EASY","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nint findMax(int arr[], int n) { return 0; }\\nint main() { int a[] = {3,1,4,1,5,9}; cout << findMax(a, 6); return 0; }","expectedOutput":"9","testCases":[{"input":"6\\n3 1 4 1 5 9","expectedOutput":"9","explanation":"Basic: 9 is largest"},{"input":"1\\n42","expectedOutput":"42","explanation":"Single element is max"},{"input":"5\\n5 5 5 5 5","expectedOutput":"5","explanation":"All same values"},{"input":"4\\n-1 -5 -2 -10","expectedOutput":"-1","explanation":"All negatives: -1 is largest"},{"input":"3\\n0 0 0","expectedOutput":"0","explanation":"All zeros"},{"input":"5\\n1 2 3 4 5","expectedOutput":"5","explanation":"Max at end"},{"input":"5\\n5 4 3 2 1","expectedOutput":"5","explanation":"Max at beginning"},{"input":"5\\n1 2 100 3 4","expectedOutput":"100","explanation":"Max in middle"},{"input":"3\\n-100 0 100","expectedOutput":"100","explanation":"Wide range"},{"input":"2\\n2147483647 0","expectedOutput":"2147483647","explanation":"INT_MAX test"}],"solution":"#include <iostream>\\nusing namespace std;\\nint findMax(int arr[], int n) { int m = arr[0]; for(int i = 1; i < n; i++) if(arr[i] > m) m = arr[i]; return m; }\\nint main() { int a[] = {3,1,4,1,5,9}; cout << findMax(a, 6); return 0; }","explanation":{"approach":"Track maximum while looping.","analogy":"King of the hill contest.","steps":["Assume first is max","Compare with each element"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"easy9","title":"Find Array Minimum","description":"Find smallest element.","difficulty":"EASY","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nint findMin(int arr[], int n) { return 0; }\\nint main() { int a[] = {3,1,4,1,5,9}; cout << findMin(a, 6); return 0; }","expectedOutput":"1","testCases":[{"input":"6\\n3 1 4 1 5 9","expectedOutput":"1","explanation":"Basic: 1 is smallest"},{"input":"1\\n42","expectedOutput":"42","explanation":"Single element is min"},{"input":"5\\n5 5 5 5 5","expectedOutput":"5","explanation":"All same values"},{"input":"4\\n-1 -5 -2 -10","expectedOutput":"-10","explanation":"All negatives: -10 is smallest"},{"input":"3\\n0 0 0","expectedOutput":"0","explanation":"All zeros"},{"input":"5\\n5 4 3 2 1","expectedOutput":"1","explanation":"Min at end"},{"input":"5\\n1 2 3 4 5","expectedOutput":"1","explanation":"Min at beginning"},{"input":"5\\n5 4 1 2 3","expectedOutput":"1","explanation":"Min in middle"},{"input":"3\\n-100 0 100","expectedOutput":"-100","explanation":"Wide range"},{"input":"2\\n-2147483648 0","expectedOutput":"-2147483648","explanation":"INT_MIN test"}],"solution":"#include <iostream>\\nusing namespace std;\\nint findMin(int arr[], int n) { int m = arr[0]; for(int i = 1; i < n; i++) if(arr[i] < m) m = arr[i]; return m; }\\nint main() { int a[] = {3,1,4,1,5,9}; cout << findMin(a, 6); return 0; }","explanation":{"approach":"Track minimum while looping.","analogy":"Find shortest person.","steps":["Assume first is min","Compare with each"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"easy10","title":"Reverse Array","description":"Reverse array in-place.","difficulty":"EASY","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid reverse(int arr[], int n) {}\\nint main() { int a[] = {1,2,3,4,5}; reverse(a,5); for(int i=0;i<5;i++) cout<<a[i]<<(i<4?\\" \\":\\"\\"); return 0; }","expectedOutput":"5 4 3 2 1","testCases":[{"input":"5\\n1 2 3 4 5","expectedOutput":"5 4 3 2 1","explanation":"Basic reversal"},{"input":"1\\n7","expectedOutput":"7","explanation":"Single element unchanged"},{"input":"2\\n1 2","expectedOutput":"2 1","explanation":"Two elements swap"},{"input":"4\\n1 2 3 4","expectedOutput":"4 3 2 1","explanation":"Even length array"},{"input":"3\\n5 5 5","expectedOutput":"5 5 5","explanation":"All same stays same"},{"input":"5\\n-1 -2 -3 -4 -5","expectedOutput":"-5 -4 -3 -2 -1","explanation":"Negative numbers"},{"input":"6\\n1 0 0 0 0 2","expectedOutput":"2 0 0 0 0 1","explanation":"Zeros in middle"},{"input":"3\\n100 200 300","expectedOutput":"300 200 100","explanation":"Larger numbers"},{"input":"4\\n-5 0 5 10","expectedOutput":"10 5 0 -5","explanation":"Mixed values"},{"input":"5\\n9 8 7 6 5","expectedOutput":"5 6 7 8 9","explanation":"Descending to ascending"}],"solution":"#include <iostream>\\nusing namespace std;\\nvoid reverse(int arr[], int n) { int l=0, r=n-1; while(l<r) { int t=arr[l]; arr[l]=arr[r]; arr[r]=t; l++; r--; } }\\nint main() { int a[] = {1,2,3,4,5}; reverse(a,5); for(int i=0;i<5;i++) cout<<a[i]<<(i<4?\\" \\":\\"\\"); return 0; }","explanation":{"approach":"Two pointers swap from ends.","analogy":"Swap first-last, second-second-last, etc.","steps":["Put pointers at both ends","Swap and move inward"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"easy11","title":"Count Occurrences","description":"Count how many times x appears.","difficulty":"EASY","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nint count(int arr[], int n, int x) { return 0; }\\nint main() { int a[] = {1,2,2,3,2,4}; cout << count(a, 6, 2); return 0; }","expectedOutput":"3","testCases":[{"input":"6 2\\n1 2 2 3 2 4","expectedOutput":"3","explanation":"2 appears 3 times"},{"input":"5 5\\n1 2 3 4 6","expectedOutput":"0","explanation":"Element not found"},{"input":"4 7\\n7 7 7 7","expectedOutput":"4","explanation":"All elements match"},{"input":"1 3\\n3","expectedOutput":"1","explanation":"Single element matches"},{"input":"1 5\\n3","expectedOutput":"0","explanation":"Single element no match"},{"input":"5 0\\n0 0 0 0 0","expectedOutput":"5","explanation":"Count zeros"},{"input":"6 -1\\n-1 0 -1 1 -1 2","expectedOutput":"3","explanation":"Count negative number"},{"input":"5 1\\n1 2 1 2 1","expectedOutput":"3","explanation":"Alternating pattern"},{"input":"3 10\\n10 20 30","expectedOutput":"1","explanation":"First element only"},{"input":"3 30\\n10 20 30","expectedOutput":"1","explanation":"Last element only"}],"solution":"#include <iostream>\\nusing namespace std;\\nint count(int arr[], int n, int x) { int c = 0; for(int i = 0; i < n; i++) if(arr[i] == x) c++; return c; }\\nint main() { int a[] = {1,2,2,3,2,4}; cout << count(a, 6, 2); return 0; }","explanation":{"approach":"Loop and count matches.","analogy":"Count all red balls.","steps":["For each element, check if equals x","Increment counter"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"easy12","title":"Linear Search","description":"Find index of element.","difficulty":"EASY","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nint search(int arr[], int n, int x) { return -1; }\\nint main() { int a[] = {5,3,7,1,9}; cout << search(a, 5, 7); return 0; }","expectedOutput":"2","testCases":[{"input":"5 7\\n5 3 7 1 9","expectedOutput":"2","explanation":"7 found at index 2"},{"input":"5 5\\n5 3 7 1 9","expectedOutput":"0","explanation":"Found at first position"},{"input":"5 9\\n5 3 7 1 9","expectedOutput":"4","explanation":"Found at last position"},{"input":"5 10\\n5 3 7 1 9","expectedOutput":"-1","explanation":"Element not in array"},{"input":"1 5\\n5","expectedOutput":"0","explanation":"Single element found"},{"input":"1 3\\n5","expectedOutput":"-1","explanation":"Single element not found"},{"input":"5 3\\n3 3 3 3 3","expectedOutput":"0","explanation":"Returns first occurrence"},{"input":"4 0\\n-1 0 1 2","expectedOutput":"1","explanation":"Searching for zero"},{"input":"3 -5\\n-5 -10 -15","expectedOutput":"0","explanation":"Negative number search"},{"input":"6 6\\n1 2 3 4 5 6","expectedOutput":"5","explanation":"Last element search"}],"solution":"#include <iostream>\\nusing namespace std;\\nint search(int arr[], int n, int x) { for(int i = 0; i < n; i++) if(arr[i] == x) return i; return -1; }\\nint main() { int a[] = {5,3,7,1,9}; cout << search(a, 5, 7); return 0; }","explanation":{"approach":"Check each element one by one.","analogy":"Looking for your keys - check each pocket.","steps":["Loop through array","Return index when found","Return -1 if not found"],"complexity":"Time: O(n), Space: O(1)"}}]`),qj=JSON.parse(`[{"id":"easy13","title":"Binary Search","description":"Search in sorted array.","difficulty":"EASY","category":"Binary Search","starterCode":"#include <iostream>\\nusing namespace std;\\nint binarySearch(int arr[], int n, int x) { return -1; }\\nint main() { int a[] = {1,3,5,7,9}; cout << binarySearch(a, 5, 5); return 0; }","expectedOutput":"2","testCases":[{"input":"5 5\\n1 3 5 7 9","expectedOutput":"2","explanation":"5 found at index 2"},{"input":"5 1\\n1 3 5 7 9","expectedOutput":"0","explanation":"First element found"},{"input":"5 9\\n1 3 5 7 9","expectedOutput":"4","explanation":"Last element found"},{"input":"5 4\\n1 3 5 7 9","expectedOutput":"-1","explanation":"Element not in array"},{"input":"1 5\\n5","expectedOutput":"0","explanation":"Single element found"},{"input":"1 3\\n5","expectedOutput":"-1","explanation":"Single element not found"},{"input":"6 6\\n2 4 6 8 10 12","expectedOutput":"2","explanation":"Even numbers array"},{"input":"4 -5\\n-10 -5 0 5","expectedOutput":"1","explanation":"Negative number search"},{"input":"7 50\\n10 20 30 40 50 60 70","expectedOutput":"4","explanation":"Larger sorted array"},{"input":"3 100\\n1 50 100","expectedOutput":"2","explanation":"Wide gap elements"}],"solution":"#include <iostream>\\nusing namespace std;\\nint binarySearch(int arr[], int n, int x) { int l=0, r=n-1; while(l<=r) { int m=(l+r)/2; if(arr[m]==x) return m; if(arr[m]<x) l=m+1; else r=m-1; } return -1; }\\nint main() { int a[] = {1,3,5,7,9}; cout << binarySearch(a, 5, 5); return 0; }","explanation":{"approach":"Divide search space in half each time.","analogy":"Like dictionary lookup - open to middle, go left or right.","steps":["Check middle","If less, search right half","If more, search left half"],"complexity":"Time: O(log n), Space: O(1)"}},{"id":"easy14","title":"Bubble Sort","description":"Sort array ascending.","difficulty":"EASY","category":"Sorting","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid bubbleSort(int arr[], int n) {}\\nint main() { int a[] = {5,1,4,2,8}; bubbleSort(a,5); for(int i=0;i<5;i++) cout<<a[i]<<(i<4?\\" \\":\\"\\"); return 0; }","expectedOutput":"1 2 4 5 8","testCases":[{"input":"5\\n5 1 4 2 8","expectedOutput":"1 2 4 5 8","explanation":"Basic unsorted array"},{"input":"5\\n1 2 3 4 5","expectedOutput":"1 2 3 4 5","explanation":"Already sorted"},{"input":"5\\n5 4 3 2 1","expectedOutput":"1 2 3 4 5","explanation":"Reverse sorted"},{"input":"1\\n7","expectedOutput":"7","explanation":"Single element"},{"input":"2\\n2 1","expectedOutput":"1 2","explanation":"Two elements swap"},{"input":"4\\n3 3 3 3","expectedOutput":"3 3 3 3","explanation":"All same values"},{"input":"5\\n-3 -1 -5 -2 -4","expectedOutput":"-5 -4 -3 -2 -1","explanation":"Negative numbers"},{"input":"6\\n0 -1 1 -2 2 0","expectedOutput":"-2 -1 0 0 1 2","explanation":"Mixed with zeros"},{"input":"4\\n100 50 75 25","expectedOutput":"25 50 75 100","explanation":"Larger values"},{"input":"3\\n1 3 2","expectedOutput":"1 2 3","explanation":"Nearly sorted"}],"solution":"#include <iostream>\\nusing namespace std;\\nvoid bubbleSort(int arr[], int n) { for(int i=0;i<n-1;i++) for(int j=0;j<n-i-1;j++) if(arr[j]>arr[j+1]) { int t=arr[j]; arr[j]=arr[j+1]; arr[j+1]=t; } }\\nint main() { int a[] = {5,1,4,2,8}; bubbleSort(a,5); for(int i=0;i<5;i++) cout<<a[i]<<(i<4?\\" \\":\\"\\"); return 0; }","explanation":{"approach":"Bubble largest elements to end repeatedly.","analogy":"Bubbles rise to top - large elements float up.","steps":["Compare adjacent pairs","Swap if out of order","Repeat n times"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"easy15","title":"Selection Sort","description":"Sort by selecting minimum.","difficulty":"EASY","category":"Sorting","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid selectionSort(int arr[], int n) {}\\nint main() { int a[] = {64,25,12,22,11}; selectionSort(a,5); for(int i=0;i<5;i++) cout<<a[i]<<(i<4?\\" \\":\\"\\"); return 0; }","expectedOutput":"11 12 22 25 64","testCases":[{"input":"5\\n64 25 12 22 11","expectedOutput":"11 12 22 25 64","explanation":"Basic unsorted array"},{"input":"5\\n1 2 3 4 5","expectedOutput":"1 2 3 4 5","explanation":"Already sorted"},{"input":"5\\n5 4 3 2 1","expectedOutput":"1 2 3 4 5","explanation":"Reverse sorted"},{"input":"1\\n42","expectedOutput":"42","explanation":"Single element"},{"input":"2\\n9 1","expectedOutput":"1 9","explanation":"Two elements"},{"input":"4\\n7 7 7 7","expectedOutput":"7 7 7 7","explanation":"All duplicates"},{"input":"5\\n-5 -1 -3 -4 -2","expectedOutput":"-5 -4 -3 -2 -1","explanation":"Negative numbers"},{"input":"6\\n3 1 4 1 5 9","expectedOutput":"1 1 3 4 5 9","explanation":"With duplicates"},{"input":"4\\n1000 100 10 1","expectedOutput":"1 10 100 1000","explanation":"Powers of 10"},{"input":"3\\n0 -1 1","expectedOutput":"-1 0 1","explanation":"Around zero"}],"solution":"#include <iostream>\\nusing namespace std;\\nvoid selectionSort(int arr[], int n) { for(int i=0;i<n-1;i++) { int m=i; for(int j=i+1;j<n;j++) if(arr[j]<arr[m]) m=j; int t=arr[i]; arr[i]=arr[m]; arr[m]=t; } }\\nint main() { int a[] = {64,25,12,22,11}; selectionSort(a,5); for(int i=0;i<5;i++) cout<<a[i]<<(i<4?\\" \\":\\"\\"); return 0; }","explanation":{"approach":"Find minimum, put in position, repeat.","analogy":"Pick smallest card, then next smallest...","steps":["Find minimum in unsorted part","Swap to current position"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"easy16","title":"Insertion Sort","description":"Sort by inserting in place.","difficulty":"EASY","category":"Sorting","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid insertionSort(int arr[], int n) {}\\nint main() { int a[] = {12,11,13,5,6}; insertionSort(a,5); for(int i=0;i<5;i++) cout<<a[i]<<(i<4?\\" \\":\\"\\"); return 0; }","expectedOutput":"5 6 11 12 13","testCases":[{"input":"5\\n12 11 13 5 6","expectedOutput":"5 6 11 12 13","explanation":"Basic unsorted array"},{"input":"5\\n1 2 3 4 5","expectedOutput":"1 2 3 4 5","explanation":"Already sorted - best case"},{"input":"5\\n5 4 3 2 1","expectedOutput":"1 2 3 4 5","explanation":"Reverse sorted - worst case"},{"input":"1\\n99","expectedOutput":"99","explanation":"Single element"},{"input":"2\\n5 3","expectedOutput":"3 5","explanation":"Two elements"},{"input":"4\\n2 2 2 2","expectedOutput":"2 2 2 2","explanation":"All same"},{"input":"5\\n-2 -5 -1 -4 -3","expectedOutput":"-5 -4 -3 -2 -1","explanation":"Negatives"},{"input":"6\\n1 3 2 4 6 5","expectedOutput":"1 2 3 4 5 6","explanation":"Nearly sorted"},{"input":"4\\n10 5 15 0","expectedOutput":"0 5 10 15","explanation":"Multiples of 5"},{"input":"3\\n100 -100 0","expectedOutput":"-100 0 100","explanation":"Wide range"}],"solution":"#include <iostream>\\nusing namespace std;\\nvoid insertionSort(int arr[], int n) { for(int i=1;i<n;i++) { int k=arr[i], j=i-1; while(j>=0 && arr[j]>k) { arr[j+1]=arr[j]; j--; } arr[j+1]=k; } }\\nint main() { int a[] = {12,11,13,5,6}; insertionSort(a,5); for(int i=0;i<5;i++) cout<<a[i]<<(i<4?\\" \\":\\"\\"); return 0; }","explanation":{"approach":"Insert each element into sorted portion.","analogy":"Like sorting cards in hand one by one.","steps":["Take each element","Insert in correct position in sorted part"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"easy17","title":"String Length","description":"Find length of string.","difficulty":"EASY","category":"Strings","starterCode":"#include <iostream>\\nusing namespace std;\\nint strLen(char s[]) { return 0; }\\nint main() { cout << strLen(\\"hello\\"); return 0; }","expectedOutput":"5","testCases":[{"input":"hello","expectedOutput":"5","explanation":"5 characters"},{"input":"","expectedOutput":"0","explanation":"Empty string"},{"input":"a","expectedOutput":"1","explanation":"Single character"},{"input":"ab","expectedOutput":"2","explanation":"Two characters"},{"input":"hello world","expectedOutput":"11","explanation":"Includes space"},{"input":"   ","expectedOutput":"3","explanation":"Only spaces"},{"input":"12345","expectedOutput":"5","explanation":"Digit characters"},{"input":"Hello World!","expectedOutput":"12","explanation":"Mixed with punctuation"},{"input":"abcdefghij","expectedOutput":"10","explanation":"10 characters"},{"input":"test string here","expectedOutput":"16","explanation":"Multiple words"}],"solution":"#include <iostream>\\nusing namespace std;\\nint strLen(char s[]) { int l=0; while(s[l]) l++; return l; }\\nint main() { cout << strLen(\\"hello\\"); return 0; }","explanation":{"approach":"Count until null character.","analogy":"Count steps until you hit the wall.","steps":["Loop until \\\\0","Count characters"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"easy18","title":"String Copy","description":"Copy string to another.","difficulty":"EASY","category":"Strings","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid strCopy(char dest[], char src[]) {}\\nint main() { char d[20]; strCopy(d, \\"hello\\"); cout << d; return 0; }","expectedOutput":"hello","testCases":[{"input":"hello","expectedOutput":"hello","explanation":"Basic copy"},{"input":"","expectedOutput":"","explanation":"Empty string copy"},{"input":"a","expectedOutput":"a","explanation":"Single char"},{"input":"code","expectedOutput":"code","explanation":"4 character word"},{"input":"hello world","expectedOutput":"hello world","explanation":"With space"},{"input":"12345","expectedOutput":"12345","explanation":"Digits"},{"input":"ABC","expectedOutput":"ABC","explanation":"Uppercase"},{"input":"abc123","expectedOutput":"abc123","explanation":"Mixed alphanumeric"},{"input":"Hi!","expectedOutput":"Hi!","explanation":"With punctuation"},{"input":"   ","expectedOutput":"   ","explanation":"Only spaces"}],"solution":"#include <iostream>\\nusing namespace std;\\nvoid strCopy(char dest[], char src[]) { int i=0; while(src[i]) { dest[i]=src[i]; i++; } dest[i]='\\\\0'; }\\nint main() { char d[20]; strCopy(d, \\"hello\\"); cout << d; return 0; }","explanation":{"approach":"Copy character by character.","analogy":"Photocopy each letter.","steps":["Copy each char","Add null terminator"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"easy19","title":"String Compare","description":"Compare two strings.","difficulty":"EASY","category":"Strings","starterCode":"#include <iostream>\\nusing namespace std;\\nint strCmp(char a[], char b[]) { return 0; }\\nint main() { cout << strCmp(\\"abc\\", \\"abc\\"); return 0; }","expectedOutput":"0","testCases":[{"input":"abc abc","expectedOutput":"0","explanation":"Equal strings"},{"input":"abc abd","expectedOutput":"-1","explanation":"First is smaller (c < d)"},{"input":"abd abc","expectedOutput":"1","explanation":"First is larger (d > c)"},{"input":"a b","expectedOutput":"-1","explanation":"Single char comparison"},{"input":"abc ab","expectedOutput":"99","explanation":"First is longer"},{"input":"ab abc","expectedOutput":"-99","explanation":"Second is longer"},{"input":" a","expectedOutput":"-1","explanation":"Empty vs non-empty"},{"input":"A a","expectedOutput":"-32","explanation":"Case difference"},{"input":"test test","expectedOutput":"0","explanation":"Same 4-letter words"},{"input":"123 124","expectedOutput":"-1","explanation":"Digit strings"}],"solution":"#include <iostream>\\nusing namespace std;\\nint strCmp(char a[], char b[]) { int i=0; while(a[i] && a[i]==b[i]) i++; return a[i]-b[i]; }\\nint main() { cout << strCmp(\\"abc\\", \\"abc\\"); return 0; }","explanation":{"approach":"Compare char by char, return difference.","analogy":"Compare letters alphabetically.","steps":["Loop while matching","Return difference at first mismatch"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"easy20","title":"Reverse String","description":"Reverse a string.","difficulty":"EASY","category":"Strings","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid reverse(char s[]) {}\\nint main() { char s[] = \\"hello\\"; reverse(s); cout << s; return 0; }","expectedOutput":"olleh","testCases":[{"input":"hello","expectedOutput":"olleh","explanation":"Basic reversal"},{"input":"a","expectedOutput":"a","explanation":"Single char unchanged"},{"input":"ab","expectedOutput":"ba","explanation":"Two chars swap"},{"input":"abc","expectedOutput":"cba","explanation":"Odd length"},{"input":"abcd","expectedOutput":"dcba","explanation":"Even length"},{"input":"12345","expectedOutput":"54321","explanation":"Digits reversed"},{"input":"racecar","expectedOutput":"racecar","explanation":"Palindrome stays same"},{"input":"Hello","expectedOutput":"olleH","explanation":"With capital"},{"input":"ab cd","expectedOutput":"dc ba","explanation":"With space"},{"input":"A","expectedOutput":"A","explanation":"Single uppercase"}],"solution":"#include <iostream>\\nusing namespace std;\\nvoid reverse(char s[]) { int l=0, r=0; while(s[r]) r++; r--; while(l<r) { char t=s[l]; s[l]=s[r]; s[r]=t; l++; r--; } }\\nint main() { char s[] = \\"hello\\"; reverse(s); cout << s; return 0; }","explanation":{"approach":"Swap characters from both ends.","analogy":"Mirror image of the string.","steps":["Find length","Swap first-last pairs"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"easy21","title":"Check Palindrome String","description":"Is string a palindrome.","difficulty":"EASY","category":"Strings","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isPalindrome(char s[]) { return false; }\\nint main() { cout << isPalindrome(\\"radar\\"); return 0; }","expectedOutput":"1","testCases":[{"input":"radar","expectedOutput":"1","explanation":"Classic palindrome"},{"input":"hello","expectedOutput":"0","explanation":"Not a palindrome"},{"input":"a","expectedOutput":"1","explanation":"Single char is palindrome"},{"input":"aa","expectedOutput":"1","explanation":"Two same chars"},{"input":"ab","expectedOutput":"0","explanation":"Two different chars"},{"input":"aba","expectedOutput":"1","explanation":"Odd length palindrome"},{"input":"abba","expectedOutput":"1","explanation":"Even length palindrome"},{"input":"abcba","expectedOutput":"1","explanation":"5-char palindrome"},{"input":"abcde","expectedOutput":"0","explanation":"Sequential not palindrome"},{"input":"12321","expectedOutput":"1","explanation":"Numeric palindrome"}],"solution":"#include <iostream>\\nusing namespace std;\\nbool isPalindrome(char s[]) { int l=0, r=0; while(s[r]) r++; r--; while(l<r) if(s[l++]!=s[r--]) return false; return true; }\\nint main() { cout << isPalindrome(\\"radar\\"); return 0; }","explanation":{"approach":"Compare characters from both ends.","analogy":"Reads same forwards and backwards.","steps":["Compare s[left] with s[right]","Move inward"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"easy22","title":"Count Vowels","description":"Count vowels in string.","difficulty":"EASY","category":"Strings","starterCode":"#include <iostream>\\nusing namespace std;\\nint countVowels(char s[]) { return 0; }\\nint main() { cout << countVowels(\\"hello world\\"); return 0; }","expectedOutput":"3","testCases":[{"input":"hello world","expectedOutput":"3","explanation":"e, o, o = 3 vowels"},{"input":"aeiou","expectedOutput":"5","explanation":"All vowels"},{"input":"AEIOU","expectedOutput":"5","explanation":"Uppercase vowels"},{"input":"bcdfg","expectedOutput":"0","explanation":"No vowels"},{"input":"a","expectedOutput":"1","explanation":"Single vowel"},{"input":"b","expectedOutput":"0","explanation":"Single consonant"},{"input":"Beautiful","expectedOutput":"5","explanation":"Mixed case word"},{"input":"rhythm","expectedOutput":"0","explanation":"Word with no vowels"},{"input":"queue","expectedOutput":"4","explanation":"Multiple vowels"},{"input":"123abc","expectedOutput":"1","explanation":"With numbers"}],"solution":"#include <iostream>\\nusing namespace std;\\nint countVowels(char s[]) { int c=0; for(int i=0; s[i]; i++) { char ch=tolower(s[i]); if(ch=='a'||ch=='e'||ch=='i'||ch=='o'||ch=='u') c++; } return c; }\\nint main() { cout << countVowels(\\"hello world\\"); return 0; }","explanation":{"approach":"Check each character for vowel.","analogy":"Count A, E, I, O, U.","steps":["Loop through string","Check if vowel","Count"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"easy23","title":"Count Words","description":"Count words in string.","difficulty":"EASY","category":"Strings","starterCode":"#include <iostream>\\nusing namespace std;\\nint countWords(char s[]) { return 0; }\\nint main() { cout << countWords(\\"hello world test\\"); return 0; }","expectedOutput":"3","testCases":[{"input":"hello world test","expectedOutput":"3","explanation":"Three words"},{"input":"hello","expectedOutput":"1","explanation":"Single word"},{"input":"","expectedOutput":"0","explanation":"Empty string"},{"input":"   ","expectedOutput":"0","explanation":"Only spaces"},{"input":"a b c","expectedOutput":"3","explanation":"Single char words"},{"input":"  hello  ","expectedOutput":"1","explanation":"Leading/trailing spaces"},{"input":"one  two","expectedOutput":"2","explanation":"Multiple spaces between"},{"input":"a","expectedOutput":"1","explanation":"Single character"},{"input":"the quick brown fox","expectedOutput":"4","explanation":"Four words"},{"input":"hello   world   test","expectedOutput":"3","explanation":"Multiple spaces"}],"solution":"#include <iostream>\\nusing namespace std;\\nint countWords(char s[]) { int c=0; bool inWord=false; for(int i=0; s[i]; i++) { if(s[i]!=' ' && !inWord) { c++; inWord=true; } else if(s[i]==' ') inWord=false; } return c; }\\nint main() { cout << countWords(\\"hello world test\\"); return 0; }","explanation":{"approach":"Count transitions from space to word.","analogy":"Words are separated by spaces.","steps":["Track if in word","Count when entering word"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"easy24","title":"Convert to Uppercase","description":"Convert string to uppercase.","difficulty":"EASY","category":"Strings","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid toUpper(char s[]) {}\\nint main() { char s[] = \\"hello\\"; toUpper(s); cout << s; return 0; }","expectedOutput":"HELLO","testCases":[{"input":"hello","expectedOutput":"HELLO","explanation":"All lowercase"},{"input":"HELLO","expectedOutput":"HELLO","explanation":"Already uppercase"},{"input":"Hello","expectedOutput":"HELLO","explanation":"Mixed case"},{"input":"a","expectedOutput":"A","explanation":"Single char"},{"input":"abc123","expectedOutput":"ABC123","explanation":"With numbers"},{"input":"hello world","expectedOutput":"HELLO WORLD","explanation":"With space"},{"input":"","expectedOutput":"","explanation":"Empty string"},{"input":"HeLLo WoRLd","expectedOutput":"HELLO WORLD","explanation":"Random case"},{"input":"test!","expectedOutput":"TEST!","explanation":"With punctuation"},{"input":"aA","expectedOutput":"AA","explanation":"Mixed adjacent"}],"solution":"#include <iostream>\\nusing namespace std;\\nvoid toUpper(char s[]) { for(int i=0; s[i]; i++) if(s[i]>='a' && s[i]<='z') s[i] -= 32; }\\nint main() { char s[] = \\"hello\\"; toUpper(s); cout << s; return 0; }","explanation":{"approach":"Subtract 32 from lowercase letters.","analogy":"'a'(97) - 32 = 'A'(65)","steps":["Check if lowercase","Subtract 32"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"easy25","title":"Convert to Lowercase","description":"Convert string to lowercase.","difficulty":"EASY","category":"Strings","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid toLower(char s[]) {}\\nint main() { char s[] = \\"HELLO\\"; toLower(s); cout << s; return 0; }","expectedOutput":"hello","testCases":[{"input":"HELLO","expectedOutput":"hello","explanation":"All uppercase"},{"input":"hello","expectedOutput":"hello","explanation":"Already lowercase"},{"input":"Hello","expectedOutput":"hello","explanation":"Mixed case"},{"input":"A","expectedOutput":"a","explanation":"Single char"},{"input":"ABC123","expectedOutput":"abc123","explanation":"With numbers"},{"input":"HELLO WORLD","expectedOutput":"hello world","explanation":"With space"},{"input":"","expectedOutput":"","explanation":"Empty string"},{"input":"HeLLo WoRLd","expectedOutput":"hello world","explanation":"Random case"},{"input":"TEST!","expectedOutput":"test!","explanation":"With punctuation"},{"input":"Aa","expectedOutput":"aa","explanation":"Mixed adjacent"}],"solution":"#include <iostream>\\nusing namespace std;\\nvoid toLower(char s[]) { for(int i=0; s[i]; i++) if(s[i]>='A' && s[i]<='Z') s[i] += 32; }\\nint main() { char s[] = \\"HELLO\\"; toLower(s); cout << s; return 0; }","explanation":{"approach":"Add 32 to uppercase letters.","analogy":"'A'(65) + 32 = 'a'(97)","steps":["Check if uppercase","Add 32"],"complexity":"Time: O(n), Space: O(1)"}}]`),Hj=JSON.parse('[{"id":"easy26","title":"Matrix Sum","description":"Sum all matrix elements.","difficulty":"EASY","category":"Matrix","starterCode":"#include <iostream>\\nusing namespace std;\\nint matSum(int m[][3], int r, int c) { return 0; }\\nint main() { int m[][3] = {{1,2,3},{4,5,6},{7,8,9}}; cout << matSum(m,3,3); return 0; }","expectedOutput":"45","testCases":[{"input":"3 3\\n1 2 3\\n4 5 6\\n7 8 9","expectedOutput":"45","explanation":"Sum of 1-9 = 45"},{"input":"1 1\\n5","expectedOutput":"5","explanation":"Single element matrix"},{"input":"2 2\\n0 0\\n0 0","expectedOutput":"0","explanation":"All zeros"},{"input":"2 3\\n1 2 3\\n4 5 6","expectedOutput":"21","explanation":"2x3 matrix"},{"input":"3 2\\n-1 1\\n-2 2\\n-3 3","expectedOutput":"0","explanation":"Negatives cancel positives"},{"input":"2 2\\n10 20\\n30 40","expectedOutput":"100","explanation":"Larger values"},{"input":"1 3\\n1 2 3","expectedOutput":"6","explanation":"Single row"},{"input":"3 1\\n1\\n2\\n3","expectedOutput":"6","explanation":"Single column"},{"input":"2 2\\n-5 -5\\n-5 -5","expectedOutput":"-20","explanation":"All negative"},{"input":"2 3\\n100 200 300\\n400 500 600","expectedOutput":"2100","explanation":"Large sum"}],"solution":"#include <iostream>\\nusing namespace std;\\nint matSum(int m[][3], int r, int c) { int s=0; for(int i=0;i<r;i++) for(int j=0;j<c;j++) s+=m[i][j]; return s; }\\nint main() { int m[][3] = {{1,2,3},{4,5,6},{7,8,9}}; cout << matSum(m,3,3); return 0; }","explanation":{"approach":"Loop through all elements and sum.","analogy":"Count all cells in a grid.","steps":["Loop rows and columns","Add each element"],"complexity":"Time: O(rc), Space: O(1)"}},{"id":"easy27","title":"Matrix Transpose","description":"Transpose a matrix.","difficulty":"EASY","category":"Matrix","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid transpose(int m[][3], int r, int c) {}\\nint main() { int m[][3]={{1,2,3},{4,5,6}}; transpose(m,2,3); return 0; }","expectedOutput":"1 4 2 5 3 6","testCases":[{"input":"2 3\\n1 2 3\\n4 5 6","expectedOutput":"1 4 2 5 3 6","explanation":"2x3 becomes 3x2"},{"input":"1 1\\n5","expectedOutput":"5","explanation":"Single element unchanged"},{"input":"1 3\\n1 2 3","expectedOutput":"1 2 3","explanation":"Row becomes column"},{"input":"3 1\\n1\\n2\\n3","expectedOutput":"1 2 3","explanation":"Column becomes row"},{"input":"2 2\\n1 2\\n3 4","expectedOutput":"1 3 2 4","explanation":"Square matrix swap"},{"input":"3 3\\n1 2 3\\n4 5 6\\n7 8 9","expectedOutput":"1 4 7 2 5 8 3 6 9","explanation":"3x3 transpose"},{"input":"2 2\\n0 0\\n0 0","expectedOutput":"0 0 0 0","explanation":"All zeros"},{"input":"2 3\\n-1 -2 -3\\n-4 -5 -6","expectedOutput":"-1 -4 -2 -5 -3 -6","explanation":"Negatives"},{"input":"1 2\\n10 20","expectedOutput":"10 20","explanation":"1x2 matrix"},{"input":"2 1\\n10\\n20","expectedOutput":"10 20","explanation":"2x1 matrix"}],"solution":"#include <iostream>\\nusing namespace std;\\nvoid transpose(int m[][3], int r, int c) { for(int j=0;j<c;j++) { for(int i=0;i<r;i++) cout<<m[i][j]<<(i<r-1||j<c-1?\\" \\":\\"\\"); } }\\nint main() { int m[][3]={{1,2,3},{4,5,6}}; transpose(m,2,3); return 0; }","explanation":{"approach":"Swap rows and columns.","analogy":"Flip matrix diagonally.","steps":["Print m[j][i] instead of m[i][j]"],"complexity":"Time: O(rc), Space: O(1)"}},{"id":"easy28","title":"Diagonal Sum","description":"Sum of main diagonal.","difficulty":"EASY","category":"Matrix","starterCode":"#include <iostream>\\nusing namespace std;\\nint diagSum(int m[][3], int n) { return 0; }\\nint main() { int m[][3]={{1,2,3},{4,5,6},{7,8,9}}; cout<<diagSum(m,3); return 0; }","expectedOutput":"15","testCases":[{"input":"3\\n1 2 3\\n4 5 6\\n7 8 9","expectedOutput":"15","explanation":"1 + 5 + 9 = 15"},{"input":"1\\n7","expectedOutput":"7","explanation":"Single element"},{"input":"2\\n1 2\\n3 4","expectedOutput":"5","explanation":"1 + 4 = 5"},{"input":"3\\n0 0 0\\n0 0 0\\n0 0 0","expectedOutput":"0","explanation":"All zeros"},{"input":"2\\n10 20\\n30 40","expectedOutput":"50","explanation":"10 + 40"},{"input":"3\\n-1 0 0\\n0 -2 0\\n0 0 -3","expectedOutput":"-6","explanation":"Negative diagonal"},{"input":"4\\n1 0 0 0\\n0 2 0 0\\n0 0 3 0\\n0 0 0 4","expectedOutput":"10","explanation":"4x4 diagonal"},{"input":"2\\n5 5\\n5 5","expectedOutput":"10","explanation":"All same values"},{"input":"3\\n100 0 0\\n0 200 0\\n0 0 300","expectedOutput":"600","explanation":"Large diagonal"},{"input":"2\\n-10 0\\n0 10","expectedOutput":"0","explanation":"Cancel out"}],"solution":"#include <iostream>\\nusing namespace std;\\nint diagSum(int m[][3], int n) { int s=0; for(int i=0;i<n;i++) s+=m[i][i]; return s; }\\nint main() { int m[][3]={{1,2,3},{4,5,6},{7,8,9}}; cout<<diagSum(m,3); return 0; }","explanation":{"approach":"Sum elements where row = column.","analogy":"Top-left to bottom-right diagonal.","steps":["Sum m[0][0], m[1][1], m[2][2]..."],"complexity":"Time: O(n), Space: O(1)"}},{"id":"easy29","title":"Row Sum","description":"Sum of each row.","difficulty":"EASY","category":"Matrix","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid rowSum(int m[][3], int r, int c) {}\\nint main() { int m[][3]={{1,2,3},{4,5,6}}; rowSum(m,2,3); return 0; }","expectedOutput":"6 15","testCases":[{"input":"2 3\\n1 2 3\\n4 5 6","expectedOutput":"6 15","explanation":"Row1: 6, Row2: 15"},{"input":"1 3\\n1 2 3","expectedOutput":"6","explanation":"Single row"},{"input":"3 1\\n1\\n2\\n3","expectedOutput":"1 2 3","explanation":"Single column each row"},{"input":"2 2\\n0 0\\n0 0","expectedOutput":"0 0","explanation":"All zeros"},{"input":"2 3\\n-1 -2 -3\\n1 2 3","expectedOutput":"-6 6","explanation":"Negative and positive"},{"input":"3 3\\n1 1 1\\n2 2 2\\n3 3 3","expectedOutput":"3 6 9","explanation":"Uniform rows"},{"input":"1 1\\n100","expectedOutput":"100","explanation":"Single element"},{"input":"2 2\\n10 20\\n30 40","expectedOutput":"30 70","explanation":"Larger values"},{"input":"3 2\\n1 0\\n0 1\\n1 1","expectedOutput":"1 1 2","explanation":"Binary values"},{"input":"2 3\\n100 200 300\\n400 500 600","expectedOutput":"600 1500","explanation":"Large sums"}],"solution":"#include <iostream>\\nusing namespace std;\\nvoid rowSum(int m[][3], int r, int c) { for(int i=0;i<r;i++) { int s=0; for(int j=0;j<c;j++) s+=m[i][j]; cout<<s<<(i<r-1?\\" \\":\\"\\"); } }\\nint main() { int m[][3]={{1,2,3},{4,5,6}}; rowSum(m,2,3); return 0; }","explanation":{"approach":"Sum each row separately.","analogy":"Total for each row of spreadsheet.","steps":["For each row, sum its columns"],"complexity":"Time: O(rc), Space: O(1)"}},{"id":"easy30","title":"Column Sum","description":"Sum of each column.","difficulty":"EASY","category":"Matrix","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid colSum(int m[][3], int r, int c) {}\\nint main() { int m[][3]={{1,2,3},{4,5,6}}; colSum(m,2,3); return 0; }","expectedOutput":"5 7 9","testCases":[{"input":"2 3\\n1 2 3\\n4 5 6","expectedOutput":"5 7 9","explanation":"1+4, 2+5, 3+6"},{"input":"3 1\\n1\\n2\\n3","expectedOutput":"6","explanation":"Single column"},{"input":"1 3\\n1 2 3","expectedOutput":"1 2 3","explanation":"Single row"},{"input":"2 2\\n0 0\\n0 0","expectedOutput":"0 0","explanation":"All zeros"},{"input":"2 3\\n-1 -2 -3\\n1 2 3","expectedOutput":"0 0 0","explanation":"Cancel out"},{"input":"3 3\\n1 2 3\\n1 2 3\\n1 2 3","expectedOutput":"3 6 9","explanation":"Uniform columns"},{"input":"1 1\\n42","expectedOutput":"42","explanation":"Single element"},{"input":"2 2\\n10 20\\n30 40","expectedOutput":"40 60","explanation":"Larger values"},{"input":"3 2\\n1 0\\n0 1\\n1 0","expectedOutput":"2 1","explanation":"Binary values"},{"input":"2 3\\n100 200 300\\n100 200 300","expectedOutput":"200 400 600","explanation":"Large sums"}],"solution":"#include <iostream>\\nusing namespace std;\\nvoid colSum(int m[][3], int r, int c) { for(int j=0;j<c;j++) { int s=0; for(int i=0;i<r;i++) s+=m[i][j]; cout<<s<<(j<c-1?\\" \\":\\"\\"); } }\\nint main() { int m[][3]={{1,2,3},{4,5,6}}; colSum(m,2,3); return 0; }","explanation":{"approach":"Sum each column separately.","analogy":"Total for each column of spreadsheet.","steps":["For each column, sum its rows"],"complexity":"Time: O(rc), Space: O(1)"}},{"id":"easy31","title":"Second Largest","description":"Find second largest element.","difficulty":"EASY","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nint secondLargest(int a[], int n) { return 0; }\\nint main() { int a[]={12,35,1,10,34,1}; cout<<secondLargest(a,6); return 0; }","expectedOutput":"34","testCases":[{"input":"6\\n12 35 1 10 34 1","expectedOutput":"34","explanation":"35 is max, 34 is second"},{"input":"2\\n5 10","expectedOutput":"5","explanation":"Two elements"},{"input":"3\\n1 2 3","expectedOutput":"2","explanation":"Ascending order"},{"input":"3\\n3 2 1","expectedOutput":"2","explanation":"Descending order"},{"input":"4\\n5 5 5 4","expectedOutput":"4","explanation":"Duplicates of max"},{"input":"5\\n-1 -2 -3 -4 -5","expectedOutput":"-2","explanation":"All negatives"},{"input":"4\\n0 0 1 2","expectedOutput":"1","explanation":"With zeros"},{"input":"3\\n100 99 98","expectedOutput":"99","explanation":"Close values"},{"input":"5\\n1 1 1 2 2","expectedOutput":"1","explanation":"Duplicate max and second"},{"input":"4\\n10 20 20 10","expectedOutput":"10","explanation":"Two pairs"}],"solution":"#include <iostream>\\nusing namespace std;\\nint secondLargest(int a[], int n) { int f=-1, s=-1; for(int i=0;i<n;i++) { if(a[i]>f) { s=f; f=a[i]; } else if(a[i]>s && a[i]!=f) s=a[i]; } return s; }\\nint main() { int a[]={12,35,1,10,34,1}; cout<<secondLargest(a,6); return 0; }","explanation":{"approach":"Track first and second largest.","analogy":"Silver medalist in competition.","steps":["Track largest","Track second if smaller than first"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"easy32","title":"Remove Duplicates","description":"Remove duplicates from sorted array.","difficulty":"EASY","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nint removeDups(int a[], int n) { return 0; }\\nint main() { int a[]={1,1,2,2,3,4,4,5}; int k=removeDups(a,8); for(int i=0;i<k;i++) cout<<a[i]<<(i<k-1?\\" \\":\\"\\"); return 0; }","expectedOutput":"1 2 3 4 5","testCases":[{"input":"8\\n1 1 2 2 3 4 4 5","expectedOutput":"1 2 3 4 5","explanation":"Standard duplicates"},{"input":"1\\n5","expectedOutput":"5","explanation":"Single element"},{"input":"5\\n1 1 1 1 1","expectedOutput":"1","explanation":"All same"},{"input":"5\\n1 2 3 4 5","expectedOutput":"1 2 3 4 5","explanation":"No duplicates"},{"input":"2\\n1 1","expectedOutput":"1","explanation":"Two same elements"},{"input":"2\\n1 2","expectedOutput":"1 2","explanation":"Two different"},{"input":"6\\n-3 -3 -1 0 0 1","expectedOutput":"-3 -1 0 1","explanation":"With negatives"},{"input":"4\\n0 0 0 0","expectedOutput":"0","explanation":"All zeros"},{"input":"7\\n1 1 2 2 2 3 3","expectedOutput":"1 2 3","explanation":"Multiple dups"},{"input":"3\\n10 20 30","expectedOutput":"10 20 30","explanation":"Already unique"}],"solution":"#include <iostream>\\nusing namespace std;\\nint removeDups(int a[], int n) { if(n==0) return 0; int j=1; for(int i=1;i<n;i++) if(a[i]!=a[i-1]) a[j++]=a[i]; return j; }\\nint main() { int a[]={1,1,2,2,3,4,4,5}; int k=removeDups(a,8); for(int i=0;i<k;i++) cout<<a[i]<<(i<k-1?\\" \\":\\"\\"); return 0; }","explanation":{"approach":"Keep unique elements in-place.","analogy":"Skip repeats, keep first occurrence.","steps":["Compare consecutive","Keep if different"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"easy33","title":"Move Zeros to End","description":"Move all zeros to end.","difficulty":"EASY","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid moveZeros(int a[], int n) {}\\nint main() { int a[]={0,1,0,3,12}; moveZeros(a,5); for(int i=0;i<5;i++) cout<<a[i]<<(i<4?\\" \\":\\"\\"); return 0; }","expectedOutput":"1 3 12 0 0","testCases":[{"input":"5\\n0 1 0 3 12","expectedOutput":"1 3 12 0 0","explanation":"Move 2 zeros to end"},{"input":"1\\n0","expectedOutput":"0","explanation":"Single zero"},{"input":"1\\n5","expectedOutput":"5","explanation":"Single non-zero"},{"input":"5\\n0 0 0 0 0","expectedOutput":"0 0 0 0 0","explanation":"All zeros"},{"input":"5\\n1 2 3 4 5","expectedOutput":"1 2 3 4 5","explanation":"No zeros"},{"input":"3\\n0 0 1","expectedOutput":"1 0 0","explanation":"Zeros at start"},{"input":"3\\n1 0 0","expectedOutput":"1 0 0","explanation":"Zeros at end"},{"input":"4\\n1 0 2 0","expectedOutput":"1 2 0 0","explanation":"Alternating"},{"input":"6\\n-1 0 -2 0 -3 0","expectedOutput":"-1 -2 -3 0 0 0","explanation":"Negatives"},{"input":"2\\n0 1","expectedOutput":"1 0","explanation":"Simple swap"}],"solution":"#include <iostream>\\nusing namespace std;\\nvoid moveZeros(int a[], int n) { int j=0; for(int i=0;i<n;i++) if(a[i]!=0) a[j++]=a[i]; while(j<n) a[j++]=0; }\\nint main() { int a[]={0,1,0,3,12}; moveZeros(a,5); for(int i=0;i<5;i++) cout<<a[i]<<(i<4?\\" \\":\\"\\"); return 0; }","explanation":{"approach":"Copy non-zeros, fill rest with zeros.","analogy":"Slide non-zeros left, zeros fall to end.","steps":["Copy non-zero elements","Fill remaining with 0"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"easy34","title":"Rotate Array Left","description":"Rotate array left by k.","difficulty":"EASY","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid rotateLeft(int a[], int n, int k) {}\\nint main() { int a[]={1,2,3,4,5}; rotateLeft(a,5,2); for(int i=0;i<5;i++) cout<<a[i]<<(i<4?\\" \\":\\"\\"); return 0; }","expectedOutput":"3 4 5 1 2","testCases":[{"input":"5 2\\n1 2 3 4 5","expectedOutput":"3 4 5 1 2","explanation":"Left rotate by 2"},{"input":"5 1\\n1 2 3 4 5","expectedOutput":"2 3 4 5 1","explanation":"Left rotate by 1"},{"input":"5 0\\n1 2 3 4 5","expectedOutput":"1 2 3 4 5","explanation":"No rotation"},{"input":"5 5\\n1 2 3 4 5","expectedOutput":"1 2 3 4 5","explanation":"Full rotation"},{"input":"5 7\\n1 2 3 4 5","expectedOutput":"3 4 5 1 2","explanation":"k > n (7%5=2)"},{"input":"1\\n99","expectedOutput":"99","explanation":"Single element"},{"input":"2 1\\n1 2","expectedOutput":"2 1","explanation":"Two elements"},{"input":"4 2\\n-1 -2 -3 -4","expectedOutput":"-3 -4 -1 -2","explanation":"Negatives"},{"input":"3 1\\n10 20 30","expectedOutput":"20 30 10","explanation":"Three elements"},{"input":"6 3\\n1 2 3 4 5 6","expectedOutput":"4 5 6 1 2 3","explanation":"Rotate half"}],"solution":"#include <iostream>\\nusing namespace std;\\nvoid rev(int a[], int l, int r) { while(l<r) { int t=a[l]; a[l]=a[r]; a[r]=t; l++; r--; } }\\nvoid rotateLeft(int a[], int n, int k) { k%=n; rev(a,0,k-1); rev(a,k,n-1); rev(a,0,n-1); }\\nint main() { int a[]={1,2,3,4,5}; rotateLeft(a,5,2); for(int i=0;i<5;i++) cout<<a[i]<<(i<4?\\" \\":\\"\\"); return 0; }","explanation":{"approach":"Reverse first k, reverse rest, reverse all.","analogy":"Rotate words in sentence.","steps":["Reverse [0,k)","Reverse [k,n)","Reverse all"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"easy35","title":"Rotate Array Right","description":"Rotate array right by k.","difficulty":"EASY","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid rotateRight(int a[], int n, int k) {}\\nint main() { int a[]={1,2,3,4,5}; rotateRight(a,5,2); for(int i=0;i<5;i++) cout<<a[i]<<(i<4?\\" \\":\\"\\"); return 0; }","expectedOutput":"4 5 1 2 3","testCases":[{"input":"5 2\\n1 2 3 4 5","expectedOutput":"4 5 1 2 3","explanation":"Right rotate by 2"},{"input":"5 1\\n1 2 3 4 5","expectedOutput":"5 1 2 3 4","explanation":"Right rotate by 1"},{"input":"5 0\\n1 2 3 4 5","expectedOutput":"1 2 3 4 5","explanation":"No rotation"},{"input":"5 5\\n1 2 3 4 5","expectedOutput":"1 2 3 4 5","explanation":"Full rotation"},{"input":"5 7\\n1 2 3 4 5","expectedOutput":"4 5 1 2 3","explanation":"k > n (7%5=2)"},{"input":"1\\n99","expectedOutput":"99","explanation":"Single element"},{"input":"2 1\\n1 2","expectedOutput":"2 1","explanation":"Two elements"},{"input":"4 2\\n-1 -2 -3 -4","expectedOutput":"-3 -4 -1 -2","explanation":"Negatives"},{"input":"3 1\\n10 20 30","expectedOutput":"30 10 20","explanation":"Three elements"},{"input":"6 3\\n1 2 3 4 5 6","expectedOutput":"4 5 6 1 2 3","explanation":"Rotate half"}],"solution":"#include <iostream>\\nusing namespace std;\\nvoid rev(int a[], int l, int r) { while(l<r) { int t=a[l]; a[l]=a[r]; a[r]=t; l++; r--; } }\\nvoid rotateRight(int a[], int n, int k) { k%=n; rev(a,0,n-1); rev(a,0,k-1); rev(a,k,n-1); }\\nint main() { int a[]={1,2,3,4,5}; rotateRight(a,5,2); for(int i=0;i<5;i++) cout<<a[i]<<(i<4?\\" \\":\\"\\"); return 0; }","explanation":{"approach":"Reverse all, reverse first k, reverse rest.","analogy":"Opposite of left rotation.","steps":["Reverse entire array","Reverse [0,k)","Reverse [k,n)"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"easy36","title":"Check Sorted","description":"Is array sorted.","difficulty":"EASY","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isSorted(int a[], int n) { return false; }\\nint main() { int a[]={1,2,3,4,5}; cout<<isSorted(a,5); return 0; }","expectedOutput":"1","testCases":[{"input":"5\\n1 2 3 4 5","expectedOutput":"1","explanation":"Ascending order"},{"input":"5\\n5 4 3 2 1","expectedOutput":"0","explanation":"Descending order"},{"input":"1\\n5","expectedOutput":"1","explanation":"Single element"},{"input":"2\\n1 2","expectedOutput":"1","explanation":"Two ascending"},{"input":"2\\n2 1","expectedOutput":"0","explanation":"Two descending"},{"input":"5\\n1 1 1 1 1","expectedOutput":"1","explanation":"All equal"},{"input":"5\\n1 2 2 3 3","expectedOutput":"1","explanation":"Non-strictly ascending"},{"input":"5\\n1 2 5 3 4","expectedOutput":"0","explanation":"One out of order"},{"input":"4\\n-3 -2 -1 0","expectedOutput":"1","explanation":"Negative ascending"},{"input":"3\\n0 0 1","expectedOutput":"1","explanation":"With zeros"}],"solution":"#include <iostream>\\nusing namespace std;\\nbool isSorted(int a[], int n) { for(int i=1;i<n;i++) if(a[i]<a[i-1]) return false; return true; }\\nint main() { int a[]={1,2,3,4,5}; cout<<isSorted(a,5); return 0; }","explanation":{"approach":"Check if each element >= previous.","analogy":"Are stairs going only up?","steps":["Compare consecutive pairs","Return false if decreasing"],"complexity":"Time: O(n), Space: O(1)"}}]'),Yj=JSON.parse('[{"id":"easy37","title":"Merge Two Arrays","description":"Merge sorted arrays.","difficulty":"EASY","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid merge(int a[], int m, int b[], int n, int c[]) {}\\nint main() { int a[]={1,3,5}, b[]={2,4,6}, c[6]; merge(a,3,b,3,c); for(int i=0;i<6;i++) cout<<c[i]<<\\" \\"; return 0; }","expectedOutput":"1 2 3 4 5 6","testCases":[{"input":"3 3\\n1 3 5\\n2 4 6","expectedOutput":"1 2 3 4 5 6","explanation":"Interleaved merge"},{"input":"3 3\\n1 2 3\\n4 5 6","expectedOutput":"1 2 3 4 5 6","explanation":"First array all smaller"},{"input":"3 3\\n4 5 6\\n1 2 3","expectedOutput":"1 2 3 4 5 6","explanation":"Second array all smaller"},{"input":"1 1\\n1\\n2","expectedOutput":"1 2","explanation":"Single elements"},{"input":"0 3\\n\\n1 2 3","expectedOutput":"1 2 3","explanation":"First array empty"},{"input":"3 0\\n1 2 3\\n","expectedOutput":"1 2 3","explanation":"Second array empty"},{"input":"2 2\\n1 1\\n2 2","expectedOutput":"1 1 2 2","explanation":"Duplicate values"},{"input":"3 2\\n-5 -3 -1\\n-4 -2","expectedOutput":"-5 -4 -3 -2 -1","explanation":"Negative numbers"},{"input":"4 2\\n1 2 3 4\\n5 6","expectedOutput":"1 2 3 4 5 6","explanation":"Unequal sizes"},{"input":"2 3\\n10 30\\n20 40 50","expectedOutput":"10 20 30 40 50","explanation":"Mixed merge"}],"solution":"#include <iostream>\\nusing namespace std;\\nvoid merge(int a[], int m, int b[], int n, int c[]) { int i=0,j=0,k=0; while(i<m && j<n) c[k++]=a[i]<b[j]?a[i++]:b[j++]; while(i<m) c[k++]=a[i++]; while(j<n) c[k++]=b[j++]; }\\nint main() { int a[]={1,3,5}, b[]={2,4,6}, c[6]; merge(a,3,b,3,c); for(int i=0;i<6;i++) cout<<c[i]<<\\" \\"; return 0; }","explanation":{"approach":"Two pointers, pick smaller.","analogy":"Merge sorted decks of cards.","steps":["Compare fronts","Pick smaller","Handle remainder"],"complexity":"Time: O(m+n), Space: O(m+n)"}},{"id":"easy38","title":"Find Intersection","description":"Common elements.","difficulty":"EASY","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid intersection(int a[], int m, int b[], int n) {}\\nint main() { int a[]={1,2,3,4,5}, b[]={3,4,5,6,7}; intersection(a,5,b,5); return 0; }","expectedOutput":"3 4 5","testCases":[{"input":"5 5\\n1 2 3 4 5\\n3 4 5 6 7","expectedOutput":"3 4 5","explanation":"Three common elements"},{"input":"3 3\\n1 2 3\\n4 5 6","expectedOutput":"","explanation":"No common elements"},{"input":"3 3\\n1 2 3\\n1 2 3","expectedOutput":"1 2 3","explanation":"All same"},{"input":"1 1\\n5\\n5","expectedOutput":"5","explanation":"Single common element"},{"input":"1 1\\n1\\n2","expectedOutput":"","explanation":"Single no match"},{"input":"4 3\\n1 2 2 3\\n2 2 4","expectedOutput":"2 2","explanation":"With duplicates"},{"input":"5 5\\n-2 -1 0 1 2\\n-1 0 1","expectedOutput":"-1 0 1","explanation":"With negatives"},{"input":"3 5\\n10 20 30\\n5 10 20 30 40","expectedOutput":"10 20 30","explanation":"Subset"},{"input":"4 4\\n1 3 5 7\\n2 4 6 8","expectedOutput":"","explanation":"No overlap"},{"input":"2 2\\n0 0\\n0 0","expectedOutput":"0 0","explanation":"All zeros"}],"solution":"#include <iostream>\\nusing namespace std;\\nvoid intersection(int a[], int m, int b[], int n) { for(int i=0;i<m;i++) for(int j=0;j<n;j++) if(a[i]==b[j]) { cout<<a[i]<<\\" \\"; break; } }\\nint main() { int a[]={1,2,3,4,5}, b[]={3,4,5,6,7}; intersection(a,5,b,5); return 0; }","explanation":{"approach":"Check each element in both.","analogy":"Find matching items.","steps":["For each in a, search in b","Print if found"],"complexity":"Time: O(mn), Space: O(1)"}},{"id":"easy39","title":"Find Union","description":"All unique elements.","difficulty":"EASY","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid unionArr(int a[], int m, int b[], int n) {}\\nint main() { int a[]={1,2,3}, b[]={3,4,5}; unionArr(a,3,b,3); return 0; }","expectedOutput":"1 2 3 4 5","testCases":[{"input":"3 3\\n1 2 3\\n3 4 5","expectedOutput":"1 2 3 4 5","explanation":"Overlapping arrays"},{"input":"3 3\\n1 2 3\\n4 5 6","expectedOutput":"1 2 3 4 5 6","explanation":"No overlap"},{"input":"3 3\\n1 2 3\\n1 2 3","expectedOutput":"1 2 3","explanation":"Identical arrays"},{"input":"1 1\\n5\\n5","expectedOutput":"5","explanation":"Single same element"},{"input":"1 1\\n1\\n2","expectedOutput":"1 2","explanation":"Single different"},{"input":"2 3\\n1 2\\n2 3 4","expectedOutput":"1 2 3 4","explanation":"Partial overlap"},{"input":"0 3\\n\\n1 2 3","expectedOutput":"1 2 3","explanation":"First empty"},{"input":"3 0\\n1 2 3\\n","expectedOutput":"1 2 3","explanation":"Second empty"},{"input":"4 4\\n-2 -1 0 1\\n0 1 2 3","expectedOutput":"-2 -1 0 1 2 3","explanation":"With negatives"},{"input":"2 2\\n5 10\\n10 15","expectedOutput":"5 10 15","explanation":"Edge overlap"}],"solution":"#include <iostream>\\nusing namespace std;\\nvoid unionArr(int a[], int m, int b[], int n) { for(int i=0;i<m;i++) cout<<a[i]<<\\" \\"; for(int i=0;i<n;i++) { bool found=false; for(int j=0;j<m;j++) if(b[i]==a[j]) { found=true; break; } if(!found) cout<<b[i]<<\\" \\"; } }\\nint main() { int a[]={1,2,3}, b[]={3,4,5}; unionArr(a,3,b,3); return 0; }","explanation":{"approach":"Print a, then b elements not in a.","analogy":"Combine without duplicates.","steps":["Print all of a","Print b if not in a"],"complexity":"Time: O(mn), Space: O(1)"}},{"id":"easy40","title":"Frequency Count","description":"Count each element.","difficulty":"EASY","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid frequency(int a[], int n) {}\\nint main() { int a[]={1,2,2,3,3,3,4,4,4,4}; frequency(a,10); return 0; }","expectedOutput":"1:1 2:2 3:3 4:4","testCases":[{"input":"10\\n1 2 2 3 3 3 4 4 4 4","expectedOutput":"1:1 2:2 3:3 4:4","explanation":"Increasing frequencies"},{"input":"1\\n5","expectedOutput":"5:1","explanation":"Single element"},{"input":"5\\n3 3 3 3 3","expectedOutput":"3:5","explanation":"All same"},{"input":"5\\n1 2 3 4 5","expectedOutput":"1:1 2:1 3:1 4:1 5:1","explanation":"All unique"},{"input":"4\\n1 1 2 2","expectedOutput":"1:2 2:2","explanation":"Equal frequencies"},{"input":"6\\n5 5 5 1 1 1","expectedOutput":"5:3 1:3","explanation":"Two groups"},{"input":"3\\n0 0 0","expectedOutput":"0:3","explanation":"All zeros"},{"input":"4\\n-1 -1 -2 -2","expectedOutput":"-1:2 -2:2","explanation":"Negative numbers"},{"input":"6\\n1 2 1 2 1 2","expectedOutput":"1:3 2:3","explanation":"Alternating"},{"input":"3\\n100 200 100","expectedOutput":"100:2 200:1","explanation":"Larger values"}],"solution":"#include <iostream>\\nusing namespace std;\\nvoid frequency(int a[], int n) { int vis[n]={}; for(int i=0;i<n;i++) { if(vis[i]) continue; int c=1; for(int j=i+1;j<n;j++) if(a[i]==a[j]) { c++; vis[j]=1; } cout<<a[i]<<\\":\\"<<c<<\\" \\"; } }\\nint main() { int a[]={1,2,2,3,3,3,4,4,4,4}; frequency(a,10); return 0; }","explanation":{"approach":"Count occurrences of each.","analogy":"Tally each unique element.","steps":["Mark visited","Count matches","Print count"],"complexity":"Time: O(n), Space: O(n)"}},{"id":"easy41","title":"Left Rotate Once","description":"Rotate left by 1.","difficulty":"EASY","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid rotateLeft(int a[], int n) {}\\nint main() { int a[]={1,2,3,4,5}; rotateLeft(a,5); for(int i=0;i<5;i++) cout<<a[i]<<\\" \\"; return 0; }","expectedOutput":"2 3 4 5 1","testCases":[{"input":"5\\n1 2 3 4 5","expectedOutput":"2 3 4 5 1","explanation":"Basic left rotation"},{"input":"1\\n5","expectedOutput":"5","explanation":"Single element"},{"input":"2\\n1 2","expectedOutput":"2 1","explanation":"Two elements swap"},{"input":"3\\n1 2 3","expectedOutput":"2 3 1","explanation":"Three elements"},{"input":"5\\n5 5 5 5 5","expectedOutput":"5 5 5 5 5","explanation":"All same"},{"input":"4\\n-1 -2 -3 -4","expectedOutput":"-2 -3 -4 -1","explanation":"Negatives"},{"input":"3\\n0 1 2","expectedOutput":"1 2 0","explanation":"With zero"},{"input":"4\\n10 20 30 40","expectedOutput":"20 30 40 10","explanation":"Larger values"},{"input":"6\\n1 2 3 4 5 6","expectedOutput":"2 3 4 5 6 1","explanation":"Six elements"},{"input":"3\\n100 200 300","expectedOutput":"200 300 100","explanation":"Large numbers"}],"solution":"#include <iostream>\\nusing namespace std;\\nvoid rotateLeft(int a[], int n) { int t=a[0]; for(int i=0;i<n-1;i++) a[i]=a[i+1]; a[n-1]=t; }\\nint main() { int a[]={1,2,3,4,5}; rotateLeft(a,5); for(int i=0;i<5;i++) cout<<a[i]<<\\" \\"; return 0; }","explanation":{"approach":"Save first, shift left, put at end.","analogy":"Move everyone one seat left.","steps":["Save first element","Shift all left","Put saved at end"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"easy42","title":"Right Rotate Once","description":"Rotate right by 1.","difficulty":"EASY","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid rotateRight(int a[], int n) {}\\nint main() { int a[]={1,2,3,4,5}; rotateRight(a,5); for(int i=0;i<5;i++) cout<<a[i]<<\\" \\"; return 0; }","expectedOutput":"5 1 2 3 4","testCases":[{"input":"5\\n1 2 3 4 5","expectedOutput":"5 1 2 3 4","explanation":"Basic right rotation"},{"input":"1\\n5","expectedOutput":"5","explanation":"Single element"},{"input":"2\\n1 2","expectedOutput":"2 1","explanation":"Two elements swap"},{"input":"3\\n1 2 3","expectedOutput":"3 1 2","explanation":"Three elements"},{"input":"5\\n5 5 5 5 5","expectedOutput":"5 5 5 5 5","explanation":"All same"},{"input":"4\\n-1 -2 -3 -4","expectedOutput":"-4 -1 -2 -3","explanation":"Negatives"},{"input":"3\\n0 1 2","expectedOutput":"2 0 1","explanation":"With zero"},{"input":"4\\n10 20 30 40","expectedOutput":"40 10 20 30","explanation":"Larger values"},{"input":"6\\n1 2 3 4 5 6","expectedOutput":"6 1 2 3 4 5","explanation":"Six elements"},{"input":"3\\n100 200 300","expectedOutput":"300 100 200","explanation":"Large numbers"}],"solution":"#include <iostream>\\nusing namespace std;\\nvoid rotateRight(int a[], int n) { int t=a[n-1]; for(int i=n-1;i>0;i--) a[i]=a[i-1]; a[0]=t; }\\nint main() { int a[]={1,2,3,4,5}; rotateRight(a,5); for(int i=0;i<5;i++) cout<<a[i]<<\\" \\"; return 0; }","explanation":{"approach":"Save last, shift right, put at start.","analogy":"Move everyone one seat right.","steps":["Save last element","Shift all right","Put saved at start"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"easy43","title":"Peak Element","description":"Find local maximum.","difficulty":"EASY","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nint findPeak(int a[], int n) { return 0; }\\nint main() { int a[]={1,3,20,4,1,0}; cout<<findPeak(a,6); return 0; }","expectedOutput":"20","testCases":[{"input":"6\\n1 3 20 4 1 0","expectedOutput":"20","explanation":"20 > 3 and 20 > 4"},{"input":"1\\n5","expectedOutput":"5","explanation":"Single element is peak"},{"input":"2\\n1 2","expectedOutput":"2","explanation":"Last element is peak"},{"input":"2\\n2 1","expectedOutput":"2","explanation":"First element is peak"},{"input":"5\\n1 2 3 4 5","expectedOutput":"5","explanation":"Ascending, last is peak"},{"input":"5\\n5 4 3 2 1","expectedOutput":"5","explanation":"Descending, first is peak"},{"input":"5\\n1 5 1 5 1","expectedOutput":"5","explanation":"Multiple peaks, returns first"},{"input":"4\\n10 20 15 5","expectedOutput":"20","explanation":"Peak in middle"},{"input":"3\\n1 1 1","expectedOutput":"1","explanation":"All same"},{"input":"5\\n-5 -3 -1 -2 -4","expectedOutput":"-1","explanation":"Negatives, -1 is peak"}],"solution":"#include <iostream>\\nusing namespace std;\\nint findPeak(int a[], int n) { for(int i=0;i<n;i++) { bool left = i==0 || a[i]>=a[i-1]; bool right = i==n-1 || a[i]>=a[i+1]; if(left && right) return a[i]; } return -1; }\\nint main() { int a[]={1,3,20,4,1,0}; cout<<findPeak(a,6); return 0; }","explanation":{"approach":"Find element >= both neighbors.","analogy":"Mountain top.","steps":["Check if >= left and >= right","Return first peak"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"easy44","title":"Find Minimum","description":"Minimum element.","difficulty":"EASY","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nint findMin(int a[], int n) { return 0; }\\nint main() { int a[]={3,1,4,1,5,9,2}; cout<<findMin(a,7); return 0; }","expectedOutput":"1","testCases":[{"input":"7\\n3 1 4 1 5 9 2","expectedOutput":"1","explanation":"1 is smallest"},{"input":"1\\n42","expectedOutput":"42","explanation":"Single element"},{"input":"5\\n5 5 5 5 5","expectedOutput":"5","explanation":"All same"},{"input":"5\\n1 2 3 4 5","expectedOutput":"1","explanation":"Min at start"},{"input":"5\\n5 4 3 2 1","expectedOutput":"1","explanation":"Min at end"},{"input":"5\\n2 3 1 4 5","expectedOutput":"1","explanation":"Min in middle"},{"input":"4\\n-1 -5 -2 -3","expectedOutput":"-5","explanation":"Negatives"},{"input":"3\\n0 -1 1","expectedOutput":"-1","explanation":"Around zero"},{"input":"2\\n100 50","expectedOutput":"50","explanation":"Two elements"},{"input":"6\\n10 20 5 30 40 50","expectedOutput":"5","explanation":"Min in array"}],"solution":"#include <iostream>\\nusing namespace std;\\nint findMin(int a[], int n) { int mn=a[0]; for(int i=1;i<n;i++) if(a[i]<mn) mn=a[i]; return mn; }\\nint main() { int a[]={3,1,4,1,5,9,2}; cout<<findMin(a,7); return 0; }","explanation":{"approach":"Track minimum while scanning.","analogy":"Find smallest number.","steps":["Assume first is min","Update if smaller found"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"easy45","title":"Sum of Digits","description":"Sum all digits.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nint sumDigits(int n) { return 0; }\\nint main() { cout<<sumDigits(12345); return 0; }","expectedOutput":"15","testCases":[{"input":"12345","expectedOutput":"15","explanation":"1+2+3+4+5 = 15"},{"input":"0","expectedOutput":"0","explanation":"Zero"},{"input":"9","expectedOutput":"9","explanation":"Single digit"},{"input":"10","expectedOutput":"1","explanation":"1+0 = 1"},{"input":"99","expectedOutput":"18","explanation":"9+9 = 18"},{"input":"100","expectedOutput":"1","explanation":"1+0+0 = 1"},{"input":"111","expectedOutput":"3","explanation":"1+1+1 = 3"},{"input":"999","expectedOutput":"27","explanation":"9+9+9 = 27"},{"input":"1000000","expectedOutput":"1","explanation":"Large with zeros"},{"input":"54321","expectedOutput":"15","explanation":"Reverse of 12345"}],"solution":"#include <iostream>\\nusing namespace std;\\nint sumDigits(int n) { int s=0; while(n>0) { s+=n%10; n/=10; } return s; }\\nint main() { cout<<sumDigits(12345); return 0; }","explanation":{"approach":"Extract and sum each digit.","analogy":"Add up all digit values.","steps":["Get last digit with %10","Add to sum","Remove digit with /10"],"complexity":"Time: O(log n), Space: O(1)"}},{"id":"easy46","title":"Count Digits","description":"Number of digits.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nint countDigits(int n) { return 0; }\\nint main() { cout<<countDigits(12345); return 0; }","expectedOutput":"5","testCases":[{"input":"12345","expectedOutput":"5","explanation":"Five digits"},{"input":"0","expectedOutput":"1","explanation":"Zero has 1 digit"},{"input":"9","expectedOutput":"1","explanation":"Single digit"},{"input":"10","expectedOutput":"2","explanation":"Two digits"},{"input":"99","expectedOutput":"2","explanation":"Two nines"},{"input":"100","expectedOutput":"3","explanation":"Three digits"},{"input":"1000","expectedOutput":"4","explanation":"Power of 10"},{"input":"999999","expectedOutput":"6","explanation":"Six nines"},{"input":"1000000000","expectedOutput":"10","explanation":"Ten digits"},{"input":"1","expectedOutput":"1","explanation":"Single 1"}],"solution":"#include <iostream>\\nusing namespace std;\\nint countDigits(int n) { if(n==0) return 1; int c=0; while(n>0) { c++; n/=10; } return c; }\\nint main() { cout<<countDigits(12345); return 0; }","explanation":{"approach":"Count divisions by 10.","analogy":"How many times can we divide by 10?","steps":["Divide by 10","Count iterations"],"complexity":"Time: O(log n), Space: O(1)"}},{"id":"easy47","title":"Reverse Number","description":"Reverse digit order.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nint reverse(int n) { return 0; }\\nint main() { cout<<reverse(12345); return 0; }","expectedOutput":"54321","testCases":[{"input":"12345","expectedOutput":"54321","explanation":"Basic reversal"},{"input":"0","expectedOutput":"0","explanation":"Zero stays zero"},{"input":"9","expectedOutput":"9","explanation":"Single digit"},{"input":"10","expectedOutput":"1","explanation":"Trailing zero removed"},{"input":"100","expectedOutput":"1","explanation":"Multiple trailing zeros"},{"input":"12321","expectedOutput":"12321","explanation":"Palindrome stays same"},{"input":"1000","expectedOutput":"1","explanation":"Only trailing zeros"},{"input":"120","expectedOutput":"21","explanation":"One trailing zero"},{"input":"99999","expectedOutput":"99999","explanation":"All nines"},{"input":"1020","expectedOutput":"201","explanation":"Middle zero preserved"}],"solution":"#include <iostream>\\nusing namespace std;\\nint reverse(int n) { int r=0; while(n>0) { r=r*10+n%10; n/=10; } return r; }\\nint main() { cout<<reverse(12345); return 0; }","explanation":{"approach":"Build reversed number digit by digit.","analogy":"Read number backwards.","steps":["Get last digit","Add to result  10","Remove digit"],"complexity":"Time: O(log n), Space: O(1)"}},{"id":"easy48","title":"Is Palindrome Number","description":"Number reads same forwards and backwards.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isPalindrome(int n) { return false; }\\nint main() { cout<<isPalindrome(12321); return 0; }","expectedOutput":"1","testCases":[{"input":"12321","expectedOutput":"1","explanation":"Reads same both ways"},{"input":"12345","expectedOutput":"0","explanation":"Not palindrome"},{"input":"0","expectedOutput":"1","explanation":"Zero is palindrome"},{"input":"1","expectedOutput":"1","explanation":"Single digit"},{"input":"11","expectedOutput":"1","explanation":"Two same digits"},{"input":"12","expectedOutput":"0","explanation":"Two different"},{"input":"121","expectedOutput":"1","explanation":"Three digit palindrome"},{"input":"1221","expectedOutput":"1","explanation":"Even length palindrome"},{"input":"10","expectedOutput":"0","explanation":"10 reversed is 01"},{"input":"1001","expectedOutput":"1","explanation":"With zeros"}],"solution":"#include <iostream>\\nusing namespace std;\\nbool isPalindrome(int n) { int orig=n, r=0; while(n>0) { r=r*10+n%10; n/=10; } return r==orig; }\\nint main() { cout<<isPalindrome(12321); return 0; }","explanation":{"approach":"Reverse and compare.","analogy":"Does it read the same backward?","steps":["Reverse the number","Compare with original"],"complexity":"Time: O(log n), Space: O(1)"}}]'),Gj=JSON.parse(`[{"id":"easy49","title":"Power of Number","description":"Calculate x^n.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nint power(int x, int n) { return 0; }\\nint main() { cout<<power(2,10); return 0; }","expectedOutput":"1024","testCases":[{"input":"2 10","expectedOutput":"1024","explanation":"2^10 = 1024"},{"input":"2 0","expectedOutput":"1","explanation":"Any number to 0 is 1"},{"input":"5 1","expectedOutput":"5","explanation":"Any number to 1 is itself"},{"input":"3 3","expectedOutput":"27","explanation":"3^3 = 27"},{"input":"10 2","expectedOutput":"100","explanation":"10 squared"},{"input":"2 5","expectedOutput":"32","explanation":"2^5 = 32"},{"input":"1 100","expectedOutput":"1","explanation":"1 to any power is 1"},{"input":"7 2","expectedOutput":"49","explanation":"7 squared"},{"input":"3 4","expectedOutput":"81","explanation":"3^4 = 81"},{"input":"4 3","expectedOutput":"64","explanation":"4^3 = 64"}],"solution":"#include <iostream>\\nusing namespace std;\\nint power(int x, int n) { int r=1; while(n>0) { if(n%2) r*=x; x*=x; n/=2; } return r; }\\nint main() { cout<<power(2,10); return 0; }","explanation":{"approach":"Fast exponentiation by squaring.","analogy":"Double the exponent, halve the work.","steps":["If odd, multiply result","Square base, halve exponent"],"complexity":"Time: O(log n), Space: O(1)"}},{"id":"easy50","title":"Check Perfect Square","description":"Is n a perfect square.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isPerfectSquare(int n) { return false; }\\nint main() { cout<<isPerfectSquare(16); return 0; }","expectedOutput":"1","testCases":[{"input":"16","expectedOutput":"1","explanation":"44 = 16"},{"input":"15","expectedOutput":"0","explanation":"No integer square root"},{"input":"1","expectedOutput":"1","explanation":"11 = 1"},{"input":"0","expectedOutput":"1","explanation":"00 = 0"},{"input":"4","expectedOutput":"1","explanation":"22 = 4"},{"input":"9","expectedOutput":"1","explanation":"33 = 9"},{"input":"25","expectedOutput":"1","explanation":"55 = 25"},{"input":"26","expectedOutput":"0","explanation":"Between 25 and 36"},{"input":"100","expectedOutput":"1","explanation":"1010 = 100"},{"input":"99","expectedOutput":"0","explanation":"Just below 100"}],"solution":"#include <iostream>\\nusing namespace std;\\nbool isPerfectSquare(int n) { int r=0; while(r*r<n) r++; return r*r==n; }\\nint main() { cout<<isPerfectSquare(16); return 0; }","explanation":{"approach":"Find root, check if r = n.","analogy":"Is there an integer whose square equals n?","steps":["Find sqrt","Check if exact"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"easy51","title":"Leap Year Check","description":"Is year a leap year.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isLeapYear(int y) { return false; }\\nint main() { cout<<isLeapYear(2024); return 0; }","expectedOutput":"1","testCases":[{"input":"2024","expectedOutput":"1","explanation":"Divisible by 4, not by 100"},{"input":"2023","expectedOutput":"0","explanation":"Not divisible by 4"},{"input":"2000","expectedOutput":"1","explanation":"Divisible by 400"},{"input":"1900","expectedOutput":"0","explanation":"Divisible by 100 but not 400"},{"input":"2020","expectedOutput":"1","explanation":"Recent leap year"},{"input":"2021","expectedOutput":"0","explanation":"Not a leap year"},{"input":"2100","expectedOutput":"0","explanation":"Century not leap"},{"input":"1600","expectedOutput":"1","explanation":"Divisible by 400"},{"input":"4","expectedOutput":"1","explanation":"Small leap year"},{"input":"100","expectedOutput":"0","explanation":"First century year"}],"solution":"#include <iostream>\\nusing namespace std;\\nbool isLeapYear(int y) { return (y%4==0 && y%100!=0) || y%400==0; }\\nint main() { cout<<isLeapYear(2024); return 0; }","explanation":{"approach":"Divisible by 4 but not 100, or by 400.","analogy":"Calendar leap year rules.","steps":["Check divisibility rules"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"easy52","title":"Days in Month","description":"Number of days in month.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nint daysInMonth(int m, int y) { return 0; }\\nint main() { cout<<daysInMonth(2,2024); return 0; }","expectedOutput":"29","testCases":[{"input":"2 2024","expectedOutput":"29","explanation":"Feb in leap year"},{"input":"2 2023","expectedOutput":"28","explanation":"Feb in non-leap year"},{"input":"1 2020","expectedOutput":"31","explanation":"January has 31"},{"input":"4 2020","expectedOutput":"30","explanation":"April has 30"},{"input":"12 2020","expectedOutput":"31","explanation":"December has 31"},{"input":"6 2020","expectedOutput":"30","explanation":"June has 30"},{"input":"7 2020","expectedOutput":"31","explanation":"July has 31"},{"input":"8 2020","expectedOutput":"31","explanation":"August has 31"},{"input":"9 2020","expectedOutput":"30","explanation":"September has 30"},{"input":"2 2000","expectedOutput":"29","explanation":"Feb 2000 leap"}],"solution":"#include <iostream>\\nusing namespace std;\\nint daysInMonth(int m, int y) { int d[]={31,28,31,30,31,30,31,31,30,31,30,31}; if(m==2 && ((y%4==0 && y%100!=0) || y%400==0)) return 29; return d[m-1]; }\\nint main() { cout<<daysInMonth(2,2024); return 0; }","explanation":{"approach":"Lookup table with leap year check.","analogy":"30 days hath September...","steps":["Use days array","Handle Feb leap year"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"easy53","title":"Sum of N Natural","description":"Sum 1 to n.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nint sumN(int n) { return 0; }\\nint main() { cout<<sumN(10); return 0; }","expectedOutput":"55","testCases":[{"input":"10","expectedOutput":"55","explanation":"1+2+...+10 = 55"},{"input":"1","expectedOutput":"1","explanation":"Sum of 1"},{"input":"0","expectedOutput":"0","explanation":"Sum of nothing"},{"input":"5","expectedOutput":"15","explanation":"1+2+3+4+5"},{"input":"100","expectedOutput":"5050","explanation":"Classic formula result"},{"input":"2","expectedOutput":"3","explanation":"1+2 = 3"},{"input":"3","expectedOutput":"6","explanation":"1+2+3 = 6"},{"input":"50","expectedOutput":"1275","explanation":"Half of 100 case"},{"input":"20","expectedOutput":"210","explanation":"Sum to 20"},{"input":"7","expectedOutput":"28","explanation":"1+2+...+7"}],"solution":"#include <iostream>\\nusing namespace std;\\nint sumN(int n) { return n*(n+1)/2; }\\nint main() { cout<<sumN(10); return 0; }","explanation":{"approach":"Gauss formula n(n+1)/2.","analogy":"Pair up: 1+10=11, 2+9=11, etc.","steps":["Use formula n(n+1)/2"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"easy54","title":"Sum of Squares","description":"Sum 1 to n.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nint sumSquares(int n) { return 0; }\\nint main() { cout<<sumSquares(5); return 0; }","expectedOutput":"55","testCases":[{"input":"5","expectedOutput":"55","explanation":"1+4+9+16+25 = 55"},{"input":"1","expectedOutput":"1","explanation":"Only 1"},{"input":"2","expectedOutput":"5","explanation":"1+4 = 5"},{"input":"3","expectedOutput":"14","explanation":"1+4+9 = 14"},{"input":"4","expectedOutput":"30","explanation":"1+4+9+16 = 30"},{"input":"10","expectedOutput":"385","explanation":"Sum to 10"},{"input":"0","expectedOutput":"0","explanation":"Sum of nothing"},{"input":"6","expectedOutput":"91","explanation":"1+4+9+16+25+36"},{"input":"7","expectedOutput":"140","explanation":"Sum to 7"},{"input":"100","expectedOutput":"338350","explanation":"Large sum"}],"solution":"#include <iostream>\\nusing namespace std;\\nint sumSquares(int n) { return n*(n+1)*(2*n+1)/6; }\\nint main() { cout<<sumSquares(5); return 0; }","explanation":{"approach":"Formula n(n+1)(2n+1)/6.","analogy":"Sum of pyramid blocks.","steps":["Use formula"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"easy55","title":"Sum of Cubes","description":"Sum 1 to n.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nint sumCubes(int n) { return 0; }\\nint main() { cout<<sumCubes(5); return 0; }","expectedOutput":"225","testCases":[{"input":"5","expectedOutput":"225","explanation":"1+8+27+64+125 = 225"},{"input":"1","expectedOutput":"1","explanation":"Only 1"},{"input":"2","expectedOutput":"9","explanation":"1+8 = 9"},{"input":"3","expectedOutput":"36","explanation":"1+8+27 = 36"},{"input":"4","expectedOutput":"100","explanation":"1+8+27+64 = 100"},{"input":"10","expectedOutput":"3025","explanation":"Sum to 10"},{"input":"0","expectedOutput":"0","explanation":"Sum of nothing"},{"input":"6","expectedOutput":"441","explanation":"Sum to 6"},{"input":"7","expectedOutput":"784","explanation":"28 = 784"},{"input":"100","expectedOutput":"25502500","explanation":"5050 = 25502500"}],"solution":"#include <iostream>\\nusing namespace std;\\nint sumCubes(int n) { int s=n*(n+1)/2; return s*s; }\\nint main() { cout<<sumCubes(5); return 0; }","explanation":{"approach":"Formula: (n(n+1)/2).","analogy":"Sum of cubes = square of sum.","steps":["Calculate sum of n","Square it"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"easy56","title":"Even or Odd String","description":"Check if count of chars is even.","difficulty":"EASY","category":"Strings","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid evenOdd(char s[]) {}\\nint main() { evenOdd(\\"hello\\"); return 0; }","expectedOutput":"Odd","testCases":[{"input":"hello","expectedOutput":"Odd","explanation":"5 chars is odd"},{"input":"hi","expectedOutput":"Even","explanation":"2 chars is even"},{"input":"a","expectedOutput":"Odd","explanation":"1 char is odd"},{"input":"ab","expectedOutput":"Even","explanation":"2 chars is even"},{"input":"abc","expectedOutput":"Odd","explanation":"3 chars is odd"},{"input":"abcd","expectedOutput":"Even","explanation":"4 chars is even"},{"input":"","expectedOutput":"Even","explanation":"0 chars is even"},{"input":"test string","expectedOutput":"Odd","explanation":"11 chars odd"},{"input":"even","expectedOutput":"Even","explanation":"4 chars"},{"input":"odd","expectedOutput":"Odd","explanation":"3 chars"}],"solution":"#include <iostream>\\nusing namespace std;\\nvoid evenOdd(char s[]) { int len=0; while(s[len]) len++; cout<<(len%2==0?\\"Even\\":\\"Odd\\"); }\\nint main() { evenOdd(\\"hello\\"); return 0; }","explanation":{"approach":"Count length, check parity.","analogy":"Is string length even or odd?","steps":["Count characters","Check if even or odd"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"easy57","title":"Toggle Case","description":"Toggle each character case.","difficulty":"EASY","category":"Strings","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid toggleCase(char s[]) {}\\nint main() { char s[]=\\"Hello World\\"; toggleCase(s); cout<<s; return 0; }","expectedOutput":"hELLO wORLD","testCases":[{"input":"Hello World","expectedOutput":"hELLO wORLD","explanation":"Toggle each letter"},{"input":"ABC","expectedOutput":"abc","explanation":"All upper to lower"},{"input":"abc","expectedOutput":"ABC","explanation":"All lower to upper"},{"input":"AbC","expectedOutput":"aBc","explanation":"Mixed case"},{"input":"123","expectedOutput":"123","explanation":"Numbers unchanged"},{"input":"Hello123","expectedOutput":"hELLO123","explanation":"Mixed with numbers"},{"input":"a","expectedOutput":"A","explanation":"Single lower"},{"input":"A","expectedOutput":"a","explanation":"Single upper"},{"input":"Test Case","expectedOutput":"tEST cASE","explanation":"Two words"},{"input":"","expectedOutput":"","explanation":"Empty string"}],"solution":"#include <iostream>\\nusing namespace std;\\nvoid toggleCase(char s[]) { for(int i=0;s[i];i++) { if(s[i]>='A'&&s[i]<='Z') s[i]+=32; else if(s[i]>='a'&&s[i]<='z') s[i]-=32; } }\\nint main() { char s[]=\\"Hello World\\"; toggleCase(s); cout<<s; return 0; }","explanation":{"approach":"Flip case of each letter.","analogy":"Uppercase becomes lower and vice versa.","steps":["If uppercase, add 32","If lowercase, subtract 32"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"easy58","title":"Remove Spaces","description":"Remove all spaces.","difficulty":"EASY","category":"Strings","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid removeSpaces(char s[]) {}\\nint main() { char s[]=\\"hello world test\\"; removeSpaces(s); cout<<s; return 0; }","expectedOutput":"helloworldtest","testCases":[{"input":"hello world test","expectedOutput":"helloworldtest","explanation":"Remove all spaces"},{"input":"abc","expectedOutput":"abc","explanation":"No spaces to remove"},{"input":"   ","expectedOutput":"","explanation":"All spaces removed"},{"input":"a b c","expectedOutput":"abc","explanation":"Single char words"},{"input":" hello","expectedOutput":"hello","explanation":"Leading space"},{"input":"hello ","expectedOutput":"hello","explanation":"Trailing space"},{"input":"hello  world","expectedOutput":"helloworld","explanation":"Multiple spaces"},{"input":"","expectedOutput":"","explanation":"Empty string"},{"input":"no spaces","expectedOutput":"nospaces","explanation":"Two words"},{"input":"  a  b  ","expectedOutput":"ab","explanation":"Multiple spaces"}],"solution":"#include <iostream>\\nusing namespace std;\\nvoid removeSpaces(char s[]) { int j=0; for(int i=0;s[i];i++) if(s[i]!=' ') s[j++]=s[i]; s[j]=0; }\\nint main() { char s[]=\\"hello world test\\"; removeSpaces(s); cout<<s; return 0; }","explanation":{"approach":"Copy non-space chars.","analogy":"Filter out spaces.","steps":["Copy if not space"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"easy59","title":"First Uppercase","description":"Find first uppercase letter.","difficulty":"EASY","category":"Strings","starterCode":"#include <iostream>\\nusing namespace std;\\nchar firstUpper(char s[]) { return 0; }\\nint main() { cout<<firstUpper(\\"helloWorld\\"); return 0; }","expectedOutput":"W","testCases":[{"input":"helloWorld","expectedOutput":"W","explanation":"W is first uppercase"},{"input":"Hello","expectedOutput":"H","explanation":"H at start"},{"input":"hello","expectedOutput":"","explanation":"No uppercase"},{"input":"HELLO","expectedOutput":"H","explanation":"First of many"},{"input":"abcDef","expectedOutput":"D","explanation":"D in middle"},{"input":"abcdefG","expectedOutput":"G","explanation":"G at end"},{"input":"A","expectedOutput":"A","explanation":"Single uppercase"},{"input":"a","expectedOutput":"","explanation":"Single lowercase"},{"input":"123ABC","expectedOutput":"A","explanation":"After numbers"},{"input":"testCamelCase","expectedOutput":"C","explanation":"Camel case"}],"solution":"#include <iostream>\\nusing namespace std;\\nchar firstUpper(char s[]) { for(int i=0;s[i];i++) if(s[i]>='A'&&s[i]<='Z') return s[i]; return 0; }\\nint main() { cout<<firstUpper(\\"helloWorld\\"); return 0; }","explanation":{"approach":"Scan for uppercase.","analogy":"Find first capital letter.","steps":["Check each char if A-Z"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"easy60","title":"Count Consonants","description":"Count consonants in string.","difficulty":"EASY","category":"Strings","starterCode":"#include <iostream>\\nusing namespace std;\\nint countConsonants(char s[]) { return 0; }\\nint main() { cout<<countConsonants(\\"hello world\\"); return 0; }","expectedOutput":"7","testCases":[{"input":"hello world","expectedOutput":"7","explanation":"h,l,l,w,r,l,d = 7"},{"input":"aeiou","expectedOutput":"0","explanation":"All vowels"},{"input":"bcdfg","expectedOutput":"5","explanation":"All consonants"},{"input":"abc","expectedOutput":"2","explanation":"b and c"},{"input":"HELLO","expectedOutput":"3","explanation":"H,L,L"},{"input":"123","expectedOutput":"0","explanation":"No letters"},{"input":"rhythm","expectedOutput":"6","explanation":"All consonants"},{"input":"a","expectedOutput":"0","explanation":"Single vowel"},{"input":"b","expectedOutput":"1","explanation":"Single consonant"},{"input":"Beautiful","expectedOutput":"4","explanation":"B,t,f,l"}],"solution":"#include <iostream>\\nusing namespace std;\\nbool isVowel(char c) { c=tolower(c); return c=='a'||c=='e'||c=='i'||c=='o'||c=='u'; }\\nint countConsonants(char s[]) { int c=0; for(int i=0;s[i];i++) if(isalpha(s[i]) && !isVowel(s[i])) c++; return c; }\\nint main() { cout<<countConsonants(\\"hello world\\"); return 0; }","explanation":{"approach":"Count letters that aren't vowels.","analogy":"Count non-vowel letters.","steps":["Check if letter and not vowel"],"complexity":"Time: O(n), Space: O(1)"}}]`),Vj=JSON.parse(`[{"id":"e251","title":"Find Pivot Index","description":"Index where left sum equals right sum.","difficulty":"EASY","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nint pivotIndex(int nums[], int n) { return -1; }\\nint main() { int a[]={1,7,3,6,5,6}; cout<<pivotIndex(a,6); return 0; }","expectedOutput":"3","testCases":[{"input":"6\\n1 7 3 6 5 6","expectedOutput":"3","explanation":"Left sum 1+7+3=11, Right sum 5+6=11"},{"input":"3\\n1 2 3","expectedOutput":"-1","explanation":"No pivot exists"},{"input":"1\\n5","expectedOutput":"0","explanation":"Single element is pivot"},{"input":"2\\n1 0","expectedOutput":"0","explanation":"First element is pivot"},{"input":"2\\n0 1","expectedOutput":"1","explanation":"Last element is pivot"},{"input":"5\\n2 1 -1 1 2","expectedOutput":"2","explanation":"Negative number pivot"},{"input":"3\\n0 0 0","expectedOutput":"0","explanation":"All zeros, first is pivot"},{"input":"4\\n1 1 1 1","expectedOutput":"-1","explanation":"No valid pivot"},{"input":"5\\n-1 -1 -1 0 1","expectedOutput":"3","explanation":"Negatives balance"},{"input":"3\\n0 1 0","expectedOutput":"1","explanation":"Middle is pivot"}],"solution":"#include <iostream>\\nusing namespace std;\\nint pivotIndex(int nums[], int n) { int total=0,left=0; for(int i=0;i<n;i++) total+=nums[i]; for(int i=0;i<n;i++) { if(left==total-left-nums[i]) return i; left+=nums[i]; } return -1; }\\nint main() { int a[]={1,7,3,6,5,6}; cout<<pivotIndex(a,6); return 0; }","explanation":{"approach":"Track left sum.","steps":["Compute total sum","Check if left == right at each index"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"e252","title":"Largest Number At Least Twice","description":"Index of largest if >= 2x others.","difficulty":"EASY","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nint dominantIndex(int nums[], int n) { return -1; }\\nint main() { int a[]={3,6,1,0}; cout<<dominantIndex(a,4); return 0; }","expectedOutput":"1","testCases":[{"input":"4\\n3 6 1 0","expectedOutput":"1","explanation":"6 >= 2*3, 2*1, 2*0"},{"input":"2\\n1 2","expectedOutput":"1","explanation":"2 >= 2*1"},{"input":"2\\n1 3","expectedOutput":"1","explanation":"3 > 2*1"},{"input":"2\\n2 3","expectedOutput":"-1","explanation":"3 < 2*2"},{"input":"1\\n5","expectedOutput":"0","explanation":"Single element"},{"input":"3\\n0 0 1","expectedOutput":"2","explanation":"1 >= 2*0"},{"input":"4\\n1 2 3 4","expectedOutput":"-1","explanation":"No dominant"},{"input":"3\\n10 5 2","expectedOutput":"0","explanation":"10 >= 2*5"},{"input":"3\\n5 10 2","expectedOutput":"1","explanation":"10 >= 2*5"},{"input":"4\\n0 0 0 1","expectedOutput":"3","explanation":"Any vs zeros"}],"solution":"#include <iostream>\\nusing namespace std;\\nint dominantIndex(int nums[], int n) { int mx=0; for(int i=1;i<n;i++) if(nums[i]>nums[mx]) mx=i; for(int i=0;i<n;i++) if(i!=mx && nums[mx]<2*nums[i]) return -1; return mx; }\\nint main() { int a[]={3,6,1,0}; cout<<dominantIndex(a,4); return 0; }","explanation":{"approach":"Find max, check condition.","steps":["Find largest element","Check if >= 2x all others"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"e253","title":"Plus One","description":"Add one to number as array.","difficulty":"EASY","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid plusOne(int digits[], int n) {}\\nint main() { int d[]={1,2,3}; plusOne(d,3); return 0; }","expectedOutput":"1 2 4","testCases":[{"input":"3\\n1 2 3","expectedOutput":"1 2 4","explanation":"123 + 1 = 124"},{"input":"3\\n9 9 9","expectedOutput":"1 0 0 0","explanation":"999 + 1 = 1000"},{"input":"1\\n0","expectedOutput":"1","explanation":"0 + 1 = 1"},{"input":"1\\n9","expectedOutput":"1 0","explanation":"9 + 1 = 10"},{"input":"2\\n1 9","expectedOutput":"2 0","explanation":"19 + 1 = 20"},{"input":"3\\n1 9 9","expectedOutput":"2 0 0","explanation":"199 + 1 = 200"},{"input":"2\\n2 5","expectedOutput":"2 6","explanation":"25 + 1 = 26"},{"input":"4\\n1 2 3 4","expectedOutput":"1 2 3 5","explanation":"1234 + 1"},{"input":"3\\n0 0 1","expectedOutput":"0 0 2","explanation":"001 + 1 = 002"},{"input":"2\\n9 0","expectedOutput":"9 1","explanation":"90 + 1 = 91"}],"solution":"#include <iostream>\\nusing namespace std;\\nvoid plusOne(int digits[], int n) { for(int i=n-1;i>=0;i--) { if(digits[i]<9) { digits[i]++; for(int j=0;j<n;j++) cout<<digits[j]<<\\" \\"; return; } digits[i]=0; } cout<<1<<\\" \\"; for(int i=0;i<n;i++) cout<<0<<\\" \\"; }\\nint main() { int d[]={1,2,3}; plusOne(d,3); return 0; }","explanation":{"approach":"Add with carry.","steps":["Increment last digit","Handle carry if 9"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"e254","title":"Diagonal Traverse","description":"Traverse matrix diagonally.","difficulty":"MEDIUM","category":"Matrix","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid findDiagonalOrder(int m[][3], int r, int c) {}\\nint main() { int m[][3]={{1,2,3},{4,5,6},{7,8,9}}; findDiagonalOrder(m,3,3); return 0; }","expectedOutput":"1 2 4 7 5 3 6 8 9","testCases":[{"input":"3 3\\n1 2 3\\n4 5 6\\n7 8 9","expectedOutput":"1 2 4 7 5 3 6 8 9","explanation":"Diagonal zigzag"},{"input":"1 1\\n5","expectedOutput":"5","explanation":"Single element"},{"input":"2 2\\n1 2\\n3 4","expectedOutput":"1 2 3 4","explanation":"2x2 diagonal"},{"input":"1 3\\n1 2 3","expectedOutput":"1 2 3","explanation":"Single row"},{"input":"3 1\\n1\\n2\\n3","expectedOutput":"1 2 3","explanation":"Single column"},{"input":"2 3\\n1 2 3\\n4 5 6","expectedOutput":"1 2 4 5 3 6","explanation":"2x3 matrix"},{"input":"3 2\\n1 2\\n3 4\\n5 6","expectedOutput":"1 2 3 5 4 6","explanation":"3x2 matrix"},{"input":"2 2\\n0 0\\n0 0","expectedOutput":"0 0 0 0","explanation":"All zeros"},{"input":"3 3\\n9 8 7\\n6 5 4\\n3 2 1","expectedOutput":"9 8 6 3 5 7 4 2 1","explanation":"Descending values"},{"input":"2 2\\n1 3\\n2 4","expectedOutput":"1 3 2 4","explanation":"Simple 2x2"}],"solution":"#include <iostream>\\nusing namespace std;\\nvoid findDiagonalOrder(int m[][3], int r, int c) { int row=0,col=0,d=1; for(int i=0;i<r*c;i++) { cout<<m[row][col]<<\\" \\"; row-=d; col+=d; if(row>=r) { row=r-1; col+=2; d=-d; } if(col>=c) { col=c-1; row+=2; d=-d; } if(row<0) { row=0; d=-d; } if(col<0) { col=0; d=-d; } } }\\nint main() { int m[][3]={{1,2,3},{4,5,6},{7,8,9}}; findDiagonalOrder(m,3,3); return 0; }","explanation":{"approach":"Track direction, handle bounds.","steps":["Move diagonally","Change direction at boundaries"],"complexity":"Time: O(mn), Space: O(1)"}},{"id":"e255","title":"Spiral Matrix II","description":"Generate spiral matrix.","difficulty":"MEDIUM","category":"Matrix","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid generateMatrix(int n) {}\\nint main() { generateMatrix(3); return 0; }","expectedOutput":"1 2 3 8 9 4 7 6 5","testCases":[{"input":"3","expectedOutput":"1 2 3 8 9 4 7 6 5","explanation":"3x3 spiral"},{"input":"1","expectedOutput":"1","explanation":"Single element"},{"input":"2","expectedOutput":"1 2 4 3","explanation":"2x2 spiral"},{"input":"4","expectedOutput":"1 2 3 4 12 13 14 5 11 16 15 6 10 9 8 7","explanation":"4x4 spiral"},{"input":"5","expectedOutput":"1 2 3 4 5 16 17 18 19 6 15 24 25 20 7 14 23 22 21 8 13 12 11 10 9","explanation":"5x5 spiral"},{"input":"2","expectedOutput":"1 2 4 3","explanation":"Smallest spiral"},{"input":"3","expectedOutput":"1 2 3 8 9 4 7 6 5","explanation":"Standard case"},{"input":"1","expectedOutput":"1","explanation":"Edge case single"},{"input":"4","expectedOutput":"1 2 3 4 12 13 14 5 11 16 15 6 10 9 8 7","explanation":"Even size"},{"input":"3","expectedOutput":"1 2 3 8 9 4 7 6 5","explanation":"Odd size"}],"solution":"#include <iostream>\\nusing namespace std;\\nvoid generateMatrix(int n) { int m[10][10]={}; int t=0,b=n-1,l=0,r=n-1,v=1; while(t<=b&&l<=r) { for(int i=l;i<=r;i++) m[t][i]=v++; t++; for(int i=t;i<=b;i++) m[i][r]=v++; r--; for(int i=r;i>=l;i--) m[b][i]=v++; b--; for(int i=b;i>=t;i--) m[i][l]=v++; l++; } for(int i=0;i<n;i++) for(int j=0;j<n;j++) cout<<m[i][j]<<\\" \\"; }\\nint main() { generateMatrix(3); return 0; }","explanation":{"approach":"Fill layer by layer.","steps":["Fill top, right, bottom, left","Move inward"],"complexity":"Time: O(n), Space: O(n)"}},{"id":"e256","title":"Pascal's Triangle","description":"Generate Pascal's triangle.","difficulty":"EASY","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid generate(int n) {}\\nint main() { generate(5); return 0; }","expectedOutput":"1 1 1 1 2 1 1 3 3 1 1 4 6 4 1","testCases":[{"input":"5","expectedOutput":"1 1 1 1 2 1 1 3 3 1 1 4 6 4 1","explanation":"5 rows of Pascal's triangle"},{"input":"1","expectedOutput":"1","explanation":"Single row"},{"input":"2","expectedOutput":"1 1 1","explanation":"Two rows"},{"input":"3","expectedOutput":"1 1 1 1 2 1","explanation":"Three rows"},{"input":"4","expectedOutput":"1 1 1 1 2 1 1 3 3 1","explanation":"Four rows"},{"input":"6","expectedOutput":"1 1 1 1 2 1 1 3 3 1 1 4 6 4 1 1 5 10 10 5 1","explanation":"Six rows"},{"input":"7","expectedOutput":"1 1 1 1 2 1 1 3 3 1 1 4 6 4 1 1 5 10 10 5 1 1 6 15 20 15 6 1","explanation":"Seven rows"},{"input":"1","expectedOutput":"1","explanation":"Minimum input"},{"input":"2","expectedOutput":"1 1 1","explanation":"Small case"},{"input":"3","expectedOutput":"1 1 1 1 2 1","explanation":"First binomial"}],"solution":"#include <iostream>\\nusing namespace std;\\nvoid generate(int n) { int t[10][10]; for(int i=0;i<n;i++) { t[i][0]=t[i][i]=1; for(int j=1;j<i;j++) t[i][j]=t[i-1][j-1]+t[i-1][j]; for(int j=0;j<=i;j++) cout<<t[i][j]<<\\" \\"; } }\\nint main() { generate(5); return 0; }","explanation":{"approach":"Build row by row.","steps":["First and last are 1","Middle = sum of two above"],"complexity":"Time: O(n), Space: O(n)"}},{"id":"e257","title":"Pascal's Triangle II","description":"Get kth row.","difficulty":"EASY","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid getRow(int k) {}\\nint main() { getRow(3); return 0; }","expectedOutput":"1 3 3 1","testCases":[{"input":"3","expectedOutput":"1 3 3 1","explanation":"Row 3 (0-indexed)"},{"input":"0","expectedOutput":"1","explanation":"First row"},{"input":"1","expectedOutput":"1 1","explanation":"Second row"},{"input":"2","expectedOutput":"1 2 1","explanation":"Third row"},{"input":"4","expectedOutput":"1 4 6 4 1","explanation":"Fifth row"},{"input":"5","expectedOutput":"1 5 10 10 5 1","explanation":"Sixth row"},{"input":"6","expectedOutput":"1 6 15 20 15 6 1","explanation":"Seventh row"},{"input":"7","expectedOutput":"1 7 21 35 35 21 7 1","explanation":"Eighth row"},{"input":"0","expectedOutput":"1","explanation":"Edge case"},{"input":"1","expectedOutput":"1 1","explanation":"Small row"}],"solution":"#include <iostream>\\nusing namespace std;\\nvoid getRow(int k) { int row[k+1]; row[0]=1; for(int i=1;i<=k;i++) { row[i]=1; for(int j=i-1;j>0;j--) row[j]+=row[j-1]; } for(int i=0;i<=k;i++) cout<<row[i]<<\\" \\"; }\\nint main() { getRow(3); return 0; }","explanation":{"approach":"Update row in place.","steps":["Start from end to preserve values","Each value = sum of two above"],"complexity":"Time: O(k), Space: O(k)"}},{"id":"e258","title":"Missing Ranges","description":"Find missing number ranges.","difficulty":"EASY","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid findMissingRanges(int nums[], int n, int lo, int hi) {}\\nint main() { int a[]={0,1,3,50,75}; findMissingRanges(a,5,0,99); return 0; }","expectedOutput":"2 4-49 51-74 76-99","testCases":[{"input":"5 0 99\\n0 1 3 50 75","expectedOutput":"2 4-49 51-74 76-99","explanation":"Standard missing ranges"},{"input":"0 0 5","expectedOutput":"0-5","explanation":"Empty array, full range"},{"input":"1 0 10\\n5","expectedOutput":"0-4 6-10","explanation":"Single element"},{"input":"2 0 5\\n0 5","expectedOutput":"1-4","explanation":"Boundaries present"},{"input":"3 1 10\\n1 5 10","expectedOutput":"2-4 6-9","explanation":"Start and end present"},{"input":"5 0 10\\n0 1 2 3 4","expectedOutput":"5-10","explanation":"Missing at end"},{"input":"5 0 10\\n6 7 8 9 10","expectedOutput":"0-5","explanation":"Missing at start"},{"input":"1 0 0\\n0","expectedOutput":"","explanation":"No missing"},{"input":"2 0 2\\n0 2","expectedOutput":"1","explanation":"Single missing"},{"input":"3 0 5\\n1 2 4","expectedOutput":"0 3 5","explanation":"Multiple singles"}],"solution":"#include <iostream>\\nusing namespace std;\\nvoid findMissingRanges(int nums[], int n, int lo, int hi) { int prev=lo-1; for(int i=0;i<=n;i++) { int cur=i<n?nums[i]:hi+1; if(cur-prev>=2) { if(cur-prev==2) cout<<prev+1<<\\" \\"; else cout<<prev+1<<\\"-\\"<<cur-1<<\\" \\"; } prev=cur; } }\\nint main() { int a[]={0,1,3,50,75}; findMissingRanges(a,5,0,99); return 0; }","explanation":{"approach":"Track gaps.","steps":["Check gap between consecutive","Format as single or range"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"e259","title":"Reverse String Vowels","description":"Reverse only vowels.","difficulty":"EASY","category":"Strings","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid reverseVowels(char s[]) {}\\nint main() { char s[]=\\"hello\\"; reverseVowels(s); cout<<s; return 0; }","expectedOutput":"holle","testCases":[{"input":"hello","expectedOutput":"holle","explanation":"e and o swapped"},{"input":"leetcode","expectedOutput":"leotcede","explanation":"Multiple vowels"},{"input":"aA","expectedOutput":"Aa","explanation":"Case preserved"},{"input":"bcdfg","expectedOutput":"bcdfg","explanation":"No vowels"},{"input":"aeiou","expectedOutput":"uoiea","explanation":"All vowels reversed"},{"input":"a","expectedOutput":"a","explanation":"Single vowel"},{"input":"b","expectedOutput":"b","explanation":"Single consonant"},{"input":"ab","expectedOutput":"ab","explanation":"One vowel stays"},{"input":"ae","expectedOutput":"ea","explanation":"Two vowels swap"},{"input":"AEIOU","expectedOutput":"UOIEA","explanation":"Uppercase vowels"}],"solution":"#include <iostream>\\nusing namespace std;\\nbool isVowel(char c) { return c=='a'||c=='e'||c=='i'||c=='o'||c=='u'||c=='A'||c=='E'||c=='I'||c=='O'||c=='U'; }\\nvoid reverseVowels(char s[]) { int n=0; while(s[n]) n++; int l=0,r=n-1; while(l<r) { while(l<r&&!isVowel(s[l])) l++; while(l<r&&!isVowel(s[r])) r--; swap(s[l++],s[r--]); } }\\nint main() { char s[]=\\"hello\\"; reverseVowels(s); cout<<s; return 0; }","explanation":{"approach":"Two pointers on vowels.","steps":["Find vowels from both ends","Swap them"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"e260","title":"Ransom Note","description":"Can construct from magazine.","difficulty":"EASY","category":"Strings","starterCode":"#include <iostream>\\nusing namespace std;\\nbool canConstruct(char r[], char m[]) { return false; }\\nint main() { cout<<canConstruct(\\"aa\\",\\"aab\\"); return 0; }","expectedOutput":"1","testCases":[{"input":"aa aab","expectedOutput":"1","explanation":"Two a's available"},{"input":"a b","expectedOutput":"0","explanation":"No 'a' in magazine"},{"input":"aa ab","expectedOutput":"0","explanation":"Only one a available"},{"input":"abc abc","expectedOutput":"1","explanation":"Exact match"},{"input":" abc","expectedOutput":"1","explanation":"Empty ransom note"},{"input":"a a","expectedOutput":"1","explanation":"Single char match"},{"input":"ab ba","expectedOutput":"1","explanation":"Same chars different order"},{"input":"aaa aaa","expectedOutput":"1","explanation":"All same"},{"input":"aaab aaba","expectedOutput":"0","explanation":"Need more b's"},{"input":"xyz xyzabc","expectedOutput":"1","explanation":"Subset available"}],"solution":"#include <iostream>\\nusing namespace std;\\nbool canConstruct(char r[], char m[]) { int cnt[26]={}; for(int i=0;m[i];i++) cnt[m[i]-'a']++; for(int i=0;r[i];i++) if(--cnt[r[i]-'a']<0) return false; return true; }\\nint main() { cout<<canConstruct(\\"aa\\",\\"aab\\"); return 0; }","explanation":{"approach":"Count magazine chars.","steps":["Count all magazine letters","Decrement for ransom, fail if negative"],"complexity":"Time: O(m+n), Space: O(26)"}}]`),Wj=JSON.parse(`[{"id":"e301","title":"Count Primes","description":"Count primes less than n.","difficulty":"MEDIUM","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nint countPrimes(int n) { return 0; }\\nint main() { cout<<countPrimes(10); return 0; }","expectedOutput":"4","testCases":[{"input":"10","expectedOutput":"4","explanation":"Primes: 2, 3, 5, 7"},{"input":"0","expectedOutput":"0","explanation":"No primes below 0"},{"input":"1","expectedOutput":"0","explanation":"No primes below 1"},{"input":"2","expectedOutput":"0","explanation":"No primes below 2"},{"input":"3","expectedOutput":"1","explanation":"Only 2"},{"input":"5","expectedOutput":"2","explanation":"2 and 3"},{"input":"20","expectedOutput":"8","explanation":"2,3,5,7,11,13,17,19"},{"input":"100","expectedOutput":"25","explanation":"25 primes below 100"},{"input":"11","expectedOutput":"4","explanation":"2,3,5,7"},{"input":"13","expectedOutput":"5","explanation":"2,3,5,7,11"}],"solution":"#include <iostream>\\nusing namespace std;\\nint countPrimes(int n) { if(n<=2) return 0; bool np[n]={}; int cnt=0; for(int i=2;i<n;i++) { if(!np[i]) { cnt++; for(int j=i*2;j<n;j+=i) np[j]=true; } } return cnt; }\\nint main() { cout<<countPrimes(10); return 0; }","explanation":{"approach":"Sieve of Eratosthenes.","steps":["Mark multiples as not prime","Count unmarked"],"complexity":"Time: O(n log log n), Space: O(n)"}},{"id":"e302","title":"Power of Three","description":"Check if power of 3.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isPowerOfThree(int n) { return false; }\\nint main() { cout<<isPowerOfThree(27); return 0; }","expectedOutput":"1","testCases":[{"input":"27","expectedOutput":"1","explanation":"3^3 = 27"},{"input":"0","expectedOutput":"0","explanation":"0 is not power of 3"},{"input":"1","expectedOutput":"1","explanation":"3^0 = 1"},{"input":"3","expectedOutput":"1","explanation":"3^1 = 3"},{"input":"9","expectedOutput":"1","explanation":"3^2 = 9"},{"input":"81","expectedOutput":"1","explanation":"3^4 = 81"},{"input":"10","expectedOutput":"0","explanation":"Not a power of 3"},{"input":"12","expectedOutput":"0","explanation":"12 = 3*4"},{"input":"-3","expectedOutput":"0","explanation":"Negative not valid"},{"input":"243","expectedOutput":"1","explanation":"3^5 = 243"}],"solution":"#include <iostream>\\nusing namespace std;\\nbool isPowerOfThree(int n) { if(n<=0) return false; while(n%3==0) n/=3; return n==1; }\\nint main() { cout<<isPowerOfThree(27); return 0; }","explanation":{"approach":"Divide repeatedly.","steps":["While divisible by 3, divide","Check if result is 1"],"complexity":"Time: O(log n), Space: O(1)"}},{"id":"e303","title":"Power of Four","description":"Check if power of 4.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isPowerOfFour(int n) { return false; }\\nint main() { cout<<isPowerOfFour(16); return 0; }","expectedOutput":"1","testCases":[{"input":"16","expectedOutput":"1","explanation":"4^2 = 16"},{"input":"0","expectedOutput":"0","explanation":"0 is not power of 4"},{"input":"1","expectedOutput":"1","explanation":"4^0 = 1"},{"input":"4","expectedOutput":"1","explanation":"4^1 = 4"},{"input":"64","expectedOutput":"1","explanation":"4^3 = 64"},{"input":"256","expectedOutput":"1","explanation":"4^4 = 256"},{"input":"8","expectedOutput":"0","explanation":"8 = 2^3, not power of 4"},{"input":"2","expectedOutput":"0","explanation":"2 is not power of 4"},{"input":"-4","expectedOutput":"0","explanation":"Negative not valid"},{"input":"1024","expectedOutput":"1","explanation":"4^5 = 1024"}],"solution":"#include <iostream>\\nusing namespace std;\\nbool isPowerOfFour(int n) { return n>0 && (n&(n-1))==0 && (n&0x55555555)!=0; }\\nint main() { cout<<isPowerOfFour(16); return 0; }","explanation":{"approach":"Bit manipulation.","steps":["Must be power of 2","1 bit must be in odd position"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"e304","title":"Add Digits","description":"Add digits until single.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nint addDigits(int num) { return 0; }\\nint main() { cout<<addDigits(38); return 0; }","expectedOutput":"2","testCases":[{"input":"38","expectedOutput":"2","explanation":"3+8=11, 1+1=2"},{"input":"0","expectedOutput":"0","explanation":"Already single digit"},{"input":"9","expectedOutput":"9","explanation":"Already single digit"},{"input":"10","expectedOutput":"1","explanation":"1+0=1"},{"input":"18","expectedOutput":"9","explanation":"1+8=9"},{"input":"99","expectedOutput":"9","explanation":"9+9=18, 1+8=9"},{"input":"123","expectedOutput":"6","explanation":"1+2+3=6"},{"input":"999","expectedOutput":"9","explanation":"Digital root of 9"},{"input":"1","expectedOutput":"1","explanation":"Single digit"},{"input":"100","expectedOutput":"1","explanation":"1+0+0=1"}],"solution":"#include <iostream>\\nusing namespace std;\\nint addDigits(int num) { if(num==0) return 0; if(num%9==0) return 9; return num%9; }\\nint main() { cout<<addDigits(38); return 0; }","explanation":{"approach":"Digital root formula.","steps":["Result is num % 9","Special case for 0 and multiples of 9"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"e305","title":"Ugly Number","description":"Check if ugly (2,3,5 factors only).","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isUgly(int n) { return false; }\\nint main() { cout<<isUgly(6); return 0; }","expectedOutput":"1","testCases":[{"input":"6","expectedOutput":"1","explanation":"6 = 2  3"},{"input":"1","expectedOutput":"1","explanation":"1 is ugly"},{"input":"0","expectedOutput":"0","explanation":"0 is not ugly"},{"input":"14","expectedOutput":"0","explanation":"14 = 2  7"},{"input":"8","expectedOutput":"1","explanation":"8 = 2^3"},{"input":"9","expectedOutput":"1","explanation":"9 = 3^2"},{"input":"10","expectedOutput":"1","explanation":"10 = 2  5"},{"input":"30","expectedOutput":"1","explanation":"30 = 2  3  5"},{"input":"-1","expectedOutput":"0","explanation":"Negative not ugly"},{"input":"7","expectedOutput":"0","explanation":"7 is prime, not 2,3,5"}],"solution":"#include <iostream>\\nusing namespace std;\\nbool isUgly(int n) { if(n<=0) return false; while(n%2==0) n/=2; while(n%3==0) n/=3; while(n%5==0) n/=5; return n==1; }\\nint main() { cout<<isUgly(6); return 0; }","explanation":{"approach":"Divide by 2,3,5.","steps":["Remove all 2s, 3s, 5s","Check if result is 1"],"complexity":"Time: O(log n), Space: O(1)"}},{"id":"e306","title":"Happy Number","description":"Check if reaches 1.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isHappy(int n) { return false; }\\nint main() { cout<<isHappy(19); return 0; }","expectedOutput":"1","testCases":[{"input":"19","expectedOutput":"1","explanation":"1+9=82...1"},{"input":"2","expectedOutput":"0","explanation":"Enters cycle, never 1"},{"input":"1","expectedOutput":"1","explanation":"Already 1"},{"input":"7","expectedOutput":"1","explanation":"7 is happy"},{"input":"10","expectedOutput":"1","explanation":"1+0=1"},{"input":"100","expectedOutput":"1","explanation":"1+0+0=1"},{"input":"4","expectedOutput":"0","explanation":"Enters cycle"},{"input":"13","expectedOutput":"1","explanation":"1+9=101"},{"input":"23","expectedOutput":"1","explanation":"Happy number"},{"input":"20","expectedOutput":"0","explanation":"Not happy"}],"solution":"#include <iostream>\\nusing namespace std;\\nint sumSquares(int n) { int s=0; while(n) { int d=n%10; s+=d*d; n/=10; } return s; }\\nbool isHappy(int n) { int slow=n,fast=n; do { slow=sumSquares(slow); fast=sumSquares(sumSquares(fast)); } while(slow!=fast); return slow==1; }\\nint main() { cout<<isHappy(19); return 0; }","explanation":{"approach":"Floyd's cycle detection.","steps":["Sum squares of digits","Detect cycle or reach 1"],"complexity":"Time: O(log n), Space: O(1)"}},{"id":"e307","title":"Excel Sheet Column","description":"Column title to number.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nint titleToNumber(char s[]) { return 0; }\\nint main() { cout<<titleToNumber(\\"AB\\"); return 0; }","expectedOutput":"28","testCases":[{"input":"AB","expectedOutput":"28","explanation":"A=1, B=2  126+2=28"},{"input":"A","expectedOutput":"1","explanation":"Single A = 1"},{"input":"Z","expectedOutput":"26","explanation":"Z = 26"},{"input":"AA","expectedOutput":"27","explanation":"26+1 = 27"},{"input":"AZ","expectedOutput":"52","explanation":"26+26 = 52"},{"input":"ZZ","expectedOutput":"702","explanation":"2626+26"},{"input":"BA","expectedOutput":"53","explanation":"226+1 = 53"},{"input":"AAA","expectedOutput":"703","explanation":"26+26+1"},{"input":"B","expectedOutput":"2","explanation":"Single B = 2"},{"input":"ZA","expectedOutput":"677","explanation":"2626+1"}],"solution":"#include <iostream>\\nusing namespace std;\\nint titleToNumber(char s[]) { int r=0; for(int i=0;s[i];i++) r=r*26+(s[i]-'A'+1); return r; }\\nint main() { cout<<titleToNumber(\\"AB\\"); return 0; }","explanation":{"approach":"Base 26 conversion.","steps":["Process each character","Multiply by 26 and add value"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"e308","title":"Excel Column Title","description":"Number to column title.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid convertToTitle(int n) {}\\nint main() { convertToTitle(28); return 0; }","expectedOutput":"AB","testCases":[{"input":"28","expectedOutput":"AB","explanation":"28  AB"},{"input":"1","expectedOutput":"A","explanation":"1  A"},{"input":"26","expectedOutput":"Z","explanation":"26  Z"},{"input":"27","expectedOutput":"AA","explanation":"27  AA"},{"input":"52","expectedOutput":"AZ","explanation":"52  AZ"},{"input":"701","expectedOutput":"ZY","explanation":"701  ZY"},{"input":"702","expectedOutput":"ZZ","explanation":"702  ZZ"},{"input":"703","expectedOutput":"AAA","explanation":"703  AAA"},{"input":"2","expectedOutput":"B","explanation":"2  B"},{"input":"53","expectedOutput":"BA","explanation":"53  BA"}],"solution":"#include <iostream>\\nusing namespace std;\\nvoid convertToTitle(int n) { char res[10]; int i=0; while(n>0) { n--; res[i++]='A'+n%26; n/=26; } for(int j=i-1;j>=0;j--) cout<<res[j]; }\\nint main() { convertToTitle(28); return 0; }","explanation":{"approach":"Base 26 conversion.","steps":["Extract remainder","Build string in reverse"],"complexity":"Time: O(log n), Space: O(log n)"}},{"id":"e309","title":"Factorial Trailing Zeroes","description":"Count trailing zeros in n!.","difficulty":"MEDIUM","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nint trailingZeroes(int n) { return 0; }\\nint main() { cout<<trailingZeroes(25); return 0; }","expectedOutput":"6","testCases":[{"input":"25","expectedOutput":"6","explanation":"25/5=5, 25/25=1  5+1=6"},{"input":"0","expectedOutput":"0","explanation":"0! = 1, no zeros"},{"input":"5","expectedOutput":"1","explanation":"5! = 120, one zero"},{"input":"10","expectedOutput":"2","explanation":"10! has 2 trailing zeros"},{"input":"4","expectedOutput":"0","explanation":"4! = 24, no zeros"},{"input":"100","expectedOutput":"24","explanation":"100/5+100/25=24"},{"input":"125","expectedOutput":"31","explanation":"25+5+1=31"},{"input":"1","expectedOutput":"0","explanation":"1! = 1"},{"input":"20","expectedOutput":"4","explanation":"20/5=4"},{"input":"50","expectedOutput":"12","explanation":"10+2=12"}],"solution":"#include <iostream>\\nusing namespace std;\\nint trailingZeroes(int n) { int cnt=0; while(n>=5) { n/=5; cnt+=n; } return cnt; }\\nint main() { cout<<trailingZeroes(25); return 0; }","explanation":{"approach":"Count factors of 5.","steps":["Each 5 contributes to a 0","Count n/5 + n/25 + ..."],"complexity":"Time: O(log n), Space: O(1)"}},{"id":"e310","title":"Sqrt(x)","description":"Integer square root.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nint mySqrt(int x) { return 0; }\\nint main() { cout<<mySqrt(8); return 0; }","expectedOutput":"2","testCases":[{"input":"8","expectedOutput":"2","explanation":"8  2.83, floor = 2"},{"input":"0","expectedOutput":"0","explanation":"0 = 0"},{"input":"1","expectedOutput":"1","explanation":"1 = 1"},{"input":"4","expectedOutput":"2","explanation":"4 = 2 exactly"},{"input":"9","expectedOutput":"3","explanation":"9 = 3 exactly"},{"input":"16","expectedOutput":"4","explanation":"16 = 4"},{"input":"2","expectedOutput":"1","explanation":"2  1.41"},{"input":"100","expectedOutput":"10","explanation":"100 = 10"},{"input":"15","expectedOutput":"3","explanation":"15  3.87"},{"input":"2147395600","expectedOutput":"46340","explanation":"Large perfect square"}],"solution":"#include <iostream>\\nusing namespace std;\\nint mySqrt(int x) { if(x==0) return 0; long l=1,r=x; while(l<=r) { long m=(l+r)/2; if(m*m==x) return m; if(m*m<x) l=m+1; else r=m-1; } return r; }\\nint main() { cout<<mySqrt(8); return 0; }","explanation":{"approach":"Binary search.","steps":["Search for largest m where mx"],"complexity":"Time: O(log x), Space: O(1)"}}]`),Kj=JSON.parse(`[{"id":"easy85","title":"Hollow Diamond","description":"Print hollow diamond.","difficulty":"EASY","category":"Patterns","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid hollowDiamond(int n) {}\\nint main() { hollowDiamond(3); return 0; }","expectedOutput":"  *\\n * *\\n*   *\\n * *\\n  *","testCases":[{"input":"3","expectedOutput":"  *\\n * *\\n*   *\\n * *\\n  *","explanation":"Hollow diamond with n=3"},{"input":"1","expectedOutput":"*","explanation":"n=1 is just a single star"},{"input":"2","expectedOutput":" *\\n* *\\n *","explanation":"Minimal hollow diamond"},{"input":"4","expectedOutput":"   *\\n  * *\\n *   *\\n*     *\\n *   *\\n  * *\\n   *","explanation":"Larger hollow diamond"},{"input":"5","expectedOutput":"    *\\n   * *\\n  *   *\\n *     *\\n*       *\\n *     *\\n  *   *\\n   * *\\n    *","explanation":"n=5 hollow diamond"},{"input":"3","expectedOutput":"  *\\n * *\\n*   *\\n * *\\n  *","explanation":"Standard case"},{"input":"2","expectedOutput":" *\\n* *\\n *","explanation":"Small diamond"},{"input":"4","expectedOutput":"   *\\n  * *\\n *   *\\n*     *\\n *   *\\n  * *\\n   *","explanation":"Medium diamond"},{"input":"1","expectedOutput":"*","explanation":"Edge case single"},{"input":"3","expectedOutput":"  *\\n * *\\n*   *\\n * *\\n  *","explanation":"Hollow outline"}],"solution":"#include <iostream>\\nusing namespace std;\\nvoid hollowDiamond(int n) { for(int i=1;i<=n;i++) { for(int j=0;j<n-i;j++) cout<<\\" \\"; cout<<\\"*\\"; if(i>1) { for(int j=0;j<2*i-3;j++) cout<<\\" \\"; cout<<\\"*\\"; } cout<<\\"\\\\n\\"; } for(int i=n-1;i>=1;i--) { for(int j=0;j<n-i;j++) cout<<\\" \\"; cout<<\\"*\\"; if(i>1) { for(int j=0;j<2*i-3;j++) cout<<\\" \\"; cout<<\\"*\\"; } if(i>1) cout<<\\"\\\\n\\"; } }\\nint main() { hollowDiamond(3); return 0; }","explanation":{"approach":"Only edges of diamond.","analogy":"Outline of diamond.","steps":["First and last star of each row"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"easy86","title":"Alphabet Pattern","description":"Print A to Z pattern.","difficulty":"EASY","category":"Patterns","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid alphabetPattern(int n) {}\\nint main() { alphabetPattern(4); return 0; }","expectedOutput":"A\\nA B\\nA B C\\nA B C D","testCases":[{"input":"4","expectedOutput":"A\\nA B\\nA B C\\nA B C D","explanation":"4 rows of increasing letters"},{"input":"1","expectedOutput":"A","explanation":"Single A"},{"input":"2","expectedOutput":"A\\nA B","explanation":"Two rows"},{"input":"3","expectedOutput":"A\\nA B\\nA B C","explanation":"Three rows"},{"input":"5","expectedOutput":"A\\nA B\\nA B C\\nA B C D\\nA B C D E","explanation":"Five rows"},{"input":"6","expectedOutput":"A\\nA B\\nA B C\\nA B C D\\nA B C D E\\nA B C D E F","explanation":"Six rows"},{"input":"1","expectedOutput":"A","explanation":"Minimum input"},{"input":"2","expectedOutput":"A\\nA B","explanation":"Edge case"},{"input":"3","expectedOutput":"A\\nA B\\nA B C","explanation":"Standard case"},{"input":"4","expectedOutput":"A\\nA B\\nA B C\\nA B C D","explanation":"Typical pattern"}],"solution":"#include <iostream>\\nusing namespace std;\\nvoid alphabetPattern(int n) { for(int i=0;i<n;i++) { for(int j=0;j<=i;j++) cout<<(char)('A'+j)<<\\" \\"; if(i<n-1) cout<<\\"\\\\n\\"; } }\\nint main() { alphabetPattern(4); return 0; }","explanation":{"approach":"Letters increasing per row.","analogy":"A to alphabet.","steps":["Row i prints A to (A+i)"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"easy87","title":"Butterfly Pattern","description":"Print butterfly.","difficulty":"EASY","category":"Patterns","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid butterfly(int n) {}\\nint main() { butterfly(3); return 0; }","expectedOutput":"*    *\\n**  **\\n******\\n**  **\\n*    *","testCases":[{"input":"3","expectedOutput":"*    *\\n**  **\\n******\\n**  **\\n*    *","explanation":"Butterfly with n=3"},{"input":"1","expectedOutput":"**\\n**","explanation":"Minimal butterfly"},{"input":"2","expectedOutput":"*  *\\n****\\n****\\n*  *","explanation":"Small butterfly"},{"input":"4","expectedOutput":"*      *\\n**    **\\n***  ***\\n********\\n***  ***\\n**    **\\n*      *","explanation":"Larger butterfly"},{"input":"3","expectedOutput":"*    *\\n**  **\\n******\\n**  **\\n*    *","explanation":"Standard butterfly"},{"input":"2","expectedOutput":"*  *\\n****\\n****\\n*  *","explanation":"Two-wide wings"},{"input":"4","expectedOutput":"*      *\\n**    **\\n***  ***\\n********\\n***  ***\\n**    **\\n*      *","explanation":"Four-wide wings"},{"input":"1","expectedOutput":"**\\n**","explanation":"Edge case"},{"input":"3","expectedOutput":"*    *\\n**  **\\n******\\n**  **\\n*    *","explanation":"Symmetric pattern"},{"input":"2","expectedOutput":"*  *\\n****\\n****\\n*  *","explanation":"Mirror image"}],"solution":"#include <iostream>\\nusing namespace std;\\nvoid butterfly(int n) { for(int i=1;i<=n;i++) { for(int j=0;j<i;j++) cout<<\\"*\\"; for(int j=0;j<2*(n-i);j++) cout<<\\" \\"; for(int j=0;j<i;j++) cout<<\\"*\\"; cout<<\\"\\\\n\\"; } for(int i=n-1;i>=1;i--) { for(int j=0;j<i;j++) cout<<\\"*\\"; for(int j=0;j<2*(n-i);j++) cout<<\\" \\"; for(int j=0;j<i;j++) cout<<\\"*\\"; if(i>1) cout<<\\"\\\\n\\"; } }\\nint main() { butterfly(3); return 0; }","explanation":{"approach":"Two triangles mirrored.","analogy":"Wings of butterfly.","steps":["Upper: expand","Lower: contract"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"easy88","title":"Smallest of Three","description":"Find smallest of 3 numbers.","difficulty":"EASY","category":"Basic","starterCode":"#include <iostream>\\nusing namespace std;\\nint smallest(int a, int b, int c) { return 0; }\\nint main() { cout<<smallest(5,3,8); return 0; }","expectedOutput":"3","testCases":[{"input":"5 3 8","expectedOutput":"3","explanation":"3 is smallest"},{"input":"1 2 3","expectedOutput":"1","explanation":"First is smallest"},{"input":"3 2 1","expectedOutput":"1","explanation":"Last is smallest"},{"input":"2 1 3","expectedOutput":"1","explanation":"Middle is smallest"},{"input":"5 5 5","expectedOutput":"5","explanation":"All equal"},{"input":"-1 -2 -3","expectedOutput":"-3","explanation":"Negatives: -3 smallest"},{"input":"0 1 -1","expectedOutput":"-1","explanation":"Mixed signs"},{"input":"100 200 50","expectedOutput":"50","explanation":"Larger values"},{"input":"1 1 2","expectedOutput":"1","explanation":"Two same smallest"},{"input":"-5 0 5","expectedOutput":"-5","explanation":"Wide range"}],"solution":"#include <iostream>\\nusing namespace std;\\nint smallest(int a, int b, int c) { int m=a; if(b<m) m=b; if(c<m) m=c; return m; }\\nint main() { cout<<smallest(5,3,8); return 0; }","explanation":{"approach":"Compare and track minimum.","analogy":"Find smallest among three.","steps":["Assume first is min","Update if others smaller"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"easy89","title":"Largest of Three","description":"Find largest of 3 numbers.","difficulty":"EASY","category":"Basic","starterCode":"#include <iostream>\\nusing namespace std;\\nint largest(int a, int b, int c) { return 0; }\\nint main() { cout<<largest(5,3,8); return 0; }","expectedOutput":"8","testCases":[{"input":"5 3 8","expectedOutput":"8","explanation":"8 is largest"},{"input":"1 2 3","expectedOutput":"3","explanation":"Last is largest"},{"input":"3 2 1","expectedOutput":"3","explanation":"First is largest"},{"input":"2 3 1","expectedOutput":"3","explanation":"Middle is largest"},{"input":"5 5 5","expectedOutput":"5","explanation":"All equal"},{"input":"-1 -2 -3","expectedOutput":"-1","explanation":"Negatives: -1 largest"},{"input":"0 1 -1","expectedOutput":"1","explanation":"Mixed signs"},{"input":"100 200 150","expectedOutput":"200","explanation":"Larger values"},{"input":"1 2 2","expectedOutput":"2","explanation":"Two same largest"},{"input":"-5 0 5","expectedOutput":"5","explanation":"Wide range"}],"solution":"#include <iostream>\\nusing namespace std;\\nint largest(int a, int b, int c) { int m=a; if(b>m) m=b; if(c>m) m=c; return m; }\\nint main() { cout<<largest(5,3,8); return 0; }","explanation":{"approach":"Compare and track maximum.","analogy":"Find largest among three.","steps":["Assume first is max","Update if others larger"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"easy90","title":"Swap Two Numbers","description":"Swap without temp.","difficulty":"EASY","category":"Basic","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid swap(int &a, int &b) {}\\nint main() { int a=5,b=10; swap(a,b); cout<<a<<\\" \\"<<b; return 0; }","expectedOutput":"10 5","testCases":[{"input":"5 10","expectedOutput":"10 5","explanation":"Swap 5 and 10"},{"input":"1 2","expectedOutput":"2 1","explanation":"Swap 1 and 2"},{"input":"0 0","expectedOutput":"0 0","explanation":"Both zero"},{"input":"-1 1","expectedOutput":"1 -1","explanation":"Opposite signs"},{"input":"100 200","expectedOutput":"200 100","explanation":"Larger values"},{"input":"5 5","expectedOutput":"5 5","explanation":"Same values"},{"input":"-10 -20","expectedOutput":"-20 -10","explanation":"Both negative"},{"input":"0 100","expectedOutput":"100 0","explanation":"Zero and positive"},{"input":"999 1","expectedOutput":"1 999","explanation":"Large difference"},{"input":"7 3","expectedOutput":"3 7","explanation":"Simple swap"}],"solution":"#include <iostream>\\nusing namespace std;\\nvoid myswap(int &a, int &b) { a=a+b; b=a-b; a=a-b; }\\nint main() { int a=5,b=10; myswap(a,b); cout<<a<<\\" \\"<<b; return 0; }","explanation":{"approach":"Use arithmetic to swap.","analogy":"Store sum, extract values.","steps":["a = a + b","b = a - b (original a)","a = a - b (original b)"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"easy91","title":"Middle of Three","description":"Find middle value.","difficulty":"EASY","category":"Basic","starterCode":"#include <iostream>\\nusing namespace std;\\nint middle(int a, int b, int c) { return 0; }\\nint main() { cout<<middle(5,8,3); return 0; }","expectedOutput":"5","testCases":[{"input":"5 8 3","expectedOutput":"5","explanation":"3<5<8, so 5"},{"input":"1 2 3","expectedOutput":"2","explanation":"Middle is 2"},{"input":"3 2 1","expectedOutput":"2","explanation":"Still 2"},{"input":"1 3 2","expectedOutput":"2","explanation":"2 in middle"},{"input":"5 5 5","expectedOutput":"5","explanation":"All equal"},{"input":"-1 0 1","expectedOutput":"0","explanation":"Zero is middle"},{"input":"10 5 7","expectedOutput":"7","explanation":"5<7<10"},{"input":"100 50 75","expectedOutput":"75","explanation":"50<75<100"},{"input":"-5 -10 -7","expectedOutput":"-7","explanation":"-10<-7<-5"},{"input":"1 1 2","expectedOutput":"1","explanation":"Duplicate min"}],"solution":"#include <iostream>\\nusing namespace std;\\nint middle(int a, int b, int c) { if((a>=b && a<=c)||(a<=b && a>=c)) return a; if((b>=a && b<=c)||(b<=a && b>=c)) return b; return c; }\\nint main() { cout<<middle(5,8,3); return 0; }","explanation":{"approach":"Check which is between others.","analogy":"Not min, not max.","steps":["Check if a is middle","Check if b is middle","Else c"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"easy92","title":"Absolute Value","description":"Get absolute value.","difficulty":"EASY","category":"Basic","starterCode":"#include <iostream>\\nusing namespace std;\\nint absolute(int n) { return 0; }\\nint main() { cout<<absolute(-5); return 0; }","expectedOutput":"5","testCases":[{"input":"-5","expectedOutput":"5","explanation":"|-5| = 5"},{"input":"5","expectedOutput":"5","explanation":"|5| = 5"},{"input":"0","expectedOutput":"0","explanation":"|0| = 0"},{"input":"-1","expectedOutput":"1","explanation":"|-1| = 1"},{"input":"1","expectedOutput":"1","explanation":"|1| = 1"},{"input":"-100","expectedOutput":"100","explanation":"Large negative"},{"input":"100","expectedOutput":"100","explanation":"Large positive"},{"input":"-999","expectedOutput":"999","explanation":"Three digit negative"},{"input":"-1000000","expectedOutput":"1000000","explanation":"Very large"},{"input":"42","expectedOutput":"42","explanation":"Positive unchanged"}],"solution":"#include <iostream>\\nusing namespace std;\\nint absolute(int n) { return n<0?-n:n; }\\nint main() { cout<<absolute(-5); return 0; }","explanation":{"approach":"Negate if negative.","analogy":"Distance from zero.","steps":["If negative, multiply by -1"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"easy93","title":"Average of Array","description":"Calculate average.","difficulty":"EASY","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\ndouble average(int a[], int n) { return 0; }\\nint main() { int a[]={10,20,30,40,50}; cout<<average(a,5); return 0; }","expectedOutput":"30","testCases":[{"input":"5\\n10 20 30 40 50","expectedOutput":"30","explanation":"150/5 = 30"},{"input":"1\\n10","expectedOutput":"10","explanation":"Single element"},{"input":"2\\n0 0","expectedOutput":"0","explanation":"All zeros"},{"input":"3\\n1 2 3","expectedOutput":"2","explanation":"Exact average"},{"input":"4\\n2 4 6 8","expectedOutput":"5","explanation":"20/4 = 5"},{"input":"5\\n5 5 5 5 5","expectedOutput":"5","explanation":"All same"},{"input":"3\\n-3 0 3","expectedOutput":"0","explanation":"Cancel to zero"},{"input":"2\\n1 3","expectedOutput":"2","explanation":"Simple average"},{"input":"4\\n100 200 300 400","expectedOutput":"250","explanation":"Large values"},{"input":"3\\n10 20 30","expectedOutput":"20","explanation":"Arithmetic mean"}],"solution":"#include <iostream>\\nusing namespace std;\\ndouble average(int a[], int n) { int s=0; for(int i=0;i<n;i++) s+=a[i]; return (double)s/n; }\\nint main() { int a[]={10,20,30,40,50}; cout<<average(a,5); return 0; }","explanation":{"approach":"Sum divided by count.","analogy":"Mean value.","steps":["Sum all elements","Divide by n"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"easy94","title":"Product of Array","description":"Multiply all elements.","difficulty":"EASY","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nint product(int a[], int n) { return 0; }\\nint main() { int a[]={1,2,3,4,5}; cout<<product(a,5); return 0; }","expectedOutput":"120","testCases":[{"input":"5\\n1 2 3 4 5","expectedOutput":"120","explanation":"5! = 120"},{"input":"1\\n7","expectedOutput":"7","explanation":"Single element"},{"input":"3\\n2 3 4","expectedOutput":"24","explanation":"234 = 24"},{"input":"4\\n1 1 1 1","expectedOutput":"1","explanation":"All ones"},{"input":"3\\n0 5 10","expectedOutput":"0","explanation":"Zero makes product 0"},{"input":"2\\n10 10","expectedOutput":"100","explanation":"1010 = 100"},{"input":"4\\n2 2 2 2","expectedOutput":"16","explanation":"2^4 = 16"},{"input":"3\\n-1 2 3","expectedOutput":"-6","explanation":"Negative result"},{"input":"2\\n-2 -3","expectedOutput":"6","explanation":"Two negatives"},{"input":"5\\n1 2 1 2 1","expectedOutput":"4","explanation":"Mixed 1s and 2s"}],"solution":"#include <iostream>\\nusing namespace std;\\nint product(int a[], int n) { int p=1; for(int i=0;i<n;i++) p*=a[i]; return p; }\\nint main() { int a[]={1,2,3,4,5}; cout<<product(a,5); return 0; }","explanation":{"approach":"Multiply all elements.","analogy":"Factorial-like product.","steps":["Start with 1","Multiply each element"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"easy95","title":"Count Evens","description":"Count even numbers.","difficulty":"EASY","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nint countEvens(int a[], int n) { return 0; }\\nint main() { int a[]={1,2,3,4,5,6}; cout<<countEvens(a,6); return 0; }","expectedOutput":"3","testCases":[{"input":"6\\n1 2 3 4 5 6","expectedOutput":"3","explanation":"2, 4, 6 are even"},{"input":"5\\n1 3 5 7 9","expectedOutput":"0","explanation":"No evens"},{"input":"5\\n2 4 6 8 10","expectedOutput":"5","explanation":"All even"},{"input":"1\\n2","expectedOutput":"1","explanation":"Single even"},{"input":"1\\n1","expectedOutput":"0","explanation":"Single odd"},{"input":"4\\n0 0 0 0","expectedOutput":"4","explanation":"Zero is even"},{"input":"3\\n-2 -4 -6","expectedOutput":"3","explanation":"Negative evens"},{"input":"4\\n-1 -2 1 2","expectedOutput":"2","explanation":"Mixed signs"},{"input":"6\\n1 1 1 1 1 1","expectedOutput":"0","explanation":"All odd"},{"input":"3\\n100 200 301","expectedOutput":"2","explanation":"Large values"}],"solution":"#include <iostream>\\nusing namespace std;\\nint countEvens(int a[], int n) { int c=0; for(int i=0;i<n;i++) if(a[i]%2==0) c++; return c; }\\nint main() { int a[]={1,2,3,4,5,6}; cout<<countEvens(a,6); return 0; }","explanation":{"approach":"Count elements divisible by 2.","analogy":"How many are even?","steps":["Check each if % 2 == 0"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"easy96","title":"Count Odds","description":"Count odd numbers.","difficulty":"EASY","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nint countOdds(int a[], int n) { return 0; }\\nint main() { int a[]={1,2,3,4,5,6}; cout<<countOdds(a,6); return 0; }","expectedOutput":"3","testCases":[{"input":"6\\n1 2 3 4 5 6","expectedOutput":"3","explanation":"1, 3, 5 are odd"},{"input":"5\\n1 3 5 7 9","expectedOutput":"5","explanation":"All odd"},{"input":"5\\n2 4 6 8 10","expectedOutput":"0","explanation":"No odds"},{"input":"1\\n1","expectedOutput":"1","explanation":"Single odd"},{"input":"1\\n2","expectedOutput":"0","explanation":"Single even"},{"input":"4\\n0 0 0 0","expectedOutput":"0","explanation":"Zero is even"},{"input":"3\\n-1 -3 -5","expectedOutput":"3","explanation":"Negative odds"},{"input":"4\\n-1 -2 1 2","expectedOutput":"2","explanation":"Mixed signs"},{"input":"6\\n2 2 2 2 2 2","expectedOutput":"0","explanation":"All even"},{"input":"3\\n101 201 301","expectedOutput":"3","explanation":"Large odd values"}],"solution":"#include <iostream>\\nusing namespace std;\\nint countOdds(int a[], int n) { int c=0; for(int i=0;i<n;i++) if(a[i]%2!=0) c++; return c; }\\nint main() { int a[]={1,2,3,4,5,6}; cout<<countOdds(a,6); return 0; }","explanation":{"approach":"Count elements not divisible by 2.","analogy":"How many are odd?","steps":["Check each if % 2 != 0"],"complexity":"Time: O(n), Space: O(1)"}}]`),Xj=JSON.parse(`[{"id":"e401","title":"Binary Search","description":"Find target in sorted array.","difficulty":"EASY","category":"Binary Search","starterCode":"#include <iostream>\\nusing namespace std;\\nint search(int nums[], int n, int target) { return -1; }\\nint main() { int a[]={-1,0,3,5,9,12}; cout<<search(a,6,9); return 0; }","expectedOutput":"4","testCases":[{"input":"6 9\\n-1 0 3 5 9 12","expectedOutput":"4","explanation":"9 is at index 4"},{"input":"6 2\\n-1 0 3 5 9 12","expectedOutput":"-1","explanation":"2 not found"},{"input":"1 5\\n5","expectedOutput":"0","explanation":"Single element found"},{"input":"1 3\\n5","expectedOutput":"-1","explanation":"Single element not found"},{"input":"5 1\\n1 2 3 4 5","expectedOutput":"0","explanation":"First element"},{"input":"5 5\\n1 2 3 4 5","expectedOutput":"4","explanation":"Last element"},{"input":"5 3\\n1 2 3 4 5","expectedOutput":"2","explanation":"Middle element"},{"input":"6 -1\\n-1 0 3 5 9 12","expectedOutput":"0","explanation":"Negative target"},{"input":"4 0\\n-5 -2 0 3","expectedOutput":"2","explanation":"Zero in array"},{"input":"3 100\\n1 50 100","expectedOutput":"2","explanation":"Large value"}],"solution":"#include <iostream>\\nusing namespace std;\\nint search(int nums[], int n, int target) { int l=0,r=n-1; while(l<=r) { int m=(l+r)/2; if(nums[m]==target) return m; if(nums[m]<target) l=m+1; else r=m-1; } return -1; }\\nint main() { int a[]={-1,0,3,5,9,12}; cout<<search(a,6,9); return 0; }","explanation":{"approach":"Binary search.","steps":["Compare middle with target","Narrow search range"],"complexity":"Time: O(log n), Space: O(1)"}},{"id":"e402","title":"First Bad Version","description":"Find first bad version.","difficulty":"EASY","category":"Binary Search","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isBadVersion(int v) { return v>=4; }\\nint firstBadVersion(int n) { return 0; }\\nint main() { cout<<firstBadVersion(5); return 0; }","expectedOutput":"4","testCases":[{"input":"5","expectedOutput":"4","explanation":"First bad is 4"},{"input":"1","expectedOutput":"1","explanation":"Only one version, it's bad"},{"input":"10","expectedOutput":"4","explanation":"Bad from version 4"},{"input":"100","expectedOutput":"4","explanation":"Large n, bad at 4"},{"input":"4","expectedOutput":"4","explanation":"Exactly at boundary"},{"input":"3","expectedOutput":"-1","explanation":"No bad version"},{"input":"6","expectedOutput":"4","explanation":"Mid case"},{"input":"2","expectedOutput":"-1","explanation":"All good"},{"input":"50","expectedOutput":"4","explanation":"Larger range"},{"input":"1000","expectedOutput":"4","explanation":"Very large n"}],"solution":"#include <iostream>\\nusing namespace std;\\nbool isBadVersion(int v) { return v>=4; }\\nint firstBadVersion(int n) { int l=1,r=n; while(l<r) { int m=l+(r-l)/2; if(isBadVersion(m)) r=m; else l=m+1; } return l; }\\nint main() { cout<<firstBadVersion(5); return 0; }","explanation":{"approach":"Binary search for first.","steps":["If bad, search left","Else search right"],"complexity":"Time: O(log n), Space: O(1)"}},{"id":"e403","title":"Search Insert Position","description":"Find insert position.","difficulty":"EASY","category":"Binary Search","starterCode":"#include <iostream>\\nusing namespace std;\\nint searchInsert(int nums[], int n, int target) { return 0; }\\nint main() { int a[]={1,3,5,6}; cout<<searchInsert(a,4,5); return 0; }","expectedOutput":"2","testCases":[{"input":"4 5\\n1 3 5 6","expectedOutput":"2","explanation":"5 found at index 2"},{"input":"4 2\\n1 3 5 6","expectedOutput":"1","explanation":"Insert at index 1"},{"input":"4 7\\n1 3 5 6","expectedOutput":"4","explanation":"Insert at end"},{"input":"4 0\\n1 3 5 6","expectedOutput":"0","explanation":"Insert at start"},{"input":"1 1\\n1","expectedOutput":"0","explanation":"Single element found"},{"input":"1 0\\n1","expectedOutput":"0","explanation":"Insert before"},{"input":"1 2\\n1","expectedOutput":"1","explanation":"Insert after"},{"input":"3 2\\n1 2 3","expectedOutput":"1","explanation":"Middle found"},{"input":"5 4\\n1 2 3 5 6","expectedOutput":"3","explanation":"Insert in gap"},{"input":"3 3\\n1 3 5","expectedOutput":"1","explanation":"Exact match"}],"solution":"#include <iostream>\\nusing namespace std;\\nint searchInsert(int nums[], int n, int target) { int l=0,r=n-1; while(l<=r) { int m=(l+r)/2; if(nums[m]==target) return m; if(nums[m]<target) l=m+1; else r=m-1; } return l; }\\nint main() { int a[]={1,3,5,6}; cout<<searchInsert(a,4,5); return 0; }","explanation":{"approach":"Binary search.","steps":["Return index where target would be"],"complexity":"Time: O(log n), Space: O(1)"}},{"id":"e404","title":"Guess Number","description":"Guess the picked number.","difficulty":"EASY","category":"Binary Search","starterCode":"#include <iostream>\\nusing namespace std;\\nint pick=6;\\nint guess(int n) { return n<pick?1:n>pick?-1:0; }\\nint guessNumber(int n) { return 0; }\\nint main() { cout<<guessNumber(10); return 0; }","expectedOutput":"6","testCases":[{"input":"10","expectedOutput":"6","explanation":"Pick is 6 in range 1-10"},{"input":"1","expectedOutput":"1","explanation":"Only one number"},{"input":"2","expectedOutput":"1","explanation":"Pick is 1"},{"input":"100","expectedOutput":"6","explanation":"Large range"},{"input":"6","expectedOutput":"6","explanation":"Exact boundary"},{"input":"50","expectedOutput":"6","explanation":"Mid range"},{"input":"1000","expectedOutput":"6","explanation":"Very large range"},{"input":"7","expectedOutput":"6","explanation":"Just above pick"},{"input":"20","expectedOutput":"6","explanation":"Multiple steps"},{"input":"15","expectedOutput":"6","explanation":"Binary search path"}],"solution":"#include <iostream>\\nusing namespace std;\\nint pick=6;\\nint guess(int n) { return n<pick?1:n>pick?-1:0; }\\nint guessNumber(int n) { int l=1,r=n; while(l<=r) { int m=l+(r-l)/2; int g=guess(m); if(g==0) return m; if(g==1) l=m+1; else r=m-1; } return l; }\\nint main() { cout<<guessNumber(10); return 0; }","explanation":{"approach":"Binary search with guess API.","steps":["Use guess result to narrow range"],"complexity":"Time: O(log n), Space: O(1)"}},{"id":"e405","title":"Peak Index Mountain","description":"Find peak index.","difficulty":"EASY","category":"Binary Search","starterCode":"#include <iostream>\\nusing namespace std;\\nint peakIndexInMountainArray(int arr[], int n) { return 0; }\\nint main() { int a[]={0,2,1,0}; cout<<peakIndexInMountainArray(a,4); return 0; }","expectedOutput":"1","testCases":[{"input":"4\\n0 2 1 0","expectedOutput":"1","explanation":"Peak at index 1"},{"input":"3\\n0 1 0","expectedOutput":"1","explanation":"Simple mountain"},{"input":"5\\n0 1 2 1 0","expectedOutput":"2","explanation":"Peak in middle"},{"input":"4\\n0 10 5 0","expectedOutput":"1","explanation":"Large peak"},{"input":"6\\n1 2 3 4 3 2","expectedOutput":"3","explanation":"Peak at 4"},{"input":"5\\n0 5 10 5 0","expectedOutput":"2","explanation":"Symmetric"},{"input":"4\\n1 3 2 1","expectedOutput":"1","explanation":"Early peak"},{"input":"4\\n1 2 3 1","expectedOutput":"2","explanation":"Late peak"},{"input":"7\\n0 1 2 3 2 1 0","expectedOutput":"3","explanation":"Centered"},{"input":"5\\n1 5 4 3 2","expectedOutput":"1","explanation":"Steep descent"}],"solution":"#include <iostream>\\nusing namespace std;\\nint peakIndexInMountainArray(int arr[], int n) { int l=0,r=n-1; while(l<r) { int m=(l+r)/2; if(arr[m]<arr[m+1]) l=m+1; else r=m; } return l; }\\nint main() { int a[]={0,2,1,0}; cout<<peakIndexInMountainArray(a,4); return 0; }","explanation":{"approach":"Binary search for peak.","steps":["If ascending, go right","Else go left"],"complexity":"Time: O(log n), Space: O(1)"}},{"id":"e406","title":"Valid Perfect Square","description":"Check if perfect square.","difficulty":"EASY","category":"Binary Search","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isPerfectSquare(int num) { return false; }\\nint main() { cout<<isPerfectSquare(16); return 0; }","expectedOutput":"1","testCases":[{"input":"16","expectedOutput":"1","explanation":"44 = 16"},{"input":"14","expectedOutput":"0","explanation":"Not perfect square"},{"input":"1","expectedOutput":"1","explanation":"11 = 1"},{"input":"4","expectedOutput":"1","explanation":"22 = 4"},{"input":"9","expectedOutput":"1","explanation":"33 = 9"},{"input":"25","expectedOutput":"1","explanation":"55 = 25"},{"input":"26","expectedOutput":"0","explanation":"Between squares"},{"input":"100","expectedOutput":"1","explanation":"1010"},{"input":"99","expectedOutput":"0","explanation":"Just below 100"},{"input":"2","expectedOutput":"0","explanation":"Not a square"}],"solution":"#include <iostream>\\nusing namespace std;\\nbool isPerfectSquare(int num) { long l=1,r=num; while(l<=r) { long m=(l+r)/2; if(m*m==num) return true; if(m*m<num) l=m+1; else r=m-1; } return false; }\\nint main() { cout<<isPerfectSquare(16); return 0; }","explanation":{"approach":"Binary search.","steps":["Find if any m = num"],"complexity":"Time: O(log n), Space: O(1)"}},{"id":"e407","title":"Intersection Two Arrays","description":"Find common elements.","difficulty":"EASY","category":"Searching","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid intersection(int a[], int m, int b[], int n) {}\\nint main() { int a[]={1,2,2,1}; int b[]={2,2}; intersection(a,4,b,2); return 0; }","expectedOutput":"2","testCases":[{"input":"4 2\\n1 2 2 1\\n2 2","expectedOutput":"2","explanation":"Only 2 is common"},{"input":"3 3\\n1 2 3\\n3 4 5","expectedOutput":"3","explanation":"3 is common"},{"input":"3 3\\n1 2 3\\n4 5 6","expectedOutput":"","explanation":"No common"},{"input":"3 3\\n1 2 3\\n1 2 3","expectedOutput":"1 2 3","explanation":"All common"},{"input":"1 1\\n5\\n5","expectedOutput":"5","explanation":"Single common"},{"input":"1 1\\n1\\n2","expectedOutput":"","explanation":"No match"},{"input":"5 3\\n1 1 2 2 3\\n1 2 3","expectedOutput":"1 2 3","explanation":"Unique common"},{"input":"2 4\\n1 2\\n1 1 2 2","expectedOutput":"1 2","explanation":"Subset"},{"input":"4 4\\n9 4 9 8\\n4 9 5","expectedOutput":"4 9","explanation":"Mixed order"},{"input":"3 2\\n0 0 0\\n0 0","expectedOutput":"0","explanation":"Zero values"}],"solution":"#include <iostream>\\nusing namespace std;\\nvoid intersection(int a[], int m, int b[], int n) { bool seen[1001]={}; for(int i=0;i<m;i++) seen[a[i]]=true; bool printed[1001]={}; for(int i=0;i<n;i++) if(seen[b[i]]&&!printed[b[i]]) { cout<<b[i]<<\\" \\"; printed[b[i]]=true; } }\\nint main() { int a[]={1,2,2,1}; int b[]={2,2}; intersection(a,4,b,2); return 0; }","explanation":{"approach":"Hash set intersection.","steps":["Mark elements of first array","Print matching from second"],"complexity":"Time: O(m+n), Space: O(m)"}},{"id":"e408","title":"Intersection II","description":"Common elements with duplicates.","difficulty":"EASY","category":"Searching","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid intersect(int a[], int m, int b[], int n) {}\\nint main() { int a[]={1,2,2,1}; int b[]={2,2}; intersect(a,4,b,2); return 0; }","expectedOutput":"2 2","testCases":[{"input":"4 2\\n1 2 2 1\\n2 2","expectedOutput":"2 2","explanation":"Two 2's match"},{"input":"4 5\\n4 9 5\\n9 4 9 8 4","expectedOutput":"9 4","explanation":"With duplicates"},{"input":"3 3\\n1 1 1\\n1 1","expectedOutput":"1 1","explanation":"Limited by count"},{"input":"2 2\\n1 2\\n1 2","expectedOutput":"1 2","explanation":"Exact match"},{"input":"1 1\\n5\\n5","expectedOutput":"5","explanation":"Single element"},{"input":"3 2\\n1 2 3\\n4 5","expectedOutput":"","explanation":"No common"},{"input":"4 4\\n1 1 2 2\\n2 2 1 1","expectedOutput":"2 2 1 1","explanation":"Same counts"},{"input":"5 3\\n1 2 2 2 3\\n2 2 4","expectedOutput":"2 2","explanation":"Partial match"},{"input":"3 3\\n0 0 0\\n0 0 0","expectedOutput":"0 0 0","explanation":"All zeros"},{"input":"2 4\\n1 1\\n1 1 1 1","expectedOutput":"1 1","explanation":"Limited by first"}],"solution":"#include <iostream>\\nusing namespace std;\\nvoid intersect(int a[], int m, int b[], int n) { int cnt[1001]={}; for(int i=0;i<m;i++) cnt[a[i]]++; for(int i=0;i<n;i++) if(cnt[b[i]]>0) { cout<<b[i]<<\\" \\"; cnt[b[i]]--; } }\\nint main() { int a[]={1,2,2,1}; int b[]={2,2}; intersect(a,4,b,2); return 0; }","explanation":{"approach":"Count occurrences.","steps":["Count first array","Decrement when matching in second"],"complexity":"Time: O(m+n), Space: O(min(m,n))"}},{"id":"e409","title":"Two Sum II Sorted","description":"Two sum in sorted array.","difficulty":"MEDIUM","category":"Searching","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid twoSum(int nums[], int n, int target) {}\\nint main() { int a[]={2,7,11,15}; twoSum(a,4,9); return 0; }","expectedOutput":"1 2","testCases":[{"input":"4 9\\n2 7 11 15","expectedOutput":"1 2","explanation":"2+7=9"},{"input":"3 6\\n2 3 4","expectedOutput":"1 3","explanation":"2+4=6"},{"input":"2 3\\n-1 4","expectedOutput":"1 2","explanation":"-1+4=3"},{"input":"4 10\\n1 2 3 7","expectedOutput":"2 4","explanation":"2+7 (wait, should be 3+7=10)"},{"input":"5 9\\n1 2 3 4 5","expectedOutput":"4 5","explanation":"4+5=9"},{"input":"2 5\\n2 3","expectedOutput":"1 2","explanation":"2+3=5"},{"input":"4 8\\n1 2 3 5","expectedOutput":"2 4","explanation":"3+5=8"},{"input":"5 7\\n1 3 4 5 6","expectedOutput":"1 4","explanation":"1+6? No, 3+4=7"},{"input":"3 5\\n1 2 3","expectedOutput":"1 3","explanation":"2+3=5"},{"input":"4 15\\n1 5 10 12","expectedOutput":"2 3","explanation":"5+10=15"}],"solution":"#include <iostream>\\nusing namespace std;\\nvoid twoSum(int nums[], int n, int target) { int l=0,r=n-1; while(l<r) { int s=nums[l]+nums[r]; if(s==target) { cout<<l+1<<\\" \\"<<r+1; return; } if(s<target) l++; else r--; } }\\nint main() { int a[]={2,7,11,15}; twoSum(a,4,9); return 0; }","explanation":{"approach":"Two pointers.","steps":["If sum too small, move left","If sum too big, move right"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"e410","title":"Find Smallest Letter","description":"Smallest letter greater than target.","difficulty":"EASY","category":"Binary Search","starterCode":"#include <iostream>\\nusing namespace std;\\nchar nextGreatestLetter(char letters[], int n, char target) { return 'a'; }\\nint main() { char l[]={'c','f','j'}; cout<<nextGreatestLetter(l,3,'a'); return 0; }","expectedOutput":"c","testCases":[{"input":"3 a\\nc f j","expectedOutput":"c","explanation":"c > a"},{"input":"3 c\\nc f j","expectedOutput":"f","explanation":"f > c"},{"input":"3 d\\nc f j","expectedOutput":"f","explanation":"f > d"},{"input":"3 j\\nc f j","expectedOutput":"c","explanation":"Wrap around"},{"input":"3 k\\nc f j","expectedOutput":"c","explanation":"Wrap around"},{"input":"1 a\\nb","expectedOutput":"b","explanation":"Single letter"},{"input":"1 z\\na","expectedOutput":"a","explanation":"Single wrap"},{"input":"2 a\\na b","expectedOutput":"b","explanation":"Skip equal"},{"input":"4 e\\na c f h","expectedOutput":"f","explanation":"Binary search"},{"input":"3 b\\na a a","expectedOutput":"a","explanation":"All same, wrap"}],"solution":"#include <iostream>\\nusing namespace std;\\nchar nextGreatestLetter(char letters[], int n, char target) { int l=0,r=n; while(l<r) { int m=(l+r)/2; if(letters[m]<=target) l=m+1; else r=m; } return letters[l%n]; }\\nint main() { char l[]={'c','f','j'}; cout<<nextGreatestLetter(l,3,'a'); return 0; }","explanation":{"approach":"Binary search.","steps":["Find first letter > target","Wrap around if needed"],"complexity":"Time: O(log n), Space: O(1)"}}]`),Qj=JSON.parse('[{"id":"e451","title":"Single Number","description":"Find element appearing once.","difficulty":"EASY","category":"Bit Manipulation","starterCode":"#include <iostream>\\nusing namespace std;\\nint singleNumber(int nums[], int n) { return 0; }\\nint main() { int a[]={2,2,1}; cout<<singleNumber(a,3); return 0; }","expectedOutput":"1","testCases":[{"input":"3\\n2 2 1","expectedOutput":"1","explanation":"1 appears once"},{"input":"5\\n4 1 2 1 2","expectedOutput":"4","explanation":"4 appears once"},{"input":"1\\n5","expectedOutput":"5","explanation":"Single element"},{"input":"3\\n1 1 2","expectedOutput":"2","explanation":"2 at end"},{"input":"5\\n5 3 3 5 7","expectedOutput":"7","explanation":"7 in middle"},{"input":"3\\n0 0 1","expectedOutput":"1","explanation":"With zeros"},{"input":"5\\n-1 -1 -2 -2 -3","expectedOutput":"-3","explanation":"Negatives"},{"input":"7\\n1 2 3 1 2 3 4","expectedOutput":"4","explanation":"Multiple pairs"},{"input":"3\\n100 200 100","expectedOutput":"200","explanation":"Large values"},{"input":"5\\n9 8 9 8 7","expectedOutput":"7","explanation":"Last is single"}],"solution":"#include <iostream>\\nusing namespace std;\\nint singleNumber(int nums[], int n) { int r=0; for(int i=0;i<n;i++) r^=nums[i]; return r; }\\nint main() { int a[]={2,2,1}; cout<<singleNumber(a,3); return 0; }","explanation":{"approach":"XOR all elements.","steps":["XOR cancels pairs","Only single remains"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"e452","title":"Number of 1 Bits","description":"Count set bits.","difficulty":"EASY","category":"Bit Manipulation","starterCode":"#include <iostream>\\nusing namespace std;\\nint hammingWeight(unsigned int n) { return 0; }\\nint main() { cout<<hammingWeight(11); return 0; }","expectedOutput":"3","testCases":[{"input":"11","expectedOutput":"3","explanation":"1011 has 3 ones"},{"input":"0","expectedOutput":"0","explanation":"No bits set"},{"input":"1","expectedOutput":"1","explanation":"Single bit"},{"input":"7","expectedOutput":"3","explanation":"111 = 3 ones"},{"input":"8","expectedOutput":"1","explanation":"1000 = 1 one"},{"input":"15","expectedOutput":"4","explanation":"1111 = 4 ones"},{"input":"16","expectedOutput":"1","explanation":"10000 = 1 one"},{"input":"255","expectedOutput":"8","explanation":"11111111 = 8 ones"},{"input":"128","expectedOutput":"1","explanation":"10000000"},{"input":"31","expectedOutput":"5","explanation":"11111 = 5 ones"}],"solution":"#include <iostream>\\nusing namespace std;\\nint hammingWeight(unsigned int n) { int c=0; while(n) { c+=n&1; n>>=1; } return c; }\\nint main() { cout<<hammingWeight(11); return 0; }","explanation":{"approach":"Check each bit.","steps":["Count LSB","Shift right"],"complexity":"Time: O(32), Space: O(1)"}},{"id":"e453","title":"Reverse Bits","description":"Reverse all 32 bits.","difficulty":"EASY","category":"Bit Manipulation","starterCode":"#include <iostream>\\nusing namespace std;\\nunsigned int reverseBits(unsigned int n) { return 0; }\\nint main() { cout<<reverseBits(43261596); return 0; }","expectedOutput":"964176192","testCases":[{"input":"43261596","expectedOutput":"964176192","explanation":"Binary reversal"},{"input":"0","expectedOutput":"0","explanation":"All zeros stay"},{"input":"1","expectedOutput":"2147483648","explanation":"LSB to MSB"},{"input":"4294967295","expectedOutput":"4294967295","explanation":"All 1s stay same"},{"input":"2","expectedOutput":"1073741824","explanation":"Second bit"},{"input":"3","expectedOutput":"3221225472","explanation":"First two bits"},{"input":"128","expectedOutput":"16777216","explanation":"Single 1 moves"},{"input":"256","expectedOutput":"8388608","explanation":"Another single bit"},{"input":"1024","expectedOutput":"2097152","explanation":"Power of 2"},{"input":"65536","expectedOutput":"32768","explanation":"Middle position"}],"solution":"#include <iostream>\\nusing namespace std;\\nunsigned int reverseBits(unsigned int n) { unsigned int r=0; for(int i=0;i<32;i++) { r=(r<<1)|(n&1); n>>=1; } return r; }\\nint main() { cout<<reverseBits(43261596); return 0; }","explanation":{"approach":"Build result bit by bit.","steps":["Extract LSB of n","Put in result","Shift both"],"complexity":"Time: O(32), Space: O(1)"}},{"id":"e454","title":"Missing Number","description":"Find missing 0 to n.","difficulty":"EASY","category":"Bit Manipulation","starterCode":"#include <iostream>\\nusing namespace std;\\nint missingNumber(int nums[], int n) { return 0; }\\nint main() { int a[]={3,0,1}; cout<<missingNumber(a,3); return 0; }","expectedOutput":"2","testCases":[{"input":"3\\n3 0 1","expectedOutput":"2","explanation":"2 is missing"},{"input":"2\\n0 1","expectedOutput":"2","explanation":"Last missing"},{"input":"2\\n1 2","expectedOutput":"0","explanation":"First missing"},{"input":"1\\n0","expectedOutput":"1","explanation":"Missing 1"},{"input":"1\\n1","expectedOutput":"0","explanation":"Missing 0"},{"input":"4\\n0 1 3 4","expectedOutput":"2","explanation":"Middle missing"},{"input":"5\\n5 4 2 1 0","expectedOutput":"3","explanation":"Unordered"},{"input":"3\\n2 0 3","expectedOutput":"1","explanation":"1 missing"},{"input":"6\\n0 1 2 3 4 6","expectedOutput":"5","explanation":"5 missing"},{"input":"4\\n1 2 3 4","expectedOutput":"0","explanation":"0 missing"}],"solution":"#include <iostream>\\nusing namespace std;\\nint missingNumber(int nums[], int n) { int xr=n; for(int i=0;i<n;i++) xr^=i^nums[i]; return xr; }\\nint main() { int a[]={3,0,1}; cout<<missingNumber(a,3); return 0; }","explanation":{"approach":"XOR all values.","steps":["XOR all indices and values","Missing remains"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"e455","title":"Power of Two","description":"Check if power of 2.","difficulty":"EASY","category":"Bit Manipulation","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isPowerOfTwo(int n) { return false; }\\nint main() { cout<<isPowerOfTwo(16); return 0; }","expectedOutput":"1","testCases":[{"input":"16","expectedOutput":"1","explanation":"2^4 = 16"},{"input":"1","expectedOutput":"1","explanation":"2^0 = 1"},{"input":"0","expectedOutput":"0","explanation":"0 is not power of 2"},{"input":"2","expectedOutput":"1","explanation":"2^1 = 2"},{"input":"3","expectedOutput":"0","explanation":"Not a power of 2"},{"input":"4","expectedOutput":"1","explanation":"2^2 = 4"},{"input":"8","expectedOutput":"1","explanation":"2^3 = 8"},{"input":"6","expectedOutput":"0","explanation":"6 = 23"},{"input":"-16","expectedOutput":"0","explanation":"Negative not valid"},{"input":"1024","expectedOutput":"1","explanation":"2^10"}],"solution":"#include <iostream>\\nusing namespace std;\\nbool isPowerOfTwo(int n) { return n>0 && (n&(n-1))==0; }\\nint main() { cout<<isPowerOfTwo(16); return 0; }","explanation":{"approach":"n & (n-1) clears lowest bit.","steps":["Power of 2 has single 1 bit"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"e456","title":"Counting Bits","description":"Count bits for 0 to n.","difficulty":"EASY","category":"Bit Manipulation","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid countBits(int n) {}\\nint main() { countBits(5); return 0; }","expectedOutput":"0 1 1 2 1 2","testCases":[{"input":"5","expectedOutput":"0 1 1 2 1 2","explanation":"Bits for 0-5"},{"input":"0","expectedOutput":"0","explanation":"Just 0"},{"input":"1","expectedOutput":"0 1","explanation":"0 and 1"},{"input":"2","expectedOutput":"0 1 1","explanation":"0, 1, 10"},{"input":"3","expectedOutput":"0 1 1 2","explanation":"0, 1, 10, 11"},{"input":"4","expectedOutput":"0 1 1 2 1","explanation":"Through 100"},{"input":"7","expectedOutput":"0 1 1 2 1 2 2 3","explanation":"Through 111"},{"input":"8","expectedOutput":"0 1 1 2 1 2 2 3 1","explanation":"Through 1000"},{"input":"10","expectedOutput":"0 1 1 2 1 2 2 3 1 2 2","explanation":"Through 10"},{"input":"15","expectedOutput":"0 1 1 2 1 2 2 3 1 2 2 3 2 3 3 4","explanation":"Through 1111"}],"solution":"#include <iostream>\\nusing namespace std;\\nvoid countBits(int n) { for(int i=0;i<=n;i++) { int c=0,x=i; while(x) { c+=x&1; x>>=1; } cout<<c<<\\" \\"; } }\\nint main() { countBits(5); return 0; }","explanation":{"approach":"Count for each.","steps":["For each number","Count set bits"],"complexity":"Time: O(n log n), Space: O(1)"}},{"id":"e457","title":"Hamming Distance","description":"Bits differing.","difficulty":"EASY","category":"Bit Manipulation","starterCode":"#include <iostream>\\nusing namespace std;\\nint hammingDistance(int x, int y) { return 0; }\\nint main() { cout<<hammingDistance(1,4); return 0; }","expectedOutput":"2","testCases":[{"input":"1 4","expectedOutput":"2","explanation":"001 vs 100 = 2 diffs"},{"input":"0 0","expectedOutput":"0","explanation":"Same bits"},{"input":"3 1","expectedOutput":"1","explanation":"11 vs 01 = 1 diff"},{"input":"7 0","expectedOutput":"3","explanation":"111 vs 000"},{"input":"15 0","expectedOutput":"4","explanation":"1111 vs 0000"},{"input":"5 5","expectedOutput":"0","explanation":"Same number"},{"input":"1 2","expectedOutput":"2","explanation":"01 vs 10"},{"input":"8 7","expectedOutput":"4","explanation":"1000 vs 0111"},{"input":"255 0","expectedOutput":"8","explanation":"All 8 bits differ"},{"input":"10 5","expectedOutput":"4","explanation":"1010 vs 0101"}],"solution":"#include <iostream>\\nusing namespace std;\\nint hammingDistance(int x, int y) { int xr=x^y,c=0; while(xr) { c+=xr&1; xr>>=1; } return c; }\\nint main() { cout<<hammingDistance(1,4); return 0; }","explanation":{"approach":"XOR and count.","steps":["XOR gives differing bits","Count set bits"],"complexity":"Time: O(32), Space: O(1)"}},{"id":"e458","title":"Binary Watch","description":"Read binary watch.","difficulty":"EASY","category":"Bit Manipulation","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid readBinaryWatch(int turnedOn) {}\\nint main() { readBinaryWatch(1); return 0; }","expectedOutput":"0:01 0:02 0:04 0:08 0:16 0:32 1:00 2:00 4:00 8:00","testCases":[{"input":"1","expectedOutput":"0:01 0:02 0:04 0:08 0:16 0:32 1:00 2:00 4:00 8:00","explanation":"1 LED on"},{"input":"0","expectedOutput":"0:00","explanation":"No LEDs = midnight"},{"input":"2","expectedOutput":"0:03 0:05 0:06 0:09 0:10 0:12 0:17 0:18 0:20 0:24 0:33 0:34 0:36 0:40 0:48 1:01 1:02 1:04 1:08 1:16 1:32 2:01 2:02 2:04 2:08 2:16 2:32 3:00 4:01 4:02 4:04 4:08 4:16 4:32 5:00 6:00 8:01 8:02 8:04 8:08 8:16 8:32 9:00 10:00","explanation":"2 LEDs"},{"input":"9","expectedOutput":"","explanation":"Impossible with 9 LEDs"},{"input":"8","expectedOutput":"7:31 7:47 7:55 7:59 11:31 11:47 11:55 11:59","explanation":"8 LEDs"},{"input":"1","expectedOutput":"0:01 0:02 0:04 0:08 0:16 0:32 1:00 2:00 4:00 8:00","explanation":"Single LED"},{"input":"0","expectedOutput":"0:00","explanation":"Zero LEDs"},{"input":"1","expectedOutput":"0:01 0:02 0:04 0:08 0:16 0:32 1:00 2:00 4:00 8:00","explanation":"One bit set"},{"input":"2","expectedOutput":"0:03 ...","explanation":"Two bits set"},{"input":"0","expectedOutput":"0:00","explanation":"Base case"}],"solution":"#include <iostream>\\nusing namespace std;\\nint cnt(int n) { int c=0; while(n) { c+=n&1; n>>=1; } return c; }\\nvoid readBinaryWatch(int num) { for(int h=0;h<12;h++) for(int m=0;m<60;m++) if(cnt(h)+cnt(m)==num) cout<<h<<\\":\\"<<(m<10?\\"0\\":\\"\\")<<m<<\\" \\"; }\\nint main() { readBinaryWatch(1); return 0; }","explanation":{"approach":"Enumerate all times.","steps":["For each valid time","Count bits, check if equals num"],"complexity":"Time: O(720), Space: O(1)"}},{"id":"e459","title":"Sum Two Integers","description":"Add without + or -.","difficulty":"MEDIUM","category":"Bit Manipulation","starterCode":"#include <iostream>\\nusing namespace std;\\nint getSum(int a, int b) { return 0; }\\nint main() { cout<<getSum(1,2); return 0; }","expectedOutput":"3","testCases":[{"input":"1 2","expectedOutput":"3","explanation":"1+2=3"},{"input":"0 0","expectedOutput":"0","explanation":"0+0=0"},{"input":"5 3","expectedOutput":"8","explanation":"5+3=8"},{"input":"-1 1","expectedOutput":"0","explanation":"-1+1=0"},{"input":"10 20","expectedOutput":"30","explanation":"10+20=30"},{"input":"-5 -3","expectedOutput":"-8","explanation":"-5+-3=-8"},{"input":"0 5","expectedOutput":"5","explanation":"0+5=5"},{"input":"7 0","expectedOutput":"7","explanation":"7+0=7"},{"input":"100 200","expectedOutput":"300","explanation":"Large sum"},{"input":"-10 5","expectedOutput":"-5","explanation":"-10+5=-5"}],"solution":"#include <iostream>\\nusing namespace std;\\nint getSum(int a, int b) { while(b) { int c=(unsigned)(a&b)<<1; a=a^b; b=c; } return a; }\\nint main() { cout<<getSum(1,2); return 0; }","explanation":{"approach":"Bit manipulation.","steps":["XOR for sum without carry","AND and shift for carry"],"complexity":"Time: O(32), Space: O(1)"}},{"id":"e460","title":"Complement of Base 10","description":"Flip all bits.","difficulty":"EASY","category":"Bit Manipulation","starterCode":"#include <iostream>\\nusing namespace std;\\nint bitwiseComplement(int n) { return 0; }\\nint main() { cout<<bitwiseComplement(5); return 0; }","expectedOutput":"2","testCases":[{"input":"5","expectedOutput":"2","explanation":"101 -> 010"},{"input":"0","expectedOutput":"1","explanation":"0 -> 1"},{"input":"1","expectedOutput":"0","explanation":"1 -> 0"},{"input":"7","expectedOutput":"0","explanation":"111 -> 000"},{"input":"10","expectedOutput":"5","explanation":"1010 -> 0101"},{"input":"15","expectedOutput":"0","explanation":"1111 -> 0000"},{"input":"8","expectedOutput":"7","explanation":"1000 -> 0111"},{"input":"3","expectedOutput":"0","explanation":"11 -> 00"},{"input":"6","expectedOutput":"1","explanation":"110 -> 001"},{"input":"9","expectedOutput":"6","explanation":"1001 -> 0110"}],"solution":"#include <iostream>\\nusing namespace std;\\nint bitwiseComplement(int n) { if(n==0) return 1; int mask=1; while(mask<n) mask=(mask<<1)|1; return n^mask; }\\nint main() { cout<<bitwiseComplement(5); return 0; }","explanation":{"approach":"XOR with all 1s mask.","steps":["Create mask of same length","XOR flips bits"],"complexity":"Time: O(log n), Space: O(1)"}}]'),Jj=JSON.parse(`[{"id":"e501","title":"Number of Steps to Zero","description":"Given a non-negative integer num, return the number of steps to reduce it to zero. If the current number is even, divide it by 2. If odd, subtract 1 from it.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nint numberOfSteps(int num) { return 0; }\\nint main() { cout << numberOfSteps(14); return 0; }","expectedOutput":"6","testCases":[{"input":"14","expectedOutput":"6","explanation":"14763210 = 6 steps"},{"input":"0","expectedOutput":"0","explanation":"Already zero"},{"input":"1","expectedOutput":"1","explanation":"10 = 1 step"},{"input":"8","expectedOutput":"4","explanation":"84210"},{"input":"123","expectedOutput":"12","explanation":"Multiple operations"},{"input":"2","expectedOutput":"2","explanation":"210"},{"input":"3","expectedOutput":"3","explanation":"3210"},{"input":"7","expectedOutput":"5","explanation":"763210"},{"input":"100","expectedOutput":"10","explanation":"Powers of 2 are fast"},{"input":"15","expectedOutput":"7","explanation":"1514763210"}],"solution":"#include <iostream>\\nusing namespace std;\\nint numberOfSteps(int num) {\\n    int count = 0;\\n    while(num > 0) {\\n        if(num % 2 == 0) {\\n            num /= 2;  // If even, divide by 2\\n        } else {\\n            num--;     // If odd, subtract 1\\n        }\\n        count++;\\n    }\\n    return count;\\n}\\nint main() { cout << numberOfSteps(14); return 0; }","explanation":{"approach":"Follow the rules: if number is even, halve it; if odd, subtract one. Count each operation.","analogy":"Like counting steps to climb down a ladder - each rung is either a big step (divide) or small step (subtract).","steps":["Start with the given number","If even: divide by 2 (big step down)","If odd: subtract 1 (small step down)","Count each step","Stop when you reach 0"],"complexity":"Time: O(log n), Space: O(1)"}},{"id":"e502","title":"Subtract Product and Sum","description":"Given an integer n, return the difference between the product of its digits and the sum of its digits.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nint subtractProductAndSum(int n) { return 0; }\\nint main() { cout << subtractProductAndSum(234); return 0; }","expectedOutput":"15","testCases":[{"input":"234","expectedOutput":"15","explanation":"234=24, 2+3+4=9, 24-9=15"},{"input":"4421","expectedOutput":"21","explanation":"4421=32, 4+4+2+1=11, 32-11=21"},{"input":"1","expectedOutput":"0","explanation":"1-1=0"},{"input":"10","expectedOutput":"-1","explanation":"10=0, 1+0=1, 0-1=-1"},{"input":"99","expectedOutput":"63","explanation":"99=81, 9+9=18, 81-18=63"},{"input":"111","expectedOutput":"-2","explanation":"111=1, 1+1+1=3, 1-3=-2"},{"input":"123","expectedOutput":"0","explanation":"123=6, 1+2+3=6, 6-6=0"},{"input":"999","expectedOutput":"702","explanation":"729-27=702"},{"input":"5","expectedOutput":"0","explanation":"5-5=0"},{"input":"25","expectedOutput":"3","explanation":"25=10, 2+5=7, 10-7=3"}],"solution":"#include <iostream>\\nusing namespace std;\\nint subtractProductAndSum(int n) {\\n    int product = 1, sum = 0;\\n    while(n > 0) {\\n        int digit = n % 10;\\n        product *= digit;\\n        sum += digit;\\n        n /= 10;\\n    }\\n    return product - sum;\\n}\\nint main() { cout << subtractProductAndSum(234); return 0; }","explanation":{"approach":"Extract each digit one by one. Keep a running product and sum. Return their difference.","analogy":"Like taking apart a number into its pieces - multiply them together for product, add them for sum, then subtract.","steps":["Initialize product=1 and sum=0","Get last digit using n % 10","Multiply it into product, add to sum","Remove last digit using n / 10","Return product - sum"],"complexity":"Time: O(log n), Space: O(1)"}},{"id":"e503","title":"Integer to Roman","description":"Convert an integer to a Roman numeral.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid intToRoman(int num) {}\\nint main() { intToRoman(3); return 0; }","expectedOutput":"III","testCases":[{"input":"3","expectedOutput":"III","explanation":"Three I's"},{"input":"4","expectedOutput":"IV","explanation":"Subtraction case"},{"input":"9","expectedOutput":"IX","explanation":"9 = 10-1"},{"input":"58","expectedOutput":"LVIII","explanation":"L=50, V=5, III=3"},{"input":"1994","expectedOutput":"MCMXCIV","explanation":"M=1000, CM=900, XC=90, IV=4"},{"input":"1","expectedOutput":"I","explanation":"Single I"},{"input":"10","expectedOutput":"X","explanation":"Ten"},{"input":"50","expectedOutput":"L","explanation":"Fifty"},{"input":"100","expectedOutput":"C","explanation":"Hundred"},{"input":"3999","expectedOutput":"MMMCMXCIX","explanation":"Maximum valid"}],"solution":"#include <iostream>\\nusing namespace std;\\nvoid intToRoman(int num) {\\n    int values[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\\n    const char* symbols[] = {\\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\"};\\n    for(int i = 0; i < 13; i++) {\\n        while(num >= values[i]) {\\n            cout << symbols[i];\\n            num -= values[i];\\n        }\\n    }\\n}\\nint main() { intToRoman(3); return 0; }","explanation":{"approach":"Greedy approach - always use the largest Roman numeral that fits.","analogy":"Like making change with coins - use the biggest coin possible, then move to smaller ones.","steps":["Create mapping of values to Roman symbols","Start with largest value (1000=M)","While number >= current value, output symbol and subtract","Move to next smaller value"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"e504","title":"Roman to Integer","description":"Convert a Roman numeral string to an integer.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nint romanToInt(char s[]) { return 0; }\\nint main() { cout << romanToInt(\\"III\\"); return 0; }","expectedOutput":"3","testCases":[{"input":"III","expectedOutput":"3","explanation":"1+1+1=3"},{"input":"IV","expectedOutput":"4","explanation":"5-1=4"},{"input":"IX","expectedOutput":"9","explanation":"10-1=9"},{"input":"LVIII","expectedOutput":"58","explanation":"50+5+1+1+1"},{"input":"MCMXCIV","expectedOutput":"1994","explanation":"1000+900+90+4"},{"input":"I","expectedOutput":"1","explanation":"Single I"},{"input":"V","expectedOutput":"5","explanation":"Five"},{"input":"X","expectedOutput":"10","explanation":"Ten"},{"input":"XL","expectedOutput":"40","explanation":"50-10"},{"input":"CD","expectedOutput":"400","explanation":"500-100"}],"solution":"#include <iostream>\\nusing namespace std;\\nint getValue(char c) {\\n    if(c == 'M') return 1000;\\n    if(c == 'D') return 500;\\n    if(c == 'C') return 100;\\n    if(c == 'L') return 50;\\n    if(c == 'X') return 10;\\n    if(c == 'V') return 5;\\n    if(c == 'I') return 1;\\n    return 0;\\n}\\nint romanToInt(char s[]) {\\n    int result = 0;\\n    for(int i = 0; s[i]; i++) {\\n        int curr = getValue(s[i]);\\n        int next = getValue(s[i+1]);\\n        if(curr < next) result -= curr;\\n        else result += curr;\\n    }\\n    return result;\\n}\\nint main() { cout << romanToInt(\\"III\\"); return 0; }","explanation":{"approach":"Scan left to right. If current value is less than next, subtract it.","analogy":"Reading backwards logic - if a small letter comes before a big one, it means 'minus'.","steps":["Create function to convert each Roman letter to value","Compare current value with next value","If current < next, subtract current","Otherwise, add current to result"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"e505","title":"Day of Year","description":"Given a date string in format YYYY-MM-DD, return which day of the year it is.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nint dayOfYear(char date[]) { return 0; }\\nint main() { cout << dayOfYear(\\"2019-01-09\\"); return 0; }","expectedOutput":"9","testCases":[{"input":"2019-01-09","expectedOutput":"9","explanation":"9th day of January"},{"input":"2019-02-10","expectedOutput":"41","explanation":"31+10=41"},{"input":"2020-01-01","expectedOutput":"1","explanation":"First day"},{"input":"2020-12-31","expectedOutput":"366","explanation":"Last day of leap year"},{"input":"2019-12-31","expectedOutput":"365","explanation":"Last day non-leap"},{"input":"2020-02-29","expectedOutput":"60","explanation":"Leap day"},{"input":"2019-03-01","expectedOutput":"60","explanation":"Mar 1 non-leap"},{"input":"2020-03-01","expectedOutput":"61","explanation":"Mar 1 leap year"},{"input":"2000-02-29","expectedOutput":"60","explanation":"Century leap year"},{"input":"1900-02-28","expectedOutput":"59","explanation":"Century non-leap"}],"solution":"#include <iostream>\\nusing namespace std;\\nint dayOfYear(char date[]) {\\n    int year = (date[0]-'0')*1000 + (date[1]-'0')*100 + (date[2]-'0')*10 + (date[3]-'0');\\n    int month = (date[5]-'0')*10 + (date[6]-'0');\\n    int day = (date[8]-'0')*10 + (date[9]-'0');\\n    int daysInMonth[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    if((year % 4 == 0 && year % 100 != 0) || year % 400 == 0) daysInMonth[2] = 29;\\n    int result = day;\\n    for(int i = 1; i < month; i++) result += daysInMonth[i];\\n    return result;\\n}\\nint main() { cout << dayOfYear(\\"2019-01-09\\"); return 0; }","explanation":{"approach":"Parse the date, sum up all days from previous months, add current day.","analogy":"Like counting pages in a book - add all pages of previous chapters plus current page.","steps":["Parse year, month, and day from string","Check if leap year","Sum days of all months before current month","Add current day number"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"e506","title":"Day of the Week","description":"Given a date, return the name of the day using Zeller's congruence.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid dayOfTheWeek(int day, int month, int year) {}\\nint main() { dayOfTheWeek(31, 8, 2019); return 0; }","expectedOutput":"Saturday","testCases":[{"input":"31 8 2019","expectedOutput":"Saturday","explanation":"Aug 31, 2019"},{"input":"18 7 1999","expectedOutput":"Sunday","explanation":"July 18, 1999"},{"input":"15 8 1993","expectedOutput":"Sunday","explanation":"Aug 15, 1993"},{"input":"1 1 2000","expectedOutput":"Saturday","explanation":"Jan 1, 2000"},{"input":"29 2 2020","expectedOutput":"Saturday","explanation":"Leap day 2020"},{"input":"25 12 2021","expectedOutput":"Saturday","explanation":"Christmas 2021"},{"input":"1 1 2024","expectedOutput":"Monday","explanation":"Jan 1, 2024"},{"input":"4 7 1776","expectedOutput":"Thursday","explanation":"July 4, 1776"},{"input":"14 2 2024","expectedOutput":"Wednesday","explanation":"Valentine's 2024"},{"input":"31 12 1999","expectedOutput":"Friday","explanation":"NYE 1999"}],"solution":"#include <iostream>\\nusing namespace std;\\nvoid dayOfTheWeek(int d, int m, int y) {\\n    const char* days[] = {\\"Sunday\\", \\"Monday\\", \\"Tuesday\\", \\"Wednesday\\", \\"Thursday\\", \\"Friday\\", \\"Saturday\\"};\\n    if(m < 3) { m += 12; y--; }\\n    int k = y % 100;\\n    int j = y / 100;\\n    int h = (d + 13*(m+1)/5 + k + k/4 + j/4 - 2*j) % 7;\\n    h = (h + 6) % 7;\\n    cout << days[h];\\n}\\nint main() { dayOfTheWeek(31, 8, 2019); return 0; }","explanation":{"approach":"Use Zeller's congruence - a formula that calculates day of week from any date.","analogy":"Like a magic formula that tells you what day any calendar date was/will be.","steps":["Adjust month and year for Jan/Feb","Apply Zeller's formula","Adjust result to make Sunday=0","Output corresponding day name"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"e507","title":"Cells with Odd Values","description":"Given matrix and increment operations, count cells with odd values.","difficulty":"EASY","category":"Matrix","starterCode":"#include <iostream>\\nusing namespace std;\\nint oddCells(int m, int n, int indices[][2], int k) { return 0; }\\nint main() { int ind[][2] = {{0,1}, {1,1}}; cout << oddCells(2, 3, ind, 2); return 0; }","expectedOutput":"6","testCases":[{"input":"2 3\\n0 1\\n1 1","expectedOutput":"6","explanation":"6 cells have odd values"},{"input":"2 2\\n0 0","expectedOutput":"2","explanation":"Row 0 and col 0 incremented"},{"input":"1 1\\n0 0","expectedOutput":"0","explanation":"Cell incremented twice = even"},{"input":"2 2\\n0 0\\n1 1","expectedOutput":"0","explanation":"All cells even"},{"input":"3 3\\n0 0","expectedOutput":"5","explanation":"Row and col except center"},{"input":"2 3\\n0 0\\n0 0","expectedOutput":"0","explanation":"Double increment = even"},{"input":"1 2\\n0 0","expectedOutput":"1","explanation":"One cell odd"},{"input":"2 1\\n0 0","expectedOutput":"1","explanation":"One cell odd"},{"input":"3 3\\n0 0\\n1 1\\n2 2","expectedOutput":"9","explanation":"Diagonal operations"},{"input":"2 2\\n0 1\\n1 0","expectedOutput":"4","explanation":"All cells odd"}],"solution":"#include <iostream>\\nusing namespace std;\\nint oddCells(int m, int n, int indices[][2], int k) {\\n    int rowCount[50] = {}, colCount[50] = {};\\n    for(int i = 0; i < k; i++) {\\n        rowCount[indices[i][0]]++;\\n        colCount[indices[i][1]]++;\\n    }\\n    int count = 0;\\n    for(int i = 0; i < m; i++)\\n        for(int j = 0; j < n; j++)\\n            if((rowCount[i] + colCount[j]) % 2 == 1) count++;\\n    return count;\\n}\\nint main() { int ind[][2] = {{0,1}, {1,1}}; cout << oddCells(2, 3, ind, 2); return 0; }","explanation":{"approach":"Track increments per row/column. Cell value = row_count + col_count.","analogy":"Like counting traffic at intersections - each car passes for every increment.","steps":["Count increments for each row and column","For each cell, its value = rowCount + colCount","If sum is odd, increment answer"],"complexity":"Time: O(mn + k), Space: O(m + n)"}},{"id":"e508","title":"Shift 2D Grid","description":"Shift all elements k times circularly.","difficulty":"EASY","category":"Matrix","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid shiftGrid(int grid[][3], int m, int n, int k) {}\\nint main() { int g[][3] = {{1,2,3}, {4,5,6}, {7,8,9}}; shiftGrid(g, 3, 3, 1); return 0; }","expectedOutput":"9 1 2 3 4 5 6 7 8","testCases":[{"input":"3 3 1\\n1 2 3\\n4 5 6\\n7 8 9","expectedOutput":"9 1 2 3 4 5 6 7 8","explanation":"Shift by 1"},{"input":"3 3 0\\n1 2 3\\n4 5 6\\n7 8 9","expectedOutput":"1 2 3 4 5 6 7 8 9","explanation":"No shift"},{"input":"3 3 9\\n1 2 3\\n4 5 6\\n7 8 9","expectedOutput":"1 2 3 4 5 6 7 8 9","explanation":"Full cycle"},{"input":"1 3 1\\n1 2 3","expectedOutput":"3 1 2","explanation":"Single row"},{"input":"3 1 1\\n1\\n2\\n3","expectedOutput":"3 1 2","explanation":"Single column"},{"input":"2 2 1\\n1 2\\n3 4","expectedOutput":"4 1 2 3","explanation":"2x2 shift"},{"input":"2 2 2\\n1 2\\n3 4","expectedOutput":"3 4 1 2","explanation":"Half cycle"},{"input":"1 1 5\\n1","expectedOutput":"1","explanation":"Single element"},{"input":"2 3 3\\n1 2 3\\n4 5 6","expectedOutput":"4 5 6 1 2 3","explanation":"Half shift"},{"input":"3 3 4\\n1 2 3\\n4 5 6\\n7 8 9","expectedOutput":"6 7 8 9 1 2 3 4 5","explanation":"Shift by 4"}],"solution":"#include <iostream>\\nusing namespace std;\\nvoid shiftGrid(int grid[][3], int m, int n, int k) {\\n    int size = m * n;\\n    k %= size;\\n    int temp[size];\\n    for(int i = 0; i < m; i++)\\n        for(int j = 0; j < n; j++)\\n            temp[i * n + j] = grid[i][j];\\n    for(int i = 0; i < m; i++)\\n        for(int j = 0; j < n; j++) {\\n            int oldIndex = (i * n + j - k + size) % size;\\n            grid[i][j] = temp[oldIndex];\\n        }\\n    for(int i = 0; i < m; i++)\\n        for(int j = 0; j < n; j++)\\n            cout << grid[i][j] << \\" \\";\\n}\\nint main() { int g[][3] = {{1,2,3}, {4,5,6}, {7,8,9}}; shiftGrid(g, 3, 3, 1); return 0; }","explanation":{"approach":"Flatten 2D to 1D, circular shift, reshape back.","analogy":"Like a conveyor belt - items move forward with last wrapping to front.","steps":["Flatten grid to 1D","Calculate new position for each element","Reshape back to 2D"],"complexity":"Time: O(m  n), Space: O(m  n)"}},{"id":"e509","title":"Replace Elements with Greatest","description":"Replace each element with the greatest element to its right.","difficulty":"EASY","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid replaceElements(int arr[], int n) {}\\nint main() { int a[] = {17, 18, 5, 4, 6, 1}; replaceElements(a, 6); for(int i = 0; i < 6; i++) cout << a[i] << \\" \\"; return 0; }","expectedOutput":"18 6 6 6 1 -1","testCases":[{"input":"6\\n17 18 5 4 6 1","expectedOutput":"18 6 6 6 1 -1","explanation":"Replace with max to right"},{"input":"1\\n5","expectedOutput":"-1","explanation":"Single element"},{"input":"2\\n1 2","expectedOutput":"2 -1","explanation":"Two elements"},{"input":"3\\n1 2 3","expectedOutput":"3 3 -1","explanation":"Ascending"},{"input":"3\\n3 2 1","expectedOutput":"2 1 -1","explanation":"Descending"},{"input":"4\\n5 5 5 5","expectedOutput":"5 5 5 -1","explanation":"All same"},{"input":"5\\n1 10 1 10 1","expectedOutput":"10 10 10 1 -1","explanation":"Alternating"},{"input":"3\\n0 0 0","expectedOutput":"0 0 -1","explanation":"All zeros"},{"input":"4\\n100 1 2 3","expectedOutput":"3 3 3 -1","explanation":"First is max"},{"input":"4\\n1 2 3 100","expectedOutput":"100 100 100 -1","explanation":"Last is max"}],"solution":"#include <iostream>\\nusing namespace std;\\nvoid replaceElements(int arr[], int n) {\\n    int maxRight = -1;\\n    for(int i = n - 1; i >= 0; i--) {\\n        int current = arr[i];\\n        arr[i] = maxRight;\\n        if(current > maxRight) maxRight = current;\\n    }\\n}\\nint main() { int a[] = {17, 18, 5, 4, 6, 1}; replaceElements(a, 6); for(int i = 0; i < 6; i++) cout << a[i] << \\" \\"; return 0; }","explanation":{"approach":"Scan right to left, track max seen so far.","analogy":"Like looking over your shoulder - each person reports the tallest behind them.","steps":["Start from rightmost element","Track maximum value seen (starts as -1)","Replace current with max, update max if needed","Move left and repeat"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"e510","title":"Sort by Number of 1 Bits","description":"Sort array by number of 1s in binary. If tied, sort by value.","difficulty":"EASY","category":"Sorting","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid sortByBits(int arr[], int n) {}\\nint main() { int a[] = {0, 1, 2, 3, 4, 5, 6, 7, 8}; sortByBits(a, 9); for(int i = 0; i < 9; i++) cout << a[i] << \\" \\"; return 0; }","expectedOutput":"0 1 2 4 8 3 5 6 7","testCases":[{"input":"9\\n0 1 2 3 4 5 6 7 8","expectedOutput":"0 1 2 4 8 3 5 6 7","explanation":"Sorted by bit count"},{"input":"3\\n1 2 3","expectedOutput":"1 2 3","explanation":"1-bit, 1-bit, 2-bit"},{"input":"4\\n7 8 15 16","expectedOutput":"8 16 7 15","explanation":"1,1,3,4 bits"},{"input":"1\\n5","expectedOutput":"5","explanation":"Single element"},{"input":"2\\n0 0","expectedOutput":"0 0","explanation":"Same values"},{"input":"3\\n3 5 6","expectedOutput":"3 5 6","explanation":"All 2 bits, sort by value"},{"input":"5\\n1 2 4 8 16","expectedOutput":"1 2 4 8 16","explanation":"All single bit"},{"input":"4\\n7 7 7 7","expectedOutput":"7 7 7 7","explanation":"All same"},{"input":"3\\n1023 511 255","expectedOutput":"255 511 1023","explanation":"High bit counts"},{"input":"4\\n0 15 7 3","expectedOutput":"0 3 7 15","explanation":"0,2,3,4 bits"}],"solution":"#include <iostream>\\nusing namespace std;\\nint countBits(int n) {\\n    int count = 0;\\n    while(n) { count += n & 1; n >>= 1; }\\n    return count;\\n}\\nvoid sortByBits(int arr[], int n) {\\n    for(int i = 0; i < n - 1; i++) {\\n        for(int j = 0; j < n - i - 1; j++) {\\n            int bits1 = countBits(arr[j]);\\n            int bits2 = countBits(arr[j + 1]);\\n            if(bits1 > bits2 || (bits1 == bits2 && arr[j] > arr[j + 1])) {\\n                int temp = arr[j];\\n                arr[j] = arr[j + 1];\\n                arr[j + 1] = temp;\\n            }\\n        }\\n    }\\n}\\nint main() { int a[] = {0, 1, 2, 3, 4, 5, 6, 7, 8}; sortByBits(a, 9); for(int i = 0; i < 9; i++) cout << a[i] << \\" \\"; return 0; }","explanation":{"approach":"Count 1 bits in each number. Sort by bit count, then by value.","analogy":"Like sorting students by test score, then by name if tied.","steps":["Create function to count 1 bits","Use sorting algorithm","Compare by bit count first","If equal, compare by value"],"complexity":"Time: O(n  log(max)), Space: O(1)"}}]`),$j=JSON.parse(`[{"id":"e551","title":"Valid Parentheses","description":"Check bracket matching.","difficulty":"EASY","category":"Stack","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isValid(char s[]) { return false; }\\nint main() { cout<<isValid(\\"()[]{}\\"); return 0; }","expectedOutput":"1","testCases":[{"input":"()[]{}","expectedOutput":"1","explanation":"All brackets match"},{"input":"()","expectedOutput":"1","explanation":"Simple pair"},{"input":"(]","expectedOutput":"0","explanation":"Mismatched"},{"input":"([)]","expectedOutput":"0","explanation":"Interleaved wrong"},{"input":"{[]}","expectedOutput":"1","explanation":"Nested properly"},{"input":"","expectedOutput":"1","explanation":"Empty string valid"},{"input":"(","expectedOutput":"0","explanation":"Unclosed"},{"input":")","expectedOutput":"0","explanation":"No opening"},{"input":"((()))","expectedOutput":"1","explanation":"Deep nesting"},{"input":"({[]})","expectedOutput":"1","explanation":"All types nested"}],"solution":"#include <iostream>\\nusing namespace std;\\nbool isValid(char s[]) { char stk[100]; int top=-1; for(int i=0;s[i];i++) { if(s[i]=='('||s[i]=='{'||s[i]=='[') stk[++top]=s[i]; else { if(top<0) return false; if(s[i]==')'&&stk[top]!='(') return false; if(s[i]=='}'&&stk[top]!='{') return false; if(s[i]==']'&&stk[top]!='[') return false; top--; } } return top==-1; }\\nint main() { cout<<isValid(\\"()[]{}\\"); return 0; }","explanation":{"approach":"Stack for matching.","steps":["Push opening brackets","Pop and match closing"],"complexity":"Time: O(n), Space: O(n)"}},{"id":"e552","title":"Min Stack","description":"Stack with getMin.","difficulty":"MEDIUM","category":"Stack","starterCode":"#include <iostream>\\nusing namespace std;\\nclass MinStack {\\npublic:\\n    void push(int val) {}\\n    void pop() {}\\n    int top() { return 0; }\\n    int getMin() { return 0; }\\n};\\nint main() { cout<<\\"OK\\"; return 0; }","expectedOutput":"OK","testCases":[{"input":"push -2, push 0, push -3, getMin, pop, top, getMin","expectedOutput":"-3, -2, 0, -2","explanation":"Standard operations"},{"input":"push 1, getMin","expectedOutput":"1","explanation":"Single element"},{"input":"push 1, push 2, getMin","expectedOutput":"1","explanation":"First is min"},{"input":"push 2, push 1, getMin","expectedOutput":"1","explanation":"Last is min"},{"input":"push 1, push 1, pop, getMin","expectedOutput":"1","explanation":"Duplicate min"},{"input":"push 5, push 3, push 7, getMin","expectedOutput":"3","explanation":"Min in middle"},{"input":"push 0, getMin","expectedOutput":"0","explanation":"Zero value"},{"input":"push -1, push -2, pop, getMin","expectedOutput":"-1","explanation":"Negative values"},{"input":"push 1, push 2, push 3, pop, pop, getMin","expectedOutput":"1","explanation":"Multiple pops"},{"input":"push 5, push 5, pop, getMin","expectedOutput":"5","explanation":"Same values"}],"solution":"#include <iostream>\\nusing namespace std;\\nclass MinStack { int stk[100],mstk[100],t; public: MinStack():t(-1){} void push(int v) { stk[++t]=v; mstk[t]=t==0?v:min(v,mstk[t-1]); } void pop() { t--; } int top() { return stk[t]; } int getMin() { return mstk[t]; } };\\nint main() { cout<<\\"OK\\"; return 0; }","explanation":{"approach":"Track min at each level.","steps":["Store min for each stack state"],"complexity":"Time: O(1), Space: O(n)"}},{"id":"e553","title":"Implement Queue Using Stacks","description":"Queue from two stacks.","difficulty":"EASY","category":"Stack","starterCode":"#include <iostream>\\nusing namespace std;\\nclass MyQueue {\\npublic:\\n    void push(int x) {}\\n    int pop() { return 0; }\\n    int peek() { return 0; }\\n    bool empty() { return true; }\\n};\\nint main() { MyQueue q; q.push(1); q.push(2); cout<<q.peek(); return 0; }","expectedOutput":"1","testCases":[{"input":"push 1, push 2, peek","expectedOutput":"1","explanation":"FIFO order"},{"input":"push 1, pop","expectedOutput":"1","explanation":"Single element"},{"input":"push 1, push 2, pop, peek","expectedOutput":"2","explanation":"After pop"},{"input":"push 1, push 2, push 3, pop, pop","expectedOutput":"1, 2","explanation":"Multiple ops"},{"input":"empty() on new queue","expectedOutput":"true","explanation":"Initially empty"},{"input":"push 1, empty","expectedOutput":"false","explanation":"Not empty after push"},{"input":"push 5, pop, empty","expectedOutput":"true","explanation":"Empty after pop"},{"input":"push 1, push 2, pop, push 3, peek","expectedOutput":"2","explanation":"Mixed ops"},{"input":"push 10, push 20, peek","expectedOutput":"10","explanation":"First in first out"},{"input":"push 1, peek, peek","expectedOutput":"1, 1","explanation":"Peek doesn't remove"}],"solution":"#include <iostream>\\nusing namespace std;\\nclass MyQueue { int s1[100],s2[100],t1,t2; public: MyQueue():t1(-1),t2(-1){} void push(int x) { s1[++t1]=x; } void move() { if(t2<0) while(t1>=0) s2[++t2]=s1[t1--]; } int pop() { move(); return s2[t2--]; } int peek() { move(); return s2[t2]; } bool empty() { return t1<0&&t2<0; } };\\nint main() { MyQueue q; q.push(1); q.push(2); cout<<q.peek(); return 0; }","explanation":{"approach":"Two stacks.","steps":["Push to s1","Move to s2 for pop/peek"],"complexity":"Time: O(1) amortized, Space: O(n)"}},{"id":"e554","title":"Implement Stack Using Queues","description":"Stack from queue.","difficulty":"EASY","category":"Stack","starterCode":"#include <iostream>\\nusing namespace std;\\nclass MyStack {\\npublic:\\n    void push(int x) {}\\n    int pop() { return 0; }\\n    int top() { return 0; }\\n    bool empty() { return true; }\\n};\\nint main() { MyStack s; s.push(1); s.push(2); cout<<s.top(); return 0; }","expectedOutput":"2","testCases":[{"input":"push 1, push 2, top","expectedOutput":"2","explanation":"LIFO order"},{"input":"push 1, pop","expectedOutput":"1","explanation":"Single element"},{"input":"push 1, push 2, pop","expectedOutput":"2","explanation":"Last in first out"},{"input":"push 1, push 2, push 3, top","expectedOutput":"3","explanation":"Multiple pushes"},{"input":"empty() on new stack","expectedOutput":"true","explanation":"Initially empty"},{"input":"push 1, empty","expectedOutput":"false","explanation":"Not empty"},{"input":"push 1, pop, empty","expectedOutput":"true","explanation":"Empty after pop"},{"input":"push 5, push 3, pop, top","expectedOutput":"5","explanation":"After pop"},{"input":"push 1, top, top","expectedOutput":"1, 1","explanation":"Top doesn't remove"},{"input":"push 10, push 20, pop, pop","expectedOutput":"20, 10","explanation":"LIFO pops"}],"solution":"#include <iostream>\\nusing namespace std;\\nclass MyStack { int q[100],f,b; public: MyStack():f(0),b(0){} void push(int x) { q[b++]=x; for(int i=0;i<b-f-1;i++) { q[b++]=q[f++]; } } int pop() { return q[f++]; } int top() { return q[f]; } bool empty() { return f==b; } };\\nint main() { MyStack s; s.push(1); s.push(2); cout<<s.top(); return 0; }","explanation":{"approach":"Rotate queue on push.","steps":["Push new element","Move all others to back"],"complexity":"Time: O(n) push, Space: O(n)"}},{"id":"e555","title":"Next Greater Element I","description":"Next greater in nums2 for nums1.","difficulty":"EASY","category":"Stack","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid nextGreaterElement(int n1[], int l1, int n2[], int l2) {}\\nint main() { int a[]={4,1,2}; int b[]={1,3,4,2}; nextGreaterElement(a,3,b,4); return 0; }","expectedOutput":"-1 3 -1","testCases":[{"input":"3 4\\n4 1 2\\n1 3 4 2","expectedOutput":"-1 3 -1","explanation":"4-1, 13, 2-1"},{"input":"2 4\\n2 4\\n1 2 3 4","expectedOutput":"3 -1","explanation":"23, 4-1"},{"input":"1 1\\n5\\n5","expectedOutput":"-1","explanation":"No greater element"},{"input":"2 3\\n1 2\\n1 2 3","expectedOutput":"2 3","explanation":"Both have greater"},{"input":"3 3\\n3 2 1\\n1 2 3","expectedOutput":"-1 3 2","explanation":"Reverse order"},{"input":"1 3\\n2\\n1 2 3","expectedOutput":"3","explanation":"Middle element"},{"input":"2 2\\n1 2\\n2 1","expectedOutput":"-1 -1","explanation":"No greater after"},{"input":"3 5\\n1 3 5\\n1 2 3 4 5","expectedOutput":"2 4 -1","explanation":"Various positions"},{"input":"1 2\\n1\\n1 2","expectedOutput":"2","explanation":"Simple case"},{"input":"2 4\\n2 1\\n1 2 3 4","expectedOutput":"3 2","explanation":"Out of order"}],"solution":"#include <iostream>\\nusing namespace std;\\nvoid nextGreaterElement(int n1[], int l1, int n2[], int l2) { for(int i=0;i<l1;i++) { int res=-1; bool found=false; for(int j=0;j<l2;j++) { if(n2[j]==n1[i]) found=true; if(found && n2[j]>n1[i]) { res=n2[j]; break; } } cout<<res<<\\" \\"; } }\\nint main() { int a[]={4,1,2}; int b[]={1,3,4,2}; nextGreaterElement(a,3,b,4); return 0; }","explanation":{"approach":"Find in nums2, then find next greater.","steps":["Locate element","Find first larger after"],"complexity":"Time: O(nm), Space: O(1)"}},{"id":"e556","title":"Baseball Game","description":"Calculate score.","difficulty":"EASY","category":"Stack","starterCode":"#include <iostream>\\nusing namespace std;\\nint calPoints(char* ops[], int n) { return 0; }\\nint main() { char* o[]={\\"5\\",\\"2\\",\\"C\\",\\"D\\",\\"+\\"}; cout<<calPoints(o,5); return 0; }","expectedOutput":"30","testCases":[{"input":"5 2 C D +","expectedOutput":"30","explanation":"5+10+15=30"},{"input":"5 -2 4 C D 9 + +","expectedOutput":"27","explanation":"Complex operations"},{"input":"1","expectedOutput":"1","explanation":"Single score"},{"input":"1 C","expectedOutput":"0","explanation":"Score then cancel"},{"input":"1 2 +","expectedOutput":"6","explanation":"1+2+3=6"},{"input":"5 D","expectedOutput":"15","explanation":"5+10=15"},{"input":"3 4 +","expectedOutput":"14","explanation":"3+4+7=14"},{"input":"1 2 3 C","expectedOutput":"3","explanation":"Cancel last"},{"input":"10 D D","expectedOutput":"70","explanation":"10+20+40"},{"input":"-5 D +","expectedOutput":"-25","explanation":"Negative scores"}],"solution":"#include <iostream>\\nusing namespace std;\\nint calPoints(char* ops[], int n) { int stk[100],top=-1; for(int i=0;i<n;i++) { if(ops[i][0]=='C') top--; else if(ops[i][0]=='D') stk[++top]=stk[top-1]*2; else if(ops[i][0]=='+') stk[++top]=stk[top-1]+stk[top-2]; else { int v=0,neg=ops[i][0]=='-'; for(int j=neg?1:0;ops[i][j];j++) v=v*10+ops[i][j]-'0'; stk[++top]=neg?-v:v; } } int sum=0; for(int i=0;i<=top;i++) sum+=stk[i]; return sum; }\\nint main() { char* o[]={\\"5\\",\\"2\\",\\"C\\",\\"D\\",\\"+\\"}; cout<<calPoints(o,5); return 0; }","explanation":{"approach":"Stack simulation.","steps":["Apply operations","Sum all scores"],"complexity":"Time: O(n), Space: O(n)"}},{"id":"e557","title":"Remove All Adjacent Duplicates","description":"Remove adjacent same chars.","difficulty":"EASY","category":"Stack","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid removeDuplicates(char s[]) {}\\nint main() { char s[]=\\"abbaca\\"; removeDuplicates(s); return 0; }","expectedOutput":"ca","testCases":[{"input":"abbaca","expectedOutput":"ca","explanation":"bba, then aaempty"},{"input":"azxxzy","expectedOutput":"ay","explanation":"xxempty, zzempty"},{"input":"aab","expectedOutput":"b","explanation":"aa removed"},{"input":"abc","expectedOutput":"abc","explanation":"No duplicates"},{"input":"aa","expectedOutput":"","explanation":"All removed"},{"input":"a","expectedOutput":"a","explanation":"Single char"},{"input":"aabb","expectedOutput":"","explanation":"Two pairs"},{"input":"abba","expectedOutput":"","explanation":"Cascading removal"},{"input":"abcd","expectedOutput":"abcd","explanation":"No adjacent same"},{"input":"aabbcc","expectedOutput":"","explanation":"Three pairs"}],"solution":"#include <iostream>\\nusing namespace std;\\nvoid removeDuplicates(char s[]) { char stk[100]; int top=-1; for(int i=0;s[i];i++) { if(top>=0&&stk[top]==s[i]) top--; else stk[++top]=s[i]; } for(int i=0;i<=top;i++) cout<<stk[i]; }\\nint main() { char s[]=\\"abbaca\\"; removeDuplicates(s); return 0; }","explanation":{"approach":"Stack for removal.","steps":["Pop if same as top","Else push"],"complexity":"Time: O(n), Space: O(n)"}},{"id":"e558","title":"Maximum Frequency Stack","description":"Pop most frequent.","difficulty":"HARD","category":"Stack","starterCode":"#include <iostream>\\nusing namespace std;\\nclass FreqStack {\\npublic:\\n    void push(int val) {}\\n    int pop() { return 0; }\\n};\\nint main() { cout<<\\"OK\\"; return 0; }","expectedOutput":"OK","testCases":[{"input":"push 5, push 7, push 5, push 7, push 4, push 5, pop, pop, pop, pop","expectedOutput":"5, 7, 5, 4","explanation":"Pop by frequency then recency"},{"input":"push 1, pop","expectedOutput":"1","explanation":"Single element"},{"input":"push 1, push 1, pop","expectedOutput":"1","explanation":"Duplicate"},{"input":"push 1, push 2, pop, pop","expectedOutput":"2, 1","explanation":"Same freq, LIFO"},{"input":"push 5, push 5, push 5, pop, pop, pop","expectedOutput":"5, 5, 5","explanation":"All same"},{"input":"push 1, push 2, push 1, pop","expectedOutput":"1","explanation":"1 is most frequent"},{"input":"push 3, push 3, push 1, push 1, pop","expectedOutput":"1","explanation":"Tie breaker by recency"},{"input":"push 1, push 2, push 3, pop, pop, pop","expectedOutput":"3, 2, 1","explanation":"LIFO when tied"},{"input":"push 9, push 9, pop, push 9, pop","expectedOutput":"9, 9","explanation":"Push after pop"},{"input":"push 1, push 1, push 2, push 2, pop, pop","expectedOutput":"2, 1","explanation":"Two pairs"}],"solution":"#include <iostream>\\nusing namespace std;\\nclass FreqStack { int stk[100],freq[101],n,mf; public: FreqStack():n(0),mf(0){ for(int i=0;i<101;i++) freq[i]=0; } void push(int v) { freq[v]++; if(freq[v]>mf) mf=freq[v]; stk[n++]=v; } int pop() { while(n>0&&freq[stk[n-1]]<mf) n--; if(n==0) { mf--; return -1; } int v=stk[--n]; freq[v]--; while(mf>0) { bool found=false; for(int i=0;i<101;i++) if(freq[i]==mf) { found=true; break; } if(found) break; mf--; } return v; } };\\nint main() { cout<<\\"OK\\"; return 0; }","explanation":{"approach":"Track frequency.","steps":["Push to stack","Pop from highest frequency"],"complexity":"Time: O(1), Space: O(n)"}},{"id":"e559","title":"Daily Temperatures","description":"Days until warmer.","difficulty":"MEDIUM","category":"Stack","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid dailyTemperatures(int t[], int n) {}\\nint main() { int t[]={73,74,75,71,69,72,76,73}; dailyTemperatures(t,8); return 0; }","expectedOutput":"1 1 4 2 1 1 0 0","testCases":[{"input":"8\\n73 74 75 71 69 72 76 73","expectedOutput":"1 1 4 2 1 1 0 0","explanation":"Days until warmer"},{"input":"4\\n30 40 50 60","expectedOutput":"1 1 1 0","explanation":"Increasing temps"},{"input":"4\\n30 60 90 0","expectedOutput":"1 1 0 0","explanation":"Last two no warmer"},{"input":"1\\n50","expectedOutput":"0","explanation":"Single day"},{"input":"3\\n70 70 70","expectedOutput":"0 0 0","explanation":"All same"},{"input":"3\\n90 80 70","expectedOutput":"0 0 0","explanation":"Decreasing"},{"input":"5\\n50 60 50 60 50","expectedOutput":"1 0 1 0 0","explanation":"Alternating"},{"input":"4\\n100 99 100 101","expectedOutput":"3 1 1 0","explanation":"Wait for 101"},{"input":"2\\n50 51","expectedOutput":"1 0","explanation":"Simple pair"},{"input":"3\\n75 80 75","expectedOutput":"1 0 0","explanation":"Peak in middle"}],"solution":"#include <iostream>\\nusing namespace std;\\nvoid dailyTemperatures(int t[], int n) { int stk[100],top=-1,res[n]={}; for(int i=0;i<n;i++) { while(top>=0&&t[i]>t[stk[top]]) { res[stk[top]]=i-stk[top]; top--; } stk[++top]=i; } for(int i=0;i<n;i++) cout<<res[i]<<\\" \\"; }\\nint main() { int t[]={73,74,75,71,69,72,76,73}; dailyTemperatures(t,8); return 0; }","explanation":{"approach":"Monotonic stack.","steps":["Pop while current is warmer","Calculate days difference"],"complexity":"Time: O(n), Space: O(n)"}},{"id":"e560","title":"Backspace String Compare","description":"Compare with backspaces.","difficulty":"EASY","category":"Stack","starterCode":"#include <iostream>\\nusing namespace std;\\nbool backspaceCompare(char s[], char t[]) { return false; }\\nint main() { cout<<backspaceCompare(\\"ab#c\\",\\"ad#c\\"); return 0; }","expectedOutput":"1","testCases":[{"input":"ab#c ad#c","expectedOutput":"1","explanation":"Both become 'ac'"},{"input":"ab## c#d#","expectedOutput":"1","explanation":"Both become empty"},{"input":"a#c a#c","expectedOutput":"1","explanation":"Same result"},{"input":"a b","expectedOutput":"0","explanation":"Different"},{"input":"## ","expectedOutput":"1","explanation":"All backspaced"},{"input":"abc abc","expectedOutput":"1","explanation":"Same strings"},{"input":"abc ab","expectedOutput":"0","explanation":"Different lengths"},{"input":"bxj##tw bxo#j##tw","expectedOutput":"1","explanation":"Complex backspace"},{"input":"a# b#","expectedOutput":"1","explanation":"Both empty"},{"input":"y#fo##f y#f#o##f","expectedOutput":"1","explanation":"Different paths same result"}],"solution":"#include <iostream>\\nusing namespace std;\\nvoid process(char s[], char r[]) { int j=0; for(int i=0;s[i];i++) { if(s[i]=='#') { if(j>0) j--; } else r[j++]=s[i]; } r[j]=0; }\\nbool backspaceCompare(char s[], char t[]) { char r1[100],r2[100]; process(s,r1); process(t,r2); for(int i=0;;i++) { if(r1[i]!=r2[i]) return false; if(!r1[i]) return true; } }\\nint main() { cout<<backspaceCompare(\\"ab#c\\",\\"ad#c\\"); return 0; }","explanation":{"approach":"Process then compare.","steps":["Apply backspaces","Compare results"],"complexity":"Time: O(n), Space: O(n)"}}]`),Zj=JSON.parse('[{"id":"e601","title":"Invert Binary Tree","description":"Mirror the tree.","difficulty":"EASY","category":"Trees","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nNode* invertTree(Node* r) { return nullptr; }\\nvoid pre(Node* r) { if(!r) return; cout<<r->v<<\\" \\"; pre(r->l); pre(r->r); }\\nint main() { Node* r=new Node(4); r->l=new Node(2); r->r=new Node(7); r=invertTree(r); pre(r); return 0; }","expectedOutput":"4 7 2","testCases":[{"input":"[4,2,7]","expectedOutput":"4 7 2","explanation":"Children swapped"},{"input":"[1]","expectedOutput":"1","explanation":"Single node unchanged"},{"input":"[]","expectedOutput":"","explanation":"Empty tree"},{"input":"[4,2,7,1,3,6,9]","expectedOutput":"4 7 9 6 2 3 1","explanation":"Full tree inverted"},{"input":"[2,1,3]","expectedOutput":"2 3 1","explanation":"Simple BST inverted"},{"input":"[1,2]","expectedOutput":"1 null 2","explanation":"Left child becomes right"},{"input":"[1,null,2]","expectedOutput":"1 2 null","explanation":"Right child becomes left"},{"input":"[5,3,8,2,4,7,9]","expectedOutput":"5 8 9 7 3 4 2","explanation":"Complete tree"},{"input":"[1,2,3,4,5]","expectedOutput":"1 3 2 5 4","explanation":"Recursively inverted"},{"input":"[10,5,15,null,null,12,20]","expectedOutput":"10 15 20 12 5","explanation":"Partial tree"}],"solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nNode* invertTree(Node* r) { if(!r) return 0; Node* t=r->l; r->l=invertTree(r->r); r->r=invertTree(t); return r; }\\nvoid pre(Node* r) { if(!r) return; cout<<r->v<<\\" \\"; pre(r->l); pre(r->r); }\\nint main() { Node* r=new Node(4); r->l=new Node(2); r->r=new Node(7); r=invertTree(r); pre(r); return 0; }","explanation":{"approach":"Swap children recursively.","steps":["Swap left and right","Recurse"],"complexity":"Time: O(n), Space: O(h)"}},{"id":"e602","title":"Same Tree","description":"Check if identical.","difficulty":"EASY","category":"Trees","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nbool isSameTree(Node* p, Node* q) { return false; }\\nint main() { Node* p=new Node(1); p->l=new Node(2); Node* q=new Node(1); q->l=new Node(2); cout<<isSameTree(p,q); return 0; }","expectedOutput":"1","testCases":[{"input":"[1,2] [1,2]","expectedOutput":"1","explanation":"Same structure and values"},{"input":"[1,2] [1,null,2]","expectedOutput":"0","explanation":"Different structure"},{"input":"[1,2,1] [1,1,2]","expectedOutput":"0","explanation":"Different values"},{"input":"[] []","expectedOutput":"1","explanation":"Both empty"},{"input":"[1] [1]","expectedOutput":"1","explanation":"Single same node"},{"input":"[1] [2]","expectedOutput":"0","explanation":"Single different node"},{"input":"[1] []","expectedOutput":"0","explanation":"One empty"},{"input":"[1,2,3] [1,2,3]","expectedOutput":"1","explanation":"Identical trees"},{"input":"[1,2,3] [1,2,4]","expectedOutput":"0","explanation":"One value different"},{"input":"[5,4,6,3,null,null,7] [5,4,6,3,null,null,7]","expectedOutput":"1","explanation":"Complex same tree"}],"solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nbool isSameTree(Node* p, Node* q) { if(!p&&!q) return true; if(!p||!q) return false; return p->v==q->v && isSameTree(p->l,q->l) && isSameTree(p->r,q->r); }\\nint main() { Node* p=new Node(1); p->l=new Node(2); Node* q=new Node(1); q->l=new Node(2); cout<<isSameTree(p,q); return 0; }","explanation":{"approach":"Compare recursively.","steps":["Both null = same","Compare values and children"],"complexity":"Time: O(n), Space: O(h)"}},{"id":"e603","title":"Merge Two Binary Trees","description":"Merge overlapping nodes.","difficulty":"EASY","category":"Trees","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nNode* mergeTrees(Node* r1, Node* r2) { return nullptr; }\\nvoid pre(Node* r) { if(!r) return; cout<<r->v<<\\" \\"; pre(r->l); pre(r->r); }\\nint main() { Node* t1=new Node(1); t1->l=new Node(3); Node* t2=new Node(2); t2->l=new Node(1); t2->r=new Node(3); Node* m=mergeTrees(t1,t2); pre(m); return 0; }","expectedOutput":"3 4 3","testCases":[{"input":"[1,3] [2,1,3]","expectedOutput":"3 4 3","explanation":"1+2=3, 3+1=4, null+3=3"},{"input":"[1] [1,2]","expectedOutput":"2 2","explanation":"Values added"},{"input":"[] [1]","expectedOutput":"1","explanation":"One empty"},{"input":"[1] []","expectedOutput":"1","explanation":"Other empty"},{"input":"[] []","expectedOutput":"","explanation":"Both empty"},{"input":"[1,2,3] [1,2,3]","expectedOutput":"2 4 6","explanation":"All values doubled"},{"input":"[0] [0]","expectedOutput":"0","explanation":"Zero values"},{"input":"[5,3,2] [1,4,null,3]","expectedOutput":"6 7 3 2","explanation":"Complex merge"},{"input":"[1,null,2] [1,2]","expectedOutput":"2 2 2","explanation":"Mixed structure"},{"input":"[10,5,15] [10,5,15]","expectedOutput":"20 10 30","explanation":"Symmetric merge"}],"solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nNode* mergeTrees(Node* r1, Node* r2) { if(!r1) return r2; if(!r2) return r1; r1->v+=r2->v; r1->l=mergeTrees(r1->l,r2->l); r1->r=mergeTrees(r1->r,r2->r); return r1; }\\nvoid pre(Node* r) { if(!r) return; cout<<r->v<<\\" \\"; pre(r->l); pre(r->r); }\\nint main() { Node* t1=new Node(1); t1->l=new Node(3); Node* t2=new Node(2); t2->l=new Node(1); t2->r=new Node(3); Node* m=mergeTrees(t1,t2); pre(m); return 0; }","explanation":{"approach":"Add values, recurse.","steps":["Sum overlapping nodes","Recurse on children"],"complexity":"Time: O(n), Space: O(h)"}},{"id":"e604","title":"Search in BST","description":"Find node in BST.","difficulty":"EASY","category":"Trees","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nNode* searchBST(Node* r, int val) { return nullptr; }\\nint main() { Node* r=new Node(4); r->l=new Node(2); r->r=new Node(7); Node* res=searchBST(r,2); cout<<(res?res->v:-1); return 0; }","expectedOutput":"2","testCases":[{"input":"[4,2,7] 2","expectedOutput":"2","explanation":"Found in left subtree"},{"input":"[4,2,7] 5","expectedOutput":"-1","explanation":"Not found"},{"input":"[4,2,7] 4","expectedOutput":"4","explanation":"Found at root"},{"input":"[4,2,7] 7","expectedOutput":"7","explanation":"Found in right subtree"},{"input":"[1] 1","expectedOutput":"1","explanation":"Single node match"},{"input":"[1] 2","expectedOutput":"-1","explanation":"Single node no match"},{"input":"[5,3,7,2,4,6,8] 6","expectedOutput":"6","explanation":"Found deep in tree"},{"input":"[5,3,7,2,4,6,8] 1","expectedOutput":"-1","explanation":"Not in tree"},{"input":"[10,5,15,3,7,12,20] 12","expectedOutput":"12","explanation":"Complex BST search"},{"input":"[50,25,75] 100","expectedOutput":"-1","explanation":"Beyond range"}],"solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nNode* searchBST(Node* r, int val) { if(!r||r->v==val) return r; return val<r->v?searchBST(r->l,val):searchBST(r->r,val); }\\nint main() { Node* r=new Node(4); r->l=new Node(2); r->r=new Node(7); Node* res=searchBST(r,2); cout<<(res?res->v:-1); return 0; }","explanation":{"approach":"BST property search.","steps":["If less go left","If more go right"],"complexity":"Time: O(h), Space: O(h)"}},{"id":"e605","title":"Range Sum BST","description":"Sum values in range.","difficulty":"EASY","category":"Trees","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nint rangeSumBST(Node* r, int lo, int hi) { return 0; }\\nint main() { Node* r=new Node(10); r->l=new Node(5); r->r=new Node(15); r->l->l=new Node(3); r->l->r=new Node(7); cout<<rangeSumBST(r,7,15); return 0; }","expectedOutput":"32","testCases":[{"input":"[10,5,15,3,7] 7 15","expectedOutput":"32","explanation":"7+10+15=32"},{"input":"[10,5,15,3,7,13,18,1,null,6] 6 10","expectedOutput":"23","explanation":"6+7+10=23"},{"input":"[1] 1 1","expectedOutput":"1","explanation":"Single node in range"},{"input":"[1] 2 3","expectedOutput":"0","explanation":"Out of range"},{"input":"[10,5,15] 1 20","expectedOutput":"30","explanation":"All nodes in range"},{"input":"[10,5,15] 5 5","expectedOutput":"5","explanation":"Exact match"},{"input":"[10,5,15] 10 10","expectedOutput":"10","explanation":"Root only"},{"input":"[5,3,7,2,4,6,8] 4 6","expectedOutput":"15","explanation":"4+5+6=15"},{"input":"[100,50,150,25,75] 50 100","expectedOutput":"225","explanation":"50+75+100"},{"input":"[20,10,30,5,15,25,35] 10 25","expectedOutput":"75","explanation":"10+15+20+25+5=75"}],"solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nint rangeSumBST(Node* r, int lo, int hi) { if(!r) return 0; int s=0; if(r->v>=lo && r->v<=hi) s+=r->v; if(r->v>lo) s+=rangeSumBST(r->l,lo,hi); if(r->v<hi) s+=rangeSumBST(r->r,lo,hi); return s; }\\nint main() { Node* r=new Node(10); r->l=new Node(5); r->r=new Node(15); r->l->l=new Node(3); r->l->r=new Node(7); cout<<rangeSumBST(r,7,15); return 0; }","explanation":{"approach":"Prune using BST property.","steps":["Add if in range","Skip subtrees outside range"],"complexity":"Time: O(n), Space: O(h)"}},{"id":"e606","title":"Minimum Depth Binary Tree","description":"Shortest path to leaf.","difficulty":"EASY","category":"Trees","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nint minDepth(Node* r) { return 0; }\\nint main() { Node* r=new Node(3); r->l=new Node(9); r->r=new Node(20); r->r->l=new Node(15); r->r->r=new Node(7); cout<<minDepth(r); return 0; }","expectedOutput":"2","testCases":[{"input":"[3,9,20,null,null,15,7]","expectedOutput":"2","explanation":"Path to 9 is shortest"},{"input":"[1]","expectedOutput":"1","explanation":"Root is leaf"},{"input":"[1,2]","expectedOutput":"2","explanation":"Only left child"},{"input":"[1,null,2]","expectedOutput":"2","explanation":"Only right child"},{"input":"[1,2,3]","expectedOutput":"2","explanation":"Two children same level"},{"input":"[2,null,3,null,4,null,5,null,6]","expectedOutput":"5","explanation":"Right-skewed"},{"input":"[1,2,3,4,5]","expectedOutput":"2","explanation":"Leaf at level 2"},{"input":"[1,2,3,4,5,6,7]","expectedOutput":"3","explanation":"Complete tree"},{"input":"[1,2,null,3,null,4]","expectedOutput":"4","explanation":"Left-skewed"},{"input":"[5,4,8,11,null,13,4,7,2]","expectedOutput":"2","explanation":"Multiple depths"}],"solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nint minDepth(Node* r) { if(!r) return 0; if(!r->l) return 1+minDepth(r->r); if(!r->r) return 1+minDepth(r->l); return 1+min(minDepth(r->l),minDepth(r->r)); }\\nint main() { Node* r=new Node(3); r->l=new Node(9); r->r=new Node(20); r->r->l=new Node(15); r->r->r=new Node(7); cout<<minDepth(r); return 0; }","explanation":{"approach":"Handle single child case.","steps":["If one child null, go other way","Else take minimum"],"complexity":"Time: O(n), Space: O(h)"}},{"id":"e607","title":"Count Complete Tree Nodes","description":"Count nodes efficiently.","difficulty":"MEDIUM","category":"Trees","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nint countNodes(Node* r) { return 0; }\\nint main() { Node* r=new Node(1); r->l=new Node(2); r->r=new Node(3); r->l->l=new Node(4); r->l->r=new Node(5); r->r->l=new Node(6); cout<<countNodes(r); return 0; }","expectedOutput":"6","testCases":[{"input":"[1,2,3,4,5,6]","expectedOutput":"6","explanation":"Complete tree with 6 nodes"},{"input":"[]","expectedOutput":"0","explanation":"Empty tree"},{"input":"[1]","expectedOutput":"1","explanation":"Single node"},{"input":"[1,2,3]","expectedOutput":"3","explanation":"Full level"},{"input":"[1,2,3,4,5,6,7]","expectedOutput":"7","explanation":"Perfect tree"},{"input":"[1,2]","expectedOutput":"2","explanation":"Root with left child"},{"input":"[1,2,3,4]","expectedOutput":"4","explanation":"One in last level"},{"input":"[1,2,3,4,5]","expectedOutput":"5","explanation":"Two in last level"},{"input":"[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]","expectedOutput":"15","explanation":"Large perfect tree"},{"input":"[1,2,3,4,5,6,7,8]","expectedOutput":"8","explanation":"One extra in last level"}],"solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nint countNodes(Node* r) { if(!r) return 0; return 1+countNodes(r->l)+countNodes(r->r); }\\nint main() { Node* r=new Node(1); r->l=new Node(2); r->r=new Node(3); r->l->l=new Node(4); r->l->r=new Node(5); r->r->l=new Node(6); cout<<countNodes(r); return 0; }","explanation":{"approach":"Recursive count.","steps":["Count left + right + 1"],"complexity":"Time: O(n), Space: O(h)"}},{"id":"e608","title":"Sum of Left Leaves","description":"Sum all left leaves.","difficulty":"EASY","category":"Trees","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nint sumOfLeftLeaves(Node* r) { return 0; }\\nint main() { Node* r=new Node(3); r->l=new Node(9); r->r=new Node(20); r->r->l=new Node(15); r->r->r=new Node(7); cout<<sumOfLeftLeaves(r); return 0; }","expectedOutput":"24","testCases":[{"input":"[3,9,20,null,null,15,7]","expectedOutput":"24","explanation":"9+15=24"},{"input":"[1]","expectedOutput":"0","explanation":"Root is not left leaf"},{"input":"[1,2,3,4,5]","expectedOutput":"4","explanation":"Only 4 is left leaf"},{"input":"[1,2]","expectedOutput":"2","explanation":"2 is left leaf"},{"input":"[1,null,2]","expectedOutput":"0","explanation":"No left leaves"},{"input":"[1,2,3,4,5,6,7]","expectedOutput":"10","explanation":"4+6=10"},{"input":"[0,2,4,1,null,3,-1,5,1,null,6,null,8]","expectedOutput":"5","explanation":"Complex tree"},{"input":"[1,2,3,null,null,4,5]","expectedOutput":"6","explanation":"2+4=6"},{"input":"[10,5,15,3,7]","expectedOutput":"3","explanation":"Only 3 is left leaf"},{"input":"[1,0,2]","expectedOutput":"0","explanation":"Left leaf is 0"}],"solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nint sumOfLeftLeaves(Node* r) { if(!r) return 0; int s=0; if(r->l && !r->l->l && !r->l->r) s+=r->l->v; s+=sumOfLeftLeaves(r->l)+sumOfLeftLeaves(r->r); return s; }\\nint main() { Node* r=new Node(3); r->l=new Node(9); r->r=new Node(20); r->r->l=new Node(15); r->r->r=new Node(7); cout<<sumOfLeftLeaves(r); return 0; }","explanation":{"approach":"Check if left child is leaf.","steps":["Add left leaf value","Recurse on children"],"complexity":"Time: O(n), Space: O(h)"}},{"id":"e609","title":"Find Mode in BST","description":"Most frequent values.","difficulty":"EASY","category":"Trees","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nvoid findMode(Node* r) {}\\nint main() { Node* r=new Node(1); r->r=new Node(2); r->r->l=new Node(2); findMode(r); return 0; }","expectedOutput":"2","testCases":[{"input":"[1,null,2,2]","expectedOutput":"2","explanation":"2 appears twice"},{"input":"[0]","expectedOutput":"0","explanation":"Single node"},{"input":"[1,null,2]","expectedOutput":"1 2","explanation":"Both appear once"},{"input":"[1,0,2,0,0]","expectedOutput":"0","explanation":"0 appears three times"},{"input":"[2,1,3,1,1]","expectedOutput":"1","explanation":"1 appears three times"},{"input":"[5,3,7,3,3,7,7]","expectedOutput":"3 7","explanation":"Both appear three times"},{"input":"[1,1,2,1,1,2,2]","expectedOutput":"1","explanation":"1 appears four times"},{"input":"[4,2,6,2,3]","expectedOutput":"2","explanation":"2 appears twice"},{"input":"[10,5,15,null,null,10,20]","expectedOutput":"10","explanation":"10 appears twice"},{"input":"[1,1,1]","expectedOutput":"1","explanation":"All same value"}],"solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nint cnt[101]={};\\nvoid inorder(Node* r) { if(!r) return; inorder(r->l); cnt[r->v]++; inorder(r->r); }\\nvoid findMode(Node* r) { inorder(r); int mx=0; for(int i=0;i<101;i++) mx=max(mx,cnt[i]); for(int i=0;i<101;i++) if(cnt[i]==mx) cout<<i<<\\" \\"; }\\nint main() { Node* r=new Node(1); r->r=new Node(2); r->r->l=new Node(2); findMode(r); return 0; }","explanation":{"approach":"Count occurrences.","steps":["Inorder traversal","Find max frequency"],"complexity":"Time: O(n), Space: O(n)"}},{"id":"e610","title":"Lowest Common Ancestor BST","description":"LCA in BST.","difficulty":"MEDIUM","category":"Trees","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nNode* lowestCommonAncestor(Node* r, Node* p, Node* q) { return nullptr; }\\nint main() { Node* r=new Node(6); r->l=new Node(2); r->r=new Node(8); cout<<lowestCommonAncestor(r,r->l,r->r)->v; return 0; }","expectedOutput":"6","testCases":[{"input":"[6,2,8] p=2 q=8","expectedOutput":"6","explanation":"Root is LCA"},{"input":"[6,2,8,0,4,7,9] p=2 q=4","expectedOutput":"2","explanation":"One node is ancestor"},{"input":"[6,2,8,0,4,7,9,null,null,3,5] p=3 q=5","expectedOutput":"4","explanation":"Deep LCA"},{"input":"[2,1] p=2 q=1","expectedOutput":"2","explanation":"Root and child"},{"input":"[6,2,8] p=2 q=2","expectedOutput":"2","explanation":"Same node"},{"input":"[6,2,8,0,4,7,9] p=0 q=4","expectedOutput":"2","explanation":"Left subtree LCA"},{"input":"[6,2,8,0,4,7,9] p=7 q=9","expectedOutput":"8","explanation":"Right subtree LCA"},{"input":"[6,2,8,0,4,7,9] p=0 q=9","expectedOutput":"6","explanation":"Across subtrees"},{"input":"[5,3,7,2,4,6,8] p=2 q=8","expectedOutput":"5","explanation":"Wide span"},{"input":"[5,3,7,2,4,6,8] p=6 q=7","expectedOutput":"7","explanation":"Parent-child"}],"solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nNode* lowestCommonAncestor(Node* r, Node* p, Node* q) { if(p->v<r->v && q->v<r->v) return lowestCommonAncestor(r->l,p,q); if(p->v>r->v && q->v>r->v) return lowestCommonAncestor(r->r,p,q); return r; }\\nint main() { Node* r=new Node(6); r->l=new Node(2); r->r=new Node(8); cout<<lowestCommonAncestor(r,r->l,r->r)->v; return 0; }","explanation":{"approach":"BST split point.","steps":["If both left, go left","If both right, go right","Else current is LCA"],"complexity":"Time: O(h), Space: O(h)"}}]'),eM=JSON.parse(`[{"id":"med1","title":"Two Sum Sorted","description":"Two pointers for sorted array.","difficulty":"MEDIUM","category":"Two Pointers","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid twoSum(int a[], int n, int t) {}\\nint main() { int a[]={2,7,11,15}; twoSum(a,4,9); return 0; }","expectedOutput":"0 1","testCases":[{"input":"4 9\\n2 7 11 15","expectedOutput":"0 1","explanation":"2+7=9"},{"input":"3 6\\n2 3 4","expectedOutput":"0 2","explanation":"2+4=6"},{"input":"2 3\\n1 2","expectedOutput":"0 1","explanation":"1+2=3"},{"input":"4 18\\n2 7 11 15","expectedOutput":"1 2","explanation":"7+11=18"},{"input":"5 10\\n1 2 3 4 6","expectedOutput":"2 4","explanation":"4+6=10"},{"input":"4 26\\n2 7 11 15","expectedOutput":"2 3","explanation":"11+15=26"},{"input":"5 5\\n1 2 2 3 4","expectedOutput":"1 2","explanation":"2+3=5 or 1+4=5"},{"input":"3 100\\n10 50 90","expectedOutput":"0 2","explanation":"10+90=100"},{"input":"4 -1\\n-3 0 2 5","expectedOutput":"0 2","explanation":"-3+2=-1"},{"input":"5 0\\n-5 -3 1 2 5","expectedOutput":"0 4","explanation":"-5+5=0"}],"solution":"#include <iostream>\\nusing namespace std;\\nvoid twoSum(int a[], int n, int t) { int l=0, r=n-1; while(l<r) { int s=a[l]+a[r]; if(s==t) { cout<<l<<\\" \\"<<r; return; } if(s<t) l++; else r--; } }\\nint main() { int a[]={2,7,11,15}; twoSum(a,4,9); return 0; }","explanation":{"approach":"Two pointers from both ends, adjust based on sum.","analogy":"Squeeze from both ends until you find the target.","steps":["If sum < target, move left pointer right","If sum > target, move right pointer left"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"med2","title":"Container With Most Water","description":"Max area between lines.","difficulty":"MEDIUM","category":"Two Pointers","starterCode":"#include <iostream>\\nusing namespace std;\\nint maxArea(int h[], int n) { return 0; }\\nint main() { int h[]={1,8,6,2,5,4,8,3,7}; cout<<maxArea(h,9); return 0; }","expectedOutput":"49","testCases":[{"input":"9\\n1 8 6 2 5 4 8 3 7","expectedOutput":"49","explanation":"Between index 1 and 8"},{"input":"2\\n1 1","expectedOutput":"1","explanation":"11=1"},{"input":"4\\n1 2 1 2","expectedOutput":"4","explanation":"22=4"},{"input":"3\\n4 3 2","expectedOutput":"4","explanation":"22=4"},{"input":"5\\n1 2 3 4 5","expectedOutput":"6","explanation":"Best container"},{"input":"5\\n5 4 3 2 1","expectedOutput":"6","explanation":"Decreasing heights"},{"input":"6\\n2 3 4 5 18 17","expectedOutput":"17","explanation":"Tall bars at end"},{"input":"4\\n1 8 8 1","expectedOutput":"8","explanation":"Two tall bars"},{"input":"9\\n1 1 1 1 1 1 1 1 1","expectedOutput":"8","explanation":"All same height"},{"input":"3\\n10 1 10","expectedOutput":"20","explanation":"Wide span"}],"solution":"#include <iostream>\\nusing namespace std;\\nint maxArea(int h[], int n) { int l=0, r=n-1, mx=0; while(l<r) { int area=(r-l)*min(h[l],h[r]); mx=max(mx,area); if(h[l]<h[r]) l++; else r--; } return mx; }\\nint main() { int h[]={1,8,6,2,5,4,8,3,7}; cout<<maxArea(h,9); return 0; }","explanation":{"approach":"Two pointers, move shorter line inward.","analogy":"The shorter wall limits water height.","steps":["Calculate area","Move the shorter side inward"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"med3","title":"Three Sum","description":"Find triplets summing to target.","difficulty":"MEDIUM","category":"Two Pointers","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid threeSum(int a[], int n, int t) {}\\nint main() { int a[]={-1,0,1,2,-1,-4}; threeSum(a,6,0); return 0; }","expectedOutput":"-1 -1 2 -1 0 1","testCases":[{"input":"6 0\\n-1 0 1 2 -1 -4","expectedOutput":"-1 -1 2 -1 0 1","explanation":"Two unique triplets"},{"input":"3 0\\n0 0 0","expectedOutput":"0 0 0","explanation":"All zeros"},{"input":"4 0\\n0 1 1 1","expectedOutput":"","explanation":"No triplet"},{"input":"4 6\\n1 2 3 4","expectedOutput":"1 2 3","explanation":"Single triplet"},{"input":"5 0\\n-2 -1 0 1 2","expectedOutput":"-2 0 2 -1 0 1","explanation":"Two triplets"},{"input":"6 9\\n1 2 3 4 5 6","expectedOutput":"1 2 6 1 3 5 2 3 4","explanation":"Multiple triplets"},{"input":"3 10\\n1 2 3","expectedOutput":"","explanation":"Sum too small"},{"input":"4 -6\\n-5 -3 1 2","expectedOutput":"-5 -3 2","explanation":"Negative sum"},{"input":"5 0\\n-1 -1 -1 2 2","expectedOutput":"-1 -1 2","explanation":"Duplicate handling"},{"input":"6 3\\n-1 0 1 2 -1 -4","expectedOutput":"-1 2 2","explanation":"Different target"}],"solution":"#include <iostream>\\nusing namespace std;\\nvoid threeSum(int a[], int n, int t) { for(int i=0;i<n-2;i++) for(int j=i+1;j<n-1;j++) for(int k=j+1;k<n;k++) if(a[i]+a[j]+a[k]==t) cout<<a[i]<<\\" \\"<<a[j]<<\\" \\"<<a[k]<<\\" \\"; }\\nint main() { int a[]={-1,0,1,2,-1,-4}; threeSum(a,6,0); return 0; }","explanation":{"approach":"Fix one element, use two sum on rest.","analogy":"Pick one, find pair in rest.","steps":["For each element, find two sum in remaining"],"complexity":"Time: O(n) brute, O(n) optimized, Space: O(1)"}},{"id":"med4","title":"Merge Sorted Arrays","description":"Merge two sorted arrays.","difficulty":"MEDIUM","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid merge(int a[], int m, int b[], int n, int c[]) {}\\nint main() { int a[]={1,3,5}, b[]={2,4,6}, c[6]; merge(a,3,b,3,c); for(int i=0;i<6;i++) cout<<c[i]<<(i<5?\\" \\":\\"\\"); return 0; }","expectedOutput":"1 2 3 4 5 6","testCases":[{"input":"3 3\\n1 3 5\\n2 4 6","expectedOutput":"1 2 3 4 5 6","explanation":"Interleaved merge"},{"input":"3 3\\n1 2 3\\n4 5 6","expectedOutput":"1 2 3 4 5 6","explanation":"First all smaller"},{"input":"3 3\\n4 5 6\\n1 2 3","expectedOutput":"1 2 3 4 5 6","explanation":"Second all smaller"},{"input":"1 1\\n1\\n2","expectedOutput":"1 2","explanation":"Single elements"},{"input":"2 3\\n1 5\\n2 3 4","expectedOutput":"1 2 3 4 5","explanation":"Different sizes"},{"input":"4 2\\n1 2 3 4\\n5 6","expectedOutput":"1 2 3 4 5 6","explanation":"No interleave"},{"input":"3 3\\n1 1 1\\n2 2 2","expectedOutput":"1 1 1 2 2 2","explanation":"Duplicates"},{"input":"3 3\\n1 2 3\\n1 2 3","expectedOutput":"1 1 2 2 3 3","explanation":"Same arrays"},{"input":"2 4\\n3 7\\n1 2 5 8","expectedOutput":"1 2 3 5 7 8","explanation":"Mixed"},{"input":"3 3\\n-3 -1 0\\n-2 1 2","expectedOutput":"-3 -2 -1 0 1 2","explanation":"Negative values"}],"solution":"#include <iostream>\\nusing namespace std;\\nvoid merge(int a[], int m, int b[], int n, int c[]) { int i=0,j=0,k=0; while(i<m && j<n) c[k++]= a[i]<b[j] ? a[i++] : b[j++]; while(i<m) c[k++]=a[i++]; while(j<n) c[k++]=b[j++]; }\\nint main() { int a[]={1,3,5}, b[]={2,4,6}, c[6]; merge(a,3,b,3,c); for(int i=0;i<6;i++) cout<<c[i]<<(i<5?\\" \\":\\"\\"); return 0; }","explanation":{"approach":"Two pointers, pick smaller each time.","analogy":"Merge two sorted decks of cards.","steps":["Compare front of both","Take smaller","Repeat"],"complexity":"Time: O(m+n), Space: O(m+n)"}},{"id":"med5","title":"Quick Sort","description":"Divide and conquer sort.","difficulty":"MEDIUM","category":"Sorting","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid quickSort(int a[], int l, int r) {}\\nint main() { int a[]={10,7,8,9,1,5}; quickSort(a,0,5); for(int i=0;i<6;i++) cout<<a[i]<<(i<5?\\" \\":\\"\\"); return 0; }","expectedOutput":"1 5 7 8 9 10","testCases":[{"input":"6\\n10 7 8 9 1 5","expectedOutput":"1 5 7 8 9 10","explanation":"Sorted array"},{"input":"5\\n5 4 3 2 1","expectedOutput":"1 2 3 4 5","explanation":"Reverse sorted"},{"input":"5\\n1 2 3 4 5","expectedOutput":"1 2 3 4 5","explanation":"Already sorted"},{"input":"1\\n5","expectedOutput":"5","explanation":"Single element"},{"input":"2\\n2 1","expectedOutput":"1 2","explanation":"Two elements"},{"input":"4\\n4 4 4 4","expectedOutput":"4 4 4 4","explanation":"All same"},{"input":"6\\n3 1 4 1 5 9","expectedOutput":"1 1 3 4 5 9","explanation":"With duplicates"},{"input":"7\\n64 25 12 22 11 90 45","expectedOutput":"11 12 22 25 45 64 90","explanation":"Larger example"},{"input":"5\\n-5 -2 0 3 1","expectedOutput":"-5 -2 0 1 3","explanation":"With negatives"},{"input":"8\\n100 50 25 12 6 3 1 0","expectedOutput":"0 1 3 6 12 25 50 100","explanation":"Powers of 2ish"}],"solution":"#include <iostream>\\nusing namespace std;\\nint partition(int a[], int l, int r) { int p=a[r], i=l-1; for(int j=l;j<r;j++) if(a[j]<p) { i++; swap(a[i],a[j]); } swap(a[i+1],a[r]); return i+1; }\\nvoid quickSort(int a[], int l, int r) { if(l<r) { int p=partition(a,l,r); quickSort(a,l,p-1); quickSort(a,p+1,r); } }\\nint main() { int a[]={10,7,8,9,1,5}; quickSort(a,0,5); for(int i=0;i<6;i++) cout<<a[i]<<(i<5?\\" \\":\\"\\"); return 0; }","explanation":{"approach":"Pick pivot, partition, recurse on halves.","analogy":"Put smaller on left, larger on right, repeat.","steps":["Choose pivot","Partition around it","Recurse"],"complexity":"Time: O(n log n) avg, Space: O(log n)"}},{"id":"med6","title":"Merge Sort","description":"Divide merge sort.","difficulty":"MEDIUM","category":"Sorting","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid mergeSort(int a[], int l, int r) {}\\nint main() { int a[]={12,11,13,5,6,7}; mergeSort(a,0,5); for(int i=0;i<6;i++) cout<<a[i]<<(i<5?\\" \\":\\"\\"); return 0; }","expectedOutput":"5 6 7 11 12 13","testCases":[{"input":"6\\n12 11 13 5 6 7","expectedOutput":"5 6 7 11 12 13","explanation":"Sorted output"},{"input":"5\\n5 4 3 2 1","expectedOutput":"1 2 3 4 5","explanation":"Reverse sorted"},{"input":"5\\n1 2 3 4 5","expectedOutput":"1 2 3 4 5","explanation":"Already sorted"},{"input":"1\\n5","expectedOutput":"5","explanation":"Single element"},{"input":"2\\n2 1","expectedOutput":"1 2","explanation":"Two elements"},{"input":"4\\n4 4 4 4","expectedOutput":"4 4 4 4","explanation":"All same"},{"input":"7\\n38 27 43 3 9 82 10","expectedOutput":"3 9 10 27 38 43 82","explanation":"Larger example"},{"input":"8\\n5 3 8 4 2 7 1 6","expectedOutput":"1 2 3 4 5 6 7 8","explanation":"Mixed order"},{"input":"5\\n-5 -2 0 3 1","expectedOutput":"-5 -2 0 1 3","explanation":"With negatives"},{"input":"6\\n100 1 50 25 75 10","expectedOutput":"1 10 25 50 75 100","explanation":"Wide range"}],"solution":"#include <iostream>\\nusing namespace std;\\nvoid merge(int a[], int l, int m, int r) { int n1=m-l+1, n2=r-m; int L[n1], R[n2]; for(int i=0;i<n1;i++) L[i]=a[l+i]; for(int i=0;i<n2;i++) R[i]=a[m+1+i]; int i=0,j=0,k=l; while(i<n1 && j<n2) a[k++]= L[i]<=R[j] ? L[i++] : R[j++]; while(i<n1) a[k++]=L[i++]; while(j<n2) a[k++]=R[j++]; }\\nvoid mergeSort(int a[], int l, int r) { if(l<r) { int m=(l+r)/2; mergeSort(a,l,m); mergeSort(a,m+1,r); merge(a,l,m,r); } }\\nint main() { int a[]={12,11,13,5,6,7}; mergeSort(a,0,5); for(int i=0;i<6;i++) cout<<a[i]<<(i<5?\\" \\":\\"\\"); return 0; }","explanation":{"approach":"Split in half, sort each, merge.","analogy":"Divide army, organize each half, combine.","steps":["Split in middle","Recursively sort","Merge sorted halves"],"complexity":"Time: O(n log n), Space: O(n)"}},{"id":"med7","title":"Kadane's Algorithm","description":"Maximum subarray sum.","difficulty":"MEDIUM","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint maxSubArray(int a[], int n) { return 0; }\\nint main() { int a[]={-2,1,-3,4,-1,2,1,-5,4}; cout<<maxSubArray(a,9); return 0; }","expectedOutput":"6","testCases":[{"input":"9\\n-2 1 -3 4 -1 2 1 -5 4","expectedOutput":"6","explanation":"[4,-1,2,1] = 6"},{"input":"1\\n1","expectedOutput":"1","explanation":"Single element"},{"input":"5\\n5 4 -1 7 8","expectedOutput":"23","explanation":"Entire array"},{"input":"5\\n-1 -2 -3 -4 -5","expectedOutput":"-1","explanation":"Least negative"},{"input":"3\\n-2 1 -1","expectedOutput":"1","explanation":"Single positive"},{"input":"6\\n1 2 3 4 5 6","expectedOutput":"21","explanation":"All positive"},{"input":"4\\n-2 -1 2 3","expectedOutput":"5","explanation":"End subarray"},{"input":"5\\n3 -1 -1 -1 3","expectedOutput":"3","explanation":"First or last"},{"input":"6\\n1 -1 1 -1 1 -1","expectedOutput":"1","explanation":"Alternating"},{"input":"4\\n-1 4 -2 5","expectedOutput":"7","explanation":"Skip first negative"}],"solution":"#include <iostream>\\nusing namespace std;\\nint maxSubArray(int a[], int n) { int mx=a[0], cur=a[0]; for(int i=1;i<n;i++) { cur=max(a[i], cur+a[i]); mx=max(mx, cur); } return mx; }\\nint main() { int a[]={-2,1,-3,4,-1,2,1,-5,4}; cout<<maxSubArray(a,9); return 0; }","explanation":{"approach":"Either start fresh or extend previous.","analogy":"Best profit streak - reset if going negative.","steps":["cur = max(current element, extend previous)","Track overall max"],"complexity":"Time: O(n), Space: O(1)"}},{"id":"med8","title":"Longest Increasing Subsequence","description":"Length of LIS.","difficulty":"MEDIUM","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint lis(int a[], int n) { return 0; }\\nint main() { int a[]={10,9,2,5,3,7,101,18}; cout<<lis(a,8); return 0; }","expectedOutput":"4","testCases":[{"input":"8\\n10 9 2 5 3 7 101 18","expectedOutput":"4","explanation":"[2,3,7,101] or [2,5,7,18]"},{"input":"6\\n0 1 0 3 2 3","expectedOutput":"4","explanation":"[0,1,2,3]"},{"input":"7\\n7 7 7 7 7 7 7","expectedOutput":"1","explanation":"All same"},{"input":"1\\n5","expectedOutput":"1","explanation":"Single element"},{"input":"5\\n1 2 3 4 5","expectedOutput":"5","explanation":"Already increasing"},{"input":"5\\n5 4 3 2 1","expectedOutput":"1","explanation":"Decreasing"},{"input":"8\\n3 10 2 1 20 4 6 7","expectedOutput":"4","explanation":"[1,4,6,7]"},{"input":"9\\n1 3 6 7 9 4 10 5 6","expectedOutput":"6","explanation":"[1,3,6,7,9,10]"},{"input":"6\\n2 5 3 7 11 8","expectedOutput":"4","explanation":"[2,3,7,11] or [2,5,7,11]"},{"input":"4\\n1 101 2 3","expectedOutput":"3","explanation":"[1,2,3]"}],"solution":"#include <iostream>\\nusing namespace std;\\nint lis(int a[], int n) { int dp[n]; for(int i=0;i<n;i++) dp[i]=1; for(int i=1;i<n;i++) for(int j=0;j<i;j++) if(a[j]<a[i]) dp[i]=max(dp[i], dp[j]+1); int mx=0; for(int i=0;i<n;i++) mx=max(mx,dp[i]); return mx; }\\nint main() { int a[]={10,9,2,5,3,7,101,18}; cout<<lis(a,8); return 0; }","explanation":{"approach":"dp[i] = longest ending at i.","analogy":"Build sequence one element at a time.","steps":["For each element, check all before","If smaller, extend that sequence"],"complexity":"Time: O(n), Space: O(n)"}},{"id":"med9","title":"Coin Change","description":"Minimum coins for amount.","difficulty":"MEDIUM","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint coinChange(int coins[], int n, int amount) { return -1; }\\nint main() { int c[]={1,2,5}; cout<<coinChange(c,3,11); return 0; }","expectedOutput":"3","testCases":[{"input":"3 11\\n1 2 5","expectedOutput":"3","explanation":"5+5+1=11"},{"input":"1 3\\n2","expectedOutput":"-1","explanation":"Impossible"},{"input":"1 0\\n1","expectedOutput":"0","explanation":"Zero amount"},{"input":"3 6\\n1 3 4","expectedOutput":"2","explanation":"3+3=6"},{"input":"3 100\\n1 5 10","expectedOutput":"10","explanation":"1010=100"},{"input":"4 15\\n1 5 10 25","expectedOutput":"2","explanation":"10+5=15"},{"input":"3 7\\n2 3 5","expectedOutput":"2","explanation":"2+5=7 or 2+2+3=7"},{"input":"2 10\\n3 7","expectedOutput":"-1","explanation":"No combination"},{"input":"4 23\\n1 5 10 21","expectedOutput":"3","explanation":"21+1+1=23"},{"input":"3 30\\n1 3 5","expectedOutput":"6","explanation":"56=30"}],"solution":"#include <iostream>\\nusing namespace std;\\nint coinChange(int coins[], int n, int amount) { int dp[amount+1]; for(int i=0;i<=amount;i++) dp[i]=amount+1; dp[0]=0; for(int i=1;i<=amount;i++) for(int j=0;j<n;j++) if(coins[j]<=i) dp[i]=min(dp[i], dp[i-coins[j]]+1); return dp[amount]>amount ? -1 : dp[amount]; }\\nint main() { int c[]={1,2,5}; cout<<coinChange(c,3,11); return 0; }","explanation":{"approach":"dp[i] = min coins for amount i.","analogy":"Build up from $0, try each coin.","steps":["For each amount, try each coin","Take minimum coins needed"],"complexity":"Time: O(amount  coins), Space: O(amount)"}},{"id":"med10","title":"Climbing Stairs","description":"Ways to climb n stairs.","difficulty":"MEDIUM","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint climbStairs(int n) { return 0; }\\nint main() { cout<<climbStairs(5); return 0; }","expectedOutput":"8","testCases":[{"input":"5","expectedOutput":"8","explanation":"8 ways to climb 5 stairs"},{"input":"1","expectedOutput":"1","explanation":"Only 1 way"},{"input":"2","expectedOutput":"2","explanation":"1+1 or 2"},{"input":"3","expectedOutput":"3","explanation":"1+1+1, 1+2, 2+1"},{"input":"4","expectedOutput":"5","explanation":"Fibonacci pattern"},{"input":"6","expectedOutput":"13","explanation":"F(7) = 13"},{"input":"7","expectedOutput":"21","explanation":"F(8) = 21"},{"input":"10","expectedOutput":"89","explanation":"F(11) = 89"},{"input":"8","expectedOutput":"34","explanation":"F(9) = 34"},{"input":"9","expectedOutput":"55","explanation":"F(10) = 55"}],"solution":"#include <iostream>\\nusing namespace std;\\nint climbStairs(int n) { if(n<=2) return n; int a=1, b=2; for(int i=3;i<=n;i++) { int c=a+b; a=b; b=c; } return b; }\\nint main() { cout<<climbStairs(5); return 0; }","explanation":{"approach":"Fibonacci pattern - ways(n) = ways(n-1) + ways(n-2).","analogy":"From step n-1 take 1 step, or from n-2 take 2.","steps":["Base: 1 or 2 steps","Each step = sum of previous two"],"complexity":"Time: O(n), Space: O(1)"}}]`),tM=JSON.parse(`[{"id":"m21","title":"Combination Sum","description":"Unique combinations summing to target.","difficulty":"MEDIUM","category":"Backtracking","starterCode":"#include <iostream>\\nusing namespace std;\\nint combinationSum(int candidates[], int n, int target) { return 0; }\\nint main() { int c[]={2,3,6,7}; cout << combinationSum(c,4,7); return 0; }","expectedOutput":"2","testCases":[{"input":"4 7\\n2 3 6 7","expectedOutput":"2","explanation":"[2,2,3] and [7]"},{"input":"3 8\\n2 3 5","expectedOutput":"3","explanation":"[2,2,2,2], [2,3,3], [3,5]"},{"input":"2 3\\n2","expectedOutput":"0","explanation":"Can't make 3 with 2s"},{"input":"1 1\\n1","expectedOutput":"1","explanation":"Single way"},{"input":"2 4\\n1 2","expectedOutput":"3","explanation":"[1,1,1,1], [1,1,2], [2,2]"},{"input":"3 7\\n1 2 3","expectedOutput":"8","explanation":"Many combinations"},{"input":"4 1\\n1 2 3 4","expectedOutput":"1","explanation":"Only [1]"},{"input":"3 6\\n3 5 7","expectedOutput":"1","explanation":"[3,3]"},{"input":"2 10\\n2 5","expectedOutput":"2","explanation":"[2,2,2,2,2] and [5,5]"},{"input":"4 11\\n2 3 5 7","expectedOutput":"5","explanation":"Multiple ways"}],"solution":"#include <iostream>\\nusing namespace std;\\nint cnt=0;\\nvoid solve(int c[], int n, int t, int start) { if(t==0) { cnt++; return; } for(int i=start;i<n&&c[i]<=t;i++) solve(c,n,t-c[i],i); }\\nint combinationSum(int c[], int n, int target) { cnt=0; for(int i=0;i<n-1;i++) for(int j=0;j<n-i-1;j++) if(c[j]>c[j+1]) swap(c[j],c[j+1]); solve(c,n,target,0); return cnt; }\\nint main() { int c[]={2,3,6,7}; cout << combinationSum(c,4,7); return 0; }","explanation":{"approach":"Backtracking with reuse.","steps":["Sort candidates","Recursively pick candidates >= start"],"complexity":"Time: O(2^t), Space: O(t)"}},{"id":"m22","title":"Combination Sum II","description":"Each number used once.","difficulty":"MEDIUM","category":"Backtracking","starterCode":"#include <iostream>\\nusing namespace std;\\nint combinationSum2(int candidates[], int n, int target) { return 0; }\\nint main() { int c[]={10,1,2,7,6,1,5}; cout << combinationSum2(c,7,8); return 0; }","expectedOutput":"4","testCases":[{"input":"7 8\\n10 1 2 7 6 1 5","expectedOutput":"4","explanation":"[1,1,6], [1,2,5], [1,7], [2,6]"},{"input":"5 5\\n2 5 2 1 2","expectedOutput":"2","explanation":"[1,2,2] and [5]"},{"input":"2 3\\n1 2","expectedOutput":"1","explanation":"[1,2]"},{"input":"3 6\\n1 1 4","expectedOutput":"0","explanation":"No valid combination"},{"input":"4 6\\n1 2 2 5","expectedOutput":"1","explanation":"[1,2,2]? No, [1,5]"},{"input":"5 10\\n1 2 3 4 5","expectedOutput":"3","explanation":"Multiple combinations"},{"input":"3 4\\n1 1 2","expectedOutput":"1","explanation":"[1,1,2]"},{"input":"6 9\\n1 1 2 5 6 7","expectedOutput":"4","explanation":"Various combinations"},{"input":"4 8\\n2 3 3 7","expectedOutput":"2","explanation":"[2,3,3] and Impossible"},{"input":"5 7\\n1 2 2 2 5","expectedOutput":"2","explanation":"[2,5] and [2,2,2,1]"}],"solution":"#include <iostream>\\nusing namespace std;\\nint cnt=0;\\nvoid solve(int c[], int n, int t, int start) { if(t==0) { cnt++; return; } for(int i=start;i<n&&c[i]<=t;i++) { if(i>start&&c[i]==c[i-1]) continue; solve(c,n,t-c[i],i+1); } }\\nint combinationSum2(int c[], int n, int t) { cnt=0; for(int i=0;i<n-1;i++) for(int j=0;j<n-i-1;j++) if(c[j]>c[j+1]) swap(c[j],c[j+1]); solve(c,n,t,0); return cnt; }\\nint main() { int c[]={10,1,2,7,6,1,5}; cout << combinationSum2(c,7,8); return 0; }","explanation":{"approach":"Backtracking skip duplicates.","steps":["Sort","Skip same elements at same level"],"complexity":"Time: O(2^n), Space: O(n)"}},{"id":"m23","title":"Permutations","description":"All permutations of array.","difficulty":"MEDIUM","category":"Backtracking","starterCode":"#include <iostream>\\nusing namespace std;\\nint permute(int nums[], int n) { return 0; }\\nint main() { int nu[]={1,2,3}; cout << permute(nu,3); return 0; }","expectedOutput":"6","testCases":[{"input":"3\\n1 2 3","expectedOutput":"6","explanation":"3! = 6 permutations"},{"input":"1\\n1","expectedOutput":"1","explanation":"1! = 1"},{"input":"2\\n0 1","expectedOutput":"2","explanation":"2! = 2"},{"input":"4\\n1 2 3 4","expectedOutput":"24","explanation":"4! = 24"},{"input":"2\\n1 2","expectedOutput":"2","explanation":"[1,2] and [2,1]"},{"input":"3\\n0 0 1","expectedOutput":"6","explanation":"Though duplicates, counted"},{"input":"5\\n1 2 3 4 5","expectedOutput":"120","explanation":"5! = 120"},{"input":"3\\n5 4 6","expectedOutput":"6","explanation":"Order doesn't matter for count"},{"input":"4\\n0 1 2 3","expectedOutput":"24","explanation":"4 elements"},{"input":"2\\n-1 1","expectedOutput":"2","explanation":"Negative values"}],"solution":"#include <iostream>\\nusing namespace std;\\nint cnt=0;\\nvoid solve(int nums[], int n, int start) { if(start==n) { cnt++; return; } for(int i=start;i<n;i++) { swap(nums[start],nums[i]); solve(nums,n,start+1); swap(nums[start],nums[i]); } }\\nint permute(int nums[], int n) { cnt=0; solve(nums,n,0); return cnt; }\\nint main() { int nu[]={1,2,3}; cout << permute(nu,3); return 0; }","explanation":{"approach":"Swap and recurse.","steps":["At each position, try all remaining","Backtrack by swapping back"],"complexity":"Time: O(n!), Space: O(n)"}},{"id":"m24","title":"Subsets","description":"All subsets of array.","difficulty":"MEDIUM","category":"Backtracking","starterCode":"#include <iostream>\\nusing namespace std;\\nint subsets(int nums[], int n) { return 0; }\\nint main() { int nu[]={1,2,3}; cout << subsets(nu,3); return 0; }","expectedOutput":"8","testCases":[{"input":"3\\n1 2 3","expectedOutput":"8","explanation":"2^3 = 8 subsets"},{"input":"1\\n0","expectedOutput":"2","explanation":"[] and [0]"},{"input":"2\\n1 2","expectedOutput":"4","explanation":"[], [1], [2], [1,2]"},{"input":"4\\n1 2 3 4","expectedOutput":"16","explanation":"2^4 = 16"},{"input":"5\\n1 2 3 4 5","expectedOutput":"32","explanation":"2^5 = 32"},{"input":"0\\n","expectedOutput":"1","explanation":"Only empty set"},{"input":"6\\n1 2 3 4 5 6","expectedOutput":"64","explanation":"2^6 = 64"},{"input":"2\\n0 0","expectedOutput":"4","explanation":"Duplicates counted"},{"input":"3\\n-1 0 1","expectedOutput":"8","explanation":"With negatives"},{"input":"7\\n1 2 3 4 5 6 7","expectedOutput":"128","explanation":"2^7 = 128"}],"solution":"#include <iostream>\\nusing namespace std;\\nint subsets(int nums[], int n) { return 1<<n; }\\nint main() { int nu[]={1,2,3}; cout << subsets(nu,3); return 0; }","explanation":{"approach":"Power set = 2^n.","steps":["Each element included or not"],"complexity":"Time: O(2^n), Space: O(n)"}},{"id":"m25","title":"Word Search","description":"Find word in grid.","difficulty":"MEDIUM","category":"Backtracking","starterCode":"#include <iostream>\\nusing namespace std;\\nbool exist(char board[][4], int m, int n, char word[]) { return false; }\\nint main() { char b[][4]={{'A','B','C','E'},{'S','F','C','S'},{'A','D','E','E'}}; cout << exist(b,3,4,\\"ABCCED\\"); return 0; }","expectedOutput":"1","testCases":[{"input":"ABCCED","expectedOutput":"1","explanation":"Path exists"},{"input":"SEE","expectedOutput":"1","explanation":"Short word exists"},{"input":"ABCB","expectedOutput":"0","explanation":"Can't reuse cell"},{"input":"A","expectedOutput":"1","explanation":"Single letter"},{"input":"Z","expectedOutput":"0","explanation":"Letter not in grid"},{"input":"ABCE","expectedOutput":"1","explanation":"Top row"},{"input":"SEC","expectedOutput":"1","explanation":"Path exists"},{"input":"ABFD","expectedOutput":"1","explanation":"Another path"},{"input":"ABCESCFSADEE","expectedOutput":"0","explanation":"Too long/complex"},{"input":"ASA","expectedOutput":"0","explanation":"Can't visit twice"}],"solution":"#include <iostream>\\nusing namespace std;\\nbool dfs(char b[][4],int m,int n,int i,int j,char w[],int k) { if(!w[k]) return true; if(i<0||i>=m||j<0||j>=n||b[i][j]!=w[k]) return false; char t=b[i][j]; b[i][j]='#'; bool f=dfs(b,m,n,i+1,j,w,k+1)||dfs(b,m,n,i-1,j,w,k+1)||dfs(b,m,n,i,j+1,w,k+1)||dfs(b,m,n,i,j-1,w,k+1); b[i][j]=t; return f; }\\nbool exist(char b[][4], int m, int n, char w[]) { for(int i=0;i<m;i++) for(int j=0;j<n;j++) if(dfs(b,m,n,i,j,w,0)) return true; return false; }\\nint main() { char b[][4]={{'A','B','C','E'},{'S','F','C','S'},{'A','D','E','E'}}; cout << exist(b,3,4,\\"ABCCED\\"); return 0; }","explanation":{"approach":"DFS with backtracking.","steps":["Try starting from each cell","Mark visited, explore 4 directions"],"complexity":"Time: O(mn4^L), Space: O(L)"}},{"id":"m26","title":"Restore IP Addresses","description":"All valid IP addresses.","difficulty":"MEDIUM","category":"Backtracking","starterCode":"#include <iostream>\\nusing namespace std;\\nint restoreIpAddresses(char s[]) { return 0; }\\nint main() { cout << restoreIpAddresses(\\"25525511135\\"); return 0; }","expectedOutput":"2","testCases":[{"input":"25525511135","expectedOutput":"2","explanation":"255.255.11.135 and 255.255.111.35"},{"input":"0000","expectedOutput":"1","explanation":"0.0.0.0"},{"input":"1111","expectedOutput":"1","explanation":"1.1.1.1"},{"input":"101010","expectedOutput":"0","explanation":"Multiple valid IPs"},{"input":"255255255255","expectedOutput":"1","explanation":"255.255.255.255"},{"input":"111","expectedOutput":"0","explanation":"Too short"},{"input":"1234567890123","expectedOutput":"0","explanation":"Too long"},{"input":"010010","expectedOutput":"0","explanation":"Leading zeros issue"},{"input":"172162541","expectedOutput":"0","explanation":"Multiple solutions"},{"input":"19216811","expectedOutput":"0","explanation":"192.168.1.1 type"}],"solution":"#include <iostream>\\nusing namespace std;\\nint cnt=0;\\nvoid solve(char s[], int start, int parts) { if(parts==4) { if(!s[start]) cnt++; return; } for(int len=1;len<=3&&s[start+len-1];len++) { int val=0; for(int i=0;i<len;i++) val=val*10+s[start+i]-'0'; if(val>255) break; if(len>1&&s[start]=='0') break; solve(s,start+len,parts+1); } }\\nint restoreIpAddresses(char s[]) { cnt=0; solve(s,0,0); return cnt; }\\nint main() { cout << restoreIpAddresses(\\"25525511135\\"); return 0; }","explanation":{"approach":"Try 1-3 digit segments.","steps":["For each part, try 1-3 digits","Validate 0-255"],"complexity":"Time: O(1), Space: O(1)"}},{"id":"m27","title":"Generate Parentheses","description":"All valid n pairs.","difficulty":"MEDIUM","category":"Backtracking","starterCode":"#include <iostream>\\nusing namespace std;\\nint generateParenthesis(int n) { return 0; }\\nint main() { cout << generateParenthesis(3); return 0; }","expectedOutput":"5","testCases":[{"input":"3","expectedOutput":"5","explanation":"Catalan number C(3)=5"},{"input":"1","expectedOutput":"1","explanation":"Only ()"},{"input":"2","expectedOutput":"2","explanation":"(()) and ()()"},{"input":"4","expectedOutput":"14","explanation":"Catalan number C(4)"},{"input":"5","expectedOutput":"42","explanation":"Catalan number C(5)"},{"input":"6","expectedOutput":"132","explanation":"Catalan number C(6)"},{"input":"0","expectedOutput":"1","explanation":"Empty string"},{"input":"7","expectedOutput":"429","explanation":"Catalan number C(7)"},{"input":"8","expectedOutput":"1430","explanation":"Catalan number C(8)"},{"input":"2","expectedOutput":"2","explanation":"Base case"}],"solution":"#include <iostream>\\nusing namespace std;\\nint cnt=0;\\nvoid gen(int open, int close, int n) { if(open==n&&close==n) { cnt++; return; } if(open<n) gen(open+1,close,n); if(close<open) gen(open,close+1,n); }\\nint generateParenthesis(int n) { cnt=0; gen(0,0,n); return cnt; }\\nint main() { cout << generateParenthesis(3); return 0; }","explanation":{"approach":"Track open and close counts.","steps":["Add ( if open < n","Add ) if close < open"],"complexity":"Time: O(4^n/n), Space: O(n)"}},{"id":"m28","title":"Letter Combinations","description":"Phone number letter combos.","difficulty":"MEDIUM","category":"Backtracking","starterCode":"#include <iostream>\\nusing namespace std;\\nint letterCombinations(char digits[]) { return 0; }\\nint main() { cout << letterCombinations(\\"23\\"); return 0; }","expectedOutput":"9","testCases":[{"input":"23","expectedOutput":"9","explanation":"33=9 combinations"},{"input":"","expectedOutput":"0","explanation":"Empty input"},{"input":"2","expectedOutput":"3","explanation":"abc = 3"},{"input":"7","expectedOutput":"4","explanation":"pqrs = 4"},{"input":"9","expectedOutput":"4","explanation":"wxyz = 4"},{"input":"234","expectedOutput":"27","explanation":"333=27"},{"input":"79","expectedOutput":"16","explanation":"44=16"},{"input":"22","expectedOutput":"9","explanation":"33=9"},{"input":"2379","expectedOutput":"144","explanation":"3344"},{"input":"5","expectedOutput":"3","explanation":"jkl = 3"}],"solution":"#include <iostream>\\nusing namespace std;\\nconst char* map[]={\\"abc\\",\\"def\\",\\"ghi\\",\\"jkl\\",\\"mno\\",\\"pqrs\\",\\"tuv\\",\\"wxyz\\"};\\nint cnt=0;\\nvoid solve(char d[], int i) { if(!d[i]) { cnt++; return; } const char* letters=map[d[i]-'2']; for(int j=0;letters[j];j++) solve(d,i+1); }\\nint letterCombinations(char d[]) { if(!d[0]) return 0; cnt=0; solve(d,0); return cnt; }\\nint main() { cout << letterCombinations(\\"23\\"); return 0; }","explanation":{"approach":"Map digits to letters, recurse.","steps":["For each digit, try all mapped letters"],"complexity":"Time: O(4^n), Space: O(n)"}},{"id":"m29","title":"Sudoku Solver","description":"Solve sudoku puzzle.","difficulty":"HARD","category":"Backtracking","starterCode":"#include <iostream>\\nusing namespace std;\\nbool solveSudoku(int board[][9]) { return false; }\\nint main() { cout << 1; return 0; }","expectedOutput":"1","testCases":[{"input":"valid puzzle","expectedOutput":"1","explanation":"Puzzle has solution"},{"input":"empty board","expectedOutput":"1","explanation":"Many solutions exist"},{"input":"almost solved","expectedOutput":"1","explanation":"Few cells empty"},{"input":"hard puzzle","expectedOutput":"1","explanation":"Complex backtracking"},{"input":"easy puzzle","expectedOutput":"1","explanation":"Simple solution"},{"input":"minimum clues","expectedOutput":"1","explanation":"17 clues minimum"},{"input":"diagonal puzzle","expectedOutput":"1","explanation":"Special pattern"},{"input":"symmetric puzzle","expectedOutput":"1","explanation":"Symmetric layout"},{"input":"anti-knight","expectedOutput":"1","explanation":"Extra constraints"},{"input":"valid input","expectedOutput":"1","explanation":"Standard sudoku"}],"solution":"#include <iostream>\\nusing namespace std;\\nbool isValid(int b[][9],int r,int c,int n) { for(int i=0;i<9;i++) if(b[r][i]==n||b[i][c]==n) return false; int sr=(r/3)*3,sc=(c/3)*3; for(int i=0;i<3;i++) for(int j=0;j<3;j++) if(b[sr+i][sc+j]==n) return false; return true; }\\nbool solve(int b[][9]) { for(int i=0;i<9;i++) for(int j=0;j<9;j++) if(b[i][j]==0) { for(int n=1;n<=9;n++) if(isValid(b,i,j,n)) { b[i][j]=n; if(solve(b)) return true; b[i][j]=0; } return false; } return true; }\\nbool solveSudoku(int b[][9]) { return solve(b); }\\nint main() { cout << 1; return 0; }","explanation":{"approach":"Backtracking with constraint check.","steps":["Find empty cell","Try 1-9, backtrack if invalid"],"complexity":"Time: O(9^81), Space: O(81)"}},{"id":"m30","title":"N-Queens Count","description":"Count valid placements.","difficulty":"HARD","category":"Backtracking","starterCode":"#include <iostream>\\nusing namespace std;\\nint totalNQueens(int n) { return 0; }\\nint main() { cout << totalNQueens(4); return 0; }","expectedOutput":"2","testCases":[{"input":"4","expectedOutput":"2","explanation":"2 solutions for 4-queens"},{"input":"1","expectedOutput":"1","explanation":"Trivial case"},{"input":"2","expectedOutput":"0","explanation":"No solution for 2"},{"input":"3","expectedOutput":"0","explanation":"No solution for 3"},{"input":"5","expectedOutput":"10","explanation":"10 solutions"},{"input":"6","expectedOutput":"4","explanation":"4 solutions"},{"input":"7","expectedOutput":"40","explanation":"40 solutions"},{"input":"8","expectedOutput":"92","explanation":"Classic 8-queens"},{"input":"9","expectedOutput":"352","explanation":"352 solutions"},{"input":"10","expectedOutput":"724","explanation":"724 solutions"}],"solution":"#include <iostream>\\nusing namespace std;\\nint cnt; bool col[10],d1[20],d2[20];\\nvoid solve(int r, int n) { if(r==n) { cnt++; return; } for(int c=0;c<n;c++) if(!col[c]&&!d1[r-c+n]&&!d2[r+c]) { col[c]=d1[r-c+n]=d2[r+c]=true; solve(r+1,n); col[c]=d1[r-c+n]=d2[r+c]=false; } }\\nint totalNQueens(int n) { cnt=0; solve(0,n); return cnt; }\\nint main() { cout << totalNQueens(4); return 0; }","explanation":{"approach":"Track columns and diagonals.","steps":["Place queen if safe","Backtrack"],"complexity":"Time: O(n!), Space: O(n)"}}]`),nM=JSON.parse(`[{"id":"m31","title":"Rotate Image","description":"Rotate matrix 90 degrees.","difficulty":"MEDIUM","category":"Matrix","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid rotate(int m[][3], int n) {}\\nint main() { int m[][3]={{1,2,3},{4,5,6},{7,8,9}}; rotate(m,3); for(int i=0;i<3;i++) { for(int j=0;j<3;j++) cout<<m[i][j]<<\\" \\"; } return 0; }","expectedOutput":"7 4 1 8 5 2 9 6 3","solution":"#include <iostream>\\nusing namespace std;\\nvoid rotate(int m[][3], int n) { for(int i=0;i<n;i++) for(int j=i+1;j<n;j++) swap(m[i][j],m[j][i]); for(int i=0;i<n;i++) for(int j=0;j<n/2;j++) swap(m[i][j],m[i][n-1-j]); }\\nint main() { int m[][3]={{1,2,3},{4,5,6},{7,8,9}}; rotate(m,3); for(int i=0;i<3;i++) { for(int j=0;j<3;j++) cout<<m[i][j]<<\\" \\"; } return 0; }","explanation":{"approach":"Transpose then reverse rows.","steps":["Transpose matrix","Reverse each row"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"{{1,2,3},{4,5,6},{7,8,9}}","expectedOutput":"7 4 1 8 5 2 9 6 3","explanation":"3x3 matrix rotated 90 clockwise"},{"input":"{{1,2},{3,4}}","expectedOutput":"3 1 4 2","explanation":"2x2 matrix rotated 90 clockwise"},{"input":"{{1}}","expectedOutput":"1","explanation":"Single element unchanged"},{"input":"{{5,1,9,11},{2,4,8,10},{13,3,6,7},{15,14,12,16}}","expectedOutput":"15 13 2 5 14 3 4 1 12 6 8 9 16 7 10 11","explanation":"4x4 matrix rotation"}]},{"id":"m32","title":"Set Matrix Zeroes","description":"Mark entire row/col as zero.","difficulty":"MEDIUM","category":"Matrix","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid setZeroes(int m[][3], int r, int c) {}\\nint main() { int m[][3]={{1,1,1},{1,0,1},{1,1,1}}; setZeroes(m,3,3); for(int i=0;i<3;i++) for(int j=0;j<3;j++) cout<<m[i][j]<<\\" \\"; return 0; }","expectedOutput":"1 0 1 0 0 0 1 0 1","solution":"#include <iostream>\\nusing namespace std;\\nvoid setZeroes(int m[][3], int r, int c) { bool zeroR[10]={},zeroC[10]={}; for(int i=0;i<r;i++) for(int j=0;j<c;j++) if(m[i][j]==0) { zeroR[i]=true; zeroC[j]=true; } for(int i=0;i<r;i++) for(int j=0;j<c;j++) if(zeroR[i]||zeroC[j]) m[i][j]=0; }\\nint main() { int m[][3]={{1,1,1},{1,0,1},{1,1,1}}; setZeroes(m,3,3); for(int i=0;i<3;i++) for(int j=0;j<3;j++) cout<<m[i][j]<<\\" \\"; return 0; }","explanation":{"approach":"Mark rows and cols to zero.","steps":["Find zeros, mark rows/cols","Set marked rows/cols to zero"],"complexity":"Time: O(mn), Space: O(m+n)"},"testCases":[{"input":"{{1,1,1},{1,0,1},{1,1,1}}","expectedOutput":"1 0 1 0 0 0 1 0 1","explanation":"Zero at center zeros middle row and column"},{"input":"{{0,1,2},{3,4,5},{6,7,8}}","expectedOutput":"0 0 0 0 4 5 0 7 8","explanation":"Zero at top-left zeros first row and column"},{"input":"{{1,2,3},{4,5,6},{7,8,9}}","expectedOutput":"1 2 3 4 5 6 7 8 9","explanation":"No zeros, matrix unchanged"},{"input":"{{0,0},{1,1}}","expectedOutput":"0 0 0 0","explanation":"Two zeros in first row"}]},{"id":"m33","title":"Spiral Matrix","description":"Return elements in spiral.","difficulty":"MEDIUM","category":"Matrix","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid spiralOrder(int m[][3], int r, int c) {}\\nint main() { int m[][3]={{1,2,3},{4,5,6},{7,8,9}}; spiralOrder(m,3,3); return 0; }","expectedOutput":"1 2 3 6 9 8 7 4 5","solution":"#include <iostream>\\nusing namespace std;\\nvoid spiralOrder(int m[][3], int r, int c) { int t=0,b=r-1,l=0,ri=c-1; while(t<=b&&l<=ri) { for(int i=l;i<=ri;i++) cout<<m[t][i]<<\\" \\"; t++; for(int i=t;i<=b;i++) cout<<m[i][ri]<<\\" \\"; ri--; if(t<=b) { for(int i=ri;i>=l;i--) cout<<m[b][i]<<\\" \\"; b--; } if(l<=ri) { for(int i=b;i>=t;i--) cout<<m[i][l]<<\\" \\"; l++; } } }\\nint main() { int m[][3]={{1,2,3},{4,5,6},{7,8,9}}; spiralOrder(m,3,3); return 0; }","explanation":{"approach":"Layer by layer traversal.","steps":["Maintain top, bottom, left, right","Process each layer"],"complexity":"Time: O(mn), Space: O(1)"},"testCases":[{"input":"{{1,2,3},{4,5,6},{7,8,9}}","expectedOutput":"1 2 3 6 9 8 7 4 5","explanation":"3x3 matrix spiral traversal"},{"input":"{{1,2,3,4}}","expectedOutput":"1 2 3 4","explanation":"Single row, left to right"},{"input":"{{1},{2},{3}}","expectedOutput":"1 2 3","explanation":"Single column, top to bottom"},{"input":"{{1,2},{3,4},{5,6}}","expectedOutput":"1 2 4 6 5 3","explanation":"3x2 matrix spiral"}]},{"id":"m34","title":"Search 2D Matrix","description":"Search in row/col sorted matrix.","difficulty":"MEDIUM","category":"Matrix","starterCode":"#include <iostream>\\nusing namespace std;\\nbool searchMatrix(int m[][4], int r, int c, int t) { return false; }\\nint main() { int m[][4]={{1,3,5,7},{10,11,16,20},{23,30,34,60}}; cout << searchMatrix(m,3,4,3); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool searchMatrix(int m[][4], int r, int c, int t) { int lo=0,hi=r*c-1; while(lo<=hi) { int mid=(lo+hi)/2; int v=m[mid/c][mid%c]; if(v==t) return true; if(v<t) lo=mid+1; else hi=mid-1; } return false; }\\nint main() { int m[][4]={{1,3,5,7},{10,11,16,20},{23,30,34,60}}; cout << searchMatrix(m,3,4,3); return 0; }","explanation":{"approach":"Binary search treating as 1D.","steps":["Map index to (row, col)","Binary search"],"complexity":"Time: O(log(mn)), Space: O(1)"},"testCases":[{"input":"matrix, target=3","expectedOutput":"1","explanation":"3 exists in first row"},{"input":"matrix, target=13","expectedOutput":"0","explanation":"13 not in matrix"},{"input":"matrix, target=1","expectedOutput":"1","explanation":"First element found"},{"input":"matrix, target=60","expectedOutput":"1","explanation":"Last element found"}]},{"id":"m35","title":"Word Search","description":"Find word in grid.","difficulty":"MEDIUM","category":"Matrix","starterCode":"#include <iostream>\\nusing namespace std;\\nbool exist(char b[][4], int m, int n, char w[]) { return false; }\\nint main() { char b[][4]={{'A','B','C','E'},{'S','F','C','S'},{'A','D','E','E'}}; cout << exist(b,3,4,\\"SEE\\"); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool dfs(char b[][4],int m,int n,int i,int j,char w[],int k) { if(!w[k]) return true; if(i<0||i>=m||j<0||j>=n||b[i][j]!=w[k]) return false; char t=b[i][j]; b[i][j]='#'; bool f=dfs(b,m,n,i+1,j,w,k+1)||dfs(b,m,n,i-1,j,w,k+1)||dfs(b,m,n,i,j+1,w,k+1)||dfs(b,m,n,i,j-1,w,k+1); b[i][j]=t; return f; }\\nbool exist(char b[][4],int m,int n,char w[]) { for(int i=0;i<m;i++) for(int j=0;j<n;j++) if(dfs(b,m,n,i,j,w,0)) return true; return false; }\\nint main() { char b[][4]={{'A','B','C','E'},{'S','F','C','S'},{'A','D','E','E'}}; cout << exist(b,3,4,\\"SEE\\"); return 0; }","explanation":{"approach":"DFS with backtracking.","steps":["Try each cell as start","DFS in 4 directions"],"complexity":"Time: O(mn4^L), Space: O(L)"},"testCases":[{"input":"board, word=SEE","expectedOutput":"1","explanation":"SEE found starting from S"},{"input":"board, word=ABCCED","expectedOutput":"1","explanation":"Word exists in grid"},{"input":"board, word=ABCB","expectedOutput":"0","explanation":"Cannot reuse cells"},{"input":"board, word=A","expectedOutput":"1","explanation":"Single char found"}]},{"id":"m36","title":"Reverse Linked List II","description":"Reverse between positions.","difficulty":"MEDIUM","category":"Linked List","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node* n; Node(int x):v(x),n(0){} };\\nNode* reverseBetween(Node* h, int l, int r) { return nullptr; }\\nint main() { Node* h=new Node(1); h->n=new Node(2); h->n->n=new Node(3); h->n->n->n=new Node(4); h->n->n->n->n=new Node(5); h=reverseBetween(h,2,4); while(h) { cout<<h->v<<\\" \\"; h=h->n; } return 0; }","expectedOutput":"1 4 3 2 5","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node* n; Node(int x):v(x),n(0){} };\\nNode* reverseBetween(Node* h, int l, int r) { Node d(0); d.n=h; Node* pre=&d; for(int i=1;i<l;i++) pre=pre->n; Node* cur=pre->n; for(int i=0;i<r-l;i++) { Node* t=cur->n; cur->n=t->n; t->n=pre->n; pre->n=t; } return d.n; }\\nint main() { Node* h=new Node(1); h->n=new Node(2); h->n->n=new Node(3); h->n->n->n=new Node(4); h->n->n->n->n=new Node(5); h=reverseBetween(h,2,4); while(h) { cout<<h->v<<\\" \\"; h=h->n; } return 0; }","explanation":{"approach":"Move nodes to front of segment.","steps":["Find node before l","Move each node to front"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"list=1,2,3,4,5 l=2 r=4","expectedOutput":"1 4 3 2 5","explanation":"Reverse positions 2-4"},{"input":"list=5 l=1 r=1","expectedOutput":"5","explanation":"Single element, no change"},{"input":"list=3,5 l=1 r=2","expectedOutput":"5 3","explanation":"Reverse entire 2-element list"},{"input":"list=1,2,3,4,5 l=1 r=5","expectedOutput":"5 4 3 2 1","explanation":"Reverse entire list"}]},{"id":"m37","title":"Copy List Random","description":"Deep copy with random pointer.","difficulty":"MEDIUM","category":"Linked List","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *n, *r; Node(int x):v(x),n(0),r(0){} };\\nNode* copyRandomList(Node* h) { return nullptr; }\\nint main() { cout << \\"OK\\"; return 0; }","expectedOutput":"OK","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *n, *r; Node(int x):v(x),n(0),r(0){} };\\nNode* copyRandomList(Node* h) { if(!h) return 0; Node* cur=h; while(cur) { Node* copy=new Node(cur->v); copy->n=cur->n; cur->n=copy; cur=copy->n; } cur=h; while(cur) { if(cur->r) cur->n->r=cur->r->n; cur=cur->n->n; } Node* newH=h->n; cur=h; while(cur) { Node* copy=cur->n; cur->n=copy->n; cur=cur->n; if(copy->n) copy->n=copy->n->n; } return newH; }\\nint main() { cout << \\"OK\\"; return 0; }","explanation":{"approach":"Interleave copies, then separate.","steps":["Insert copies after originals","Set random pointers","Separate lists"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"list with random pointers","expectedOutput":"OK","explanation":"Deep copy preserves structure"},{"input":"null list","expectedOutput":"OK","explanation":"Empty list returns null"},{"input":"single node with self random","expectedOutput":"OK","explanation":"Handles self-referential random"},{"input":"two nodes cycle","expectedOutput":"OK","explanation":"Handles cyclic random pointers"}]},{"id":"m38","title":"Add Two Numbers","description":"Add two numbers as linked lists.","difficulty":"MEDIUM","category":"Linked List","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node* n; Node(int x):v(x),n(0){} };\\nNode* addTwoNumbers(Node* l1, Node* l2) { return nullptr; }\\nint main() { Node* l1=new Node(2); l1->n=new Node(4); l1->n->n=new Node(3); Node* l2=new Node(5); l2->n=new Node(6); l2->n->n=new Node(4); Node* r=addTwoNumbers(l1,l2); while(r) { cout<<r->v; r=r->n; } return 0; }","expectedOutput":"708","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node* n; Node(int x):v(x),n(0){} };\\nNode* addTwoNumbers(Node* l1, Node* l2) { Node d(0),*t=&d; int c=0; while(l1||l2||c) { int s=c; if(l1) { s+=l1->v; l1=l1->n; } if(l2) { s+=l2->v; l2=l2->n; } c=s/10; t->n=new Node(s%10); t=t->n; } return d.n; }\\nint main() { Node* l1=new Node(2); l1->n=new Node(4); l1->n->n=new Node(3); Node* l2=new Node(5); l2->n=new Node(6); l2->n->n=new Node(4); Node* r=addTwoNumbers(l1,l2); while(r) { cout<<r->v; r=r->n; } return 0; }","explanation":{"approach":"Add digit by digit with carry.","steps":["Traverse both lists","Add digits and carry","Create result node"],"complexity":"Time: O(max(m,n)), Space: O(max(m,n))"},"testCases":[{"input":"l1=2,4,3 l2=5,6,4","expectedOutput":"708","explanation":"342+465=807, reversed: 708"},{"input":"l1=0 l2=0","expectedOutput":"0","explanation":"0+0=0"},{"input":"l1=9,9,9 l2=1","expectedOutput":"0001","explanation":"999+1=1000"},{"input":"l1=1,8 l2=0","expectedOutput":"18","explanation":"81+0=81"}]},{"id":"m39","title":"Remove Nth From End","description":"Remove nth node from end.","difficulty":"MEDIUM","category":"Linked List","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node* n; Node(int x):v(x),n(0){} };\\nNode* removeNthFromEnd(Node* h, int n) { return nullptr; }\\nint main() { Node* h=new Node(1); h->n=new Node(2); h->n->n=new Node(3); h->n->n->n=new Node(4); h->n->n->n->n=new Node(5); h=removeNthFromEnd(h,2); while(h) { cout<<h->v<<\\" \\"; h=h->n; } return 0; }","expectedOutput":"1 2 3 5","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node* n; Node(int x):v(x),n(0){} };\\nNode* removeNthFromEnd(Node* h, int n) { Node d(0); d.n=h; Node *f=&d,*s=&d; for(int i=0;i<=n;i++) f=f->n; while(f) { f=f->n; s=s->n; } s->n=s->n->n; return d.n; }\\nint main() { Node* h=new Node(1); h->n=new Node(2); h->n->n=new Node(3); h->n->n->n=new Node(4); h->n->n->n->n=new Node(5); h=removeNthFromEnd(h,2); while(h) { cout<<h->v<<\\" \\"; h=h->n; } return 0; }","explanation":{"approach":"Two pointers n apart.","steps":["Move fast n+1 ahead","Move both until fast reaches end","Remove slow.next"],"complexity":"Time: O(L), Space: O(1)"},"testCases":[{"input":"list=1,2,3,4,5 n=2","expectedOutput":"1 2 3 5","explanation":"Remove 4 (2nd from end)"},{"input":"list=1 n=1","expectedOutput":"","explanation":"Remove only element"},{"input":"list=1,2 n=1","expectedOutput":"1","explanation":"Remove last element"},{"input":"list=1,2 n=2","expectedOutput":"2","explanation":"Remove first element"}]},{"id":"m40","title":"Partition List","description":"Partition around value x.","difficulty":"MEDIUM","category":"Linked List","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node* n; Node(int x):v(x),n(0){} };\\nNode* partition(Node* h, int x) { return nullptr; }\\nint main() { Node* h=new Node(1); h->n=new Node(4); h->n->n=new Node(3); h->n->n->n=new Node(2); h->n->n->n->n=new Node(5); h->n->n->n->n->n=new Node(2); h=partition(h,3); while(h) { cout<<h->v<<\\" \\"; h=h->n; } return 0; }","expectedOutput":"1 2 2 4 3 5","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node* n; Node(int x):v(x),n(0){} };\\nNode* partition(Node* h, int x) { Node less(0),greater(0); Node *l=&less, *g=&greater; while(h) { if(h->v<x) { l->n=h; l=l->n; } else { g->n=h; g=g->n; } h=h->n; } g->n=0; l->n=greater.n; return less.n; }\\nint main() { Node* h=new Node(1); h->n=new Node(4); h->n->n=new Node(3); h->n->n->n=new Node(2); h->n->n->n->n=new Node(5); h->n->n->n->n->n=new Node(2); h=partition(h,3); while(h) { cout<<h->v<<\\" \\"; h=h->n; } return 0; }","explanation":{"approach":"Two lists: less and greater.","steps":["Build two lists","Connect less to greater"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"list=1,4,3,2,5,2 x=3","expectedOutput":"1 2 2 4 3 5","explanation":"Nodes <3 before nodes >=3"},{"input":"list=2,1 x=2","expectedOutput":"1 2","explanation":"1<2 comes first"},{"input":"list=1,2,3 x=4","expectedOutput":"1 2 3","explanation":"All less than x"},{"input":"list=3,1 x=0","expectedOutput":"3 1","explanation":"All >= x, unchanged"}]}]`),iM=JSON.parse('[{"id":"med31","title":"Swap Nodes in Pairs","description":"Swap adjacent nodes.","difficulty":"MEDIUM","category":"Linked List","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node* n; Node(int x):v(x),n(0){} };\\nNode* swapPairs(Node* h) { return nullptr; }\\nint main() { Node* h=new Node(1); h->n=new Node(2); h->n->n=new Node(3); h->n->n->n=new Node(4); h=swapPairs(h); while(h) { cout<<h->v<<\\" \\"; h=h->n; } return 0; }","expectedOutput":"2 1 4 3","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node* n; Node(int x):v(x),n(0){} };\\nNode* swapPairs(Node* h) { Node d(0); d.n=h; Node* p=&d; while(p->n && p->n->n) { Node* a=p->n, *b=p->n->n; a->n=b->n; b->n=a; p->n=b; p=a; } return d.n; }\\nint main() { Node* h=new Node(1); h->n=new Node(2); h->n->n=new Node(3); h->n->n->n=new Node(4); h=swapPairs(h); while(h) { cout<<h->v<<\\" \\"; h=h->n; } return 0; }","explanation":{"approach":"Swap pairs iteratively.","steps":["Get pair (a,b)","Reconnect: prevbanext","Move p to a"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"list=1,2,3,4","expectedOutput":"2 1 4 3","explanation":"Swap pairs: 1,22,1 and 3,44,3"},{"input":"list=1,2,3","expectedOutput":"2 1 3","explanation":"Odd length, last unpaired"},{"input":"list=1","expectedOutput":"1","explanation":"Single element unchanged"},{"input":"list=1,2","expectedOutput":"2 1","explanation":"One pair swapped"}]},{"id":"med32","title":"Sort List","description":"Sort linked list.","difficulty":"MEDIUM","category":"Linked List","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node* n; Node(int x):v(x),n(0){} };\\nNode* sortList(Node* h) { return nullptr; }\\nint main() { Node* h=new Node(4); h->n=new Node(2); h->n->n=new Node(1); h->n->n->n=new Node(3); h=sortList(h); while(h) { cout<<h->v<<\\" \\"; h=h->n; } return 0; }","expectedOutput":"1 2 3 4","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node* n; Node(int x):v(x),n(0){} };\\nNode* merge(Node* a, Node* b) { Node d(0),*t=&d; while(a&&b) { if(a->v<b->v) { t->n=a; a=a->n; } else { t->n=b; b=b->n; } t=t->n; } t->n=a?a:b; return d.n; }\\nNode* sortList(Node* h) { if(!h||!h->n) return h; Node* s=h,*f=h,*p=0; while(f&&f->n) { p=s; s=s->n; f=f->n->n; } p->n=0; return merge(sortList(h),sortList(s)); }\\nint main() { Node* h=new Node(4); h->n=new Node(2); h->n->n=new Node(1); h->n->n->n=new Node(3); h=sortList(h); while(h) { cout<<h->v<<\\" \\"; h=h->n; } return 0; }","explanation":{"approach":"Merge sort for linked list.","steps":["Find middle","Split list","Recursively sort","Merge"],"complexity":"Time: O(n log n), Space: O(log n)"},"testCases":[{"input":"list=4,2,1,3","expectedOutput":"1 2 3 4","explanation":"Unsorted list becomes sorted"},{"input":"list=-1,5,3,4,0","expectedOutput":"-1 0 3 4 5","explanation":"Handles negative and mixed"},{"input":"list=1","expectedOutput":"1","explanation":"Single element already sorted"},{"input":"list=2,1","expectedOutput":"1 2","explanation":"Two elements swapped"}]},{"id":"med33","title":"Reorder List","description":"Reorder L0LnL1Ln-1...","difficulty":"MEDIUM","category":"Linked List","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node* n; Node(int x):v(x),n(0){} };\\nvoid reorderList(Node* h) {}\\nint main() { Node* h=new Node(1); h->n=new Node(2); h->n->n=new Node(3); h->n->n->n=new Node(4); reorderList(h); while(h) { cout<<h->v<<\\" \\"; h=h->n; } return 0; }","expectedOutput":"1 4 2 3","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node* n; Node(int x):v(x),n(0){} };\\nvoid reorderList(Node* h) { if(!h||!h->n) return; Node* s=h,*f=h; while(f->n&&f->n->n) { s=s->n; f=f->n->n; } Node* sec=s->n; s->n=0; Node* p=0; while(sec) { Node* t=sec->n; sec->n=p; p=sec; sec=t; } Node* f1=h,*f2=p; while(f2) { Node* t1=f1->n,*t2=f2->n; f1->n=f2; f2->n=t1; f1=t1; f2=t2; } }\\nint main() { Node* h=new Node(1); h->n=new Node(2); h->n->n=new Node(3); h->n->n->n=new Node(4); reorderList(h); while(h) { cout<<h->v<<\\" \\"; h=h->n; } return 0; }","explanation":{"approach":"Split, reverse second half, merge alternately.","steps":["Find middle","Reverse second half","Merge alternately"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"list=1,2,3,4","expectedOutput":"1 4 2 3","explanation":"Interleave first and reversed second half"},{"input":"list=1,2,3,4,5","expectedOutput":"1 5 2 4 3","explanation":"Odd length interleaving"},{"input":"list=1","expectedOutput":"1","explanation":"Single element unchanged"},{"input":"list=1,2","expectedOutput":"1 2","explanation":"Two elements unchanged"}]},{"id":"med34","title":"Validate BST","description":"Check if valid BST.","difficulty":"MEDIUM","category":"Trees","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nbool isValidBST(Node* r) { return false; }\\nint main() { Node* r=new Node(2); r->l=new Node(1); r->r=new Node(3); cout<<isValidBST(r); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nbool valid(Node* r, long mn, long mx) { if(!r) return true; if(r->v<=mn||r->v>=mx) return false; return valid(r->l,mn,r->v)&&valid(r->r,r->v,mx); }\\nbool isValidBST(Node* r) { return valid(r,LONG_MIN,LONG_MAX); }\\nint main() { Node* r=new Node(2); r->l=new Node(1); r->r=new Node(3); cout<<isValidBST(r); return 0; }","explanation":{"approach":"Track valid range at each node.","steps":["Pass min/max bounds","Left updates max, right updates min"],"complexity":"Time: O(n), Space: O(h)"},"testCases":[{"input":"tree=[2,1,3]","expectedOutput":"1","explanation":"Valid BST: 1<2<3"},{"input":"tree=[5,1,4,null,null,3,6]","expectedOutput":"0","explanation":"Invalid: 4 in right but <5"},{"input":"tree=[1]","expectedOutput":"1","explanation":"Single node is valid BST"},{"input":"tree=[5,4,6,null,null,3,7]","expectedOutput":"0","explanation":"3 in right subtree but <5"}]},{"id":"med35","title":"Flatten Binary Tree","description":"Flatten to linked list.","difficulty":"MEDIUM","category":"Trees","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nvoid flatten(Node* r) {}\\nint main() { Node* r=new Node(1); r->l=new Node(2); r->r=new Node(5); r->l->l=new Node(3); r->l->r=new Node(4); r->r->r=new Node(6); flatten(r); while(r) { cout<<r->v<<\\" \\"; r=r->r; } return 0; }","expectedOutput":"1 2 3 4 5 6","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nvoid flatten(Node* r) { while(r) { if(r->l) { Node* p=r->l; while(p->r) p=p->r; p->r=r->r; r->r=r->l; r->l=0; } r=r->r; } }\\nint main() { Node* r=new Node(1); r->l=new Node(2); r->r=new Node(5); r->l->l=new Node(3); r->l->r=new Node(4); r->r->r=new Node(6); flatten(r); while(r) { cout<<r->v<<\\" \\"; r=r->r; } return 0; }","explanation":{"approach":"Move left subtree to right, attach old right to end.","steps":["Find rightmost of left subtree","Attach right subtree there","Move left to right"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"tree=[1,2,5,3,4,null,6]","expectedOutput":"1 2 3 4 5 6","explanation":"Preorder to right-only list"},{"input":"tree=[1]","expectedOutput":"1","explanation":"Single node unchanged"},{"input":"tree=[1,2]","expectedOutput":"1 2","explanation":"Left child becomes right"},{"input":"tree=[1,null,2]","expectedOutput":"1 2","explanation":"Right-only tree unchanged"}]},{"id":"med36","title":"Binary Tree Right View","description":"Nodes visible from right.","difficulty":"MEDIUM","category":"Trees","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nvoid rightView(Node* r) {}\\nint main() { Node* r=new Node(1); r->l=new Node(2); r->r=new Node(3); r->l->r=new Node(5); r->r->r=new Node(4); rightView(r); return 0; }","expectedOutput":"1 3 4","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nint maxLevel=-1;\\nvoid solve(Node* r, int lv) { if(!r) return; if(lv>maxLevel) { cout<<r->v<<\\" \\"; maxLevel=lv; } solve(r->r,lv+1); solve(r->l,lv+1); }\\nvoid rightView(Node* r) { maxLevel=-1; solve(r,0); }\\nint main() { Node* r=new Node(1); r->l=new Node(2); r->r=new Node(3); r->l->r=new Node(5); r->r->r=new Node(4); rightView(r); return 0; }","explanation":{"approach":"First node at each level from right.","steps":["Track max level seen","Print if new level","Go right first"],"complexity":"Time: O(n), Space: O(h)"},"testCases":[{"input":"tree=[1,2,3,null,5,null,4]","expectedOutput":"1 3 4","explanation":"Rightmost at each level"},{"input":"tree=[1,2]","expectedOutput":"1 2","explanation":"Left visible when no right"},{"input":"tree=[1]","expectedOutput":"1","explanation":"Single node"},{"input":"tree=[1,2,3]","expectedOutput":"1 3","explanation":"Root and right child"}]},{"id":"med37","title":"Kth Smallest in BST","description":"Find kth smallest element.","difficulty":"MEDIUM","category":"Trees","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nint kthSmallest(Node* r, int k) { return 0; }\\nint main() { Node* r=new Node(3); r->l=new Node(1); r->r=new Node(4); r->l->r=new Node(2); cout<<kthSmallest(r,1); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nint cnt,result;\\nvoid inorder(Node* r, int k) { if(!r) return; inorder(r->l,k); if(++cnt==k) { result=r->v; return; } inorder(r->r,k); }\\nint kthSmallest(Node* r, int k) { cnt=0; result=0; inorder(r,k); return result; }\\nint main() { Node* r=new Node(3); r->l=new Node(1); r->r=new Node(4); r->l->r=new Node(2); cout<<kthSmallest(r,1); return 0; }","explanation":{"approach":"Inorder gives sorted order.","steps":["Inorder traversal","Count until k"],"complexity":"Time: O(h+k), Space: O(h)"},"testCases":[{"input":"tree=[3,1,4,null,2], k=1","expectedOutput":"1","explanation":"1st smallest is 1"},{"input":"tree=[5,3,6,2,4,null,null,1], k=3","expectedOutput":"3","explanation":"3rd smallest"},{"input":"tree=[1], k=1","expectedOutput":"1","explanation":"Only element"},{"input":"tree=[3,1,4,null,2], k=4","expectedOutput":"4","explanation":"4th smallest (largest)"}]},{"id":"med38","title":"Construct BST from Preorder","description":"Build BST from preorder.","difficulty":"MEDIUM","category":"Trees","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nNode* buildBST(int pre[], int n) { return nullptr; }\\nvoid inorder(Node* r) { if(!r) return; inorder(r->l); cout<<r->v<<\\" \\"; inorder(r->r); }\\nint main() { int pre[]={8,5,1,7,10,12}; Node* r=buildBST(pre,6); inorder(r); return 0; }","expectedOutput":"1 5 7 8 10 12","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nint idx=0;\\nNode* build(int pre[], int n, int mn, int mx) { if(idx>=n||pre[idx]<mn||pre[idx]>mx) return 0; Node* r=new Node(pre[idx++]); r->l=build(pre,n,mn,r->v); r->r=build(pre,n,r->v,mx); return r; }\\nNode* buildBST(int pre[], int n) { idx=0; return build(pre,n,INT_MIN,INT_MAX); }\\nvoid inorder(Node* r) { if(!r) return; inorder(r->l); cout<<r->v<<\\" \\"; inorder(r->r); }\\nint main() { int pre[]={8,5,1,7,10,12}; Node* r=buildBST(pre,6); inorder(r); return 0; }","explanation":{"approach":"Use bounds to determine subtree.","steps":["If value in range, create node","Recurse with updated bounds"],"complexity":"Time: O(n), Space: O(h)"},"testCases":[{"input":"preorder=[8,5,1,7,10,12]","expectedOutput":"1 5 7 8 10 12","explanation":"Build BST, inorder is sorted"},{"input":"preorder=[1,3]","expectedOutput":"1 3","explanation":"Root with right child"},{"input":"preorder=[2,1,3]","expectedOutput":"1 2 3","explanation":"Balanced tree"},{"input":"preorder=[5]","expectedOutput":"5","explanation":"Single node"}]},{"id":"med39","title":"Course Schedule","description":"Can finish all courses.","difficulty":"MEDIUM","category":"Graph","starterCode":"#include <iostream>\\nusing namespace std;\\nbool canFinish(int n, int pre[][2], int m) { return false; }\\nint main() { int pre[][2]={{1,0},{0,1}}; cout<<canFinish(2,pre,2); return 0; }","expectedOutput":"0","solution":"#include <iostream>\\nusing namespace std;\\nint adj[100][100],deg[100],sz[100];\\nbool canFinish(int n, int pre[][2], int m) { for(int i=0;i<n;i++) { sz[i]=0; deg[i]=0; } for(int i=0;i<m;i++) { adj[pre[i][1]][sz[pre[i][1]]++]=pre[i][0]; deg[pre[i][0]]++; } int q[100],f=0,r=0,cnt=0; for(int i=0;i<n;i++) if(deg[i]==0) q[r++]=i; while(f<r) { int u=q[f++]; cnt++; for(int i=0;i<sz[u];i++) if(--deg[adj[u][i]]==0) q[r++]=adj[u][i]; } return cnt==n; }\\nint main() { int pre[][2]={{1,0},{0,1}}; cout<<canFinish(2,pre,2); return 0; }","explanation":{"approach":"Topological sort - detect cycle.","steps":["Build graph and in-degrees","BFS from zero-degree nodes","Check if all visited"],"complexity":"Time: O(V+E), Space: O(V+E)"},"testCases":[{"input":"n=2, prereqs=[[1,0],[0,1]]","expectedOutput":"0","explanation":"Cycle detected, cannot finish"},{"input":"n=2, prereqs=[[1,0]]","expectedOutput":"1","explanation":"Take 0 then 1, no cycle"},{"input":"n=1, prereqs=[]","expectedOutput":"1","explanation":"Single course, no prereqs"},{"input":"n=3, prereqs=[[1,0],[2,1]]","expectedOutput":"1","explanation":"Linear dependency, valid"}]},{"id":"med40","title":"Number of Islands","description":"Count connected 1s.","difficulty":"MEDIUM","category":"Graph","starterCode":"#include <iostream>\\nusing namespace std;\\nint numIslands(int g[][5], int r, int c) { return 0; }\\nint main() { int g[][5]={{1,1,0,0,0},{1,1,0,0,0},{0,0,1,0,0},{0,0,0,1,1}}; cout<<numIslands(g,4,5); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nvoid dfs(int g[][5], int r, int c, int i, int j) { if(i<0||i>=r||j<0||j>=c||g[i][j]!=1) return; g[i][j]=0; dfs(g,r,c,i+1,j); dfs(g,r,c,i-1,j); dfs(g,r,c,i,j+1); dfs(g,r,c,i,j-1); }\\nint numIslands(int g[][5], int r, int c) { int cnt=0; for(int i=0;i<r;i++) for(int j=0;j<c;j++) if(g[i][j]==1) { cnt++; dfs(g,r,c,i,j); } return cnt; }\\nint main() { int g[][5]={{1,1,0,0,0},{1,1,0,0,0},{0,0,1,0,0},{0,0,0,1,1}}; cout<<numIslands(g,4,5); return 0; }","explanation":{"approach":"DFS to mark connected land.","steps":["For each 1, increment count","DFS to mark all connected as visited"],"complexity":"Time: O(rc), Space: O(rc)"},"testCases":[{"input":"grid 4x5 with 3 islands","expectedOutput":"3","explanation":"Three separate island groups"},{"input":"grid all 0s","expectedOutput":"0","explanation":"No land, no islands"},{"input":"grid all 1s","expectedOutput":"1","explanation":"All connected, one island"},{"input":"grid [[1]]","expectedOutput":"1","explanation":"Single cell island"}]}]'),aM=JSON.parse(`[{"id":"med41","title":"Clone Graph","description":"Deep copy of graph.","difficulty":"MEDIUM","category":"Graph","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node* adj[10]; int sz; Node(int x):v(x),sz(0){} };\\nNode* cloneGraph(Node* n) { return nullptr; }\\nint main() { cout<<\\"Graph cloned\\"; return 0; }","expectedOutput":"Graph cloned","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node* adj[10]; int sz; Node(int x):v(x),sz(0){} };\\nNode* visited[101]={};\\nNode* cloneGraph(Node* n) { if(!n) return 0; if(visited[n->v]) return visited[n->v]; Node* c=new Node(n->v); visited[n->v]=c; for(int i=0;i<n->sz;i++) c->adj[c->sz++]=cloneGraph(n->adj[i]); return c; }\\nint main() { cout<<\\"Graph cloned\\"; return 0; }","explanation":{"approach":"DFS with visited map.","steps":["Check if already cloned","Create clone","Recurse on neighbors"],"complexity":"Time: O(V+E), Space: O(V)"},"testCases":[{"input":"adjList = [[2,4],[1,3],[2,4],[1,3]]","expectedOutput":"Graph cloned","explanation":"4-node graph cloned successfully"},{"input":"adjList = [[]]","expectedOutput":"Graph cloned","explanation":"Single node with no neighbors"},{"input":"adjList = []","expectedOutput":"null","explanation":"Empty graph returns null"},{"input":"adjList = [[2],[1]]","expectedOutput":"Graph cloned","explanation":"Two connected nodes"}]},{"id":"med42","title":"Pacific Atlantic Water","description":"Cells flowing to both oceans.","difficulty":"MEDIUM","category":"Graph","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid pacificAtlantic(int h[][5], int r, int c) {}\\nint main() { int h[][5]={{1,2,2,3,5},{3,2,3,4,4},{2,4,5,3,1},{6,7,1,4,5},{5,1,1,2,4}}; pacificAtlantic(h,5,5); return 0; }","expectedOutput":"0,4 1,3 1,4 2,2 3,0 3,1 4,0","solution":"#include <iostream>\\nusing namespace std;\\nbool pac[10][10],atl[10][10];\\nvoid dfs(int h[][5], int r, int c, int i, int j, bool vis[][10], int prev) { if(i<0||i>=r||j<0||j>=c||vis[i][j]||h[i][j]<prev) return; vis[i][j]=true; dfs(h,r,c,i+1,j,vis,h[i][j]); dfs(h,r,c,i-1,j,vis,h[i][j]); dfs(h,r,c,i,j+1,vis,h[i][j]); dfs(h,r,c,i,j-1,vis,h[i][j]); }\\nvoid pacificAtlantic(int h[][5], int r, int c) { for(int i=0;i<r;i++) for(int j=0;j<c;j++) { pac[i][j]=atl[i][j]=false; } for(int i=0;i<r;i++) { dfs(h,r,c,i,0,pac,0); dfs(h,r,c,i,c-1,atl,0); } for(int j=0;j<c;j++) { dfs(h,r,c,0,j,pac,0); dfs(h,r,c,r-1,j,atl,0); } for(int i=0;i<r;i++) for(int j=0;j<c;j++) if(pac[i][j]&&atl[i][j]) cout<<i<<\\",\\"<<j<<\\" \\"; }\\nint main() { int h[][5]={{1,2,2,3,5},{3,2,3,4,4},{2,4,5,3,1},{6,7,1,4,5},{5,1,1,2,4}}; pacificAtlantic(h,5,5); return 0; }","explanation":{"approach":"DFS from ocean edges inward.","steps":["DFS from Pacific edges","DFS from Atlantic edges","Find intersection"],"complexity":"Time: O(rc), Space: O(rc)"},"testCases":[{"input":"5x5 height map","expectedOutput":"0,4 1,3 1,4 2,2 3,0 3,1 4,0","explanation":"7 cells can flow to both oceans"},{"input":"1x1 grid [[1]]","expectedOutput":"0,0","explanation":"Single cell flows to both"},{"input":"2x2 equal heights","expectedOutput":"0,0 0,1 1,0 1,1","explanation":"All cells at same height"},{"input":"1x3 increasing [1,2,3]","expectedOutput":"0,2","explanation":"Only rightmost flows to both"}]},{"id":"med43","title":"Rotting Oranges","description":"Time for all oranges to rot.","difficulty":"MEDIUM","category":"BFS","starterCode":"#include <iostream>\\nusing namespace std;\\nint orangesRotting(int g[][3], int r, int c) { return 0; }\\nint main() { int g[][3]={{2,1,1},{1,1,0},{0,1,1}}; cout<<orangesRotting(g,3,3); return 0; }","expectedOutput":"4","solution":"#include <iostream>\\nusing namespace std;\\nint orangesRotting(int g[][3], int r, int c) { int qr[100],qc[100],f=0,re=0,fresh=0; for(int i=0;i<r;i++) for(int j=0;j<c;j++) { if(g[i][j]==2) { qr[re]=i; qc[re++]=j; } else if(g[i][j]==1) fresh++; } if(fresh==0) return 0; int dx[]={1,-1,0,0},dy[]={0,0,1,-1},t=-1; while(f<re) { int sz=re-f; t++; for(int q=0;q<sz;q++) { int i=qr[f],j=qc[f++]; for(int d=0;d<4;d++) { int ni=i+dx[d],nj=j+dy[d]; if(ni>=0&&ni<r&&nj>=0&&nj<c&&g[ni][nj]==1) { g[ni][nj]=2; fresh--; qr[re]=ni; qc[re++]=nj; } } } } return fresh==0?t:-1; }\\nint main() { int g[][3]={{2,1,1},{1,1,0},{0,1,1}}; cout<<orangesRotting(g,3,3); return 0; }","explanation":{"approach":"Multi-source BFS.","steps":["Add all rotten to queue","BFS, count levels","Check if all fresh rotted"],"complexity":"Time: O(rc), Space: O(rc)"},"testCases":[{"input":"grid=[[2,1,1],[1,1,0],[0,1,1]]","expectedOutput":"4","explanation":"4 minutes for rot to spread to all"},{"input":"grid=[[2,1,1],[0,1,1],[1,0,1]]","expectedOutput":"-1","explanation":"Bottom-left isolated, impossible"},{"input":"grid=[[0,2]]","expectedOutput":"0","explanation":"No fresh oranges"},{"input":"grid=[[1]]","expectedOutput":"-1","explanation":"No rotten to start rotation"}]},{"id":"med44","title":"Word Ladder Length","description":"Min transformations.","difficulty":"MEDIUM","category":"BFS","starterCode":"#include <iostream>\\nusing namespace std;\\nint ladderLength(char begin[], char end[], char words[][10], int n) { return 0; }\\nint main() { char words[][10]={\\"hot\\",\\"dot\\",\\"dog\\",\\"lot\\",\\"log\\",\\"cog\\"}; cout<<ladderLength(\\"hit\\",\\"cog\\",words,6); return 0; }","expectedOutput":"5","solution":"#include <iostream>\\nusing namespace std;\\nbool diff1(char a[], char b[]) { int c=0; for(int i=0;a[i];i++) if(a[i]!=b[i]) c++; return c==1; }\\nint ladderLength(char begin[], char end[], char words[][10], int n) { char q[100][10]; int f=0,r=0; bool vis[100]={}; int i=0; while(begin[i]) { q[r][i]=begin[i]; i++; } q[r][i]=0; r++; int lv=1; while(f<r) { int sz=r-f; for(int s=0;s<sz;s++) { char* cur=q[f++]; for(int w=0;w<n;w++) { if(!vis[w] && diff1(cur,words[w])) { bool eq=true; for(int k=0;end[k];k++) if(end[k]!=words[w][k]) eq=false; if(eq) return lv+1; vis[w]=true; int j=0; while(words[w][j]) { q[r][j]=words[w][j]; j++; } q[r][j]=0; r++; } } } lv++; } return 0; }\\nint main() { char words[][10]={\\"hot\\",\\"dot\\",\\"dog\\",\\"lot\\",\\"log\\",\\"cog\\"}; cout<<ladderLength(\\"hit\\",\\"cog\\",words,6); return 0; }","explanation":{"approach":"BFS to find shortest path.","steps":["BFS from begin word","Try all 1-letter changes","Count levels"],"complexity":"Time: O(n  m  26), Space: O(n)"},"testCases":[{"input":"hitcog via [hot,dot,dog,lot,log,cog]","expectedOutput":"5","explanation":"hithotdotdogcog"},{"input":"hitcog via [hot,dot,dog,lot,log]","expectedOutput":"0","explanation":"cog not in wordList"},{"input":"ac via [a,b,c]","expectedOutput":"2","explanation":"abc or ac directly"},{"input":"hotdog via [hot,dog]","expectedOutput":"0","explanation":"No valid single-letter path"}]},{"id":"med45","title":"Coin Change","description":"Min coins for amount.","difficulty":"MEDIUM","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint coinChange(int coins[], int n, int amt) { return 0; }\\nint main() { int coins[]={1,2,5}; cout<<coinChange(coins,3,11); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nint coinChange(int coins[], int n, int amt) { int dp[amt+1]; for(int i=0;i<=amt;i++) dp[i]=1e9; dp[0]=0; for(int i=1;i<=amt;i++) for(int j=0;j<n;j++) if(coins[j]<=i && dp[i-coins[j]]!=1e9) dp[i]=min(dp[i],dp[i-coins[j]]+1); return dp[amt]>=1e9?-1:dp[amt]; }\\nint main() { int coins[]={1,2,5}; cout<<coinChange(coins,3,11); return 0; }","explanation":{"approach":"DP - min coins for each amount.","steps":["dp[i] = min coins for i","Try each coin"],"complexity":"Time: O(amt  n), Space: O(amt)"},"testCases":[{"input":"coins=[1,2,5], amount=11","expectedOutput":"3","explanation":"11 = 5+5+1"},{"input":"coins=[2], amount=3","expectedOutput":"-1","explanation":"Cannot make 3 with only 2s"},{"input":"coins=[1], amount=0","expectedOutput":"0","explanation":"Zero amount needs 0 coins"},{"input":"coins=[1,2,5], amount=5","expectedOutput":"1","explanation":"Single 5 coin"}]},{"id":"med46","title":"Longest Increasing Subseq","description":"LIS length.","difficulty":"MEDIUM","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint lengthOfLIS(int a[], int n) { return 0; }\\nint main() { int a[]={10,9,2,5,3,7,101,18}; cout<<lengthOfLIS(a,8); return 0; }","expectedOutput":"4","solution":"#include <iostream>\\nusing namespace std;\\nint lengthOfLIS(int a[], int n) { int dp[n]; for(int i=0;i<n;i++) dp[i]=1; for(int i=1;i<n;i++) for(int j=0;j<i;j++) if(a[j]<a[i]) dp[i]=max(dp[i],dp[j]+1); int mx=0; for(int i=0;i<n;i++) mx=max(mx,dp[i]); return mx; }\\nint main() { int a[]={10,9,2,5,3,7,101,18}; cout<<lengthOfLIS(a,8); return 0; }","explanation":{"approach":"DP - LIS ending at each index.","steps":["dp[i] = LIS ending at i","Check all j < i"],"complexity":"Time: O(n), Space: O(n)"},"testCases":[{"input":"nums=[10,9,2,5,3,7,101,18]","expectedOutput":"4","explanation":"LIS: 2,3,7,101 or 2,5,7,101"},{"input":"nums=[0,1,0,3,2,3]","expectedOutput":"4","explanation":"LIS: 0,1,2,3"},{"input":"nums=[7,7,7,7,7]","expectedOutput":"1","explanation":"All same, LIS is 1"},{"input":"nums=[1,3,6,7,9,4,10,5,6]","expectedOutput":"6","explanation":"LIS: 1,3,6,7,9,10"}]},{"id":"med47","title":"Word Break","description":"Can segment into dict words.","difficulty":"MEDIUM","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nbool wordBreak(char s[], char dict[][10], int n) { return false; }\\nint main() { char dict[][10]={\\"apple\\",\\"pen\\"}; cout<<wordBreak(\\"applepenapple\\",dict,2); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool eq(char a[], int start, int end, char b[]) { int i=0; for(int j=start;j<end;j++,i++) if(a[j]!=b[i]) return false; return !b[i]; }\\nbool wordBreak(char s[], char dict[][10], int n) { int len=0; while(s[len]) len++; bool dp[len+1]={}; dp[0]=true; for(int i=1;i<=len;i++) for(int j=0;j<i;j++) if(dp[j]) for(int k=0;k<n;k++) if(eq(s,j,i,dict[k])) { dp[i]=true; break; } return dp[len]; }\\nint main() { char dict[][10]={\\"apple\\",\\"pen\\"}; cout<<wordBreak(\\"applepenapple\\",dict,2); return 0; }","explanation":{"approach":"DP - can reach each position.","steps":["dp[i] = can segment s[0..i]","Check all j < i with dict word"],"complexity":"Time: O(n  m), Space: O(n)"},"testCases":[{"input":"s=applepenapple, dict=[apple,pen]","expectedOutput":"1","explanation":"apple+pen+apple"},{"input":"s=catsandog, dict=[cats,dog,sand,and,cat]","expectedOutput":"0","explanation":"Cannot segment completely"},{"input":"s=leetcode, dict=[leet,code]","expectedOutput":"1","explanation":"leet+code"},{"input":"s=a, dict=[a]","expectedOutput":"1","explanation":"Single char match"}]},{"id":"med48","title":"House Robber","description":"Max money without adjacent.","difficulty":"MEDIUM","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint rob(int a[], int n) { return 0; }\\nint main() { int a[]={2,7,9,3,1}; cout<<rob(a,5); return 0; }","expectedOutput":"12","solution":"#include <iostream>\\nusing namespace std;\\nint rob(int a[], int n) { if(n==0) return 0; if(n==1) return a[0]; int dp[n]; dp[0]=a[0]; dp[1]=max(a[0],a[1]); for(int i=2;i<n;i++) dp[i]=max(dp[i-1],dp[i-2]+a[i]); return dp[n-1]; }\\nint main() { int a[]={2,7,9,3,1}; cout<<rob(a,5); return 0; }","explanation":{"approach":"DP - max at each house.","steps":["dp[i] = max(skip, rob+dp[i-2])"],"complexity":"Time: O(n), Space: O(n)"},"testCases":[{"input":"nums=[2,7,9,3,1]","expectedOutput":"12","explanation":"Rob houses 0,2,4: 2+9+1=12"},{"input":"nums=[1,2,3,1]","expectedOutput":"4","explanation":"Rob houses 0 and 2: 1+3=4"},{"input":"nums=[2,1,1,2]","expectedOutput":"4","explanation":"Rob houses 0 and 3: 2+2=4"},{"input":"nums=[0]","expectedOutput":"0","explanation":"Single house with 0 value"}]},{"id":"med49","title":"Decode Ways","description":"Number of decodings.","difficulty":"MEDIUM","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint numDecodings(char s[]) { return 0; }\\nint main() { cout<<numDecodings(\\"226\\"); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nint numDecodings(char s[]) { int n=0; while(s[n]) n++; if(n==0||s[0]=='0') return 0; int dp[n+1]={}; dp[0]=1; dp[1]=1; for(int i=2;i<=n;i++) { if(s[i-1]!='0') dp[i]=dp[i-1]; int two=(s[i-2]-'0')*10+(s[i-1]-'0'); if(two>=10&&two<=26) dp[i]+=dp[i-2]; } return dp[n]; }\\nint main() { cout<<numDecodings(\\"226\\"); return 0; }","explanation":{"approach":"DP - ways at each position.","steps":["dp[i] = ways to decode s[0..i]","Try 1 and 2 digit decodings"],"complexity":"Time: O(n), Space: O(n)"},"testCases":[{"input":"s=226","expectedOutput":"3","explanation":"2,2,6 or 22,6 or 2,26"},{"input":"s=12","expectedOutput":"2","explanation":"1,2 or 12"},{"input":"s=06","expectedOutput":"0","explanation":"Leading zero invalid"},{"input":"s=11106","expectedOutput":"2","explanation":"1,1,10,6 or 11,10,6"}]},{"id":"med50","title":"Unique Paths","description":"Paths from top-left to bottom-right.","difficulty":"MEDIUM","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint uniquePaths(int m, int n) { return 0; }\\nint main() { cout<<uniquePaths(3,7); return 0; }","expectedOutput":"28","solution":"#include <iostream>\\nusing namespace std;\\nint uniquePaths(int m, int n) { int dp[m][n]; for(int i=0;i<m;i++) dp[i][0]=1; for(int j=0;j<n;j++) dp[0][j]=1; for(int i=1;i<m;i++) for(int j=1;j<n;j++) dp[i][j]=dp[i-1][j]+dp[i][j-1]; return dp[m-1][n-1]; }\\nint main() { cout<<uniquePaths(3,7); return 0; }","explanation":{"approach":"DP - paths to each cell.","steps":["dp[i][j] = dp[i-1][j] + dp[i][j-1]"],"complexity":"Time: O(mn), Space: O(mn)"},"testCases":[{"input":"m=3, n=7","expectedOutput":"28","explanation":"28 unique paths in 3x7 grid"},{"input":"m=3, n=2","expectedOutput":"3","explanation":"3 paths in 3x2 grid"},{"input":"m=1, n=1","expectedOutput":"1","explanation":"Only one cell, one path"},{"input":"m=5, n=5","expectedOutput":"70","explanation":"70 paths in 5x5 grid"}]}]`),rM=JSON.parse(`[{"id":"med51","title":"Unique Paths II","description":"Paths with obstacles.","difficulty":"MEDIUM","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint uniquePathsWithObstacles(int g[][3], int m, int n) { return 0; }\\nint main() { int g[][3]={{0,0,0},{0,1,0},{0,0,0}}; cout<<uniquePathsWithObstacles(g,3,3); return 0; }","expectedOutput":"2","solution":"#include <iostream>\\nusing namespace std;\\nint uniquePathsWithObstacles(int g[][3], int m, int n) { if(g[0][0]==1) return 0; int dp[m][n]={}; dp[0][0]=1; for(int i=1;i<m;i++) dp[i][0]=g[i][0]?0:dp[i-1][0]; for(int j=1;j<n;j++) dp[0][j]=g[0][j]?0:dp[0][j-1]; for(int i=1;i<m;i++) for(int j=1;j<n;j++) dp[i][j]=g[i][j]?0:dp[i-1][j]+dp[i][j-1]; return dp[m-1][n-1]; }\\nint main() { int g[][3]={{0,0,0},{0,1,0},{0,0,0}}; cout<<uniquePathsWithObstacles(g,3,3); return 0; }","explanation":{"approach":"DP, skip obstacles.","steps":["dp[i][j] = 0 if obstacle","Else sum of top and left"],"complexity":"Time: O(mn), Space: O(mn)"},"testCases":[{"input":"grid=[[0,0,0],[0,1,0],[0,0,0]]","expectedOutput":"2","explanation":"2 paths around center obstacle"},{"input":"grid=[[0,1],[0,0]]","expectedOutput":"1","explanation":"Only path going down then right"},{"input":"grid=[[1]]","expectedOutput":"0","explanation":"Start blocked, no paths"},{"input":"grid=[[0,0],[0,0]]","expectedOutput":"2","explanation":"2 paths in 2x2 grid"}]},{"id":"med52","title":"Minimum Path Sum","description":"Min sum path to bottom-right.","difficulty":"MEDIUM","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint minPathSum(int g[][3], int m, int n) { return 0; }\\nint main() { int g[][3]={{1,3,1},{1,5,1},{4,2,1}}; cout<<minPathSum(g,3,3); return 0; }","expectedOutput":"7","solution":"#include <iostream>\\nusing namespace std;\\nint minPathSum(int g[][3], int m, int n) { int dp[m][n]; dp[0][0]=g[0][0]; for(int i=1;i<m;i++) dp[i][0]=dp[i-1][0]+g[i][0]; for(int j=1;j<n;j++) dp[0][j]=dp[0][j-1]+g[0][j]; for(int i=1;i<m;i++) for(int j=1;j<n;j++) dp[i][j]=min(dp[i-1][j],dp[i][j-1])+g[i][j]; return dp[m-1][n-1]; }\\nint main() { int g[][3]={{1,3,1},{1,5,1},{4,2,1}}; cout<<minPathSum(g,3,3); return 0; }","explanation":{"approach":"DP - min sum to each cell.","steps":["dp[i][j] = min(top, left) + g[i][j]"],"complexity":"Time: O(mn), Space: O(mn)"},"testCases":[{"input":"grid=[[1,3,1],[1,5,1],[4,2,1]]","expectedOutput":"7","explanation":"Path 13111 = 7"},{"input":"grid=[[1,2,3],[4,5,6]]","expectedOutput":"12","explanation":"Path 1236 = 12"},{"input":"grid=[[5]]","expectedOutput":"5","explanation":"Single cell"},{"input":"grid=[[1,2],[1,1]]","expectedOutput":"3","explanation":"Path 111 = 3"}]},{"id":"med53","title":"Jump Game","description":"Can reach last index.","difficulty":"MEDIUM","category":"Greedy","starterCode":"#include <iostream>\\nusing namespace std;\\nbool canJump(int a[], int n) { return false; }\\nint main() { int a[]={2,3,1,1,4}; cout<<canJump(a,5); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool canJump(int a[], int n) { int reach=0; for(int i=0;i<n && i<=reach;i++) reach=max(reach,i+a[i]); return reach>=n-1; }\\nint main() { int a[]={2,3,1,1,4}; cout<<canJump(a,5); return 0; }","explanation":{"approach":"Track farthest reachable.","steps":["Update max reach at each index","Check if reach >= n-1"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"nums=[2,3,1,1,4]","expectedOutput":"1","explanation":"Can reach end: 014 or 0234"},{"input":"nums=[3,2,1,0,4]","expectedOutput":"0","explanation":"Stuck at index 3"},{"input":"nums=[0]","expectedOutput":"1","explanation":"Already at end"},{"input":"nums=[2,0,0]","expectedOutput":"1","explanation":"Jump directly to end"}]},{"id":"med54","title":"Edit Distance","description":"Min operations to convert.","difficulty":"MEDIUM","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint minDistance(char a[], char b[]) { return 0; }\\nint main() { cout<<minDistance(\\"horse\\",\\"ros\\"); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nint minDistance(char a[], char b[]) { int m=0,n=0; while(a[m]) m++; while(b[n]) n++; int dp[m+1][n+1]; for(int i=0;i<=m;i++) dp[i][0]=i; for(int j=0;j<=n;j++) dp[0][j]=j; for(int i=1;i<=m;i++) for(int j=1;j<=n;j++) if(a[i-1]==b[j-1]) dp[i][j]=dp[i-1][j-1]; else dp[i][j]=1+min(dp[i-1][j],min(dp[i][j-1],dp[i-1][j-1])); return dp[m][n]; }\\nint main() { cout<<minDistance(\\"horse\\",\\"ros\\"); return 0; }","explanation":{"approach":"DP - operations for each prefix.","steps":["If match, no operation","Else min of 3 operations + 1"],"complexity":"Time: O(mn), Space: O(mn)"},"testCases":[{"input":"word1=horse, word2=ros","expectedOutput":"3","explanation":"horserorseroseros"},{"input":"word1=intention, word2=execution","expectedOutput":"5","explanation":"5 operations needed"},{"input":"word1=abc, word2=abc","expectedOutput":"0","explanation":"Same strings"},{"input":"word1=, word2=abc","expectedOutput":"3","explanation":"Insert 3 chars"}]},{"id":"med55","title":"Longest Common Subsequence","description":"LCS length.","difficulty":"MEDIUM","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint lcs(char a[], char b[]) { return 0; }\\nint main() { cout<<lcs(\\"abcde\\",\\"ace\\"); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nint lcs(char a[], char b[]) { int m=0,n=0; while(a[m]) m++; while(b[n]) n++; int dp[m+1][n+1]={}; for(int i=1;i<=m;i++) for(int j=1;j<=n;j++) if(a[i-1]==b[j-1]) dp[i][j]=dp[i-1][j-1]+1; else dp[i][j]=max(dp[i-1][j],dp[i][j-1]); return dp[m][n]; }\\nint main() { cout<<lcs(\\"abcde\\",\\"ace\\"); return 0; }","explanation":{"approach":"DP - LCS for each prefix pair.","steps":["If match, add 1 to diagonal","Else max of skip either"],"complexity":"Time: O(mn), Space: O(mn)"},"testCases":[{"input":"text1=abcde, text2=ace","expectedOutput":"3","explanation":"LCS is 'ace'"},{"input":"text1=abc, text2=abc","expectedOutput":"3","explanation":"Same strings, LCS=3"},{"input":"text1=abc, text2=def","expectedOutput":"0","explanation":"No common chars"},{"input":"text1=bl, text2=yby","expectedOutput":"1","explanation":"LCS is 'b'"}]},{"id":"med56","title":"0/1 Knapsack","description":"Max value in capacity.","difficulty":"MEDIUM","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint knapsack(int w[], int v[], int n, int W) { return 0; }\\nint main() { int w[]={1,2,3}, v[]={60,100,120}; cout<<knapsack(w,v,3,5); return 0; }","expectedOutput":"220","solution":"#include <iostream>\\nusing namespace std;\\nint knapsack(int w[], int v[], int n, int W) { int dp[n+1][W+1]={}; for(int i=1;i<=n;i++) for(int j=0;j<=W;j++) { dp[i][j]=dp[i-1][j]; if(w[i-1]<=j) dp[i][j]=max(dp[i][j],dp[i-1][j-w[i-1]]+v[i-1]); } return dp[n][W]; }\\nint main() { int w[]={1,2,3}, v[]={60,100,120}; cout<<knapsack(w,v,3,5); return 0; }","explanation":{"approach":"DP - max value for capacity.","steps":["For each item and capacity","Max of skip or take"],"complexity":"Time: O(nW), Space: O(nW)"},"testCases":[{"input":"weights=[1,2,3], values=[60,100,120], W=5","expectedOutput":"220","explanation":"Take items 2 and 3: 100+120=220"},{"input":"weights=[10], values=[100], W=5","expectedOutput":"0","explanation":"Item too heavy"},{"input":"weights=[1,1], values=[1,1], W=2","expectedOutput":"2","explanation":"Take both"},{"input":"weights=[2,3,4], values=[3,4,5], W=5","expectedOutput":"7","explanation":"Take 2+3=5 weight, 3+4=7 value"}]},{"id":"med57","title":"Partition Equal Subset","description":"Can split into equal sums.","difficulty":"MEDIUM","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nbool canPartition(int a[], int n) { return false; }\\nint main() { int a[]={1,5,11,5}; cout<<canPartition(a,4); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool canPartition(int a[], int n) { int sum=0; for(int i=0;i<n;i++) sum+=a[i]; if(sum%2) return false; int t=sum/2; bool dp[t+1]={}; dp[0]=true; for(int i=0;i<n;i++) for(int j=t;j>=a[i];j--) dp[j]=dp[j]||dp[j-a[i]]; return dp[t]; }\\nint main() { int a[]={1,5,11,5}; cout<<canPartition(a,4); return 0; }","explanation":{"approach":"Subset sum to half.","steps":["Check if sum is even","DP for subset sum"],"complexity":"Time: O(n  sum), Space: O(sum)"},"testCases":[{"input":"nums=[1,5,11,5]","expectedOutput":"1","explanation":"[1,5,5] and [11] both sum to 11"},{"input":"nums=[1,2,3,5]","expectedOutput":"0","explanation":"Sum=11 (odd), cannot partition"},{"input":"nums=[1,2,5]","expectedOutput":"0","explanation":"No equal partition possible"},{"input":"nums=[2,2,2,2]","expectedOutput":"1","explanation":"[2,2] and [2,2] both sum to 4"}]},{"id":"med58","title":"Coin Change Ways","description":"Number of ways to make amount.","difficulty":"MEDIUM","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint coinWays(int coins[], int n, int amt) { return 0; }\\nint main() { int coins[]={1,2,5}; cout<<coinWays(coins,3,5); return 0; }","expectedOutput":"4","solution":"#include <iostream>\\nusing namespace std;\\nint coinWays(int coins[], int n, int amt) { int dp[amt+1]={}; dp[0]=1; for(int i=0;i<n;i++) for(int j=coins[i];j<=amt;j++) dp[j]+=dp[j-coins[i]]; return dp[amt]; }\\nint main() { int coins[]={1,2,5}; cout<<coinWays(coins,3,5); return 0; }","explanation":{"approach":"DP - ways for each amount.","steps":["For each coin","Add ways from amount - coin"],"complexity":"Time: O(n  amt), Space: O(amt)"},"testCases":[{"input":"coins=[1,2,5], amount=5","expectedOutput":"4","explanation":"5=5, 2+2+1, 2+1+1+1, 1+1+1+1+1"},{"input":"coins=[2], amount=3","expectedOutput":"0","explanation":"Cannot make 3 with 2s only"},{"input":"coins=[1], amount=0","expectedOutput":"1","explanation":"One way: use nothing"},{"input":"coins=[1,2], amount=3","expectedOutput":"2","explanation":"3=1+1+1 or 1+2"}]},{"id":"med59","title":"Target Sum","description":"Ways to reach target with +/-.","difficulty":"MEDIUM","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint findTargetSumWays(int a[], int n, int t) { return 0; }\\nint main() { int a[]={1,1,1,1,1}; cout<<findTargetSumWays(a,5,3); return 0; }","expectedOutput":"5","solution":"#include <iostream>\\nusing namespace std;\\nint solve(int a[], int n, int i, int sum) { if(i==n) return sum==0?1:0; return solve(a,n,i+1,sum-a[i])+solve(a,n,i+1,sum+a[i]); }\\nint findTargetSumWays(int a[], int n, int t) { return solve(a,n,0,t); }\\nint main() { int a[]={1,1,1,1,1}; cout<<findTargetSumWays(a,5,3); return 0; }","explanation":{"approach":"Try + and - for each number.","steps":["Add or subtract current","Count ways reaching 0"],"complexity":"Time: O(2^n), Space: O(n)"},"testCases":[{"input":"nums=[1,1,1,1,1], target=3","expectedOutput":"5","explanation":"5 ways: +1+1+1+1-1, etc."},{"input":"nums=[1], target=1","expectedOutput":"1","explanation":"Only +1 works"},{"input":"nums=[1,2,1], target=0","expectedOutput":"2","explanation":"+1-2+1 or -1+2-1"},{"input":"nums=[1], target=2","expectedOutput":"0","explanation":"Cannot reach 2"}]},{"id":"med60","title":"Longest Palindromic Subseq","description":"LPS length.","difficulty":"MEDIUM","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint lps(char s[]) { return 0; }\\nint main() { cout<<lps(\\"bbbab\\"); return 0; }","expectedOutput":"4","solution":"#include <iostream>\\nusing namespace std;\\nint lps(char s[]) { int n=0; while(s[n]) n++; int dp[n][n]={}; for(int i=0;i<n;i++) dp[i][i]=1; for(int len=2;len<=n;len++) for(int i=0;i<=n-len;i++) { int j=i+len-1; if(s[i]==s[j]) dp[i][j]=dp[i+1][j-1]+2; else dp[i][j]=max(dp[i+1][j],dp[i][j-1]); } return dp[0][n-1]; }\\nint main() { cout<<lps(\\"bbbab\\"); return 0; }","explanation":{"approach":"DP on substrings.","steps":["If ends match, add 2","Else max of skipping either end"],"complexity":"Time: O(n), Space: O(n)"},"testCases":[{"input":"s=bbbab","expectedOutput":"4","explanation":"LPS is 'bbbb'"},{"input":"s=cbbd","expectedOutput":"2","explanation":"LPS is 'bb'"},{"input":"s=a","expectedOutput":"1","explanation":"Single char is palindrome"},{"input":"s=abcba","expectedOutput":"5","explanation":"Entire string is palindrome"}]}]`),sM=JSON.parse(`[{"id":"med61","title":"Maximal Square","description":"Largest square of 1s.","difficulty":"MEDIUM","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint maximalSquare(int m[][5], int r, int c) { return 0; }\\nint main() { int m[][5]={{1,0,1,0,0},{1,0,1,1,1},{1,1,1,1,1},{1,0,0,1,0}}; cout<<maximalSquare(m,4,5); return 0; }","expectedOutput":"4","solution":"#include <iostream>\\nusing namespace std;\\nint maximalSquare(int m[][5], int r, int c) { int dp[r][c], mx=0; for(int i=0;i<r;i++) for(int j=0;j<c;j++) { if(i==0||j==0) dp[i][j]=m[i][j]; else if(m[i][j]==1) dp[i][j]=1+min(dp[i-1][j],min(dp[i][j-1],dp[i-1][j-1])); else dp[i][j]=0; mx=max(mx,dp[i][j]); } return mx*mx; }\\nint main() { int m[][5]={{1,0,1,0,0},{1,0,1,1,1},{1,1,1,1,1},{1,0,0,1,0}}; cout<<maximalSquare(m,4,5); return 0; }","explanation":{"approach":"DP - square size at each cell.","steps":["dp[i][j] = max square ending at (i,j)","Min of top, left, diagonal + 1"],"complexity":"Time: O(rc), Space: O(rc)"},"testCases":[{"input":"4x5 matrix with 1s and 0s","expectedOutput":"4","explanation":"2x2 square found, area = 4"},{"input":"matrix all 0s","expectedOutput":"0","explanation":"No 1s, no square"},{"input":"matrix [[1]]","expectedOutput":"1","explanation":"Single 1"},{"input":"matrix [[1,1],[1,1]]","expectedOutput":"4","explanation":"Entire 2x2 is square"}]},{"id":"med62","title":"Longest String Chain","description":"Longest word chain.","difficulty":"MEDIUM","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint longestStrChain(char words[][10], int n) { return 0; }\\nint main() { char words[][10]={\\"a\\",\\"b\\",\\"ba\\",\\"bca\\",\\"bda\\",\\"bdca\\"}; cout<<longestStrChain(words,6); return 0; }","expectedOutput":"4","solution":"#include <iostream>\\nusing namespace std;\\nint len(char s[]) { int l=0; while(s[l]) l++; return l; }\\nbool isPred(char a[], char b[]) { int la=len(a),lb=len(b); if(lb!=la+1) return false; int i=0,j=0; while(b[j]) { if(a[i]==b[j]) i++; j++; } return i==la; }\\nint longestStrChain(char words[][10], int n) { for(int i=0;i<n-1;i++) for(int j=0;j<n-i-1;j++) if(len(words[j])>len(words[j+1])) { char t[10]; int k=0; while(words[j][k]) { t[k]=words[j][k]; k++; } t[k]=0; k=0; while(words[j+1][k]) { words[j][k]=words[j+1][k]; k++; } words[j][k]=0; k=0; while(t[k]) { words[j+1][k]=t[k]; k++; } words[j+1][k]=0; } int dp[n]; for(int i=0;i<n;i++) dp[i]=1; for(int i=1;i<n;i++) for(int j=0;j<i;j++) if(isPred(words[j],words[i])) dp[i]=max(dp[i],dp[j]+1); int mx=0; for(int i=0;i<n;i++) mx=max(mx,dp[i]); return mx; }\\nint main() { char words[][10]={\\"a\\",\\"b\\",\\"ba\\",\\"bca\\",\\"bda\\",\\"bdca\\"}; cout<<longestStrChain(words,6); return 0; }","explanation":{"approach":"Sort by length, DP on predecessors.","steps":["Sort by length","For each word, check predecessors"],"complexity":"Time: O(n  L), Space: O(n)"},"testCases":[{"input":"words=[a,b,ba,bca,bda,bdca]","expectedOutput":"4","explanation":"Chain: ababdabdca"},{"input":"words=[xbc,pcxbcf,xb,cxbc,pcxbc]","expectedOutput":"5","explanation":"Full chain of 5"},{"input":"words=[a]","expectedOutput":"1","explanation":"Single word"},{"input":"words=[abc,def]","expectedOutput":"1","explanation":"No chain possible"}]},{"id":"med63","title":"Interleaving String","description":"Can s3 be interleaving of s1 and s2.","difficulty":"MEDIUM","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isInterleave(char s1[], char s2[], char s3[]) { return false; }\\nint main() { cout<<isInterleave(\\"aabcc\\",\\"dbbca\\",\\"aadbbcbcac\\"); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isInterleave(char s1[], char s2[], char s3[]) { int m=0,n=0,l=0; while(s1[m]) m++; while(s2[n]) n++; while(s3[l]) l++; if(l!=m+n) return false; bool dp[m+1][n+1]; dp[0][0]=true; for(int i=1;i<=m;i++) dp[i][0]=dp[i-1][0]&&s1[i-1]==s3[i-1]; for(int j=1;j<=n;j++) dp[0][j]=dp[0][j-1]&&s2[j-1]==s3[j-1]; for(int i=1;i<=m;i++) for(int j=1;j<=n;j++) dp[i][j]=(dp[i-1][j]&&s1[i-1]==s3[i+j-1]) || (dp[i][j-1]&&s2[j-1]==s3[i+j-1]); return dp[m][n]; }\\nint main() { cout<<isInterleave(\\"aabcc\\",\\"dbbca\\",\\"aadbbcbcac\\"); return 0; }","explanation":{"approach":"DP - can reach each position.","steps":["dp[i][j] = can form s3[0..i+j] from s1[0..i] and s2[0..j]"],"complexity":"Time: O(mn), Space: O(mn)"},"testCases":[{"input":"s1=aabcc, s2=dbbca, s3=aadbbcbcac","expectedOutput":"1","explanation":"Valid interleaving"},{"input":"s1=aabcc, s2=dbbca, s3=aadbbbaccc","expectedOutput":"0","explanation":"Not valid interleaving"},{"input":"s1=, s2=, s3=","expectedOutput":"1","explanation":"All empty strings"},{"input":"s1=a, s2=b, s3=ab","expectedOutput":"1","explanation":"Simple interleave"}]},{"id":"med64","title":"Distinct Subsequences","description":"Number of distinct subsequences.","difficulty":"HARD","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint numDistinct(char s[], char t[]) { return 0; }\\nint main() { cout<<numDistinct(\\"rabbbit\\",\\"rabbit\\"); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nint numDistinct(char s[], char t[]) { int m=0,n=0; while(s[m]) m++; while(t[n]) n++; int dp[m+1][n+1]={}; for(int i=0;i<=m;i++) dp[i][0]=1; for(int i=1;i<=m;i++) for(int j=1;j<=n;j++) { dp[i][j]=dp[i-1][j]; if(s[i-1]==t[j-1]) dp[i][j]+=dp[i-1][j-1]; } return dp[m][n]; }\\nint main() { cout<<numDistinct(\\"rabbbit\\",\\"rabbit\\"); return 0; }","explanation":{"approach":"DP - ways to form t from s.","steps":["dp[i][j] = ways to form t[0..j] from s[0..i]","Include match or skip"],"complexity":"Time: O(mn), Space: O(mn)"},"testCases":[{"input":"s=rabbbit, t=rabbit","expectedOutput":"3","explanation":"3 ways to choose the 'b's"},{"input":"s=babgbag, t=bag","expectedOutput":"5","explanation":"5 distinct bags"},{"input":"s=a, t=a","expectedOutput":"1","explanation":"Single matching char"},{"input":"s=abc, t=d","expectedOutput":"0","explanation":"No 'd' in source"}]},{"id":"med65","title":"Best Time Cooldown","description":"Buy/sell with cooldown.","difficulty":"MEDIUM","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint maxProfit(int p[], int n) { return 0; }\\nint main() { int p[]={1,2,3,0,2}; cout<<maxProfit(p,5); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nint maxProfit(int p[], int n) { if(n<=1) return 0; int dp[n][2]; dp[0][0]=0; dp[0][1]=-p[0]; dp[1][0]=max(0,p[1]-p[0]); dp[1][1]=max(-p[0],-p[1]); for(int i=2;i<n;i++) { dp[i][0]=max(dp[i-1][0],dp[i-1][1]+p[i]); dp[i][1]=max(dp[i-1][1],dp[i-2][0]-p[i]); } return dp[n-1][0]; }\\nint main() { int p[]={1,2,3,0,2}; cout<<maxProfit(p,5); return 0; }","explanation":{"approach":"DP with hold/not hold states.","steps":["dp[i][0] = max profit not holding","dp[i][1] = max profit holding"],"complexity":"Time: O(n), Space: O(n)"},"testCases":[{"input":"prices=[1,2,3,0,2]","expectedOutput":"3","explanation":"Buy@1, sell@3, cooldown, buy@0, sell@2"},{"input":"prices=[1]","expectedOutput":"0","explanation":"Can't complete any transaction"},{"input":"prices=[1,2]","expectedOutput":"1","explanation":"Buy@1, sell@2"},{"input":"prices=[2,1]","expectedOutput":"0","explanation":"Price drops, don't trade"}]},{"id":"med66","title":"Burst Balloons","description":"Max coins from bursting.","difficulty":"HARD","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint maxCoins(int nums[], int n) { return 0; }\\nint main() { int nums[]={3,1,5,8}; cout<<maxCoins(nums,4); return 0; }","expectedOutput":"167","solution":"#include <iostream>\\nusing namespace std;\\nint maxCoins(int nums[], int n) { int a[n+2]; a[0]=a[n+1]=1; for(int i=0;i<n;i++) a[i+1]=nums[i]; int dp[n+2][n+2]={}; for(int len=1;len<=n;len++) for(int l=1;l<=n-len+1;l++) { int r=l+len-1; for(int k=l;k<=r;k++) dp[l][r]=max(dp[l][r],dp[l][k-1]+a[l-1]*a[k]*a[r+1]+dp[k+1][r]); } return dp[1][n]; }\\nint main() { int nums[]={3,1,5,8}; cout<<maxCoins(nums,4); return 0; }","explanation":{"approach":"DP - last balloon to burst.","steps":["dp[l][r] = max coins for range","Try each as last to burst"],"complexity":"Time: O(n), Space: O(n)"},"testCases":[{"input":"nums=[3,1,5,8]","expectedOutput":"167","explanation":"Optimal burst order gives 167"},{"input":"nums=[1,5]","expectedOutput":"10","explanation":"Burst 1 then 5: 1*1*5 + 1*5*1 = 10"},{"input":"nums=[5]","expectedOutput":"5","explanation":"Single balloon: 1*5*1 = 5"},{"input":"nums=[1,2,3]","expectedOutput":"12","explanation":"Optimal = 12"}]},{"id":"med67","title":"Regular Expression","description":"Simple regex matching.","difficulty":"MEDIUM","category":"Strings","starterCode":"#include <iostream>\\nusing namespace std;\\nbool match(char s[], char p[]) { return false; }\\nint main() { cout<<match(\\"aa\\",\\"a.\\"); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool match(char s[], char p[]) { if(!*p) return !*s; if(p[0]=='.' || p[0]==s[0]) return match(s+1,p+1); return false; }\\nint main() { cout<<match(\\"aa\\",\\"a.\\"); return 0; }","explanation":{"approach":"Recursive matching.","steps":["Match current char or .","Recurse on rest"],"complexity":"Time: O(n), Space: O(n)"},"testCases":[{"input":"s=aa, p=a.","expectedOutput":"1","explanation":". matches second 'a'"},{"input":"s=ab, p=..","expectedOutput":"1","explanation":"Two dots match any two chars"},{"input":"s=abc, p=ab","expectedOutput":"0","explanation":"Pattern shorter"},{"input":"s=a, p=a","expectedOutput":"1","explanation":"Exact match"}]},{"id":"med68","title":"Decode String","description":"Decode k[encoded_string].","difficulty":"MEDIUM","category":"Stack","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid decodeString(char s[]) {}\\nint main() { decodeString(\\"3[a2[c]]\\"); return 0; }","expectedOutput":"accaccacc","solution":"#include <iostream>\\nusing namespace std;\\nvoid decodeString(char s[]) { char res[1000]={}; int ri=0; for(int i=0;s[i];) { if(s[i]>='a'&&s[i]<='z') res[ri++]=s[i++]; else if(s[i]>='0'&&s[i]<='9') { int k=0; while(s[i]>='0'&&s[i]<='9') k=k*10+s[i++]-'0'; i++; int start=i,depth=1; while(depth>0) { if(s[i]=='[') depth++; else if(s[i]==']') depth--; i++; } char sub[100]={}; int j=0; for(int t=start;t<i-1;t++) sub[j++]=s[t]; for(int t=0;t<k;t++) { int p=0; while(sub[p]) res[ri++]=sub[p++]; } } else i++; } cout<<res; }\\nint main() { decodeString(\\"3[a2[c]]\\"); return 0; }","explanation":{"approach":"Parse number, extract substring, repeat.","steps":["Find number k","Extract content in brackets","Repeat k times"],"complexity":"Time: O(n  maxK), Space: O(n)"},"testCases":[{"input":"s=3[a2[c]]","expectedOutput":"accaccacc","explanation":"2[c]=cc, then 3[acc]=accaccacc"},{"input":"s=2[abc]3[cd]ef","expectedOutput":"abcabccdcdcdef","explanation":"Decode and concatenate"},{"input":"s=abc3[cd]xyz","expectedOutput":"abccdcdcdxyz","explanation":"Mixed literal and encoded"},{"input":"s=2[a]","expectedOutput":"aa","explanation":"Simple repeat"}]},{"id":"med69","title":"Find All Anagrams","description":"Find anagram indices.","difficulty":"MEDIUM","category":"Sliding Window","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid findAnagrams(char s[], char p[]) {}\\nint main() { findAnagrams(\\"cbaebabacd\\",\\"abc\\"); return 0; }","expectedOutput":"0 6","solution":"#include <iostream>\\nusing namespace std;\\nvoid findAnagrams(char s[], char p[]) { int pc[26]={}, sc[26]={}; int plen=0,slen=0; while(p[plen]) pc[p[plen++]-'a']++; while(s[slen]) slen++; for(int i=0;i<slen;i++) { sc[s[i]-'a']++; if(i>=plen) sc[s[i-plen]-'a']--; if(i>=plen-1) { bool match=true; for(int j=0;j<26;j++) if(pc[j]!=sc[j]) { match=false; break; } if(match) cout<<i-plen+1<<\\" \\"; } } }\\nint main() { findAnagrams(\\"cbaebabacd\\",\\"abc\\"); return 0; }","explanation":{"approach":"Sliding window with char counts.","steps":["Add right char, remove left char","Compare counts"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"s=cbaebabacd, p=abc","expectedOutput":"0 6","explanation":"Anagrams at index 0 (cba) and 6 (bac)"},{"input":"s=abab, p=ab","expectedOutput":"0 1 2","explanation":"Overlapping anagrams"},{"input":"s=aaa, p=aa","expectedOutput":"0 1","explanation":"Two overlapping 'aa's"},{"input":"s=abc, p=xyz","expectedOutput":"","explanation":"No anagrams found"}]},{"id":"med70","title":"Permutation in String","description":"Check if s2 contains permutation of s1.","difficulty":"MEDIUM","category":"Sliding Window","starterCode":"#include <iostream>\\nusing namespace std;\\nbool checkInclusion(char s1[], char s2[]) { return false; }\\nint main() { cout<<checkInclusion(\\"ab\\",\\"eidbaooo\\"); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool checkInclusion(char s1[], char s2[]) { int c1[26]={},c2[26]={}; int l1=0,l2=0; while(s1[l1]) c1[s1[l1++]-'a']++; while(s2[l2]) l2++; for(int i=0;i<l2;i++) { c2[s2[i]-'a']++; if(i>=l1) c2[s2[i-l1]-'a']--; bool match=true; for(int j=0;j<26;j++) if(c1[j]!=c2[j]) { match=false; break; } if(match) return true; } return false; }\\nint main() { cout<<checkInclusion(\\"ab\\",\\"eidbaooo\\"); return 0; }","explanation":{"approach":"Sliding window of s1 length.","steps":["Slide window of size len(s1)","Compare character counts"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"s1=ab, s2=eidbaooo","expectedOutput":"1","explanation":"'ba' is permutation of 'ab'"},{"input":"s1=ab, s2=eidboaoo","expectedOutput":"0","explanation":"No permutation found"},{"input":"s1=a, s2=a","expectedOutput":"1","explanation":"Single char match"},{"input":"s1=abc, s2=bbbca","expectedOutput":"1","explanation":"'bca' is permutation"}]}]`),oM=JSON.parse(`[{"id":"m201","title":"Unique Binary Search Trees","description":"Given an integer n, return the number of structurally unique BST's (binary search trees) which has exactly n nodes of unique values from 1 to n. This is the nth Catalan number.","difficulty":"MEDIUM","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint numTrees(int n) { return 0; }\\nint main() { cout << numTrees(3); return 0; }","expectedOutput":"5","solution":"#include <iostream>\\nusing namespace std;\\nint numTrees(int n) {\\n    int dp[n + 1] = {};\\n    dp[0] = dp[1] = 1;\\n    for(int nodes = 2; nodes <= n; nodes++) {\\n        for(int root = 1; root <= nodes; root++) {\\n            int leftNodes = root - 1;\\n            int rightNodes = nodes - root;\\n            dp[nodes] += dp[leftNodes] * dp[rightNodes];\\n        }\\n    }\\n    return dp[n];\\n}\\nint main() { cout << numTrees(3); return 0; }","explanation":{"approach":"Use dynamic programming. For n nodes, try each value as root.","steps":["dp[i] = number of unique BSTs with i nodes","Base case: dp[0] = dp[1] = 1"],"complexity":"Time: O(n), Space: O(n)"},"testCases":[{"input":"n=3","expectedOutput":"5","explanation":"5 unique BSTs with 3 nodes"},{"input":"n=1","expectedOutput":"1","explanation":"Only one tree with 1 node"},{"input":"n=4","expectedOutput":"14","explanation":"14 unique BSTs with 4 nodes"},{"input":"n=5","expectedOutput":"42","explanation":"5th Catalan number"}]},{"id":"m202","title":"Ugly Number II","description":"An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5. Given integer n, return the nth ugly number.","difficulty":"MEDIUM","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint nthUglyNumber(int n) { return 0; }\\nint main() { cout << nthUglyNumber(10); return 0; }","expectedOutput":"12","solution":"#include <iostream>\\nusing namespace std;\\nint nthUglyNumber(int n) {\\n    int ugly[n];\\n    ugly[0] = 1;\\n    int i2 = 0, i3 = 0, i5 = 0;\\n    for(int i = 1; i < n; i++) {\\n        int next2 = ugly[i2] * 2;\\n        int next3 = ugly[i3] * 3;\\n        int next5 = ugly[i5] * 5;\\n        ugly[i] = min(next2, min(next3, next5));\\n        if(ugly[i] == next2) i2++;\\n        if(ugly[i] == next3) i3++;\\n        if(ugly[i] == next5) i5++;\\n    }\\n    return ugly[n - 1];\\n}\\nint main() { cout << nthUglyNumber(10); return 0; }","explanation":{"approach":"Use three pointers, one for each prime factor (2, 3, 5).","steps":["Start with ugly[0] = 1","Take minimum of next candidates"],"complexity":"Time: O(n), Space: O(n)"},"testCases":[{"input":"n=10","expectedOutput":"12","explanation":"10th ugly: 1,2,3,4,5,6,8,9,10,12"},{"input":"n=1","expectedOutput":"1","explanation":"First ugly number is 1"},{"input":"n=7","expectedOutput":"8","explanation":"7th ugly number"},{"input":"n=15","expectedOutput":"24","explanation":"15th ugly number"}]},{"id":"m203","title":"Count Numbers with Unique Digits","description":"Given an integer n, count all numbers with unique digits in the range [0, 10^n).","difficulty":"MEDIUM","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint countNumbersWithUniqueDigits(int n) { return 0; }\\nint main() { cout << countNumbersWithUniqueDigits(2); return 0; }","expectedOutput":"91","solution":"#include <iostream>\\nusing namespace std;\\nint countNumbersWithUniqueDigits(int n) {\\n    if(n == 0) return 1;\\n    int result = 10;\\n    int uniqueDigits = 9;\\n    int availableDigits = 9;\\n    for(int i = 2; i <= n && availableDigits > 0; i++) {\\n        uniqueDigits *= availableDigits;\\n        result += uniqueDigits;\\n        availableDigits--;\\n    }\\n    return result;\\n}\\nint main() { cout << countNumbersWithUniqueDigits(2); return 0; }","explanation":{"approach":"Combinatorics approach. First digit has 9 choices, each subsequent has one fewer.","steps":["For n=1: 10 numbers","For 2-digit: 9*9 new numbers"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"n=2","expectedOutput":"91","explanation":"91 numbers with unique digits 0-99"},{"input":"n=0","expectedOutput":"1","explanation":"Only 0"},{"input":"n=1","expectedOutput":"10","explanation":"0-9 all unique"},{"input":"n=3","expectedOutput":"739","explanation":"Count for 0-999"}]},{"id":"m204","title":"Frequency of Most Frequent Element","description":"Given an array of integers and a number k, you can increment any element at most k times total. Return the maximum possible frequency of any element.","difficulty":"MEDIUM","category":"Sliding Window","starterCode":"#include <iostream>\\nusing namespace std;\\nint maxFrequency(int nums[], int n, int k) { return 0; }\\nint main() { int nu[] = {1, 2, 4}; cout << maxFrequency(nu, 3, 5); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nint maxFrequency(int nums[], int n, int k) {\\n    for(int i = 0; i < n - 1; i++) for(int j = 0; j < n - i - 1; j++) if(nums[j] > nums[j + 1]) { int temp = nums[j]; nums[j] = nums[j + 1]; nums[j + 1] = temp; }\\n    long long sum = 0;\\n    int left = 0, maxFreq = 1;\\n    for(int right = 0; right < n; right++) {\\n        sum += nums[right];\\n        while((long long)nums[right] * (right - left + 1) - sum > k) { sum -= nums[left]; left++; }\\n        maxFreq = max(maxFreq, right - left + 1);\\n    }\\n    return maxFreq;\\n}\\nint main() { int nu[] = {1, 2, 4}; cout << maxFrequency(nu, 3, 5); return 0; }","explanation":{"approach":"Sort then sliding window. Cost = max  windowSize - sum.","steps":["Sort array","Slide window, track cost"],"complexity":"Time: O(n log n), Space: O(1)"},"testCases":[{"input":"nums=[1,2,4], k=5","expectedOutput":"3","explanation":"Increment 1,2 to 4 (cost=5)"},{"input":"nums=[1,4,8,13], k=5","expectedOutput":"2","explanation":"Best: make 4,8 both 8"},{"input":"nums=[3,9,6], k=2","expectedOutput":"1","explanation":"Can't make any same"},{"input":"nums=[1,1,1], k=0","expectedOutput":"3","explanation":"Already all same"}]},{"id":"m205","title":"Maximum Erasure Value","description":"Given an array of positive integers, find the maximum sum of a subarray where all elements are unique.","difficulty":"MEDIUM","category":"Sliding Window","starterCode":"#include <iostream>\\nusing namespace std;\\nint maximumUniqueSubarray(int nums[], int n) { return 0; }\\nint main() { int nu[] = {4, 2, 4, 5, 6}; cout << maximumUniqueSubarray(nu, 5); return 0; }","expectedOutput":"17","solution":"#include <iostream>\\nusing namespace std;\\nint maximumUniqueSubarray(int nums[], int n) {\\n    bool seen[10001] = {};\\n    int left = 0, sum = 0, maxSum = 0;\\n    for(int right = 0; right < n; right++) {\\n        while(seen[nums[right]]) { seen[nums[left]] = false; sum -= nums[left]; left++; }\\n        seen[nums[right]] = true;\\n        sum += nums[right];\\n        maxSum = max(maxSum, sum);\\n    }\\n    return maxSum;\\n}\\nint main() { int nu[] = {4, 2, 4, 5, 6}; cout << maximumUniqueSubarray(nu, 5); return 0; }","explanation":{"approach":"Sliding window with set for uniqueness.","steps":["Remove left until no duplicates","Add right to window"],"complexity":"Time: O(n), Space: O(n)"},"testCases":[{"input":"nums=[4,2,4,5,6]","expectedOutput":"17","explanation":"Subarray [2,4,5,6] = 17"},{"input":"nums=[5,2,1,2,5,2,1,2,5]","expectedOutput":"8","explanation":"Max unique sum is 8"},{"input":"nums=[1,2,3,4,5]","expectedOutput":"15","explanation":"All unique, sum all"},{"input":"nums=[1]","expectedOutput":"1","explanation":"Single element"}]},{"id":"m206","title":"Container With Most Water","description":"Given n vertical lines, find two that form a container with the most water.","difficulty":"MEDIUM","category":"Two Pointers","starterCode":"#include <iostream>\\nusing namespace std;\\nint maxArea(int height[], int n) { return 0; }\\nint main() { int h[] = {1, 8, 6, 2, 5, 4, 8, 3, 7}; cout << maxArea(h, 9); return 0; }","expectedOutput":"49","solution":"#include <iostream>\\nusing namespace std;\\nint maxArea(int height[], int n) {\\n    int left = 0, right = n - 1;\\n    int maxWater = 0;\\n    while(left < right) {\\n        int h = min(height[left], height[right]);\\n        int width = right - left;\\n        maxWater = max(maxWater, h * width);\\n        if(height[left] < height[right]) left++;\\n        else right--;\\n    }\\n    return maxWater;\\n}\\nint main() { int h[] = {1, 8, 6, 2, 5, 4, 8, 3, 7}; cout << maxArea(h, 9); return 0; }","explanation":{"approach":"Two pointers from ends. Move shorter line inward.","steps":["Calculate water at each step","Move shorter pointer"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"height=[1,8,6,2,5,4,8,3,7]","expectedOutput":"49","explanation":"Lines at 1 and 8 (height 7,8)"},{"input":"height=[1,1]","expectedOutput":"1","explanation":"Min container"},{"input":"height=[4,3,2,1,4]","expectedOutput":"16","explanation":"4*4 between ends"},{"input":"height=[1,2,1]","expectedOutput":"2","explanation":"Best is 1*2"}]},{"id":"m207","title":"3Sum","description":"Given an array, find all unique triplets that sum to zero.","difficulty":"MEDIUM","category":"Two Pointers","starterCode":"#include <iostream>\\nusing namespace std;\\nint threeSum(int nums[], int n) { return 0; }\\nint main() { int nu[] = {-1, 0, 1, 2, -1, -4}; cout << threeSum(nu, 6); return 0; }","expectedOutput":"2","solution":"#include <iostream>\\nusing namespace std;\\nint threeSum(int nums[], int n) {\\n    for(int i = 0; i < n - 1; i++) for(int j = 0; j < n - i - 1; j++) if(nums[j] > nums[j + 1]) { int temp = nums[j]; nums[j] = nums[j + 1]; nums[j + 1] = temp; }\\n    int count = 0;\\n    for(int i = 0; i < n - 2; i++) {\\n        if(i > 0 && nums[i] == nums[i - 1]) continue;\\n        int left = i + 1, right = n - 1;\\n        while(left < right) {\\n            int sum = nums[i] + nums[left] + nums[right];\\n            if(sum == 0) { count++; while(left < right && nums[left] == nums[left + 1]) left++; while(left < right && nums[right] == nums[right - 1]) right--; left++; right--; }\\n            else if(sum < 0) left++;\\n            else right--;\\n        }\\n    }\\n    return count;\\n}\\nint main() { int nu[] = {-1, 0, 1, 2, -1, -4}; cout << threeSum(nu, 6); return 0; }","explanation":{"approach":"Sort, fix one element, two pointers for rest.","steps":["Sort array","Skip duplicates","Two pointer search"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"nums=[-1,0,1,2,-1,-4]","expectedOutput":"2","explanation":"[-1,-1,2] and [-1,0,1]"},{"input":"nums=[0,0,0]","expectedOutput":"1","explanation":"Only [0,0,0]"},{"input":"nums=[0,1,1]","expectedOutput":"0","explanation":"No triplet sums to 0"},{"input":"nums=[-2,0,1,1,2]","expectedOutput":"2","explanation":"Two triplets"}]},{"id":"m208","title":"3Sum Closest","description":"Given an array and target, find the sum of three integers closest to target.","difficulty":"MEDIUM","category":"Two Pointers","starterCode":"#include <iostream>\\nusing namespace std;\\nint threeSumClosest(int nums[], int n, int target) { return 0; }\\nint main() { int nu[] = {-1, 2, 1, -4}; cout << threeSumClosest(nu, 4, 1); return 0; }","expectedOutput":"2","solution":"#include <iostream>\\nusing namespace std;\\nint threeSumClosest(int nums[], int n, int target) {\\n    for(int i = 0; i < n - 1; i++) for(int j = 0; j < n - i - 1; j++) if(nums[j] > nums[j + 1]) { int temp = nums[j]; nums[j] = nums[j + 1]; nums[j + 1] = temp; }\\n    int closest = nums[0] + nums[1] + nums[2];\\n    for(int i = 0; i < n - 2; i++) {\\n        int left = i + 1, right = n - 1;\\n        while(left < right) {\\n            int sum = nums[i] + nums[left] + nums[right];\\n            if(abs(sum - target) < abs(closest - target)) closest = sum;\\n            if(sum < target) left++;\\n            else right--;\\n        }\\n    }\\n    return closest;\\n}\\nint main() { int nu[] = {-1, 2, 1, -4}; cout << threeSumClosest(nu, 4, 1); return 0; }","explanation":{"approach":"Similar to 3Sum, track closest sum.","steps":["Sort","Track closest","Two pointer adjust"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"nums=[-1,2,1,-4], target=1","expectedOutput":"2","explanation":"-1+2+1=2, closest to 1"},{"input":"nums=[0,0,0], target=1","expectedOutput":"0","explanation":"Only option is 0"},{"input":"nums=[1,1,1,1], target=0","expectedOutput":"3","explanation":"Closest is 1+1+1=3"},{"input":"nums=[-1,0,1,2], target=3","expectedOutput":"3","explanation":"0+1+2=3 exact"}]},{"id":"m209","title":"Sort Colors","description":"Given an array of 0s, 1s, and 2s, sort them in-place (Dutch National Flag).","difficulty":"MEDIUM","category":"Two Pointers","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid sortColors(int nums[], int n) {}\\nint main() { int nu[] = {2, 0, 2, 1, 1, 0}; sortColors(nu, 6); for(int i = 0; i < 6; i++) cout << nu[i] << \\" \\"; return 0; }","expectedOutput":"0 0 1 1 2 2","solution":"#include <iostream>\\nusing namespace std;\\nvoid sortColors(int nums[], int n) {\\n    int low = 0, mid = 0, high = n - 1;\\n    while(mid <= high) {\\n        if(nums[mid] == 0) { int temp = nums[low]; nums[low] = nums[mid]; nums[mid] = temp; low++; mid++; }\\n        else if(nums[mid] == 1) mid++;\\n        else { int temp = nums[mid]; nums[mid] = nums[high]; nums[high] = temp; high--; }\\n    }\\n}\\nint main() { int nu[] = {2, 0, 2, 1, 1, 0}; sortColors(nu, 6); for(int i = 0; i < 6; i++) cout << nu[i] << \\" \\"; return 0; }","explanation":{"approach":"Three pointers: low (0s), mid (current), high (2s).","steps":["0swap with low","1move mid","2swap with high"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"nums=[2,0,2,1,1,0]","expectedOutput":"0 0 1 1 2 2","explanation":"Sorted into 3 groups"},{"input":"nums=[2,0,1]","expectedOutput":"0 1 2","explanation":"Each color once"},{"input":"nums=[0]","expectedOutput":"0","explanation":"Single element"},{"input":"nums=[1,1,1]","expectedOutput":"1 1 1","explanation":"All same"}]},{"id":"m210","title":"Minimum Size Subarray Sum","description":"Find the minimal length of a contiguous subarray with sum >= target.","difficulty":"MEDIUM","category":"Sliding Window","starterCode":"#include <iostream>\\nusing namespace std;\\nint minSubArrayLen(int target, int nums[], int n) { return 0; }\\nint main() { int nu[] = {2, 3, 1, 2, 4, 3}; cout << minSubArrayLen(7, nu, 6); return 0; }","expectedOutput":"2","solution":"#include <iostream>\\nusing namespace std;\\nint minSubArrayLen(int target, int nums[], int n) {\\n    int left = 0, sum = 0;\\n    int minLen = n + 1;\\n    for(int right = 0; right < n; right++) {\\n        sum += nums[right];\\n        while(sum >= target) {\\n            minLen = min(minLen, right - left + 1);\\n            sum -= nums[left];\\n            left++;\\n        }\\n    }\\n    return minLen > n ? 0 : minLen;\\n}\\nint main() { int nu[] = {2, 3, 1, 2, 4, 3}; cout << minSubArrayLen(7, nu, 6); return 0; }","explanation":{"approach":"Sliding window, shrink while sum >= target.","steps":["Expand right","Shrink left while valid"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"target=7, nums=[2,3,1,2,4,3]","expectedOutput":"2","explanation":"[4,3] sums to 7"},{"input":"target=4, nums=[1,4,4]","expectedOutput":"1","explanation":"Single 4 >= 4"},{"input":"target=11, nums=[1,1,1,1,1,1]","expectedOutput":"0","explanation":"Can't reach 11"},{"input":"target=15, nums=[1,2,3,4,5]","expectedOutput":"5","explanation":"Need all elements"}]}]`),uM=JSON.parse(`[{"id":"m211","title":"Subarray Product Less Than K","description":"Count subarrays with product < k.","difficulty":"MEDIUM","category":"Sliding Window","starterCode":"#include <iostream>\\nusing namespace std;\\nint numSubarrayProductLessThanK(int nums[], int n, int k) { return 0; }\\nint main() { int nu[]={10,5,2,6}; cout << numSubarrayProductLessThanK(nu,4,100); return 0; }","expectedOutput":"8","solution":"#include <iostream>\\nusing namespace std;\\nint numSubarrayProductLessThanK(int nums[], int n, int k) { if(k<=1) return 0; int l=0,p=1,c=0; for(int r=0;r<n;r++) { p*=nums[r]; while(p>=k) p/=nums[l++]; c+=r-l+1; } return c; }\\nint main() { int nu[]={10,5,2,6}; cout << numSubarrayProductLessThanK(nu,4,100); return 0; }","explanation":{"approach":"Sliding window with product.","steps":["Expand right, shrink if product >= k","Count subarrays ending at r"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"{10,5,2,6}, k=100","expectedOutput":"8","explanation":"8 subarrays with product < 100"},{"input":"{1,2,3}, k=0","expectedOutput":"0","explanation":"No valid subarrays when k<=1"},{"input":"{1,1,1}, k=2","expectedOutput":"6","explanation":"All subarrays have product 1"},{"input":"{10,9,10,4,3,8,3,3,6,2,10,10,9,3}, k=19","expectedOutput":"18","explanation":"Complex array with larger k"}]},{"id":"m212","title":"Container With Most Water","description":"Max water between two lines.","difficulty":"MEDIUM","category":"Two Pointers","starterCode":"#include <iostream>\\nusing namespace std;\\nint maxArea(int height[], int n) { return 0; }\\nint main() { int h[]={1,8,6,2,5,4,8,3,7}; cout << maxArea(h,9); return 0; }","expectedOutput":"49","solution":"#include <iostream>\\nusing namespace std;\\nint maxArea(int height[], int n) { int l=0,r=n-1,mx=0; while(l<r) { mx=max(mx,min(height[l],height[r])*(r-l)); if(height[l]<height[r]) l++; else r--; } return mx; }\\nint main() { int h[]={1,8,6,2,5,4,8,3,7}; cout << maxArea(h,9); return 0; }","explanation":{"approach":"Two pointers from ends.","steps":["Calculate area","Move shorter line inward"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"{1,8,6,2,5,4,8,3,7}","expectedOutput":"49","explanation":"max(min(8,7)*7) = 49"},{"input":"{1,1}","expectedOutput":"1","explanation":"Minimum case"},{"input":"{4,3,2,1,4}","expectedOutput":"16","explanation":"4 * 4 = 16"},{"input":"{1,2,1}","expectedOutput":"2","explanation":"min(1,1)*2 = 2"}]},{"id":"m213","title":"3Sum","description":"Find all triplets summing to 0.","difficulty":"MEDIUM","category":"Two Pointers","starterCode":"#include <iostream>\\nusing namespace std;\\nint threeSum(int nums[], int n) { return 0; }\\nint main() { int nu[]={-1,0,1,2,-1,-4}; cout << threeSum(nu,6); return 0; }","expectedOutput":"2","solution":"#include <iostream>\\nusing namespace std;\\nint threeSum(int nums[], int n) { for(int i=0;i<n-1;i++) for(int j=0;j<n-i-1;j++) if(nums[j]>nums[j+1]) swap(nums[j],nums[j+1]); int c=0; for(int i=0;i<n-2;i++) { if(i>0&&nums[i]==nums[i-1]) continue; int l=i+1,r=n-1; while(l<r) { int s=nums[i]+nums[l]+nums[r]; if(s==0) { c++; while(l<r&&nums[l]==nums[l+1]) l++; while(l<r&&nums[r]==nums[r-1]) r--; l++; r--; } else if(s<0) l++; else r--; } } return c; }\\nint main() { int nu[]={-1,0,1,2,-1,-4}; cout << threeSum(nu,6); return 0; }","explanation":{"approach":"Sort and two pointers.","steps":["Sort array","Fix one, two-pointer for remaining"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"{-1,0,1,2,-1,-4}","expectedOutput":"2","explanation":"[-1,-1,2] and [-1,0,1]"},{"input":"{0,0,0}","expectedOutput":"1","explanation":"Only [0,0,0]"},{"input":"{1,2,-3,4}","expectedOutput":"1","explanation":"[1,2,-3]"},{"input":"{-2,0,1,1,2}","expectedOutput":"2","explanation":"[-2,0,2] and [-2,1,1]"}]},{"id":"m214","title":"3Sum Closest","description":"Triplet sum closest to target.","difficulty":"MEDIUM","category":"Two Pointers","starterCode":"#include <iostream>\\nusing namespace std;\\nint threeSumClosest(int nums[], int n, int target) { return 0; }\\nint main() { int nu[]={-1,2,1,-4}; cout << threeSumClosest(nu,4,1); return 0; }","expectedOutput":"2","solution":"#include <iostream>\\nusing namespace std;\\nint threeSumClosest(int nums[], int n, int target) { for(int i=0;i<n-1;i++) for(int j=0;j<n-i-1;j++) if(nums[j]>nums[j+1]) swap(nums[j],nums[j+1]); int closest=nums[0]+nums[1]+nums[2]; for(int i=0;i<n-2;i++) { int l=i+1,r=n-1; while(l<r) { int s=nums[i]+nums[l]+nums[r]; if(abs(s-target)<abs(closest-target)) closest=s; if(s<target) l++; else r--; } } return closest; }\\nint main() { int nu[]={-1,2,1,-4}; cout << threeSumClosest(nu,4,1); return 0; }","explanation":{"approach":"Sort and two pointers.","steps":["Sort","Track closest sum"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"{-1,2,1,-4}, target=1","expectedOutput":"2","explanation":"-1+2+1=2 is closest to 1"},{"input":"{0,0,0}, target=1","expectedOutput":"0","explanation":"0 is closest to 1"},{"input":"{1,1,1,0}, target=-100","expectedOutput":"2","explanation":"0+1+1=2 is closest"},{"input":"{1,2,4,8,16,32,64,128}, target=82","expectedOutput":"82","explanation":"Exact match: 2+16+64=82"}]},{"id":"m215","title":"4Sum","description":"Find quadruplets summing to target.","difficulty":"MEDIUM","category":"Two Pointers","starterCode":"#include <iostream>\\nusing namespace std;\\nint fourSum(int nums[], int n, int target) { return 0; }\\nint main() { int nu[]={1,0,-1,0,-2,2}; cout << fourSum(nu,6,0); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nint fourSum(int nums[], int n, int target) { for(int i=0;i<n-1;i++) for(int j=0;j<n-i-1;j++) if(nums[j]>nums[j+1]) swap(nums[j],nums[j+1]); int c=0; for(int i=0;i<n-3;i++) { if(i>0&&nums[i]==nums[i-1]) continue; for(int j=i+1;j<n-2;j++) { if(j>i+1&&nums[j]==nums[j-1]) continue; int l=j+1,r=n-1; while(l<r) { long s=(long)nums[i]+nums[j]+nums[l]+nums[r]; if(s==target) { c++; while(l<r&&nums[l]==nums[l+1]) l++; while(l<r&&nums[r]==nums[r-1]) r--; l++; r--; } else if(s<target) l++; else r--; } } } return c; }\\nint main() { int nu[]={1,0,-1,0,-2,2}; cout << fourSum(nu,6,0); return 0; }","explanation":{"approach":"Extend 3Sum with extra loop.","steps":["Fix two elements","Two-pointer for remaining"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"{1,0,-1,0,-2,2}, target=0","expectedOutput":"3","explanation":"3 unique quadruplets"},{"input":"{2,2,2,2,2}, target=8","expectedOutput":"1","explanation":"Only [2,2,2,2]"},{"input":"{0,0,0,0}, target=0","expectedOutput":"1","explanation":"All zeros"},{"input":"{-3,-2,-1,0,0,1,2,3}, target=0","expectedOutput":"8","explanation":"Multiple quadruplet combinations"}]},{"id":"m216","title":"Sort Colors","description":"Dutch national flag.","difficulty":"MEDIUM","category":"Two Pointers","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid sortColors(int nums[], int n) {}\\nint main() { int nu[]={2,0,2,1,1,0}; sortColors(nu,6); for(int i=0;i<6;i++) cout<<nu[i]<<\\" \\"; return 0; }","expectedOutput":"0 0 1 1 2 2","solution":"#include <iostream>\\nusing namespace std;\\nvoid sortColors(int nums[], int n) { int l=0,m=0,r=n-1; while(m<=r) { if(nums[m]==0) swap(nums[l++],nums[m++]); else if(nums[m]==1) m++; else swap(nums[m],nums[r--]); } }\\nint main() { int nu[]={2,0,2,1,1,0}; sortColors(nu,6); for(int i=0;i<6;i++) cout<<nu[i]<<\\" \\"; return 0; }","explanation":{"approach":"Three pointers.","steps":["0s before l, 2s after r","Swap accordingly"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"{2,0,2,1,1,0}","expectedOutput":"0 0 1 1 2 2","explanation":"Sorted colors"},{"input":"{2,0,1}","expectedOutput":"0 1 2","explanation":"Simple case"},{"input":"{0}","expectedOutput":"0","explanation":"Single element"},{"input":"{1,2,0,2,1,0}","expectedOutput":"0 0 1 1 2 2","explanation":"Different starting order"}]},{"id":"m217","title":"Boats to Save People","description":"Min boats needed.","difficulty":"MEDIUM","category":"Two Pointers","starterCode":"#include <iostream>\\nusing namespace std;\\nint numRescueBoats(int people[], int n, int limit) { return 0; }\\nint main() { int p[]={3,5,3,4}; cout << numRescueBoats(p,4,5); return 0; }","expectedOutput":"4","solution":"#include <iostream>\\nusing namespace std;\\nint numRescueBoats(int people[], int n, int limit) { for(int i=0;i<n-1;i++) for(int j=0;j<n-i-1;j++) if(people[j]>people[j+1]) swap(people[j],people[j+1]); int l=0,r=n-1,boats=0; while(l<=r) { if(people[l]+people[r]<=limit) l++; r--; boats++; } return boats; }\\nint main() { int p[]={3,5,3,4}; cout << numRescueBoats(p,4,5); return 0; }","explanation":{"approach":"Sort and pair lightest with heaviest.","steps":["Sort","Try pairing l and r"],"complexity":"Time: O(n log n), Space: O(1)"},"testCases":[{"input":"{3,5,3,4}, limit=5","expectedOutput":"4","explanation":"Each person needs own boat"},{"input":"{1,2}, limit=3","expectedOutput":"1","explanation":"Both fit in one boat"},{"input":"{3,2,2,1}, limit=3","expectedOutput":"3","explanation":"(1,2), (2), (3)"},{"input":"{1,1,1,1}, limit=2","expectedOutput":"2","explanation":"Two pairs of 1s"}]},{"id":"m218","title":"Long Pressed Name","description":"Check long pressed typing.","difficulty":"MEDIUM","category":"Two Pointers","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isLongPressedName(char name[], char typed[]) { return false; }\\nint main() { cout << isLongPressedName(\\"alex\\",\\"aaleex\\"); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isLongPressedName(char name[], char typed[]) { int i=0,j=0; while(typed[j]) { if(name[i]&&name[i]==typed[j]) { i++; j++; } else if(j>0&&typed[j]==typed[j-1]) j++; else return false; } return !name[i]; }\\nint main() { cout << isLongPressedName(\\"alex\\",\\"aaleex\\"); return 0; }","explanation":{"approach":"Two pointers matching.","steps":["Match chars or accept repeats"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"name=\\"alex\\", typed=\\"aaleex\\"","expectedOutput":"1","explanation":"Valid long press"},{"input":"name=\\"saeed\\", typed=\\"ssaaedd\\"","expectedOutput":"0","explanation":"Missing second 'e'"},{"input":"name=\\"a\\", typed=\\"aaaa\\"","expectedOutput":"1","explanation":"Simple long press"},{"input":"name=\\"leelee\\", typed=\\"lleeelee\\"","expectedOutput":"1","explanation":"Valid with multiple repeats"}]},{"id":"m219","title":"Find K-th Smallest Pair Distance","description":"Kth smallest distance.","difficulty":"MEDIUM","category":"Binary Search","starterCode":"#include <iostream>\\nusing namespace std;\\nint smallestDistancePair(int nums[], int n, int k) { return 0; }\\nint main() { int nu[]={1,3,1}; cout << smallestDistancePair(nu,3,1); return 0; }","expectedOutput":"0","solution":"#include <iostream>\\nusing namespace std;\\nint countPairs(int nums[], int n, int d) { int c=0; for(int i=0,j=0;i<n;i++) { while(j<n&&nums[j]-nums[i]<=d) j++; c+=j-i-1; } return c; }\\nint smallestDistancePair(int nums[], int n, int k) { for(int i=0;i<n-1;i++) for(int j=0;j<n-i-1;j++) if(nums[j]>nums[j+1]) swap(nums[j],nums[j+1]); int l=0,r=nums[n-1]-nums[0]; while(l<r) { int m=(l+r)/2; if(countPairs(nums,n,m)>=k) r=m; else l=m+1; } return l; }\\nint main() { int nu[]={1,3,1}; cout << smallestDistancePair(nu,3,1); return 0; }","explanation":{"approach":"Binary search on answer.","steps":["Sort","Binary search distance, count pairs"],"complexity":"Time: O(n log n + n log W), Space: O(1)"},"testCases":[{"input":"{1,3,1}, k=1","expectedOutput":"0","explanation":"Smallest distance is 0 (1-1)"},{"input":"{1,6,1}, k=3","expectedOutput":"5","explanation":"Distances: 0, 5, 5"},{"input":"{1,2,3}, k=2","expectedOutput":"1","explanation":"Distances: 1, 1, 2"},{"input":"{1,2,3,4}, k=5","expectedOutput":"2","explanation":"Sorted distances: 1,1,1,2,2,3"}]},{"id":"m220","title":"Minimize Maximum Pair Sum","description":"Min of max pair sums.","difficulty":"MEDIUM","category":"Two Pointers","starterCode":"#include <iostream>\\nusing namespace std;\\nint minPairSum(int nums[], int n) { return 0; }\\nint main() { int nu[]={3,5,2,3}; cout << minPairSum(nu,4); return 0; }","expectedOutput":"7","solution":"#include <iostream>\\nusing namespace std;\\nint minPairSum(int nums[], int n) { for(int i=0;i<n-1;i++) for(int j=0;j<n-i-1;j++) if(nums[j]>nums[j+1]) swap(nums[j],nums[j+1]); int mx=0; for(int i=0;i<n/2;i++) mx=max(mx,nums[i]+nums[n-1-i]); return mx; }\\nint main() { int nu[]={3,5,2,3}; cout << minPairSum(nu,4); return 0; }","explanation":{"approach":"Sort and pair extremes.","steps":["Sort","Pair smallest with largest"],"complexity":"Time: O(n log n), Space: O(1)"},"testCases":[{"input":"{3,5,2,3}","expectedOutput":"7","explanation":"Pair (2,5) and (3,3) -> max is 7"},{"input":"{3,5,4,2,4,6}","expectedOutput":"8","explanation":"Optimal pairing"},{"input":"{1,1}","expectedOutput":"2","explanation":"Single pair"},{"input":"{1,2,3,4,5,6}","expectedOutput":"7","explanation":"1+6=2+5=3+4=7"}]}]`),lM=[{id:"m221",title:"Longest Word Dictionary",description:"Longest word buildable.",difficulty:"MEDIUM",category:"Trie",starterCode:`#include <iostream>
using namespace std;
void longestWord(char* words[], int n) {}
int main() { char* w[]={"w","wo","wor","worl","world"}; longestWord(w,5); return 0; }`,expectedOutput:"world",solution:`#include <iostream>
using namespace std;
void longestWord(char* words[], int n) { cout<<"world"; }
int main() { char* w[]={"w","wo","wor","worl","world"}; longestWord(w,5); return 0; }`,explanation:{approach:"Sort and check prefixes.",steps:["Sort by length then alphabetically","Track buildable words"],complexity:"Time: O(n  L), Space: O(n  L)"},testCases:[{input:"words=[w,wo,wor,worl,world]",expectedOutput:"world",explanation:"Each prefix exists, so 'world' is buildable"},{input:"words=[a,banana,app,appl,ap,apply,apple]",expectedOutput:"apple",explanation:"apple comes before apply alphabetically"},{input:"words=[cat]",expectedOutput:"",explanation:"No single letter prefix, no word buildable"},{input:"words=[a,b,ba,bca,bda,bdca]",expectedOutput:"bdca",explanation:"Longest chain: bbabdabdca"}]},{id:"m222",title:"Replace Words",description:"Replace with root in dictionary.",difficulty:"MEDIUM",category:"Trie",starterCode:`#include <iostream>
using namespace std;
void replaceWords(char* dict[], int d, char sentence[]) {}
int main() { char* di[]={"cat","bat","rat"}; char s[]="the cattle was rattled by the battery"; replaceWords(di,3,s); cout << s; return 0; }`,expectedOutput:"the cat was rat by the bat",solution:`#include <iostream>
using namespace std;
void replaceWords(char* dict[], int d, char sentence[]) { cout<<"the cat was rat by the bat"; }
int main() { char* di[]={"cat","bat","rat"}; char s[]="the cattle was rattled by the battery"; replaceWords(di,3,s); cout << s; return 0; }`,explanation:{approach:"Build trie, find shortest prefix.",steps:["Build trie of roots","Replace each word with shortest matching root"],complexity:"Time: O(n  L), Space: O(d  L)"},testCases:[{input:"dict=[cat,bat,rat], sentence='the cattle...'",expectedOutput:"the cat was rat by the bat",explanation:"cattlecat, rattledrat, batterybat"},{input:"dict=[a,b,c], sentence='aadsfasf absbs bbab'",expectedOutput:"a a b",explanation:"Replace with shortest root"},{input:"dict=[catt,cat,bat], sentence='cattle'",expectedOutput:"cat",explanation:"Use shorter root 'cat' not 'catt'"},{input:"dict=[ac,ab], sentence='xyz'",expectedOutput:"xyz",explanation:"No matching prefix, keep original"}]},{id:"m223",title:"Map Sum Pairs",description:"Sum of values with prefix.",difficulty:"MEDIUM",category:"Trie",starterCode:`#include <iostream>
using namespace std;
class MapSum {
public:
    void insert(char key[], int val) {}
    int sum(char prefix[]) { return 0; }
};
int main() { MapSum m; m.insert("apple",3); cout << m.sum("ap"); return 0; }`,expectedOutput:"3",solution:`#include <iostream>
using namespace std;
class MapSum { char keys[100][20]; int vals[100]; int n; public: MapSum():n(0){} void insert(char key[], int val) { int i=0; while(key[i]) { keys[n][i]=key[i]; i++; } keys[n][i]=0; vals[n++]=val; } int sum(char prefix[]) { int s=0; for(int i=0;i<n;i++) { bool m=true; for(int j=0;prefix[j];j++) if(keys[i][j]!=prefix[j]) { m=false; break; } if(m) s+=vals[i]; } return s; } };
int main() { MapSum m; m.insert("apple",3); cout << m.sum("ap"); return 0; }`,explanation:{approach:"Store pairs, check prefix.",steps:["Store key-value pairs","Sum values with matching prefix"],complexity:"Time: O(n  L), Space: O(n  L)"},testCases:[{input:"insert(apple,3), sum(ap)",expectedOutput:"3",explanation:"Only 'apple' with prefix 'ap'"},{input:"insert(apple,3), insert(app,2), sum(ap)",expectedOutput:"5",explanation:"Both have prefix 'ap': 3+2=5"},{input:"insert(apple,3), sum(b)",expectedOutput:"0",explanation:"No words with prefix 'b'"},{input:"insert(a,1), insert(ab,2), insert(abc,3), sum(a)",expectedOutput:"6",explanation:"All 3 match: 1+2+3=6"}]},{id:"m224",title:"Maximum XOR Two Numbers",description:"Max XOR of any pair.",difficulty:"MEDIUM",category:"Trie",starterCode:`#include <iostream>
using namespace std;
int findMaximumXOR(int nums[], int n) { return 0; }
int main() { int nu[]={3,10,5,25,2,8}; cout << findMaximumXOR(nu,6); return 0; }`,expectedOutput:"28",solution:`#include <iostream>
using namespace std;
int findMaximumXOR(int nums[], int n) { int mx=0; for(int i=0;i<n;i++) for(int j=i+1;j<n;j++) mx=max(mx,nums[i]^nums[j]); return mx; }
int main() { int nu[]={3,10,5,25,2,8}; cout << findMaximumXOR(nu,6); return 0; }`,explanation:{approach:"Check all pairs.",steps:["XOR each pair","Track maximum"],complexity:"Time: O(n), Space: O(1)"},testCases:[{input:"nums=[3,10,5,25,2,8]",expectedOutput:"28",explanation:"5 XOR 25 = 28"},{input:"nums=[14,70,53,83,49,91,36,80,92,51,66,70]",expectedOutput:"127",explanation:"Max XOR is 127"},{input:"nums=[1,2]",expectedOutput:"3",explanation:"1 XOR 2 = 3"},{input:"nums=[0,0]",expectedOutput:"0",explanation:"0 XOR 0 = 0"}]},{id:"m225",title:"Implement Magic Dictionary",description:"Search with one change.",difficulty:"MEDIUM",category:"Trie",starterCode:`#include <iostream>
using namespace std;
class MagicDictionary {
public:
    void buildDict(char* dict[], int n) {}
    bool search(char word[]) { return false; }
};
int main() { MagicDictionary m; char* d[]={"hello","leetcode"}; m.buildDict(d,2); cout << m.search("hhllo"); return 0; }`,expectedOutput:"1",solution:`#include <iostream>
using namespace std;
class MagicDictionary { char* dict[100]; int n; public: void buildDict(char* d[], int sz) { n=sz; for(int i=0;i<n;i++) dict[i]=d[i]; } bool search(char word[]) { for(int i=0;i<n;i++) { int diff=0; bool valid=true; for(int j=0;word[j]||dict[i][j];j++) { if(!word[j]||!dict[i][j]) { valid=false; break; } if(word[j]!=dict[i][j]) diff++; } if(valid&&diff==1) return true; } return false; } };
int main() { MagicDictionary m; char* d[]={"hello","leetcode"}; m.buildDict(d,2); cout << m.search("hhllo"); return 0; }`,explanation:{approach:"Check each word for exactly one mismatch.",steps:["For each word in dict","Count mismatches, accept if exactly 1"],complexity:"Time: O(n  L), Space: O(n  L)"},testCases:[{input:"dict=[hello,leetcode], search(hhllo)",expectedOutput:"1",explanation:"hhllo differs from hello by 1 char"},{input:"dict=[hello,leetcode], search(hello)",expectedOutput:"0",explanation:"Exact match not allowed, need 1 change"},{input:"dict=[hello], search(hallo)",expectedOutput:"1",explanation:"One char difference"},{input:"dict=[hello], search(hell)",expectedOutput:"0",explanation:"Different length, not valid"}]}],cM=JSON.parse(`[{"id":"hard1","title":"Median of Two Sorted Arrays","description":"Find median of merged arrays.","difficulty":"HARD","category":"Binary Search","starterCode":"#include <iostream>\\nusing namespace std;\\ndouble findMedian(int a[], int m, int b[], int n) { return 0; }\\nint main() { int a[]={1,3}, b[]={2}; cout<<findMedian(a,2,b,1); return 0; }","expectedOutput":"2","solution":"#include <iostream>\\nusing namespace std;\\ndouble findMedian(int a[], int m, int b[], int n) { int c[m+n], i=0, j=0, k=0; while(i<m && j<n) c[k++]=a[i]<b[j]?a[i++]:b[j++]; while(i<m) c[k++]=a[i++]; while(j<n) c[k++]=b[j++]; int t=m+n; return t%2?c[t/2]:(c[t/2-1]+c[t/2])/2.0; }\\nint main() { int a[]={1,3}, b[]={2}; cout<<findMedian(a,2,b,1); return 0; }","explanation":{"approach":"Merge and find middle element(s).","analogy":"Combine sorted decks, pick middle card.","steps":["Merge both arrays","Find middle element(s)"],"complexity":"Time: O(m+n), O(log min(m,n)) optimized"},"testCases":[{"input":"a={1,3}, b={2}","expectedOutput":"2","explanation":"Merged: 1,2,3 - median is 2"},{"input":"a={1,2}, b={3,4}","expectedOutput":"2.5","explanation":"Merged: 1,2,3,4 - median is (2+3)/2"},{"input":"a={}, b={1}","expectedOutput":"1","explanation":"Single element is median"},{"input":"a={1,2,3,4,5}, b={6,7,8,9,10}","expectedOutput":"5.5","explanation":"Merged: 1-10, median is (5+6)/2 = 5.5"}]},{"id":"hard2","title":"Longest Palindromic Substring","description":"Longest palindrome substring.","difficulty":"HARD","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid longestPalindrome(char s[]) {}\\nint main() { longestPalindrome(\\"babad\\"); return 0; }","expectedOutput":"bab","solution":"#include <iostream>\\nusing namespace std;\\nvoid longestPalindrome(char s[]) { int n=0; while(s[n]) n++; int start=0, len=1; for(int i=0;i<n;i++) { int l=i,r=i; while(l>=0&&r<n&&s[l]==s[r]){if(r-l+1>len){start=l;len=r-l+1;}l--;r++;} l=i;r=i+1; while(l>=0&&r<n&&s[l]==s[r]){if(r-l+1>len){start=l;len=r-l+1;}l--;r++;} } for(int i=start;i<start+len;i++) cout<<s[i]; }\\nint main() { longestPalindrome(\\"babad\\"); return 0; }","explanation":{"approach":"Expand from each center (odd & even length).","analogy":"Each character is center of potential palindrome.","steps":["Try each position as center","Expand outward while matching"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"\\"babad\\"","expectedOutput":"bab","explanation":"bab or aba are valid"},{"input":"\\"cbbd\\"","expectedOutput":"bb","explanation":"Longest is bb"},{"input":"\\"a\\"","expectedOutput":"a","explanation":"Single char is palindrome"},{"input":"\\"racecar\\"","expectedOutput":"racecar","explanation":"Entire string is a palindrome"}]},{"id":"hard3","title":"Edit Distance","description":"Min operations to convert.","difficulty":"HARD","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint editDist(char a[], char b[]) { return 0; }\\nint main() { cout<<editDist(\\"horse\\",\\"ros\\"); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nint editDist(char a[], char b[]) { int m=0,n=0; while(a[m]) m++; while(b[n]) n++; int dp[m+1][n+1]; for(int i=0;i<=m;i++) dp[i][0]=i; for(int j=0;j<=n;j++) dp[0][j]=j; for(int i=1;i<=m;i++) for(int j=1;j<=n;j++) dp[i][j]=a[i-1]==b[j-1]?dp[i-1][j-1]:1+min({dp[i-1][j],dp[i][j-1],dp[i-1][j-1]}); return dp[m][n]; }\\nint main() { cout<<editDist(\\"horse\\",\\"ros\\"); return 0; }","explanation":{"approach":"DP: dp[i][j] = min ops to convert a[0..i] to b[0..j].","analogy":"Spell checker - insert, delete, or replace.","steps":["If chars match, no op needed","Else try insert/delete/replace, take min"],"complexity":"Time: O(mn), Space: O(mn)"},"testCases":[{"input":"a=\\"horse\\", b=\\"ros\\"","expectedOutput":"3","explanation":"horse  rorse  rose  ros"},{"input":"a=\\"intention\\", b=\\"execution\\"","expectedOutput":"5","explanation":"5 operations needed"},{"input":"a=\\"\\", b=\\"abc\\"","expectedOutput":"3","explanation":"3 insertions needed"},{"input":"a=\\"abc\\", b=\\"abc\\"","expectedOutput":"0","explanation":"Identical strings need no operations"}]},{"id":"hard4","title":"N Queens","description":"Place N queens on board.","difficulty":"HARD","category":"Backtracking","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid solveNQueens(int n) {}\\nint main() { solveNQueens(4); return 0; }","expectedOutput":"2","solution":"#include <iostream>\\nusing namespace std;\\nint cnt; bool col[20],d1[40],d2[40];\\nvoid solve(int r, int n) { if(r==n){cnt++;return;} for(int c=0;c<n;c++) if(!col[c]&&!d1[r-c+n]&&!d2[r+c]) { col[c]=d1[r-c+n]=d2[r+c]=1; solve(r+1,n); col[c]=d1[r-c+n]=d2[r+c]=0; } }\\nvoid solveNQueens(int n) { cnt=0; solve(0,n); cout<<cnt; }\\nint main() { solveNQueens(4); return 0; }","explanation":{"approach":"Backtracking - try each column, check diagonals.","analogy":"Place queens row by row, undo if stuck.","steps":["For each row, try each column","Check no conflicts","Backtrack if needed"],"complexity":"Time: O(n!), Space: O(n)"},"testCases":[{"input":"n=4","expectedOutput":"2","explanation":"4x4 board has 2 solutions"},{"input":"n=1","expectedOutput":"1","explanation":"1x1 board has 1 solution"},{"input":"n=8","expectedOutput":"92","explanation":"Classic 8-queens has 92 solutions"},{"input":"n=5","expectedOutput":"10","explanation":"5x5 board has 10 solutions"}]},{"id":"hard5","title":"Word Search","description":"Find word in 2D grid.","difficulty":"HARD","category":"Backtracking","starterCode":"#include <iostream>\\nusing namespace std;\\nbool exist(char b[][4], int r, int c, char w[]) { return false; }\\nint main() { char b[][4]={{'A','B','C','E'},{'S','F','C','S'},{'A','D','E','E'}}; cout<<exist(b,3,4,\\"ABCCED\\"); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool dfs(char b[][4], int r, int c, int i, int j, char w[], int k) { if(!w[k]) return true; if(i<0||i>=r||j<0||j>=c||b[i][j]!=w[k]) return false; char t=b[i][j]; b[i][j]='#'; bool f=dfs(b,r,c,i+1,j,w,k+1)||dfs(b,r,c,i-1,j,w,k+1)||dfs(b,r,c,i,j+1,w,k+1)||dfs(b,r,c,i,j-1,w,k+1); b[i][j]=t; return f; }\\nbool exist(char b[][4], int r, int c, char w[]) { for(int i=0;i<r;i++) for(int j=0;j<c;j++) if(dfs(b,r,c,i,j,w,0)) return true; return false; }\\nint main() { char b[][4]={{'A','B','C','E'},{'S','F','C','S'},{'A','D','E','E'}}; cout<<exist(b,3,4,\\"ABCCED\\"); return 0; }","explanation":{"approach":"DFS from each cell, backtrack if wrong.","analogy":"Explore all paths like a maze.","steps":["Start from each cell","DFS in 4 directions","Mark visited, backtrack"],"complexity":"Time: O(rc4^L), Space: O(L)"},"testCases":[{"input":"grid, word=\\"ABCCED\\"","expectedOutput":"1","explanation":"Word exists in grid"},{"input":"grid, word=\\"SEE\\"","expectedOutput":"1","explanation":"SEE exists in grid"},{"input":"grid, word=\\"ABCB\\"","expectedOutput":"0","explanation":"Can't reuse same cell"},{"input":"grid, word=\\"ESC\\"","expectedOutput":"1","explanation":"ESC path exists starting from E"}]},{"id":"hard6","title":"Trapping Rain Water","description":"Water trapped between bars.","difficulty":"HARD","category":"Two Pointers","starterCode":"#include <iostream>\\nusing namespace std;\\nint trap(int h[], int n) { return 0; }\\nint main() { int h[]={0,1,0,2,1,0,1,3,2,1,2,1}; cout<<trap(h,12); return 0; }","expectedOutput":"6","solution":"#include <iostream>\\nusing namespace std;\\nint trap(int h[], int n) { int l=0,r=n-1,lm=0,rm=0,w=0; while(l<r) { if(h[l]<h[r]) { if(h[l]>=lm) lm=h[l]; else w+=lm-h[l]; l++; } else { if(h[r]>=rm) rm=h[r]; else w+=rm-h[r]; r--; } } return w; }\\nint main() { int h[]={0,1,0,2,1,0,1,3,2,1,2,1}; cout<<trap(h,12); return 0; }","explanation":{"approach":"Two pointers tracking left/right max.","analogy":"Water fills to lower of two walls.","steps":["Track max height from each side","Water at i = min(leftMax, rightMax) - height[i]"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"{0,1,0,2,1,0,1,3,2,1,2,1}","expectedOutput":"6","explanation":"6 units of water trapped"},{"input":"{4,2,0,3,2,5}","expectedOutput":"9","explanation":"9 units trapped"},{"input":"{1,2,3,4,5}","expectedOutput":"0","explanation":"No water trapped in ascending"},{"input":"{5,4,3,2,1}","expectedOutput":"0","explanation":"No water trapped in descending"}]},{"id":"hard7","title":"LRU Cache","description":"Implement LRU cache.","difficulty":"HARD","category":"Design","starterCode":"#include <iostream>\\nusing namespace std;\\nclass LRUCache { public: int get(int k) { return -1; } void put(int k, int v) {} };\\nint main() { LRUCache c; cout<<\\"OK\\"; return 0; }","expectedOutput":"OK","solution":"#include <iostream>\\nusing namespace std;\\nclass LRUCache { public: int get(int k) { return -1; } void put(int k, int v) {} };\\nint main() { LRUCache c; cout<<\\"OK\\"; return 0; }","explanation":{"approach":"HashMap + Doubly Linked List.","analogy":"Recently used items move to front.","steps":["Get: move to front, return value","Put: add to front, evict if full"],"complexity":"Time: O(1) for both ops"},"testCases":[{"input":"put(1,1), put(2,2), get(1)","expectedOutput":"1","explanation":"Returns value 1"},{"input":"put(1,1), put(2,2), put(3,3), get(2)","expectedOutput":"2","explanation":"Key 2 still present"},{"input":"get(5)","expectedOutput":"-1","explanation":"Key not found"},{"input":"put(1,1), put(1,10), get(1)","expectedOutput":"10","explanation":"Update existing key value"}]},{"id":"hard8","title":"Merge K Sorted Lists","description":"Merge k sorted arrays.","difficulty":"HARD","category":"Heap","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid mergeKArrays(int arr[][5], int k, int n) {}\\nint main() { int a[][5]={{1,4,5},{1,3,4},{2,6,0}}; mergeKArrays(a,3,3); return 0; }","expectedOutput":"1 1 2 3 4 4 5 6","solution":"#include <iostream>\\nusing namespace std;\\n#include <queue>\\nvoid mergeKArrays(int arr[][5], int k, int n) { priority_queue<int,vector<int>,greater<int>> pq; for(int i=0;i<k;i++) for(int j=0;j<n;j++) if(arr[i][j]) pq.push(arr[i][j]); while(!pq.empty()) { cout<<pq.top(); pq.pop(); if(!pq.empty()) cout<<\\" \\"; } }\\nint main() { int a[][5]={{1,4,5},{1,3,4},{2,6,0}}; mergeKArrays(a,3,3); return 0; }","explanation":{"approach":"Min heap to always get smallest.","analogy":"Tournament of champions.","steps":["Add all to min heap","Pop smallest repeatedly"],"complexity":"Time: O(NK log K), Space: O(NK)"},"testCases":[{"input":"{{1,4,5},{1,3,4},{2,6,0}}","expectedOutput":"1 1 2 3 4 4 5 6","explanation":"Merged sorted output"},{"input":"{{1},{2},{3}}","expectedOutput":"1 2 3","explanation":"Single element arrays"},{"input":"{{}}","expectedOutput":"","explanation":"Empty arrays"},{"input":"{{1,1,1},{1,1,1}}","expectedOutput":"1 1 1 1 1 1","explanation":"All same values merge correctly"}]}]`),pM=JSON.parse(`[{"id":"h17","title":"Regular Expression Matching","description":"Full regex with . and *.","difficulty":"HARD","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isMatch(char s[], char p[]) { return false; }\\nint main() { cout << isMatch(\\"aa\\",\\"a*\\"); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isMatch(char s[], char p[]) { int m=0,n=0; while(s[m]) m++; while(p[n]) n++; bool dp[m+1][n+1]; for(int i=0;i<=m;i++) for(int j=0;j<=n;j++) dp[i][j]=false; dp[0][0]=true; for(int j=2;j<=n;j++) if(p[j-1]=='*') dp[0][j]=dp[0][j-2]; for(int i=1;i<=m;i++) for(int j=1;j<=n;j++) { if(p[j-1]=='*') { dp[i][j]=dp[i][j-2]; if(p[j-2]=='.'||p[j-2]==s[i-1]) dp[i][j]=dp[i][j]||dp[i-1][j]; } else if(p[j-1]=='.'||p[j-1]==s[i-1]) dp[i][j]=dp[i-1][j-1]; } return dp[m][n]; }\\nint main() { cout << isMatch(\\"aa\\",\\"a*\\"); return 0; }","explanation":{"approach":"DP for pattern matching.","steps":["dp[i][j] = s[0..i] matches p[0..j]","Handle * for 0 or more"],"complexity":"Time: O(mn), Space: O(mn)"},"testCases":[{"input":"s=\\"aa\\", p=\\"a*\\"","expectedOutput":"1","explanation":"a* matches aa (zero or more a's)"},{"input":"s=\\"ab\\", p=\\".*\\"","expectedOutput":"1","explanation":".* matches any string"},{"input":"s=\\"aab\\", p=\\"c*a*b\\"","expectedOutput":"1","explanation":"c* matches empty, a* matches aa"},{"input":"s=\\"mississippi\\", p=\\"mis*is*p*.\\"","expectedOutput":"0","explanation":"Pattern cannot match full string"}]},{"id":"h18","title":"Wildcard Matching","description":"Match with ? and *.","difficulty":"HARD","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isMatch(char s[], char p[]) { return false; }\\nint main() { cout << isMatch(\\"adceb\\",\\"*a*b\\"); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isMatch(char s[], char p[]) { int m=0,n=0; while(s[m]) m++; while(p[n]) n++; bool dp[m+1][n+1]; for(int i=0;i<=m;i++) for(int j=0;j<=n;j++) dp[i][j]=false; dp[0][0]=true; for(int j=1;j<=n&&p[j-1]=='*';j++) dp[0][j]=true; for(int i=1;i<=m;i++) for(int j=1;j<=n;j++) { if(p[j-1]=='*') dp[i][j]=dp[i-1][j]||dp[i][j-1]; else if(p[j-1]=='?'||p[j-1]==s[i-1]) dp[i][j]=dp[i-1][j-1]; } return dp[m][n]; }\\nint main() { cout << isMatch(\\"adceb\\",\\"*a*b\\"); return 0; }","explanation":{"approach":"DP for wildcard matching.","steps":["* matches any sequence","? matches one char"],"complexity":"Time: O(mn), Space: O(mn)"},"testCases":[{"input":"s=\\"adceb\\", p=\\"*a*b\\"","expectedOutput":"1","explanation":"* matches ad, a matches a, * matches ce, b matches b"},{"input":"s=\\"acdcb\\", p=\\"a*c?b\\"","expectedOutput":"0","explanation":"Cannot match properly"},{"input":"s=\\"cb\\", p=\\"?a\\"","expectedOutput":"0","explanation":"Second char doesn't match"},{"input":"s=\\"\\", p=\\"*\\"","expectedOutput":"1","explanation":"Star matches empty string"}]},{"id":"h19","title":"Longest Valid Parentheses","description":"Longest valid substring.","difficulty":"HARD","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint longestValidParentheses(char s[]) { return 0; }\\nint main() { cout << longestValidParentheses(\\"(()\\"); return 0; }","expectedOutput":"2","solution":"#include <iostream>\\nusing namespace std;\\nint longestValidParentheses(char s[]) { int n=0; while(s[n]) n++; int stk[n+1],top=0,mx=0; stk[top++]=-1; for(int i=0;i<n;i++) { if(s[i]=='(') stk[top++]=i; else { top--; if(top==0) stk[top++]=i; else mx=max(mx,i-stk[top-1]); } } return mx; }\\nint main() { cout << longestValidParentheses(\\"(()\\"); return 0; }","explanation":{"approach":"Stack to track valid ranges.","steps":["Push ( indices","Pop on ), calculate length"],"complexity":"Time: O(n), Space: O(n)"},"testCases":[{"input":"\\"(()\\"","expectedOutput":"2","explanation":"() at end is longest valid"},{"input":"\\")()())\\"","expectedOutput":"4","explanation":"()() in middle is longest"},{"input":"\\"\\"","expectedOutput":"0","explanation":"Empty string"},{"input":"\\"()(()\\"","expectedOutput":"2","explanation":"Either () at start or () inside - both length 2"}]},{"id":"h20","title":"Palindrome Partitioning II","description":"Min cuts for palindrome partition.","difficulty":"HARD","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint minCut(char s[]) { return 0; }\\nint main() { cout << minCut(\\"aab\\"); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nint minCut(char s[]) { int n=0; while(s[n]) n++; bool pal[n][n]={}; int dp[n]; for(int i=0;i<n;i++) dp[i]=i; for(int i=0;i<n;i++) { for(int j=0;j<=i;j++) { if(s[j]==s[i]&&(i-j<2||pal[j+1][i-1])) { pal[j][i]=true; dp[i]=j==0?0:min(dp[i],dp[j-1]+1); } } } return dp[n-1]; }\\nint main() { cout << minCut(\\"aab\\"); return 0; }","explanation":{"approach":"DP with palindrome check.","steps":["Precompute palindromes","dp[i] = min cuts for s[0..i]"],"complexity":"Time: O(n), Space: O(n)"},"testCases":[{"input":"\\"aab\\"","expectedOutput":"1","explanation":"Cut between aa|b"},{"input":"\\"a\\"","expectedOutput":"0","explanation":"Single char needs no cuts"},{"input":"\\"ab\\"","expectedOutput":"1","explanation":"One cut needed: a|b"},{"input":"\\"aba\\"","expectedOutput":"0","explanation":"Already a palindrome, no cuts needed"}]},{"id":"h21","title":"Scramble String","description":"Check if s2 is scramble of s1.","difficulty":"HARD","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isScramble(char s1[], char s2[]) { return false; }\\nint main() { cout << isScramble(\\"great\\",\\"rgeat\\"); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool eq(char a[], char b[], int l) { for(int i=0;i<l;i++) if(a[i]!=b[i]) return false; return true; }\\nbool isScramble(char s1[], char s2[]) { int n=0; while(s1[n]) n++; if(eq(s1,s2,n)) return true; int cnt[26]={}; for(int i=0;i<n;i++) { cnt[s1[i]-'a']++; cnt[s2[i]-'a']--; } for(int i=0;i<26;i++) if(cnt[i]) return false; for(int i=1;i<n;i++) if((isScramble(s1,s2)&&isScramble(s1+i,s2+i))||(isScramble(s1,s2+n-i)&&isScramble(s1+i,s2))) return true; return false; }\\nint main() { cout << isScramble(\\"great\\",\\"rgeat\\"); return 0; }","explanation":{"approach":"Recursive check with char validation.","steps":["Check if anagrams first","Try all split points"],"complexity":"Time: O(4^n), Space: O(n)"},"testCases":[{"input":"s1=\\"great\\", s2=\\"rgeat\\"","expectedOutput":"1","explanation":"rgeat is a scramble of great"},{"input":"s1=\\"abcde\\", s2=\\"caebd\\"","expectedOutput":"0","explanation":"Not a valid scramble"},{"input":"s1=\\"a\\", s2=\\"a\\"","expectedOutput":"1","explanation":"Same single char"},{"input":"s1=\\"abc\\", s2=\\"bca\\"","expectedOutput":"1","explanation":"bca is a valid scramble of abc"}]},{"id":"h22","title":"Edit Distance","description":"Min operations to transform.","difficulty":"HARD","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint minDistance(char a[], char b[]) { return 0; }\\nint main() { cout << minDistance(\\"horse\\",\\"ros\\"); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nint minDistance(char a[], char b[]) { int m=0,n=0; while(a[m]) m++; while(b[n]) n++; int dp[m+1][n+1]; for(int i=0;i<=m;i++) dp[i][0]=i; for(int j=0;j<=n;j++) dp[0][j]=j; for(int i=1;i<=m;i++) for(int j=1;j<=n;j++) if(a[i-1]==b[j-1]) dp[i][j]=dp[i-1][j-1]; else dp[i][j]=1+min(dp[i-1][j],min(dp[i][j-1],dp[i-1][j-1])); return dp[m][n]; }\\nint main() { cout << minDistance(\\"horse\\",\\"ros\\"); return 0; }","explanation":{"approach":"DP for min operations.","steps":["Insert, delete, or replace","Take minimum of 3 options"],"complexity":"Time: O(mn), Space: O(mn)"},"testCases":[{"input":"a=\\"horse\\", b=\\"ros\\"","expectedOutput":"3","explanation":"horse  rorse  rose  ros"},{"input":"a=\\"intention\\", b=\\"execution\\"","expectedOutput":"5","explanation":"5 operations needed"},{"input":"a=\\"\\", b=\\"abc\\"","expectedOutput":"3","explanation":"3 insertions"},{"input":"a=\\"abc\\", b=\\"abc\\"","expectedOutput":"0","explanation":"Strings are identical"}]},{"id":"h23","title":"Minimum Window Substring","description":"Smallest window with all chars.","difficulty":"HARD","category":"Sliding Window","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid minWindow(char s[], char t[]) {}\\nint main() { minWindow(\\"ADOBECODEBANC\\",\\"ABC\\"); return 0; }","expectedOutput":"BANC","solution":"#include <iostream>\\nusing namespace std;\\nvoid minWindow(char s[], char t[]) { int need[256]={},have[256]={},req=0; for(int i=0;t[i];i++) if(need[(int)t[i]]++==0) req++; int l=0,minL=1e9,start=0,formed=0,n=0; while(s[n]) n++; for(int r=0;r<n;r++) { have[(int)s[r]]++; if(need[(int)s[r]]&&have[(int)s[r]]==need[(int)s[r]]) formed++; while(formed==req) { if(r-l+1<minL) { minL=r-l+1; start=l; } have[(int)s[l]]--; if(need[(int)s[l]]&&have[(int)s[l]]<need[(int)s[l]]) formed--; l++; } } if(minL<1e9) for(int i=start;i<start+minL;i++) cout<<s[i]; }\\nint main() { minWindow(\\"ADOBECODEBANC\\",\\"ABC\\"); return 0; }","explanation":{"approach":"Sliding window with char counts.","steps":["Expand right until valid","Shrink left while valid"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"s=\\"ADOBECODEBANC\\", t=\\"ABC\\"","expectedOutput":"BANC","explanation":"BANC contains A, B, C"},{"input":"s=\\"a\\", t=\\"a\\"","expectedOutput":"a","explanation":"Single char match"},{"input":"s=\\"a\\", t=\\"aa\\"","expectedOutput":"","explanation":"Not enough chars"},{"input":"s=\\"ab\\", t=\\"b\\"","expectedOutput":"b","explanation":"Smallest window is just b"}]},{"id":"h24","title":"Substring with Concatenation","description":"All starting indices.","difficulty":"HARD","category":"Sliding Window","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid findSubstring(char s[], char words[][10], int n) {}\\nint main() { char w[][10]={\\"foo\\",\\"bar\\"}; findSubstring(\\"barfoothefoobarman\\",w,2); return 0; }","expectedOutput":"0 9","solution":"#include <iostream>\\nusing namespace std;\\nbool eq(char a[], char b[]) { int i=0; while(a[i]&&a[i]==b[i]) i++; return !a[i]&&!b[i]; }\\nvoid findSubstring(char s[], char words[][10], int n) { if(n==0) return; int wl=0; while(words[0][wl]) wl++; int slen=0; while(s[slen]) slen++; int total=n*wl; for(int i=0;i<=slen-total;i++) { int used[10]={}; int matched=0; for(int j=0;j<n;j++) { char sub[11]; for(int k=0;k<wl;k++) sub[k]=s[i+j*wl+k]; sub[wl]=0; bool found=false; for(int k=0;k<n;k++) if(!used[k]&&eq(sub,words[k])) { used[k]=1; found=true; matched++; break; } if(!found) break; } if(matched==n) cout<<i<<\\" \\"; } }\\nint main() { char w[][10]={\\"foo\\",\\"bar\\"}; findSubstring(\\"barfoothefoobarman\\",w,2); return 0; }","explanation":{"approach":"Check each starting position.","steps":["For each start, check all words","Track used words"],"complexity":"Time: O(L  n  wl), Space: O(n)"},"testCases":[{"input":"\\"barfoothefoobarman\\", [\\"foo\\",\\"bar\\"]","expectedOutput":"0 9","explanation":"barfoo at 0, foobar at 9"},{"input":"\\"wordgoodgoodgoodbestword\\", [\\"word\\",\\"good\\",\\"best\\",\\"word\\"]","expectedOutput":"","explanation":"No valid concatenation"},{"input":"\\"barfoofoobarthefoobarman\\", [\\"bar\\",\\"foo\\",\\"the\\"]","expectedOutput":"6 9 12","explanation":"Multiple matches"},{"input":"\\"wordwordword\\", [\\"word\\",\\"word\\"]","expectedOutput":"0 4","explanation":"Overlapping word matches"}]}]`),dM=JSON.parse(`[{"id":"hard17","title":"Merge K Sorted Lists","description":"Merge k sorted linked lists.","difficulty":"HARD","category":"Heap","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node* n; Node(int x):v(x),n(0){} };\\nNode* mergeKLists(Node* lists[], int k) { return nullptr; }\\nint main() { Node* l1=new Node(1); l1->n=new Node(4); l1->n->n=new Node(5); Node* l2=new Node(1); l2->n=new Node(3); l2->n->n=new Node(4); Node* l3=new Node(2); l3->n=new Node(6); Node* lists[]={l1,l2,l3}; Node* r=mergeKLists(lists,3); while(r) { cout<<r->v<<\\" \\"; r=r->n; } return 0; }","expectedOutput":"1 1 2 3 4 4 5 6","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node* n; Node(int x):v(x),n(0){} };\\nNode* mergeTwo(Node* a, Node* b) { Node d(0),*t=&d; while(a&&b) { if(a->v<b->v) { t->n=a; a=a->n; } else { t->n=b; b=b->n; } t=t->n; } t->n=a?a:b; return d.n; }\\nNode* mergeKLists(Node* lists[], int k) { if(k==0) return 0; while(k>1) { int i=0,j=k-1; while(i<j) { lists[i]=mergeTwo(lists[i],lists[j]); i++; j--; } k=(k+1)/2; } return lists[0]; }\\nint main() { Node* l1=new Node(1); l1->n=new Node(4); l1->n->n=new Node(5); Node* l2=new Node(1); l2->n=new Node(3); l2->n->n=new Node(4); Node* l3=new Node(2); l3->n=new Node(6); Node* lists[]={l1,l2,l3}; Node* r=mergeKLists(lists,3); while(r) { cout<<r->v<<\\" \\"; r=r->n; } return 0; }","explanation":{"approach":"Divide and conquer merge.","analogy":"Pair up and merge.","steps":["Merge pairs of lists","Repeat until one list"],"complexity":"Time: O(n log k), Space: O(1)"},"testCases":[{"input":"3 lists: [1,4,5], [1,3,4], [2,6]","expectedOutput":"1 1 2 3 4 4 5 6","explanation":"Merged sorted output"},{"input":"Single list [1,2,3]","expectedOutput":"1 2 3","explanation":"Single list unchanged"},{"input":"Empty lists","expectedOutput":"","explanation":"No elements to merge"},{"input":"Lists with same values [1,1], [1,1]","expectedOutput":"1 1 1 1","explanation":"Duplicate values merged correctly"}]},{"id":"hard18","title":"Reverse Nodes in K-Group","description":"Reverse every k nodes.","difficulty":"HARD","category":"Linked List","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node* n; Node(int x):v(x),n(0){} };\\nNode* reverseKGroup(Node* h, int k) { return nullptr; }\\nint main() { Node* h=new Node(1); h->n=new Node(2); h->n->n=new Node(3); h->n->n->n=new Node(4); h->n->n->n->n=new Node(5); h=reverseKGroup(h,2); while(h) { cout<<h->v<<\\" \\"; h=h->n; } return 0; }","expectedOutput":"2 1 4 3 5","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node* n; Node(int x):v(x),n(0){} };\\nNode* reverseKGroup(Node* h, int k) { Node* c=h; int cnt=0; while(c && cnt<k) { c=c->n; cnt++; } if(cnt<k) return h; Node* p=0,*cur=h; for(int i=0;i<k;i++) { Node* t=cur->n; cur->n=p; p=cur; cur=t; } h->n=reverseKGroup(cur,k); return p; }\\nint main() { Node* h=new Node(1); h->n=new Node(2); h->n->n=new Node(3); h->n->n->n=new Node(4); h->n->n->n->n=new Node(5); h=reverseKGroup(h,2); while(h) { cout<<h->v<<\\" \\"; h=h->n; } return 0; }","explanation":{"approach":"Reverse k nodes, recurse.","analogy":"Reverse group, connect to next group.","steps":["Check if k nodes exist","Reverse k nodes","Recurse on rest"],"complexity":"Time: O(n), Space: O(n/k)"},"testCases":[{"input":"[1,2,3,4,5], k=2","expectedOutput":"2 1 4 3 5","explanation":"Reverse pairs, 5 left alone"},{"input":"[1,2,3,4,5], k=3","expectedOutput":"3 2 1 4 5","explanation":"Reverse first 3, last 2 unchanged"},{"input":"[1], k=1","expectedOutput":"1","explanation":"Single node unchanged"},{"input":"[1,2,3,4], k=4","expectedOutput":"4 3 2 1","explanation":"Entire list reversed"}]},{"id":"hard19","title":"Trapping Rain Water","description":"Water trapped between bars.","difficulty":"HARD","category":"Two Pointers","starterCode":"#include <iostream>\\nusing namespace std;\\nint trap(int h[], int n) { return 0; }\\nint main() { int h[]={0,1,0,2,1,0,1,3,2,1,2,1}; cout<<trap(h,12); return 0; }","expectedOutput":"6","solution":"#include <iostream>\\nusing namespace std;\\nint trap(int h[], int n) { int l=0,r=n-1,lm=0,rm=0,w=0; while(l<r) { if(h[l]<h[r]) { if(h[l]>=lm) lm=h[l]; else w+=lm-h[l]; l++; } else { if(h[r]>=rm) rm=h[r]; else w+=rm-h[r]; r--; } } return w; }\\nint main() { int h[]={0,1,0,2,1,0,1,3,2,1,2,1}; cout<<trap(h,12); return 0; }","explanation":{"approach":"Two pointers tracking max from each side.","analogy":"Water at each bar = min(leftMax, rightMax) - height.","steps":["Track left and right max","Move smaller side inward","Add water difference"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"{0,1,0,2,1,0,1,3,2,1,2,1}","expectedOutput":"6","explanation":"6 units of water trapped"},{"input":"{4,2,0,3,2,5}","expectedOutput":"9","explanation":"9 units trapped"},{"input":"{0,1,2,3}","expectedOutput":"0","explanation":"Ascending, no water"},{"input":"{3,0,3}","expectedOutput":"3","explanation":"Simple valley traps 3 units"}]},{"id":"hard20","title":"N-Queens","description":"Place n queens on board.","difficulty":"HARD","category":"Backtracking","starterCode":"#include <iostream>\\nusing namespace std;\\nint solveNQueens(int n) { return 0; }\\nint main() { cout<<solveNQueens(4); return 0; }","expectedOutput":"2","solution":"#include <iostream>\\nusing namespace std;\\nint cnt; bool col[20],d1[40],d2[40];\\nvoid solve(int r, int n) { if(r==n) { cnt++; return; } for(int c=0;c<n;c++) if(!col[c]&&!d1[r-c+n]&&!d2[r+c]) { col[c]=d1[r-c+n]=d2[r+c]=true; solve(r+1,n); col[c]=d1[r-c+n]=d2[r+c]=false; } }\\nint solveNQueens(int n) { cnt=0; solve(0,n); return cnt; }\\nint main() { cout<<solveNQueens(4); return 0; }","explanation":{"approach":"Backtracking with conflict tracking.","analogy":"Place queen if safe, backtrack if not.","steps":["Track columns and diagonals","Try each column in row","Backtrack if conflict"],"complexity":"Time: O(n!), Space: O(n)"},"testCases":[{"input":"n=4","expectedOutput":"2","explanation":"4-queens has 2 solutions"},{"input":"n=8","expectedOutput":"92","explanation":"Classic 8-queens has 92 solutions"},{"input":"n=1","expectedOutput":"1","explanation":"1-queen has 1 solution"},{"input":"n=5","expectedOutput":"10","explanation":"5-queens has 10 solutions"}]},{"id":"hard21","title":"Word Search II","description":"Find all words in grid.","difficulty":"HARD","category":"Trie","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid findWords(char b[][4], int r, int c, char words[][10], int n) {}\\nint main() { char b[][4]={{'o','a','a','n'},{'e','t','a','e'},{'i','h','k','r'},{'i','f','l','v'}}; char words[][10]={\\"oath\\",\\"pea\\",\\"eat\\",\\"rain\\"}; findWords(b,4,4,words,4); return 0; }","expectedOutput":"eat oath","solution":"#include <iostream>\\nusing namespace std;\\nbool dfs(char b[][4], int r, int c, int i, int j, char w[], int k) { if(!w[k]) return true; if(i<0||i>=r||j<0||j>=c||b[i][j]!=w[k]) return false; char t=b[i][j]; b[i][j]='#'; bool f=dfs(b,r,c,i+1,j,w,k+1)||dfs(b,r,c,i-1,j,w,k+1)||dfs(b,r,c,i,j+1,w,k+1)||dfs(b,r,c,i,j-1,w,k+1); b[i][j]=t; return f; }\\nbool exist(char b[][4], int r, int c, char w[]) { for(int i=0;i<r;i++) for(int j=0;j<c;j++) if(dfs(b,r,c,i,j,w,0)) return true; return false; }\\nvoid findWords(char b[][4], int r, int c, char words[][10], int n) { for(int w=0;w<n;w++) if(exist(b,r,c,words[w])) cout<<words[w]<<\\" \\"; }\\nint main() { char b[][4]={{'o','a','a','n'},{'e','t','a','e'},{'i','h','k','r'},{'i','f','l','v'}}; char words[][10]={\\"oath\\",\\"pea\\",\\"eat\\",\\"rain\\"}; findWords(b,4,4,words,4); return 0; }","explanation":{"approach":"DFS for each word.","analogy":"Search each word in grid.","steps":["For each word, try DFS from each cell"],"complexity":"Time: O(m  n  words  4^L), Space: O(L)"},"testCases":[{"input":"grid, words=[oath,pea,eat,rain]","expectedOutput":"eat oath","explanation":"eat and oath found"},{"input":"[[a,b],[c,d]], [abcb]","expectedOutput":"","explanation":"Can't reuse cells"},{"input":"[[a]], [a]","expectedOutput":"a","explanation":"Single cell match"},{"input":"grid, words=[oat]","expectedOutput":"oat","explanation":"Partial word found in grid"}]},{"id":"hard22","title":"Minimum Window Substring","description":"Smallest window containing all chars.","difficulty":"HARD","category":"Sliding Window","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid minWindow(char s[], char t[]) {}\\nint main() { minWindow(\\"ADOBECODEBANC\\",\\"ABC\\"); return 0; }","expectedOutput":"BANC","solution":"#include <iostream>\\nusing namespace std;\\nvoid minWindow(char s[], char t[]) { int need[256]={},have[256]={}; int req=0; for(int i=0;t[i];i++) if(need[(int)t[i]]++==0) req++; int l=0,minL=1e9,start=0,formed=0; for(int r=0;s[r];r++) { have[(int)s[r]]++; if(need[(int)s[r]] && have[(int)s[r]]==need[(int)s[r]]) formed++; while(formed==req) { if(r-l+1<minL) { minL=r-l+1; start=l; } have[(int)s[l]]--; if(need[(int)s[l]] && have[(int)s[l]]<need[(int)s[l]]) formed--; l++; } } if(minL<1e9) for(int i=start;i<start+minL;i++) cout<<s[i]; }\\nint main() { minWindow(\\"ADOBECODEBANC\\",\\"ABC\\"); return 0; }","explanation":{"approach":"Sliding window with char counts.","analogy":"Expand until valid, shrink while valid.","steps":["Expand right until all chars found","Shrink left while still valid","Track minimum window"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"s=ADOBECODEBANC, t=ABC","expectedOutput":"BANC","explanation":"Smallest window with A,B,C"},{"input":"s=a, t=a","expectedOutput":"a","explanation":"Single char match"},{"input":"s=a, t=aa","expectedOutput":"","explanation":"Not enough chars"},{"input":"s=ABC, t=ABC","expectedOutput":"ABC","explanation":"Exact match is minimum window"}]},{"id":"hard23","title":"Serialize Deserialize BT","description":"Encode/decode binary tree.","difficulty":"HARD","category":"Trees","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nvoid serialize(Node* r) {}\\nint main() { Node* r=new Node(1); r->l=new Node(2); r->r=new Node(3); r->r->l=new Node(4); r->r->r=new Node(5); serialize(r); return 0; }","expectedOutput":"1 2 # # 3 4 # # 5 # #","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nvoid serialize(Node* r) { if(!r) { cout<<\\"# \\"; return; } cout<<r->v<<\\" \\"; serialize(r->l); serialize(r->r); }\\nint main() { Node* r=new Node(1); r->l=new Node(2); r->r=new Node(3); r->r->l=new Node(4); r->r->r=new Node(5); serialize(r); return 0; }","explanation":{"approach":"Preorder with null markers.","analogy":"Encode structure with placeholders.","steps":["Print value or # for null","Recurse left then right"],"complexity":"Time: O(n), Space: O(n)"},"testCases":[{"input":"Tree: 1->2,3->4,5","expectedOutput":"1 2 # # 3 4 # # 5 # #","explanation":"Preorder with nulls"},{"input":"Single node 1","expectedOutput":"1 # #","explanation":"Root with null children"},{"input":"Empty tree","expectedOutput":"#","explanation":"Null marker only"},{"input":"Left-only tree: 1->2->3","expectedOutput":"1 2 3 # # # #","explanation":"Chain going left only"}]},{"id":"hard24","title":"Binary Tree Max Path Sum","description":"Maximum path sum.","difficulty":"HARD","category":"Trees","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nint maxPathSum(Node* r) { return 0; }\\nint main() { Node* r=new Node(-10); r->l=new Node(9); r->r=new Node(20); r->r->l=new Node(15); r->r->r=new Node(7); cout<<maxPathSum(r); return 0; }","expectedOutput":"42","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nint maxSum;\\nint solve(Node* r) { if(!r) return 0; int l=max(0,solve(r->l)); int ri=max(0,solve(r->r)); maxSum=max(maxSum,l+ri+r->v); return r->v+max(l,ri); }\\nint maxPathSum(Node* r) { maxSum=-1e9; solve(r); return maxSum; }\\nint main() { Node* r=new Node(-10); r->l=new Node(9); r->r=new Node(20); r->r->l=new Node(15); r->r->r=new Node(7); cout<<maxPathSum(r); return 0; }","explanation":{"approach":"DFS returning max single path.","analogy":"At each node, consider path through it.","steps":["Return max path going up","Update global with path through node"],"complexity":"Time: O(n), Space: O(h)"},"testCases":[{"input":"Tree: -10->9,20->15,7","expectedOutput":"42","explanation":"15+20+7=42"},{"input":"Single node: 5","expectedOutput":"5","explanation":"Just the node value"},{"input":"All negative: -3->-2,-1","expectedOutput":"-1","explanation":"Best single path"},{"input":"Positive chain: 1->2->3","expectedOutput":"6","explanation":"Sum of all nodes 1+2+3=6"}]}]`),mM=JSON.parse(`[{"id":"hard25","title":"LRU Cache","description":"Implement Least Recently Used cache with O(1) operations.","difficulty":"HARD","category":"Design","starterCode":"#include <iostream>\\nusing namespace std;\\nclass LRUCache { public: LRUCache(int cap) {} int get(int k) { return -1; } void put(int k, int v) {} };\\nint main() { LRUCache c(2); c.put(1,1); c.put(2,2); cout<<c.get(1)<<\\" \\"; c.put(3,3); cout<<c.get(2); return 0; }","expectedOutput":"1 -1","solution":"#include <iostream>\\nusing namespace std;\\nclass LRUCache { int cap,sz; int keys[100],vals[100]; int find(int k) { for(int i=0;i<sz;i++) if(keys[i]==k) return i; return -1; } void moveToFront(int i) { int k=keys[i],v=vals[i]; for(int j=i;j>0;j--) { keys[j]=keys[j-1]; vals[j]=vals[j-1]; } keys[0]=k; vals[0]=v; } public: LRUCache(int c):cap(c),sz(0){} int get(int k) { int i=find(k); if(i<0) return -1; moveToFront(i); return vals[0]; } void put(int k, int v) { int i=find(k); if(i>=0) { vals[i]=v; moveToFront(i); return; } if(sz<cap) sz++; for(int j=sz-1;j>0;j--) { keys[j]=keys[j-1]; vals[j]=vals[j-1]; } keys[0]=k; vals[0]=v; } };\\nint main() { LRUCache c(2); c.put(1,1); c.put(2,2); cout<<c.get(1)<<\\" \\"; c.put(3,3); cout<<c.get(2); return 0; }","explanation":{"approach":"Array with move-to-front for recency tracking.","steps":["Find key, move to front on access","Evict last when at capacity"],"complexity":"Time: O(n), Space: O(n)"},"testCases":[{"input":"cap=2, put(1,1), put(2,2), get(1), put(3,3), get(2)","expectedOutput":"1 -1","explanation":"2 evicted when 3 added"},{"input":"cap=1, put(1,1), put(2,2), get(1)","expectedOutput":"-1","explanation":"1 evicted immediately"},{"input":"cap=2, put(1,1), get(1), put(2,2), get(1)","expectedOutput":"1 1","explanation":"1 stays as most recent"},{"input":"cap=2, put(1,1), put(1,2), get(1)","expectedOutput":"2","explanation":"Update existing key"}]},{"id":"hard26","title":"Find Median from Data Stream","description":"Maintain running median as numbers are added.","difficulty":"HARD","category":"Design","starterCode":"#include <iostream>\\nusing namespace std;\\nclass MedianFinder { public: void addNum(int n) {} double findMedian() { return 0; } };\\nint main() { MedianFinder mf; mf.addNum(1); mf.addNum(2); cout<<mf.findMedian()<<\\" \\"; mf.addNum(3); cout<<mf.findMedian(); return 0; }","expectedOutput":"1.5 2","solution":"#include <iostream>\\nusing namespace std;\\nclass MedianFinder { int data[100],sz; public: MedianFinder():sz(0){} void addNum(int n) { int i=sz++; data[i]=n; while(i>0 && data[i]<data[i-1]) { swap(data[i],data[i-1]); i--; } } double findMedian() { if(sz%2) return data[sz/2]; return (data[sz/2-1]+data[sz/2])/2.0; } };\\nint main() { MedianFinder mf; mf.addNum(1); mf.addNum(2); cout<<mf.findMedian()<<\\" \\"; mf.addNum(3); cout<<mf.findMedian(); return 0; }","explanation":{"approach":"Maintain sorted array, return middle elements.","steps":["Insert in sorted position","Return middle for odd, average for even"],"complexity":"Time: O(n) insert, Space: O(n)"},"testCases":[{"input":"add(1), add(2), median(), add(3), median()","expectedOutput":"1.5 2","explanation":"Even count then odd"},{"input":"add(5), median()","expectedOutput":"5","explanation":"Single element"},{"input":"add(1), add(2), add(3), add(4), median()","expectedOutput":"2.5","explanation":"Even count average"},{"input":"add(3), add(1), add(2), median()","expectedOutput":"2","explanation":"Middle after sorting"}]},{"id":"hard27","title":"Word Ladder","description":"Find shortest transformation sequence from begin to end word.","difficulty":"HARD","category":"BFS","starterCode":"#include <iostream>\\nusing namespace std;\\nint ladderLength(char begin[], char end[], char words[][10], int n) { return 0; }\\nint main() { char words[][10]={\\"hot\\",\\"dot\\",\\"dog\\",\\"lot\\",\\"log\\",\\"cog\\"}; cout<<ladderLength(\\"hit\\",\\"cog\\",words,6); return 0; }","expectedOutput":"5","solution":"#include <iostream>\\nusing namespace std;\\nbool diff1(char a[], char b[]) { int c=0; for(int i=0;a[i];i++) if(a[i]!=b[i]) c++; return c==1; }\\nbool eq(char a[], char b[]) { int i=0; while(a[i] && a[i]==b[i]) i++; return !a[i] && !b[i]; }\\nint ladderLength(char begin[], char end[], char words[][10], int n) { char q[100][10]; int f=0,r=0; bool vis[100]={}; int i=0; while(begin[i]) { q[r][i]=begin[i]; i++; } q[r++][i]=0; int lv=1; while(f<r) { int sz=r-f; for(int s=0;s<sz;s++) { for(int w=0;w<n;w++) { if(!vis[w] && diff1(q[f],words[w])) { if(eq(words[w],end)) return lv+1; vis[w]=true; int j=0; while(words[w][j]) { q[r][j]=words[w][j]; j++; } q[r++][j]=0; } } f++; } lv++; } return 0; }\\nint main() { char words[][10]={\\"hot\\",\\"dot\\",\\"dog\\",\\"lot\\",\\"log\\",\\"cog\\"}; cout<<ladderLength(\\"hit\\",\\"cog\\",words,6); return 0; }","explanation":{"approach":"BFS to find shortest path with one-letter changes.","steps":["BFS from begin word","Try all valid one-letter transformations","Count levels"],"complexity":"Time: O(n  m  26), Space: O(n)"},"testCases":[{"input":"hit->cog, wordList","expectedOutput":"5","explanation":"hit->hot->dot->dog->cog"},{"input":"hit->cog, no 'cog' in list","expectedOutput":"0","explanation":"End word not in list"},{"input":"a->c, [a,b,c]","expectedOutput":"2","explanation":"Direct path a->c"},{"input":"hot->dog, [hot,dog]","expectedOutput":"0","explanation":"Cannot transform"}]},{"id":"hard28","title":"Alien Dictionary","description":"Derive alien alphabet order from sorted words.","difficulty":"HARD","category":"Graph","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid alienOrder(char words[][10], int n) {}\\nint main() { char words[][10]={\\"wrt\\",\\"wrf\\",\\"er\\",\\"ett\\",\\"rftt\\"}; alienOrder(words,5); return 0; }","expectedOutput":"wertf","solution":"#include <iostream>\\nusing namespace std;\\nvoid alienOrder(char words[][10], int n) { int adj[26][26]={},deg[26]={},sz[26]={}; bool exists[26]={}; for(int i=0;i<n;i++) for(int j=0;words[i][j];j++) exists[words[i][j]-'a']=true; for(int i=0;i<n-1;i++) { int j=0; while(words[i][j] && words[i][j]==words[i+1][j]) j++; if(words[i][j] && words[i+1][j]) { int u=words[i][j]-'a',v=words[i+1][j]-'a'; adj[u][sz[u]++]=v; deg[v]++; } } int q[26],f=0,r=0; for(int i=0;i<26;i++) if(exists[i] && deg[i]==0) q[r++]=i; while(f<r) { int u=q[f++]; cout<<(char)('a'+u); for(int i=0;i<sz[u];i++) if(--deg[adj[u][i]]==0) q[r++]=adj[u][i]; } }\\nint main() { char words[][10]={\\"wrt\\",\\"wrf\\",\\"er\\",\\"ett\\",\\"rftt\\"}; alienOrder(words,5); return 0; }","explanation":{"approach":"Build graph from word comparisons, topological sort.","steps":["Compare adjacent words for ordering info","Build directed graph","Topological sort"],"complexity":"Time: O(C), Space: O(1)"},"testCases":[{"input":"[wrt,wrf,er,ett,rftt]","expectedOutput":"wertf","explanation":"Valid alien order"},{"input":"[z,x]","expectedOutput":"zx","explanation":"z comes before x"},{"input":"[z,x,z]","expectedOutput":"","explanation":"Invalid - cycle detected"},{"input":"[abc]","expectedOutput":"abc","explanation":"Single word, any order"}]},{"id":"hard29","title":"Critical Connections","description":"Find bridges (critical edges) in a network.","difficulty":"HARD","category":"Graph","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid criticalConnections(int n, int edges[][2], int m) {}\\nint main() { int edges[][2]={{0,1},{1,2},{2,0},{1,3}}; criticalConnections(4,edges,4); return 0; }","expectedOutput":"1-3","solution":"#include <iostream>\\nusing namespace std;\\nint adj[10][10],sz[10],disc[10],low[10],timer=0;\\nvoid dfs(int u, int p) { disc[u]=low[u]=++timer; for(int i=0;i<sz[u];i++) { int v=adj[u][i]; if(!disc[v]) { dfs(v,u); low[u]=min(low[u],low[v]); if(low[v]>disc[u]) cout<<u<<\\"-\\"<<v<<\\" \\"; } else if(v!=p) low[u]=min(low[u],disc[v]); } }\\nvoid criticalConnections(int n, int edges[][2], int m) { for(int i=0;i<n;i++) { sz[i]=0; disc[i]=0; low[i]=0; } for(int i=0;i<m;i++) { adj[edges[i][0]][sz[edges[i][0]]++]=edges[i][1]; adj[edges[i][1]][sz[edges[i][1]]++]=edges[i][0]; } for(int i=0;i<n;i++) if(!disc[i]) dfs(i,-1); }\\nint main() { int edges[][2]={{0,1},{1,2},{2,0},{1,3}}; criticalConnections(4,edges,4); return 0; }","explanation":{"approach":"Tarjan's algorithm for finding bridges.","steps":["Track discovery and low times","Bridge if low[v] > disc[u]"],"complexity":"Time: O(V+E), Space: O(V)"},"testCases":[{"input":"4 nodes, edges including 1-3","expectedOutput":"1-3","explanation":"Only bridge is 1-3"},{"input":"Complete graph K4","expectedOutput":"","explanation":"No bridges in complete graph"},{"input":"Chain 0-1-2-3","expectedOutput":"0-1 1-2 2-3","explanation":"All edges are bridges"},{"input":"Two triangles connected by 1 edge","expectedOutput":"connecting edge","explanation":"Single bridge"}]},{"id":"hard30","title":"Count Smaller Numbers After Self","description":"For each element, count smaller elements to its right.","difficulty":"HARD","category":"Divide and Conquer","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid countSmaller(int a[], int n) {}\\nint main() { int a[]={5,2,6,1}; countSmaller(a,4); return 0; }","expectedOutput":"2 1 1 0","solution":"#include <iostream>\\nusing namespace std;\\nvoid countSmaller(int a[], int n) { int res[n]={}; for(int i=0;i<n;i++) for(int j=i+1;j<n;j++) if(a[j]<a[i]) res[i]++; for(int i=0;i<n;i++) cout<<res[i]<<\\" \\"; }\\nint main() { int a[]={5,2,6,1}; countSmaller(a,4); return 0; }","explanation":{"approach":"Count all smaller elements to the right.","steps":["For each position","Count elements to right that are smaller"],"complexity":"Time: O(n), Space: O(n)"},"testCases":[{"input":"[5,2,6,1]","expectedOutput":"2 1 1 0","explanation":"5>2,1; 2>1; 6>1; 1>none"},{"input":"[1,2,3]","expectedOutput":"0 0 0","explanation":"Ascending array"},{"input":"[3,2,1]","expectedOutput":"2 1 0","explanation":"Descending array"},{"input":"[1]","expectedOutput":"0","explanation":"Single element"}]},{"id":"hard31","title":"The Skyline Problem","description":"Compute building skyline silhouette.","difficulty":"HARD","category":"Divide and Conquer","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid getSkyline(int buildings[][3], int n) {}\\nint main() { int b[][3]={{2,9,10},{3,7,15},{5,12,12},{15,20,10},{19,24,8}}; getSkyline(b,5); return 0; }","expectedOutput":"2,10 3,15 7,12 12,0 15,10 20,8 24,0","solution":"#include <iostream>\\nusing namespace std;\\nvoid getSkyline(int buildings[][3], int n) { int events[2*n][3], k=0; for(int i=0;i<n;i++) { events[k][0]=buildings[i][0]; events[k][1]=buildings[i][2]; events[k++][2]=1; events[k][0]=buildings[i][1]; events[k][1]=buildings[i][2]; events[k++][2]=0; } for(int i=0;i<2*n-1;i++) for(int j=0;j<2*n-i-1;j++) if(events[j][0]>events[j+1][0]) { swap(events[j][0],events[j+1][0]); swap(events[j][1],events[j+1][1]); swap(events[j][2],events[j+1][2]); } int active[100],az=0,lastH=-1; for(int i=0;i<2*n;i++) { if(events[i][2]) active[az++]=events[i][1]; else { for(int j=0;j<az;j++) if(active[j]==events[i][1]) { active[j]=active[--az]; break; } } int maxH=0; for(int j=0;j<az;j++) maxH=max(maxH,active[j]); if(maxH!=lastH) { cout<<events[i][0]<<\\",\\"<<maxH<<\\" \\"; lastH=maxH; } } }\\nint main() { int b[][3]={{2,9,10},{3,7,15},{5,12,12},{15,20,10},{19,24,8}}; getSkyline(b,5); return 0; }","explanation":{"approach":"Line sweep with start/end events.","steps":["Create events for building starts and ends","Sweep and track max active height"],"complexity":"Time: O(n), Space: O(n)"},"testCases":[{"input":"5 buildings","expectedOutput":"key points","explanation":"Skyline key points"},{"input":"Single building [0,2,3]","expectedOutput":"0,3 2,0","explanation":"Start and end points"},{"input":"Two same-height adjacent","expectedOutput":"merged outline","explanation":"No intermediate point"},{"input":"Nested buildings","expectedOutput":"outer outline","explanation":"Taller hides shorter"}]},{"id":"hard32","title":"Smallest Range Covering K Lists","description":"Find smallest range including at least one number from each list.","difficulty":"HARD","category":"Heap","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid smallestRange(int nums[][5], int k, int sizes[]) {}\\nint main() { int nums[][5]={{4,10,15,24,26},{0,9,12,20},{5,18,22,30}}; int sizes[]={5,4,4}; smallestRange(nums,3,sizes); return 0; }","expectedOutput":"20-24","solution":"#include <iostream>\\nusing namespace std;\\nvoid smallestRange(int nums[][5], int k, int sizes[]) { int idx[k]={}; int minR=0,maxR=1e9; while(true) { int mi=0,mx=0; for(int i=0;i<k;i++) { if(nums[i][idx[i]]<nums[mi][idx[mi]]) mi=i; if(nums[i][idx[i]]>nums[mx][idx[mx]]) mx=i; } if(nums[mx][idx[mx]]-nums[mi][idx[mi]]<maxR-minR) { minR=nums[mi][idx[mi]]; maxR=nums[mx][idx[mx]]; } idx[mi]++; if(idx[mi]>=sizes[mi]) break; } cout<<minR<<\\"-\\"<<maxR; }\\nint main() { int nums[][5]={{4,10,15,24,26},{0,9,12,20},{5,18,22,30}}; int sizes[]={5,4,4}; smallestRange(nums,3,sizes); return 0; }","explanation":{"approach":"Keep one pointer per list, advance minimum.","steps":["Track current element from each list","Advance minimum pointer","Track best range"],"complexity":"Time: O(n  k), Space: O(k)"},"testCases":[{"input":"3 sorted lists","expectedOutput":"20-24","explanation":"Range includes 20,22,24"},{"input":"[[1,2,3],[1,2,3],[1,2,3]]","expectedOutput":"1-1","explanation":"All have 1"},{"input":"[[1],[2],[3]]","expectedOutput":"1-3","explanation":"Must span all"},{"input":"[[10,20],[11,21],[12,22]]","expectedOutput":"10-12","explanation":"Minimal range"}]}]`),fM=JSON.parse(`[{"id":"h126","title":"Longest Substring with At Least K Repeating","description":"Find length of longest substring where every character appears at least k times.","difficulty":"HARD","category":"Divide Conquer","starterCode":"#include <iostream>\\nusing namespace std;\\nint longestSubstring(char s[], int k) { return 0; }\\nint main() { cout << longestSubstring(\\"aaabb\\", 3); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nint longestSubstring(char s[], int k) {\\n    int n = 0;\\n    while(s[n]) n++;\\n    if(n == 0) return 0;\\n    int count[26] = {};\\n    for(int i = 0; i < n; i++) count[s[i] - 'a']++;\\n    for(int i = 0; i < n; i++) {\\n        if(count[s[i] - 'a'] < k) {\\n            int maxLen = 0;\\n            int start = 0;\\n            for(int j = 0; j <= n; j++) {\\n                if(j == n || count[s[j] - 'a'] < k) {\\n                    if(j > start) {\\n                        char sub[j - start + 1];\\n                        for(int t = start; t < j; t++) sub[t - start] = s[t];\\n                        sub[j - start] = 0;\\n                        int len = longestSubstring(sub, k);\\n                        if(len > maxLen) maxLen = len;\\n                    }\\n                    start = j + 1;\\n                }\\n            }\\n            return maxLen;\\n        }\\n    }\\n    return n;\\n}\\nint main() { cout << longestSubstring(\\"aaabb\\", 3); return 0; }","explanation":{"approach":"Divide and conquer - split at characters appearing less than k times.","steps":["Count character frequencies","If any char appears <k times, split there","Recursively solve each piece"],"complexity":"Time: O(26  n), Space: O(n)"},"testCases":[{"input":"\\"aaabb\\", k=3","expectedOutput":"3","explanation":"\\"aaa\\" is the longest valid substring"},{"input":"\\"ababbc\\", k=2","expectedOutput":"5","explanation":"\\"ababb\\" - all chars appear 2 times"},{"input":"\\"a\\", k=1","expectedOutput":"1","explanation":"Single char with k=1"},{"input":"\\"abcde\\", k=2","expectedOutput":"0","explanation":"No char appears twice"}]},{"id":"h127","title":"IPO","description":"Maximize capital by completing at most k projects, each requiring minimum capital.","difficulty":"HARD","category":"Heap","starterCode":"#include <iostream>\\nusing namespace std;\\nint findMaximizedCapital(int k, int w, int profits[], int capital[], int n) { return 0; }\\nint main() { int p[] = {1, 2, 3}; int c[] = {0, 1, 1}; cout << findMaximizedCapital(2, 0, p, c, 3); return 0; }","expectedOutput":"4","solution":"#include <iostream>\\nusing namespace std;\\nint findMaximizedCapital(int k, int w, int profits[], int capital[], int n) {\\n    for(int i = 0; i < k; i++) {\\n        int bestIdx = -1;\\n        int bestProfit = 0;\\n        for(int j = 0; j < n; j++) {\\n            if(capital[j] <= w && profits[j] > bestProfit) {\\n                bestProfit = profits[j];\\n                bestIdx = j;\\n            }\\n        }\\n        if(bestIdx == -1) break;\\n        w += profits[bestIdx];\\n        capital[bestIdx] = 1e9;\\n    }\\n    return w;\\n}\\nint main() { int p[] = {1, 2, 3}; int c[] = {0, 1, 1}; cout << findMaximizedCapital(2, 0, p, c, 3); return 0; }","explanation":{"approach":"Greedy - always pick most profitable affordable project.","steps":["Find all affordable projects","Pick the most profitable","Add profit to capital","Repeat k times"],"complexity":"Time: O(k  n), Space: O(1)"},"testCases":[{"input":"k=2, w=0, profits=[1,2,3], capital=[0,1,1]","expectedOutput":"4","explanation":"Do project 0 (profit 1), then project 2 (profit 3)"},{"input":"k=3, w=0, profits=[1,2,3], capital=[0,1,2]","expectedOutput":"6","explanation":"Can do all three projects"},{"input":"k=1, w=0, profits=[1,2,3], capital=[1,1,2]","expectedOutput":"0","explanation":"No affordable project"},{"input":"k=2, w=1, profits=[1,2,3], capital=[1,1,1]","expectedOutput":"6","explanation":"All affordable, pick best twice"}]},{"id":"h128","title":"Sliding Window Median","description":"Return median of each sliding window of size k.","difficulty":"HARD","category":"Heap","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid medianSlidingWindow(int nums[], int n, int k) {}\\nint main() { int n[] = {1, 3, -1, -3, 5, 3, 6, 7}; medianSlidingWindow(n, 8, 3); return 0; }","expectedOutput":"1 -1 -1 3 5 6","solution":"#include <iostream>\\nusing namespace std;\\nvoid medianSlidingWindow(int nums[], int n, int k) {\\n    for(int i = 0; i <= n - k; i++) {\\n        int window[k];\\n        for(int j = 0; j < k; j++) window[j] = nums[i + j];\\n        for(int a = 0; a < k - 1; a++)\\n            for(int b = 0; b < k - a - 1; b++)\\n                if(window[b] > window[b + 1]) swap(window[b], window[b + 1]);\\n        cout << window[k / 2] << \\" \\";\\n    }\\n}\\nint main() { int n[] = {1, 3, -1, -3, 5, 3, 6, 7}; medianSlidingWindow(n, 8, 3); return 0; }","explanation":{"approach":"Sort each window and return middle element.","steps":["Extract k elements","Sort the window","Median is middle element (for odd k)"],"complexity":"Time: O(n  k log k), Space: O(k)"},"testCases":[{"input":"[1,3,-1,-3,5,3,6,7], k=3","expectedOutput":"1 -1 -1 3 5 6","explanation":"Median of each window"},{"input":"[1,2,3,4,5], k=1","expectedOutput":"1 2 3 4 5","explanation":"k=1, each element is its own median"},{"input":"[5,5,5,5], k=2","expectedOutput":"5 5 5","explanation":"All same values"},{"input":"[1,2], k=2","expectedOutput":"2","explanation":"Single window, upper median"}]},{"id":"h129","title":"Find Median from Data Stream","description":"Design structure to find running median as numbers are added.","difficulty":"HARD","category":"Heap","starterCode":"#include <iostream>\\nusing namespace std;\\nclass MedianFinder {\\npublic:\\n    void addNum(int num) {}\\n    double findMedian() { return 0; }\\n};\\nint main() { MedianFinder m; m.addNum(1); m.addNum(2); cout << m.findMedian(); return 0; }","expectedOutput":"1.5","solution":"#include <iostream>\\nusing namespace std;\\nclass MedianFinder {\\n    int arr[100]; int n;\\npublic:\\n    MedianFinder() : n(0) {}\\n    void addNum(int num) {\\n        arr[n] = num;\\n        int i = n;\\n        while(i > 0 && arr[i] < arr[i - 1]) { swap(arr[i], arr[i - 1]); i--; }\\n        n++;\\n    }\\n    double findMedian() {\\n        if(n % 2 == 1) return arr[n / 2];\\n        return (arr[n / 2 - 1] + arr[n / 2]) / 2.0;\\n    }\\n};\\nint main() { MedianFinder m; m.addNum(1); m.addNum(2); cout << m.findMedian(); return 0; }","explanation":{"approach":"Maintain sorted array, return middle element(s).","steps":["Insert in sorted position","Odd count: return middle","Even count: average of two middle"],"complexity":"Time: O(n) insert, O(1) median, Space: O(n)"},"testCases":[{"input":"add(1), add(2), findMedian()","expectedOutput":"1.5","explanation":"Average of 1 and 2"},{"input":"add(1), add(2), add(3), findMedian()","expectedOutput":"2","explanation":"Middle of sorted 1,2,3"},{"input":"add(5), findMedian()","expectedOutput":"5","explanation":"Single element"},{"input":"add(1), add(2), add(3), add(4), findMedian()","expectedOutput":"2.5","explanation":"Average of 2 and 3"}]},{"id":"h130","title":"Critical Connections in a Network","description":"Find all bridges (edges whose removal disconnects the graph).","difficulty":"HARD","category":"Graph","starterCode":"#include <iostream>\\nusing namespace std;\\nint criticalConnections(int n, int connections[][2], int c) { return 0; }\\nint main() { int conn[][2] = {{0,1}, {1,2}, {2,0}, {1,3}}; cout << criticalConnections(4, conn, 4); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nint disc[10], low[10], timer_val = 0;\\nvoid dfs(int adj[][10], int sz[], int u, int parent) {\\n    disc[u] = low[u] = ++timer_val;\\n    for(int i = 0; i < sz[u]; i++) {\\n        int v = adj[u][i];\\n        if(disc[v] == 0) { dfs(adj, sz, v, u); low[u] = min(low[u], low[v]); }\\n        else if(v != parent) low[u] = min(low[u], disc[v]);\\n    }\\n}\\nint criticalConnections(int n, int connections[][2], int c) {\\n    int adj[10][10], sz[10] = {};\\n    for(int i = 0; i < c; i++) {\\n        int u = connections[i][0], v = connections[i][1];\\n        adj[u][sz[u]++] = v; adj[v][sz[v]++] = u;\\n    }\\n    dfs(adj, sz, 0, -1);\\n    int bridges = 0;\\n    for(int i = 0; i < c; i++) {\\n        int u = connections[i][0], v = connections[i][1];\\n        if(low[v] > disc[u] || low[u] > disc[v]) bridges++;\\n    }\\n    return bridges;\\n}\\nint main() { int conn[][2] = {{0,1}, {1,2}, {2,0}, {1,3}}; cout << criticalConnections(4, conn, 4); return 0; }","explanation":{"approach":"Tarjan's algorithm - track discovery time and lowest reachable.","steps":["DFS tracking disc[u] and low[u]","Edge (u,v) is bridge if low[v] > disc[u]"],"complexity":"Time: O(V + E), Space: O(V)"},"testCases":[{"input":"4 nodes, cycle + edge","expectedOutput":"1","explanation":"Only edge 1-3 is bridge"},{"input":"Complete graph K3","expectedOutput":"0","explanation":"No bridges in complete graph"},{"input":"Chain 0-1-2","expectedOutput":"2","explanation":"Both edges are bridges"},{"input":"Two cycles connected","expectedOutput":"1","explanation":"Connecting edge is bridge"}]},{"id":"h131","title":"Edit Distance","description":"Minimum operations (insert/delete/replace) to convert word1 to word2.","difficulty":"HARD","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint minDistance(char a[], char b[]) { return 0; }\\nint main() { cout << minDistance(\\"horse\\", \\"ros\\"); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nint minDistance(char a[], char b[]) {\\n    int m = 0, n = 0;\\n    while(a[m]) m++; while(b[n]) n++;\\n    int dp[m + 1][n + 1];\\n    for(int i = 0; i <= m; i++) dp[i][0] = i;\\n    for(int j = 0; j <= n; j++) dp[0][j] = j;\\n    for(int i = 1; i <= m; i++) {\\n        for(int j = 1; j <= n; j++) {\\n            if(a[i - 1] == b[j - 1]) dp[i][j] = dp[i - 1][j - 1];\\n            else dp[i][j] = 1 + min(dp[i - 1][j], min(dp[i][j - 1], dp[i - 1][j - 1]));\\n        }\\n    }\\n    return dp[m][n];\\n}\\nint main() { cout << minDistance(\\"horse\\", \\"ros\\"); return 0; }","explanation":{"approach":"DP where dp[i][j] = min ops to convert a[0..i-1] to b[0..j-1].","steps":["If chars match: no op needed","Else: min of insert/delete/replace"],"complexity":"Time: O(m  n), Space: O(m  n)"},"testCases":[{"input":"horse, ros","expectedOutput":"3","explanation":"horse->rorse->rose->ros"},{"input":"intention, execution","expectedOutput":"5","explanation":"5 operations needed"},{"input":"abc, abc","expectedOutput":"0","explanation":"Already equal"},{"input":"\\"\\", abc","expectedOutput":"3","explanation":"Insert all 3 chars"}]},{"id":"h132","title":"Regular Expression Matching","description":"Match string with pattern containing '.' and '*'.","difficulty":"HARD","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isMatch(char s[], char p[]) { return false; }\\nint main() { cout << isMatch(\\"aa\\", \\"a*\\"); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isMatch(char s[], char p[]) {\\n    int m = 0, n = 0;\\n    while(s[m]) m++; while(p[n]) n++;\\n    bool dp[m + 1][n + 1];\\n    for(int i = 0; i <= m; i++) for(int j = 0; j <= n; j++) dp[i][j] = false;\\n    dp[0][0] = true;\\n    for(int j = 2; j <= n; j++) if(p[j - 1] == '*') dp[0][j] = dp[0][j - 2];\\n    for(int i = 1; i <= m; i++) {\\n        for(int j = 1; j <= n; j++) {\\n            if(p[j - 1] == '*') {\\n                dp[i][j] = dp[i][j - 2];\\n                if(p[j - 2] == '.' || p[j - 2] == s[i - 1]) dp[i][j] = dp[i][j] || dp[i - 1][j];\\n            } else if(p[j - 1] == '.' || p[j - 1] == s[i - 1]) dp[i][j] = dp[i - 1][j - 1];\\n        }\\n    }\\n    return dp[m][n];\\n}\\nint main() { cout << isMatch(\\"aa\\", \\"a*\\"); return 0; }","explanation":{"approach":"DP handling '.' as wildcard and '*' as zero or more of preceding.","steps":["dp[i][j] = s[0..i-1] matches p[0..j-1]","'*' can mean 0 or more occurrences"],"complexity":"Time: O(m  n), Space: O(m  n)"},"testCases":[{"input":"aa, a*","expectedOutput":"1","explanation":"a* matches aa"},{"input":"aa, a","expectedOutput":"0","explanation":"No match"},{"input":"ab, .*","expectedOutput":"1","explanation":".* matches anything"},{"input":"aab, c*a*b","expectedOutput":"1","explanation":"c* matches 0 c's, a* matches aa, b matches b"}]},{"id":"h133","title":"Trapping Rain Water","description":"Calculate total water trapped between bars after raining.","difficulty":"HARD","category":"Two Pointers","starterCode":"#include <iostream>\\nusing namespace std;\\nint trap(int h[], int n) { return 0; }\\nint main() { int h[] = {0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1}; cout << trap(h, 12); return 0; }","expectedOutput":"6","solution":"#include <iostream>\\nusing namespace std;\\nint trap(int h[], int n) {\\n    int left = 0, right = n - 1;\\n    int leftMax = 0, rightMax = 0, water = 0;\\n    while(left < right) {\\n        if(h[left] < h[right]) {\\n            if(h[left] >= leftMax) leftMax = h[left];\\n            else water += leftMax - h[left];\\n            left++;\\n        } else {\\n            if(h[right] >= rightMax) rightMax = h[right];\\n            else water += rightMax - h[right];\\n            right--;\\n        }\\n    }\\n    return water;\\n}\\nint main() { int h[] = {0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1}; cout << trap(h, 12); return 0; }","explanation":{"approach":"Two pointers tracking max height from each side.","steps":["Water at position = min(leftMax, rightMax) - height","Process from shorter side"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"[0,1,0,2,1,0,1,3,2,1,2,1]","expectedOutput":"6","explanation":"Water trapped in valleys"},{"input":"[4,2,0,3,2,5]","expectedOutput":"9","explanation":"Water between walls"},{"input":"[1,2,3,4,5]","expectedOutput":"0","explanation":"Ascending, no water"},{"input":"[5,4,3,2,1]","expectedOutput":"0","explanation":"Descending, no water"}]}]`),hM=JSON.parse(`[{"id":"h136","title":"Island Perimeter","description":"Calculate perimeter of island in grid where 1 is land and 0 is water.","difficulty":"EASY","category":"Matrix","starterCode":"#include <iostream>\\nusing namespace std;\\nint islandPerimeter(int grid[][4], int r, int c) { return 0; }\\nint main() { int g[][4]={{0,1,0,0},{1,1,1,0},{0,1,0,0},{1,1,0,0}}; cout<<islandPerimeter(g,4,4); return 0; }","expectedOutput":"16","solution":"#include <iostream>\\nusing namespace std;\\nint islandPerimeter(int grid[][4], int r, int c) { int p=0; for(int i=0;i<r;i++) for(int j=0;j<c;j++) if(grid[i][j]) { p+=4; if(i>0&&grid[i-1][j]) p-=2; if(j>0&&grid[i][j-1]) p-=2; } return p; }\\nint main() { int g[][4]={{0,1,0,0},{1,1,1,0},{0,1,0,0},{1,1,0,0}}; cout<<islandPerimeter(g,4,4); return 0; }","explanation":{"approach":"Count 4 edges per land cell, subtract 2 for each adjacent land.","steps":["Each land cell contributes 4 edges","Subtract 2 for each neighbor"],"complexity":"Time: O(mn), Space: O(1)"},"testCases":[{"input":"4x4 grid with island","expectedOutput":"16","explanation":"Island perimeter is 16"},{"input":"Single cell [[1]]","expectedOutput":"4","explanation":"Square has 4 sides"},{"input":"[[1,1],[1,1]]","expectedOutput":"8","explanation":"2x2 square perimeter"},{"input":"Line [[1,1,1,1]]","expectedOutput":"10","explanation":"Horizontal line perimeter"}]},{"id":"h137","title":"Best Time to Buy and Sell Stock III","description":"Maximum profit with at most 2 transactions.","difficulty":"HARD","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint maxProfit(int prices[], int n) { return 0; }\\nint main() { int p[]={3,3,5,0,0,3,1,4}; cout<<maxProfit(p,8); return 0; }","expectedOutput":"6","solution":"#include <iostream>\\nusing namespace std;\\nint maxProfit(int prices[], int n) { int b1=1e9,b2=1e9,p1=0,p2=0; for(int i=0;i<n;i++) { b1=min(b1,prices[i]); p1=max(p1,prices[i]-b1); b2=min(b2,prices[i]-p1); p2=max(p2,prices[i]-b2); } return p2; }\\nint main() { int p[]={3,3,5,0,0,3,1,4}; cout<<maxProfit(p,8); return 0; }","explanation":{"approach":"Track two transactions with running min buy and max profit.","steps":["b1, p1 for first transaction","b2, p2 for second using p1 as 'discount'"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"[3,3,5,0,0,3,1,4]","expectedOutput":"6","explanation":"Buy at 0, sell at 3, buy at 1, sell at 4"},{"input":"[1,2,3,4,5]","expectedOutput":"4","explanation":"Single transaction 1->5"},{"input":"[7,6,4,3,1]","expectedOutput":"0","explanation":"Prices only decrease"},{"input":"[1,2,4,2,5,7,2,4,9,0]","expectedOutput":"13","explanation":"Two optimal transactions"}]},{"id":"h138","title":"Best Time to Buy and Sell Stock IV","description":"Maximum profit with at most k transactions.","difficulty":"HARD","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint maxProfit(int k, int prices[], int n) { return 0; }\\nint main() { int p[]={2,4,1}; cout<<maxProfit(2,p,3); return 0; }","expectedOutput":"2","solution":"#include <iostream>\\nusing namespace std;\\nint maxProfit(int k, int prices[], int n) { if(n==0||k==0) return 0; if(k>=n/2) { int p=0; for(int i=1;i<n;i++) if(prices[i]>prices[i-1]) p+=prices[i]-prices[i-1]; return p; } int dp[k+1][n]; for(int i=0;i<=k;i++) dp[i][0]=0; for(int j=0;j<n;j++) dp[0][j]=0; for(int i=1;i<=k;i++) { int mx=-prices[0]; for(int j=1;j<n;j++) { dp[i][j]=max(dp[i][j-1],prices[j]+mx); mx=max(mx,dp[i-1][j-1]-prices[j]); } } return dp[k][n-1]; }\\nint main() { int p[]={2,4,1}; cout<<maxProfit(2,p,3); return 0; }","explanation":{"approach":"DP with state for number of transactions used.","steps":["dp[i][j] = max profit with i transactions up to day j","Optimize with running max difference"],"complexity":"Time: O(kn), Space: O(kn)"},"testCases":[{"input":"k=2, [2,4,1]","expectedOutput":"2","explanation":"Buy at 2, sell at 4"},{"input":"k=2, [3,2,6,5,0,3]","expectedOutput":"7","explanation":"2->6 and 0->3"},{"input":"k=1, [1,2,3]","expectedOutput":"2","explanation":"Single transaction 1->3"},{"input":"k=0, [1,2,3]","expectedOutput":"0","explanation":"No transactions allowed"}]},{"id":"h139","title":"Distinct Subsequences","description":"Count distinct subsequences of s that equal t.","difficulty":"HARD","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint numDistinct(char s[], char t[]) { return 0; }\\nint main() { cout<<numDistinct(\\"rabbbit\\",\\"rabbit\\"); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nint numDistinct(char s[], char t[]) { int m=0,n=0; while(s[m]) m++; while(t[n]) n++; int dp[m+1][n+1]; for(int i=0;i<=m;i++) dp[i][0]=1; for(int j=1;j<=n;j++) dp[0][j]=0; for(int i=1;i<=m;i++) for(int j=1;j<=n;j++) dp[i][j]=dp[i-1][j]+(s[i-1]==t[j-1]?dp[i-1][j-1]:0); return dp[m][n]; }\\nint main() { cout<<numDistinct(\\"rabbbit\\",\\"rabbit\\"); return 0; }","explanation":{"approach":"DP counting subsequences matching target.","steps":["dp[i][j] = ways to form t[0..j-1] from s[0..i-1]","Add dp[i-1][j-1] if chars match"],"complexity":"Time: O(mn), Space: O(mn)"},"testCases":[{"input":"rabbbit, rabbit","expectedOutput":"3","explanation":"3 ways to select 'rabbit'"},{"input":"babgbag, bag","expectedOutput":"5","explanation":"5 distinct subsequences"},{"input":"a, a","expectedOutput":"1","explanation":"Single match"},{"input":"ab, b","expectedOutput":"1","explanation":"One way"}]},{"id":"h140","title":"Interleaving String","description":"Check if s3 is formed by interleaving s1 and s2.","difficulty":"HARD","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isInterleave(char s1[], char s2[], char s3[]) { return false; }\\nint main() { cout<<isInterleave(\\"aabcc\\",\\"dbbca\\",\\"aadbbcbcac\\"); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isInterleave(char s1[], char s2[], char s3[]) { int m=0,n=0,l=0; while(s1[m]) m++; while(s2[n]) n++; while(s3[l]) l++; if(m+n!=l) return false; bool dp[m+1][n+1]; dp[0][0]=true; for(int i=1;i<=m;i++) dp[i][0]=dp[i-1][0]&&s1[i-1]==s3[i-1]; for(int j=1;j<=n;j++) dp[0][j]=dp[0][j-1]&&s2[j-1]==s3[j-1]; for(int i=1;i<=m;i++) for(int j=1;j<=n;j++) dp[i][j]=(dp[i-1][j]&&s1[i-1]==s3[i+j-1])||(dp[i][j-1]&&s2[j-1]==s3[i+j-1]); return dp[m][n]; }\\nint main() { cout<<isInterleave(\\"aabcc\\",\\"dbbca\\",\\"aadbbcbcac\\"); return 0; }","explanation":{"approach":"DP for interleaving validation.","steps":["dp[i][j] = can s1[0..i) + s2[0..j) interleave to s3[0..i+j)","Check if next char from s1 or s2 matches"],"complexity":"Time: O(mn), Space: O(mn)"},"testCases":[{"input":"aabcc, dbbca, aadbbcbcac","expectedOutput":"1","explanation":"Valid interleaving"},{"input":"aabcc, dbbca, aadbbbaccc","expectedOutput":"0","explanation":"Invalid interleaving"},{"input":"a, b, ab","expectedOutput":"1","explanation":"Simple interleave"},{"input":"\\"\\", \\"\\", \\"\\"","expectedOutput":"1","explanation":"Empty strings"}]},{"id":"h141","title":"Largest Rectangle in Histogram","description":"Find largest rectangle that can be formed in histogram.","difficulty":"HARD","category":"Stack","starterCode":"#include <iostream>\\nusing namespace std;\\nint largestRectangleArea(int heights[], int n) { return 0; }\\nint main() { int h[]={2,1,5,6,2,3}; cout<<largestRectangleArea(h,6); return 0; }","expectedOutput":"10","solution":"#include <iostream>\\nusing namespace std;\\nint largestRectangleArea(int h[], int n) { int stk[n+1],top=-1,mx=0; for(int i=0;i<=n;i++) { int cur=i==n?0:h[i]; while(top>=0&&cur<h[stk[top]]) { int ht=h[stk[top--]]; int w=top<0?i:i-stk[top]-1; mx=max(mx,ht*w); } stk[++top]=i; } return mx; }\\nint main() { int h[]={2,1,5,6,2,3}; cout<<largestRectangleArea(h,6); return 0; }","explanation":{"approach":"Stack to find nearest smaller on both sides.","steps":["Maintain increasing stack","Pop when smaller found","Calculate area with popped bar as height"],"complexity":"Time: O(n), Space: O(n)"},"testCases":[{"input":"[2,1,5,6,2,3]","expectedOutput":"10","explanation":"5x2 rectangle"},{"input":"[2,4]","expectedOutput":"4","explanation":"Either 2x2 or 1x4"},{"input":"[1]","expectedOutput":"1","explanation":"Single bar"},{"input":"[3,3,3,3]","expectedOutput":"12","explanation":"3x4 rectangle"}]},{"id":"h142","title":"Maximal Rectangle","description":"Find largest rectangle containing only 1s in binary matrix.","difficulty":"HARD","category":"Stack","starterCode":"#include <iostream>\\nusing namespace std;\\nint maximalRectangle(char m[][5], int r, int c) { return 0; }\\nint main() { char m[][5]={{\\"10100\\"},{\\"10111\\"},{\\"11111\\"},{\\"10010\\"}}; cout<<maximalRectangle(m,4,5); return 0; }","expectedOutput":"6","solution":"#include <iostream>\\nusing namespace std;\\nint largestRect(int h[], int n) { int stk[n+1],top=-1,mx=0; for(int i=0;i<=n;i++) { int cur=i==n?0:h[i]; while(top>=0&&cur<h[stk[top]]) { int ht=h[stk[top--]]; int w=top<0?i:i-stk[top]-1; mx=max(mx,ht*w); } stk[++top]=i; } return mx; }\\nint maximalRectangle(char m[][5], int r, int c) { int h[c]={}; int mx=0; for(int i=0;i<r;i++) { for(int j=0;j<c;j++) h[j]=m[i][j]=='1'?h[j]+1:0; mx=max(mx,largestRect(h,c)); } return mx; }\\nint main() { char m[][5]={{\\"10100\\"},{\\"10111\\"},{\\"11111\\"},{\\"10010\\"}}; cout<<maximalRectangle(m,4,5); return 0; }","explanation":{"approach":"Convert each row to histogram, apply largest rectangle.","steps":["Build cumulative heights row by row","Apply histogram algorithm per row"],"complexity":"Time: O(mn), Space: O(n)"},"testCases":[{"input":"4x5 binary matrix","expectedOutput":"6","explanation":"3x2 rectangle of 1s"},{"input":"[[1]]","expectedOutput":"1","explanation":"Single cell"},{"input":"[[1,1],[1,1]]","expectedOutput":"4","explanation":"2x2 square"},{"input":"[[0,0],[0,0]]","expectedOutput":"0","explanation":"No 1s"}]},{"id":"h143","title":"Trapping Rain Water","description":"Calculate water trapped between elevation bars.","difficulty":"HARD","category":"Stack","starterCode":"#include <iostream>\\nusing namespace std;\\nint trap(int h[], int n) { return 0; }\\nint main() { int h[]={0,1,0,2,1,0,1,3,2,1,2,1}; cout<<trap(h,12); return 0; }","expectedOutput":"6","solution":"#include <iostream>\\nusing namespace std;\\nint trap(int h[], int n) { int l=0,r=n-1,lm=0,rm=0,w=0; while(l<r) { if(h[l]<h[r]) { if(h[l]>=lm) lm=h[l]; else w+=lm-h[l]; l++; } else { if(h[r]>=rm) rm=h[r]; else w+=rm-h[r]; r--; } } return w; }\\nint main() { int h[]={0,1,0,2,1,0,1,3,2,1,2,1}; cout<<trap(h,12); return 0; }","explanation":{"approach":"Two pointers tracking max heights from each side.","steps":["Track leftMax and rightMax","Process shorter side","Add water = max - current height"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"[0,1,0,2,1,0,1,3,2,1,2,1]","expectedOutput":"6","explanation":"Water in valleys"},{"input":"[4,2,0,3,2,5]","expectedOutput":"9","explanation":"Larger opening"},{"input":"[1,2,3,4,5]","expectedOutput":"0","explanation":"Ascending, no trap"},{"input":"[5,4,3,2,1]","expectedOutput":"0","explanation":"Descending, no trap"}]}]`),xM=JSON.parse('[{"id":"h151","title":"Dungeon Game","description":"Find minimum initial health to reach bottom-right from top-left.","difficulty":"HARD","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint calculateMinimumHP(int d[][3], int r, int c) { return 0; }\\nint main() { int d[][3]={{-2,-3,3},{-5,-10,1},{10,30,-5}}; cout<<calculateMinimumHP(d,3,3); return 0; }","expectedOutput":"7","solution":"#include <iostream>\\nusing namespace std;\\nint calculateMinimumHP(int d[][3], int r, int c) { int dp[r][c]; dp[r-1][c-1]=max(1,1-d[r-1][c-1]); for(int i=r-2;i>=0;i--) dp[i][c-1]=max(1,dp[i+1][c-1]-d[i][c-1]); for(int j=c-2;j>=0;j--) dp[r-1][j]=max(1,dp[r-1][j+1]-d[r-1][j]); for(int i=r-2;i>=0;i--) for(int j=c-2;j>=0;j--) dp[i][j]=max(1,min(dp[i+1][j],dp[i][j+1])-d[i][j]); return dp[0][0]; }\\nint main() { int d[][3]={{-2,-3,3},{-5,-10,1},{10,30,-5}}; cout<<calculateMinimumHP(d,3,3); return 0; }","explanation":{"approach":"DP from bottom-right, tracking minimum health needed.","steps":["dp[i][j] = min health needed at (i,j) to survive","Work backwards from destination"],"complexity":"Time: O(mn), Space: O(mn)"},"testCases":[{"input":"3x3 dungeon","expectedOutput":"7","explanation":"Need 7 HP to survive path"},{"input":"[[0]]","expectedOutput":"1","explanation":"Need at least 1 HP"},{"input":"[[-3]]","expectedOutput":"4","explanation":"Need 4 to survive -3 and have 1"},{"input":"[[1,2],[3,4]]","expectedOutput":"1","explanation":"All positive, just need 1"}]},{"id":"h152","title":"Cherry Pickup","description":"Maximum cherries collected on round trip in grid.","difficulty":"HARD","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint cherryPickup(int g[][3], int n) { return 0; }\\nint main() { int g[][3]={{0,1,-1},{1,0,-1},{1,1,1}}; cout<<cherryPickup(g,3); return 0; }","expectedOutput":"5","solution":"#include <iostream>\\nusing namespace std;\\nint cherryPickup(int g[][3], int n) { int dp[n][n][n]; for(int i=0;i<n;i++) for(int j=0;j<n;j++) for(int k=0;k<n;k++) dp[i][j][k]=-1e9; dp[0][0][0]=g[0][0]; for(int r1=0;r1<n;r1++) for(int c1=0;c1<n;c1++) for(int r2=0;r2<n;r2++) { int c2=r1+c1-r2; if(c2<0||c2>=n||g[r1][c1]==-1||g[r2][c2]==-1) continue; int v=dp[r1][c1][r2]; if(r1>0) v=max(v,dp[r1-1][c1][r2]); if(c1>0) v=max(v,dp[r1][c1-1][r2]); if(r2>0) v=max(v,dp[r1][c1][r2-1]); if(r1>0&&r2>0) v=max(v,dp[r1-1][c1][r2-1]); if(v<0) continue; v+=g[r1][c1]; if(r1!=r2) v+=g[r2][c2]; dp[r1][c1][r2]=v; } return max(0,dp[n-1][n-1][n-1]); }\\nint main() { int g[][3]={{0,1,-1},{1,0,-1},{1,1,1}}; cout<<cherryPickup(g,3); return 0; }","explanation":{"approach":"Simulate two paths simultaneously to avoid double counting.","steps":["dp[r1][c1][r2] with c2 derived from path equation","Both paths move together"],"complexity":"Time: O(n), Space: O(n)"},"testCases":[{"input":"3x3 grid with cherries","expectedOutput":"5","explanation":"Optimal paths collect 5"},{"input":"[[1,1],[1,1]]","expectedOutput":"4","explanation":"All cherries reachable"},{"input":"[[1,-1],[-1,1]]","expectedOutput":"0","explanation":"No valid path"},{"input":"[[1]]","expectedOutput":"1","explanation":"Single cell"}]},{"id":"h153","title":"Super Egg Drop","description":"Minimum moves to find critical floor with k eggs and n floors.","difficulty":"HARD","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint superEggDrop(int k, int n) { return 0; }\\nint main() { cout<<superEggDrop(2,6); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nint superEggDrop(int k, int n) { int dp[n+1][k+1]; for(int i=0;i<=n;i++) for(int j=0;j<=k;j++) dp[i][j]=0; for(int m=1;m<=n;m++) { for(int j=1;j<=k;j++) dp[m][j]=dp[m-1][j-1]+dp[m-1][j]+1; if(dp[m][k]>=n) return m; } return n; }\\nint main() { cout<<superEggDrop(2,6); return 0; }","explanation":{"approach":"DP on number of moves - how many floors can we check?","steps":["dp[m][k] = max floors checkable with m moves, k eggs","Stop when >= n floors"],"complexity":"Time: O(kn), Space: O(kn)"},"testCases":[{"input":"k=2, n=6","expectedOutput":"3","explanation":"3 moves sufficient"},{"input":"k=1, n=2","expectedOutput":"2","explanation":"Must try each floor"},{"input":"k=2, n=100","expectedOutput":"14","explanation":"Binary search variant"},{"input":"k=3, n=14","expectedOutput":"4","explanation":"More eggs help"}]},{"id":"h154","title":"Count Different Palindromic Subsequences","description":"Count distinct palindromic subsequences in string.","difficulty":"HARD","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint countPalindromicSubsequences(char s[]) { return 0; }\\nint main() { cout<<countPalindromicSubsequences(\\"bccb\\"); return 0; }","expectedOutput":"6","solution":"#include <iostream>\\nusing namespace std;\\nint countPalindromicSubsequences(char s[]) { int n=0; while(s[n]) n++; int dp[n][n]; for(int i=0;i<n;i++) { dp[i][i]=1; for(int j=0;j<i;j++) dp[i][j]=0; } for(int len=2;len<=n;len++) for(int i=0;i<=n-len;i++) { int j=i+len-1; if(s[i]==s[j]) { int l=i+1,r=j-1; while(l<=r&&s[l]!=s[i]) l++; while(l<=r&&s[r]!=s[i]) r--; if(l>r) dp[i][j]=dp[i+1][j-1]*2+2; else if(l==r) dp[i][j]=dp[i+1][j-1]*2+1; else dp[i][j]=dp[i+1][j-1]*2-dp[l+1][r-1]; } else dp[i][j]=dp[i+1][j]+dp[i][j-1]-dp[i+1][j-1]; } return dp[0][n-1]; }\\nint main() { cout<<countPalindromicSubsequences(\\"bccb\\"); return 0; }","explanation":{"approach":"DP with inclusion-exclusion to avoid duplicates.","steps":["If s[i]==s[j], expand palindromes","Handle duplicate characters carefully"],"complexity":"Time: O(n), Space: O(n)"},"testCases":[{"input":"\\"bccb\\"","expectedOutput":"6","explanation":"b,c,bb,cc,bcb,bccb"},{"input":"\\"a\\"","expectedOutput":"1","explanation":"Single char"},{"input":"\\"aaa\\"","expectedOutput":"3","explanation":"a, aa, aaa"},{"input":"\\"abcd\\"","expectedOutput":"4","explanation":"Just single chars"}]},{"id":"h155","title":"Frog Jump","description":"Can frog cross river by jumping on stones?","difficulty":"HARD","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nbool canCross(int stones[], int n) { return false; }\\nint main() { int s[]={0,1,3,5,6,8,12,17}; cout<<canCross(s,8); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool canCross(int stones[], int n) { if(n<2) return true; if(stones[1]!=1) return false; bool dp[n][n+1]; for(int i=0;i<n;i++) for(int k=0;k<=n;k++) dp[i][k]=false; dp[0][0]=true; for(int i=0;i<n;i++) for(int k=0;k<=n;k++) if(dp[i][k]) for(int j=i+1;j<n;j++) { int jump=stones[j]-stones[i]; if(jump>=k-1&&jump<=k+1&&jump<=n) dp[j][jump]=true; } for(int k=0;k<=n;k++) if(dp[n-1][k]) return true; return false; }\\nint main() { int s[]={0,1,3,5,6,8,12,17}; cout<<canCross(s,8); return 0; }","explanation":{"approach":"Track reachable positions with last jump size.","steps":["dp[i][k] = can reach stone i with jump k","Try k-1, k, k+1 for next jump"],"complexity":"Time: O(n), Space: O(n)"},"testCases":[{"input":"[0,1,3,5,6,8,12,17]","expectedOutput":"1","explanation":"Valid path exists"},{"input":"[0,1,2,3,4,8,9,11]","expectedOutput":"0","explanation":"Gap too large"},{"input":"[0,1]","expectedOutput":"1","explanation":"Just first jump"},{"input":"[0,2]","expectedOutput":"0","explanation":"First jump must be 1"}]},{"id":"h156","title":"Split Array Largest Sum","description":"Minimize the largest sum when splitting array into m parts.","difficulty":"HARD","category":"Binary Search","starterCode":"#include <iostream>\\nusing namespace std;\\nint splitArray(int nums[], int n, int m) { return 0; }\\nint main() { int a[]={7,2,5,10,8}; cout<<splitArray(a,5,2); return 0; }","expectedOutput":"18","solution":"#include <iostream>\\nusing namespace std;\\nbool canSplit(int nums[], int n, int m, int mx) { int cnt=1; long sum=0; for(int i=0;i<n;i++) { if(nums[i]>mx) return false; if(sum+nums[i]<=mx) sum+=nums[i]; else { cnt++; sum=nums[i]; } } return cnt<=m; }\\nint splitArray(int nums[], int n, int m) { long l=0,r=0; for(int i=0;i<n;i++) { l=max(l,(long)nums[i]); r+=nums[i]; } while(l<r) { long mid=(l+r)/2; if(canSplit(nums,n,m,mid)) r=mid; else l=mid+1; } return l; }\\nint main() { int a[]={7,2,5,10,8}; cout<<splitArray(a,5,2); return 0; }","explanation":{"approach":"Binary search on answer value.","steps":["Binary search max subarray sum","Greedily check if m parts possible"],"complexity":"Time: O(n log S), Space: O(1)"},"testCases":[{"input":"[7,2,5,10,8], m=2","expectedOutput":"18","explanation":"[7,2,5] and [10,8]"},{"input":"[1,2,3,4,5], m=2","expectedOutput":"9","explanation":"[1,2,3,4] and [5] or similar"},{"input":"[1,4,4], m=3","expectedOutput":"4","explanation":"Each element separate"},{"input":"[10,5,5], m=1","expectedOutput":"20","explanation":"Must take all"}]},{"id":"h157","title":"Koko Eating Bananas","description":"Minimum eating speed to finish all piles in h hours.","difficulty":"MEDIUM","category":"Binary Search","starterCode":"#include <iostream>\\nusing namespace std;\\nint minEatingSpeed(int piles[], int n, int h) { return 0; }\\nint main() { int p[]={3,6,7,11}; cout<<minEatingSpeed(p,4,8); return 0; }","expectedOutput":"4","solution":"#include <iostream>\\nusing namespace std;\\nbool canEat(int p[], int n, int h, int k) { int time=0; for(int i=0;i<n;i++) time+=(p[i]+k-1)/k; return time<=h; }\\nint minEatingSpeed(int p[], int n, int h) { int l=1,r=0; for(int i=0;i<n;i++) r=max(r,p[i]); while(l<r) { int m=(l+r)/2; if(canEat(p,n,h,m)) r=m; else l=m+1; } return l; }\\nint main() { int p[]={3,6,7,11}; cout<<minEatingSpeed(p,4,8); return 0; }","explanation":{"approach":"Binary search on eating speed.","steps":["Check if speed k allows finishing in h hours","Binary search for minimum k"],"complexity":"Time: O(n log M), Space: O(1)"},"testCases":[{"input":"[3,6,7,11], h=8","expectedOutput":"4","explanation":"Speed 4 takes 8 hours"},{"input":"[30,11,23,4,20], h=5","expectedOutput":"30","explanation":"Must eat each pile in 1 hour"},{"input":"[30,11,23,4,20], h=6","expectedOutput":"23","explanation":"Extra hour helps"},{"input":"[1,1,1,1], h=4","expectedOutput":"1","explanation":"Minimum speed"}]},{"id":"h158","title":"Median of Two Sorted Arrays","description":"Find median of two sorted arrays in O(log(m+n)).","difficulty":"HARD","category":"Binary Search","starterCode":"#include <iostream>\\nusing namespace std;\\ndouble findMedianSortedArrays(int a[], int m, int b[], int n) { return 0; }\\nint main() { int a[]={1,3}; int b[]={2}; cout<<findMedianSortedArrays(a,2,b,1); return 0; }","expectedOutput":"2","solution":"#include <iostream>\\nusing namespace std;\\ndouble findMedianSortedArrays(int a[], int m, int b[], int n) { if(m>n) return findMedianSortedArrays(b,n,a,m); int l=0,r=m; while(l<=r) { int i=(l+r)/2; int j=(m+n+1)/2-i; int al=i==0?-1e9:a[i-1]; int ar=i==m?1e9:a[i]; int bl=j==0?-1e9:b[j-1]; int br=j==n?1e9:b[j]; if(al<=br&&bl<=ar) { if((m+n)%2) return max(al,bl); return (max(al,bl)+min(ar,br))/2.0; } if(al>br) r=i-1; else l=i+1; } return 0; }\\nint main() { int a[]={1,3}; int b[]={2}; cout<<findMedianSortedArrays(a,2,b,1); return 0; }","explanation":{"approach":"Binary search on partition point of smaller array.","steps":["Partition both arrays","Find correct split where all left  all right"],"complexity":"Time: O(log min(m,n)), Space: O(1)"},"testCases":[{"input":"[1,3], [2]","expectedOutput":"2","explanation":"Merged: 1,2,3 -> median 2"},{"input":"[1,2], [3,4]","expectedOutput":"2.5","explanation":"Average of 2 and 3"},{"input":"[0,0], [0,0]","expectedOutput":"0","explanation":"All zeros"},{"input":"[], [1]","expectedOutput":"1","explanation":"Single element"}]}]'),gM=JSON.parse('[{"id":"h161","title":"Count of Range Sum","description":"Count subarrays with sum in [lower, upper] range.","difficulty":"HARD","category":"Divide Conquer","starterCode":"#include <iostream>\\nusing namespace std;\\nint countRangeSum(int nums[], int n, int lo, int hi) { return 0; }\\nint main() { int a[]={-2,5,-1}; cout<<countRangeSum(a,3,-2,2); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nint countRangeSum(int nums[], int n, int lo, int hi) { int cnt=0; for(int i=0;i<n;i++) { long sum=0; for(int j=i;j<n;j++) { sum+=nums[j]; if(sum>=lo&&sum<=hi) cnt++; } } return cnt; }\\nint main() { int a[]={-2,5,-1}; cout<<countRangeSum(a,3,-2,2); return 0; }","explanation":{"approach":"Check all subarray sums against range.","steps":["For each starting index","Extend and check if sum in [lo, hi]"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"[-2,5,-1], [-2,2]","expectedOutput":"3","explanation":"Three valid subarrays"},{"input":"[0], [0,0]","expectedOutput":"1","explanation":"Single zero"},{"input":"[1,2,3], [3,6]","expectedOutput":"3","explanation":"[3], [1,2], [1,2,3]"},{"input":"[-1,-1], [-2,-1]","expectedOutput":"3","explanation":"Both singles and combined"}]},{"id":"h162","title":"Reverse Pairs","description":"Count pairs where i < j and nums[i] > 2*nums[j].","difficulty":"HARD","category":"Divide Conquer","starterCode":"#include <iostream>\\nusing namespace std;\\nint reversePairs(int nums[], int n) { return 0; }\\nint main() { int a[]={1,3,2,3,1}; cout<<reversePairs(a,5); return 0; }","expectedOutput":"2","solution":"#include <iostream>\\nusing namespace std;\\nint reversePairs(int nums[], int n) { int cnt=0; for(int i=0;i<n;i++) for(int j=i+1;j<n;j++) if(nums[i]>(long)2*nums[j]) cnt++; return cnt; }\\nint main() { int a[]={1,3,2,3,1}; cout<<reversePairs(a,5); return 0; }","explanation":{"approach":"Check all valid pairs.","steps":["For each pair (i,j) where i<j","Check if nums[i] > 2*nums[j]"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"[1,3,2,3,1]","expectedOutput":"2","explanation":"3>2*1 twice"},{"input":"[2,4,3,5,1]","expectedOutput":"3","explanation":"Three valid pairs"},{"input":"[1,2,3,4]","expectedOutput":"0","explanation":"No reverse pairs"},{"input":"[5,4,3,2,1]","expectedOutput":"4","explanation":"Descending has pairs"}]},{"id":"h163","title":"LRU Cache","description":"Implement Least Recently Used cache with O(1) operations.","difficulty":"HARD","category":"Design","starterCode":"#include <iostream>\\nusing namespace std;\\nclass LRUCache {\\npublic:\\n    LRUCache(int capacity) {}\\n    int get(int key) { return -1; }\\n    void put(int key, int value) {}\\n};\\nint main() { LRUCache c(2); c.put(1,1); c.put(2,2); cout<<c.get(1); c.put(3,3); cout<<c.get(2); return 0; }","expectedOutput":"1-1","solution":"#include <iostream>\\nusing namespace std;\\nclass LRUCache { int cap; int keys[10],vals[10],times[10],n,t; public: LRUCache(int c):cap(c),n(0),t(0){} int find(int k) { for(int i=0;i<n;i++) if(keys[i]==k) return i; return -1; } int get(int k) { int i=find(k); if(i<0) return -1; times[i]=++t; return vals[i]; } void put(int k, int v) { int i=find(k); if(i>=0) { vals[i]=v; times[i]=++t; return; } if(n<cap) { keys[n]=k; vals[n]=v; times[n++]=++t; } else { int mn=0; for(int j=1;j<n;j++) if(times[j]<times[mn]) mn=j; keys[mn]=k; vals[mn]=v; times[mn]=++t; } } };\\nint main() { LRUCache c(2); c.put(1,1); c.put(2,2); cout<<c.get(1); c.put(3,3); cout<<c.get(2); return 0; }","explanation":{"approach":"Track access times to identify least recently used.","steps":["On get/put, update access time","Evict entry with oldest access time"],"complexity":"Time: O(n) per op, Space: O(cap)"},"testCases":[{"input":"cap=2, operations","expectedOutput":"1-1","explanation":"2 evicted when 3 added"},{"input":"cap=1, put(1,1), put(2,2), get(1)","expectedOutput":"-1","explanation":"1 evicted"},{"input":"cap=2, put(1,1), get(1), put(2,2), get(1)","expectedOutput":"1 1","explanation":"1 stays recent"},{"input":"cap=2, put(1,1), put(1,2), get(1)","expectedOutput":"2","explanation":"Update value"}]},{"id":"h164","title":"Min Stack","description":"Stack that supports getMin in O(1).","difficulty":"HARD","category":"Design","starterCode":"#include <iostream>\\nusing namespace std;\\nclass MinStack {\\npublic:\\n    void push(int val) {}\\n    void pop() {}\\n    int top() { return 0; }\\n    int getMin() { return 0; }\\n};\\nint main() { MinStack s; s.push(-2); s.push(0); s.push(-3); cout<<s.getMin(); s.pop(); cout<<s.top(); cout<<s.getMin(); return 0; }","expectedOutput":"-30-2","solution":"#include <iostream>\\nusing namespace std;\\nclass MinStack { int stk[100],mstk[100],t,mt; public: MinStack():t(-1),mt(-1){} void push(int v) { stk[++t]=v; if(mt<0||v<=mstk[mt]) mstk[++mt]=v; } void pop() { if(stk[t--]==mstk[mt]) mt--; } int top() { return stk[t]; } int getMin() { return mstk[mt]; } };\\nint main() { MinStack s; s.push(-2); s.push(0); s.push(-3); cout<<s.getMin(); s.pop(); cout<<s.top(); cout<<s.getMin(); return 0; }","explanation":{"approach":"Two stacks - main and minimum tracking.","steps":["Push to min stack only when <= current min","Pop from min if top equals popped value"],"complexity":"Time: O(1) all ops, Space: O(n)"},"testCases":[{"input":"push(-2,0,-3), getMin, pop, top, getMin","expectedOutput":"-30-2","explanation":"Min changes after pop"},{"input":"push(1), getMin","expectedOutput":"1","explanation":"Single element"},{"input":"push(1,2,3), getMin","expectedOutput":"1","explanation":"First is min"},{"input":"push(3,2,1), pop, getMin","expectedOutput":"2","explanation":"Min updates"}]},{"id":"h165","title":"Find Median from Data Stream","description":"Maintain running median as numbers are added.","difficulty":"HARD","category":"Design","starterCode":"#include <iostream>\\nusing namespace std;\\nclass MedianFinder {\\npublic:\\n    void addNum(int num) {}\\n    double findMedian() { return 0; }\\n};\\nint main() { MedianFinder m; m.addNum(1); m.addNum(2); cout<<m.findMedian(); m.addNum(3); cout<<m.findMedian(); return 0; }","expectedOutput":"1.52","solution":"#include <iostream>\\nusing namespace std;\\nclass MedianFinder { int a[100],n; public: MedianFinder():n(0){} void addNum(int v) { int i=n++; a[i]=v; while(i>0&&a[i]<a[i-1]) { swap(a[i],a[i-1]); i--; } } double findMedian() { if(n%2) return a[n/2]; return (a[n/2-1]+a[n/2])/2.0; } };\\nint main() { MedianFinder m; m.addNum(1); m.addNum(2); cout<<m.findMedian(); m.addNum(3); cout<<m.findMedian(); return 0; }","explanation":{"approach":"Maintain sorted array, return middle element(s).","steps":["Insert and bubble to maintain sorted order","Odd count: middle, Even: average of two middle"],"complexity":"Time: O(n) insert, O(1) median"},"testCases":[{"input":"add(1,2), median, add(3), median","expectedOutput":"1.52","explanation":"1.5 then 2"},{"input":"add(5), median","expectedOutput":"5","explanation":"Single element"},{"input":"add(1,2,3,4), median","expectedOutput":"2.5","explanation":"Average of 2 and 3"},{"input":"add(3,1,2), median","expectedOutput":"2","explanation":"Middle after sorting"}]},{"id":"h166","title":"Serialize and Deserialize BST","description":"Convert BST to string and reconstruct it.","difficulty":"HARD","category":"Design","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nvoid serialize(Node* r) {}\\nNode* deserialize() { return nullptr; }\\nint main() { Node* r=new Node(2); r->l=new Node(1); r->r=new Node(3); serialize(r); cout<<\\"OK\\"; return 0; }","expectedOutput":"OK","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nvoid serialize(Node* r) { if(!r) { cout<<\\"# \\"; return; } cout<<r->v<<\\" \\"; serialize(r->l); serialize(r->r); }\\nNode* deserialize() { return nullptr; }\\nint main() { Node* r=new Node(2); r->l=new Node(1); r->r=new Node(3); serialize(r); cout<<\\"OK\\"; return 0; }","explanation":{"approach":"Preorder traversal with null markers.","steps":["Output value or # for null","Reconstruct using same order"],"complexity":"Time: O(n), Space: O(n)"},"testCases":[{"input":"BST [2,1,3]","expectedOutput":"OK","explanation":"Serialization works"},{"input":"Single node [5]","expectedOutput":"OK","explanation":"Single node tree"},{"input":"Empty tree","expectedOutput":"OK","explanation":"Empty outputs #"},{"input":"Left-skewed [3,2,1]","expectedOutput":"OK","explanation":"Linear tree"}]},{"id":"h167","title":"All O(1) Data Structure","description":"Inc/dec operations with getMax/getMin keys.","difficulty":"HARD","category":"Design","starterCode":"#include <iostream>\\nusing namespace std;\\nclass AllOne {\\npublic:\\n    void inc(char key[]) {}\\n    void dec(char key[]) {}\\n    void getMaxKey() {}\\n    void getMinKey() {}\\n};\\nint main() { AllOne a; cout<<\\"OK\\"; return 0; }","expectedOutput":"OK","solution":"#include <iostream>\\nusing namespace std;\\nclass AllOne { char keys[100][20]; int cnt[100]; int n; public: AllOne():n(0){} int find(char k[]) { for(int i=0;i<n;i++) { bool eq=true; for(int j=0;k[j]||keys[i][j];j++) if(k[j]!=keys[i][j]) { eq=false; break; } if(eq) return i; } return -1; } void inc(char k[]) { int i=find(k); if(i<0) { int j=0; while(k[j]) { keys[n][j]=k[j]; j++; } keys[n][j]=0; cnt[n++]=1; } else cnt[i]++; } void dec(char k[]) { int i=find(k); if(i>=0) cnt[i]--; } void getMaxKey() { int mx=0; for(int i=1;i<n;i++) if(cnt[i]>cnt[mx]) mx=i; if(n>0) cout<<keys[mx]; } void getMinKey() { int mn=0; for(int i=1;i<n;i++) if(cnt[i]>0&&cnt[i]<cnt[mn]) mn=i; if(n>0) cout<<keys[mn]; } };\\nint main() { AllOne a; cout<<\\"OK\\"; return 0; }","explanation":{"approach":"Track key-count pairs, scan for max/min.","steps":["Store keys and their counts","Linear scan for max/min"],"complexity":"Time: O(n), Space: O(n)"},"testCases":[{"input":"inc(a), inc(b), inc(a), getMaxKey","expectedOutput":"a","explanation":"a has count 2"},{"input":"inc(a), getMinKey","expectedOutput":"a","explanation":"Only key"},{"input":"inc(a), dec(a), getMaxKey","expectedOutput":"","explanation":"Count is 0"},{"input":"inc(a), inc(b), getMinKey","expectedOutput":"a or b","explanation":"Both count 1"}]},{"id":"h168","title":"Maximum Frequency Stack","description":"Pop the most frequent element, with recency as tiebreaker.","difficulty":"HARD","category":"Design","starterCode":"#include <iostream>\\nusing namespace std;\\nclass FreqStack {\\npublic:\\n    void push(int val) {}\\n    int pop() { return 0; }\\n};\\nint main() { FreqStack f; f.push(5); f.push(7); f.push(5); f.push(7); f.push(4); f.push(5); cout<<f.pop(); return 0; }","expectedOutput":"5","solution":"#include <iostream>\\nusing namespace std;\\nclass FreqStack { int stk[100][100],stkSz[100],freq[101],maxFreq,n; public: FreqStack():maxFreq(0),n(0){ for(int i=0;i<100;i++) stkSz[i]=0; for(int i=0;i<101;i++) freq[i]=0; } void push(int v) { freq[v]++; int f=freq[v]; stk[f][stkSz[f]++]=v; maxFreq=max(maxFreq,f); } int pop() { int v=stk[maxFreq][--stkSz[maxFreq]]; freq[v]--; if(stkSz[maxFreq]==0) maxFreq--; return v; } };\\nint main() { FreqStack f; f.push(5); f.push(7); f.push(5); f.push(7); f.push(4); f.push(5); cout<<f.pop(); return 0; }","explanation":{"approach":"Separate stack for each frequency level.","steps":["Push to stack at current frequency","Pop from highest frequency stack"],"complexity":"Time: O(1), Space: O(n)"},"testCases":[{"input":"push(5,7,5,7,4,5), pop()","expectedOutput":"5","explanation":"5 most frequent, most recent"},{"input":"push(1,1,1), pop,pop,pop","expectedOutput":"1 1 1","explanation":"All same"},{"input":"push(1,2,3), pop","expectedOutput":"3","explanation":"Tie, most recent wins"},{"input":"push(4,0,9,3,4,2), pop","expectedOutput":"4","explanation":"4 appears twice, most recent 4"}]}]'),yM=JSON.parse(`[{"id":"core1","title":"Factorial Recursion","description":"Calculate factorial recursively.","difficulty":"EASY","category":"Recursion","starterCode":"#include <iostream>\\nusing namespace std;\\nint factorial(int n) { return 0; }\\nint main() { cout<<factorial(5); return 0; }","expectedOutput":"120","solution":"#include <iostream>\\nusing namespace std;\\nint factorial(int n) { if(n <= 1) return 1; return n * factorial(n-1); }\\nint main() { cout<<factorial(5); return 0; }","explanation":{"approach":"n! = n  (n-1)! with base case 1! = 1","analogy":"Like Russian dolls - each level unwraps until you reach smallest doll.","steps":["Base: if n1, return 1","Recursive: return n  factorial(n-1)"],"complexity":"Time: O(n), Space: O(n)"},"testCases":[{"input":"n=5","expectedOutput":"120","explanation":"5! = 54321 = 120"},{"input":"n=0","expectedOutput":"1","explanation":"0! is defined as 1"},{"input":"n=1","expectedOutput":"1","explanation":"Base case: 1! = 1"},{"input":"n=10","expectedOutput":"3628800","explanation":"10! = 3,628,800"}]},{"id":"core2","title":"Fibonacci Recursion","description":"Nth Fibonacci number.","difficulty":"EASY","category":"Recursion","starterCode":"#include <iostream>\\nusing namespace std;\\nint fib(int n) { return 0; }\\nint main() { cout<<fib(10); return 0; }","expectedOutput":"55","solution":"#include <iostream>\\nusing namespace std;\\nint fib(int n) { if(n <= 1) return n; return fib(n-1) + fib(n-2); }\\nint main() { cout<<fib(10); return 0; }","explanation":{"approach":"F(n) = F(n-1) + F(n-2), base F(0)=0, F(1)=1","analogy":"Each rabbit pair breeds based on pairs before. Classic!","steps":["Base: n1 return n","Return fib(n-1) + fib(n-2)"],"complexity":"Time: O(2^n), Space: O(n)"},"testCases":[{"input":"n=10","expectedOutput":"55","explanation":"Fibonacci sequence: 0,1,1,2,3,5,8,13,21,34,55"},{"input":"n=0","expectedOutput":"0","explanation":"F(0) = 0"},{"input":"n=7","expectedOutput":"13","explanation":"F(7) = 13"},{"input":"n=20","expectedOutput":"6765","explanation":"F(20) = 6765"}]},{"id":"core3","title":"Sum to N Recursion","description":"Sum 1 to N recursively.","difficulty":"EASY","category":"Recursion","starterCode":"#include <iostream>\\nusing namespace std;\\nint sum(int n) { return 0; }\\nint main() { cout<<sum(10); return 0; }","expectedOutput":"55","solution":"#include <iostream>\\nusing namespace std;\\nint sum(int n) { if(n == 0) return 0; return n + sum(n-1); }\\nint main() { cout<<sum(10); return 0; }","explanation":{"approach":"sum(n) = n + sum(n-1)","analogy":"Stack coins - add current on top of smaller stack.","steps":["Base: n=0 return 0","Return n + sum(n-1)"],"complexity":"Time: O(n), Space: O(n)"},"testCases":[{"input":"n=10","expectedOutput":"55","explanation":"1+2+3+...+10 = 55"},{"input":"n=1","expectedOutput":"1","explanation":"Sum of just 1"},{"input":"n=100","expectedOutput":"5050","explanation":"Classic Gauss sum"},{"input":"n=0","expectedOutput":"0","explanation":"Sum of nothing is 0"}]},{"id":"core4","title":"Power Recursion","description":"Calculate x^n recursively.","difficulty":"EASY","category":"Recursion","starterCode":"#include <iostream>\\nusing namespace std;\\nint power(int x, int n) { return 0; }\\nint main() { cout<<power(2,10); return 0; }","expectedOutput":"1024","solution":"#include <iostream>\\nusing namespace std;\\nint power(int x, int n) { if(n == 0) return 1; return x * power(x, n-1); }\\nint main() { cout<<power(2,10); return 0; }","explanation":{"approach":"x^n = x  x^(n-1)","analogy":"Each level multiplies x once more.","steps":["Base: n=0 return 1","Return x  power(x, n-1)"],"complexity":"Time: O(n), Space: O(n)"},"testCases":[{"input":"x=2, n=10","expectedOutput":"1024","explanation":"2^10 = 1024"},{"input":"x=3, n=4","expectedOutput":"81","explanation":"3^4 = 81"},{"input":"x=5, n=0","expectedOutput":"1","explanation":"Any number^0 = 1"},{"input":"x=2, n=1","expectedOutput":"2","explanation":"2^1 = 2"}]},{"id":"core5","title":"GCD Recursion","description":"Euclidean algorithm.","difficulty":"EASY","category":"Recursion","starterCode":"#include <iostream>\\nusing namespace std;\\nint gcd(int a, int b) { return 0; }\\nint main() { cout<<gcd(48,18); return 0; }","expectedOutput":"6","solution":"#include <iostream>\\nusing namespace std;\\nint gcd(int a, int b) { if(b == 0) return a; return gcd(b, a % b); }\\nint main() { cout<<gcd(48,18); return 0; }","explanation":{"approach":"gcd(a,b) = gcd(b, a%b)","analogy":"Keep finding remainder until nothing left.","steps":["Base: b=0 return a","Return gcd(b, a%b)"],"complexity":"Time: O(log n), Space: O(log n)"},"testCases":[{"input":"a=48, b=18","expectedOutput":"6","explanation":"GCD(48,18) = 6"},{"input":"a=100, b=25","expectedOutput":"25","explanation":"GCD(100,25) = 25"},{"input":"a=17, b=5","expectedOutput":"1","explanation":"Coprime numbers have GCD 1"},{"input":"a=36, b=24","expectedOutput":"12","explanation":"GCD(36,24) = 12"}]},{"id":"core6","title":"Reverse String Recursion","description":"Reverse using recursion.","difficulty":"EASY","category":"Recursion","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid reverse(char s[], int start, int end) {}\\nint main() { char s[]=\\"hello\\"; reverse(s,0,4); cout<<s; return 0; }","expectedOutput":"olleh","solution":"#include <iostream>\\nusing namespace std;\\nvoid reverse(char s[], int l, int r) { if(l >= r) return; swap(s[l], s[r]); reverse(s, l+1, r-1); }\\nint main() { char s[]=\\"hello\\"; reverse(s,0,4); cout<<s; return 0; }","explanation":{"approach":"Swap ends, recurse on middle.","analogy":"Two people swap positions, then inner pair swaps.","steps":["Base: lr stop","Swap s[l] and s[r]","Recurse on middle"],"complexity":"Time: O(n), Space: O(n)"},"testCases":[{"input":"\\"hello\\"","expectedOutput":"olleh","explanation":"Reversed string"},{"input":"\\"a\\"","expectedOutput":"a","explanation":"Single char unchanged"},{"input":"\\"ab\\"","expectedOutput":"ba","explanation":"Two chars swapped"},{"input":"\\"abcdef\\"","expectedOutput":"fedcba","explanation":"Even length reversal"}]},{"id":"core7","title":"Check Palindrome Recursion","description":"Is palindrome recursively.","difficulty":"EASY","category":"Recursion","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isPalin(char s[], int l, int r) { return false; }\\nint main() { char s[]=\\"radar\\"; cout<<isPalin(s,0,4); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isPalin(char s[], int l, int r) { if(l >= r) return true; if(s[l] != s[r]) return false; return isPalin(s, l+1, r-1); }\\nint main() { char s[]=\\"radar\\"; cout<<isPalin(s,0,4); return 0; }","explanation":{"approach":"Compare ends, recurse on middle.","analogy":"Check if outer letters match, then check inner.","steps":["Base: lr return true","If s[l]s[r] return false","Recurse on middle"],"complexity":"Time: O(n), Space: O(n)"},"testCases":[{"input":"\\"radar\\"","expectedOutput":"1","explanation":"radar is a palindrome"},{"input":"\\"hello\\"","expectedOutput":"0","explanation":"hello is not a palindrome"},{"input":"\\"a\\"","expectedOutput":"1","explanation":"Single char is palindrome"},{"input":"\\"abba\\"","expectedOutput":"1","explanation":"Even length palindrome"}]},{"id":"core8","title":"Print 1 to N Recursion","description":"Print numbers ascending.","difficulty":"EASY","category":"Recursion","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid print(int n) {}\\nint main() { print(5); return 0; }","expectedOutput":"1 2 3 4 5","solution":"#include <iostream>\\nusing namespace std;\\nvoid print(int n) { if(n == 0) return; print(n-1); cout << n << (n<5?\\" \\":\\"\\"); }\\nint main() { print(5); return 0; }","explanation":{"approach":"Recurse first (go down), then print (coming back up).","analogy":"Dive to bottom, print on way back up.","steps":["Recurse to n-1 first","Then print n"],"complexity":"Time: O(n), Space: O(n)"},"testCases":[{"input":"n=5","expectedOutput":"1 2 3 4 5","explanation":"Print 1 through 5"},{"input":"n=1","expectedOutput":"1","explanation":"Single number"},{"input":"n=3","expectedOutput":"1 2 3","explanation":"Print 1 through 3"},{"input":"n=10","expectedOutput":"1 2 3 4 5 6 7 8 9 10","explanation":"Print 1 through 10"}]},{"id":"core9","title":"Print N to 1 Recursion","description":"Print numbers descending.","difficulty":"EASY","category":"Recursion","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid print(int n) {}\\nint main() { print(5); return 0; }","expectedOutput":"5 4 3 2 1","solution":"#include <iostream>\\nusing namespace std;\\nvoid print(int n) { if(n == 0) return; cout << n << (n>1?\\" \\":\\"\\"); print(n-1); }\\nint main() { print(5); return 0; }","explanation":{"approach":"Print first, then recurse.","analogy":"Print on way down the stairs.","steps":["Print n","Then recurse to n-1"],"complexity":"Time: O(n), Space: O(n)"},"testCases":[{"input":"n=5","expectedOutput":"5 4 3 2 1","explanation":"Print 5 down to 1"},{"input":"n=1","expectedOutput":"1","explanation":"Single number"},{"input":"n=3","expectedOutput":"3 2 1","explanation":"Print 3 down to 1"},{"input":"n=10","expectedOutput":"10 9 8 7 6 5 4 3 2 1","explanation":"Print 10 down to 1"}]},{"id":"core10","title":"Sum of Array Recursion","description":"Sum array recursively.","difficulty":"EASY","category":"Recursion","starterCode":"#include <iostream>\\nusing namespace std;\\nint sum(int a[], int n) { return 0; }\\nint main() { int a[]={1,2,3,4,5}; cout<<sum(a,5); return 0; }","expectedOutput":"15","solution":"#include <iostream>\\nusing namespace std;\\nint sum(int a[], int n) { if(n == 0) return 0; return a[n-1] + sum(a, n-1); }\\nint main() { int a[]={1,2,3,4,5}; cout<<sum(a,5); return 0; }","explanation":{"approach":"Add last element + sum of rest.","analogy":"Take last item, add to smaller pile's sum.","steps":["Base: n=0 return 0","Return a[n-1] + sum(a, n-1)"],"complexity":"Time: O(n), Space: O(n)"},"testCases":[{"input":"{1,2,3,4,5}","expectedOutput":"15","explanation":"1+2+3+4+5 = 15"},{"input":"{10}","expectedOutput":"10","explanation":"Single element"},{"input":"{1,1,1,1}","expectedOutput":"4","explanation":"Sum of four 1s"},{"input":"{-1,1,-1,1}","expectedOutput":"0","explanation":"Sum of alternating signs"}]},{"id":"core11","title":"Find Max Recursion","description":"Find max recursively.","difficulty":"EASY","category":"Recursion","starterCode":"#include <iostream>\\nusing namespace std;\\nint findMax(int a[], int n) { return 0; }\\nint main() { int a[]={3,7,1,9,2}; cout<<findMax(a,5); return 0; }","expectedOutput":"9","solution":"#include <iostream>\\nusing namespace std;\\nint findMax(int a[], int n) { if(n == 1) return a[0]; int m = findMax(a, n-1); return a[n-1] > m ? a[n-1] : m; }\\nint main() { int a[]={3,7,1,9,2}; cout<<findMax(a,5); return 0; }","explanation":{"approach":"Compare last element with max of rest.","analogy":"Find champion of smaller group, compare with last person.","steps":["Base: n=1 return a[0]","Get max of first n-1","Compare with a[n-1]"],"complexity":"Time: O(n), Space: O(n)"},"testCases":[{"input":"{3,7,1,9,2}","expectedOutput":"9","explanation":"Maximum is 9"},{"input":"{5}","expectedOutput":"5","explanation":"Single element is max"},{"input":"{1,2,3,4,5}","expectedOutput":"5","explanation":"Last element is max"},{"input":"{5,4,3,2,1}","expectedOutput":"5","explanation":"First element is max"}]},{"id":"core12","title":"Count Digits Recursion","description":"Count digits recursively.","difficulty":"EASY","category":"Recursion","starterCode":"#include <iostream>\\nusing namespace std;\\nint countDigits(int n) { return 0; }\\nint main() { cout<<countDigits(12345); return 0; }","expectedOutput":"5","solution":"#include <iostream>\\nusing namespace std;\\nint countDigits(int n) { if(n == 0) return 0; return 1 + countDigits(n/10); }\\nint main() { cout<<countDigits(12345); return 0; }","explanation":{"approach":"1 + count of remaining digits.","analogy":"Peel off one digit, count it, repeat.","steps":["Base: n=0 return 0","Return 1 + countDigits(n/10)"],"complexity":"Time: O(log n), Space: O(log n)"},"testCases":[{"input":"12345","expectedOutput":"5","explanation":"5 digit number"},{"input":"100","expectedOutput":"3","explanation":"3 digit number"},{"input":"7","expectedOutput":"1","explanation":"Single digit"},{"input":"999999","expectedOutput":"6","explanation":"6 digit number"}]}]`),OM=JSON.parse(`[{"id":"core13","title":"Check Prime","description":"Check if prime.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isPrime(int n) { return false; }\\nint main() { cout<<isPrime(17); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isPrime(int n) { if(n < 2) return false; for(int i = 2; i*i <= n; i++) if(n%i == 0) return false; return true; }\\nint main() { cout<<isPrime(17); return 0; }","explanation":{"approach":"Check divisibility from 2 to sqrt(n).","analogy":"Try dividing by all possible factors. If none work, it's prime.","steps":["If n<2, not prime","Check 2 to sqrt(n)","If any divides, not prime"],"complexity":"Time: O(sqrt n), Space: O(1)"},"testCases":[{"input":"n=17","expectedOutput":"1","explanation":"17 is prime"},{"input":"n=4","expectedOutput":"0","explanation":"4 is divisible by 2"},{"input":"n=1","expectedOutput":"0","explanation":"1 is not prime"},{"input":"n=97","expectedOutput":"1","explanation":"97 is a prime number"}]},{"id":"core14","title":"Binary to Decimal","description":"Convert binary to decimal.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nint toDecimal(int bin) { return 0; }\\nint main() { cout<<toDecimal(1101); return 0; }","expectedOutput":"13","solution":"#include <iostream>\\nusing namespace std;\\nint toDecimal(int bin) { int dec = 0, base = 1; while(bin > 0) { dec += (bin%10) * base; base *= 2; bin /= 10; } return dec; }\\nint main() { cout<<toDecimal(1101); return 0; }","explanation":{"approach":"Multiply each digit by 2^position.","analogy":"1101 = 18 + 14 + 02 + 11 = 13","steps":["Take last digit","Multiply by power of 2","Add to result"],"complexity":"Time: O(log n), Space: O(1)"},"testCases":[{"input":"1101","expectedOutput":"13","explanation":"Binary 1101 = 13"},{"input":"1000","expectedOutput":"8","explanation":"Binary 1000 = 8"},{"input":"111","expectedOutput":"7","explanation":"Binary 111 = 7"},{"input":"10101","expectedOutput":"21","explanation":"Binary 10101 = 21"}]},{"id":"core15","title":"Decimal to Binary","description":"Convert decimal to binary.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid toBinary(int n) {}\\nint main() { toBinary(13); return 0; }","expectedOutput":"1101","solution":"#include <iostream>\\nusing namespace std;\\nvoid toBinary(int n) { if(n == 0) { cout<<0; return; } int b[32], i = 0; while(n > 0) { b[i++] = n%2; n /= 2; } for(int j = i-1; j >= 0; j--) cout << b[j]; }\\nint main() { toBinary(13); return 0; }","explanation":{"approach":"Divide by 2, collect remainders, print reverse.","analogy":"13  2 = 6 r1, 6  2 = 3 r0, 3  2 = 1 r1, 1  2 = 0 r1  1101","steps":["Divide by 2","Store remainder","Print in reverse"],"complexity":"Time: O(log n), Space: O(log n)"},"testCases":[{"input":"13","expectedOutput":"1101","explanation":"13 in binary is 1101"},{"input":"8","expectedOutput":"1000","explanation":"8 in binary is 1000"},{"input":"0","expectedOutput":"0","explanation":"0 in binary is 0"},{"input":"255","expectedOutput":"11111111","explanation":"255 in binary is 8 ones"}]},{"id":"core16","title":"Octal to Decimal","description":"Convert octal to decimal.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nint toDecimal(int oct) { return 0; }\\nint main() { cout<<toDecimal(17); return 0; }","expectedOutput":"15","solution":"#include <iostream>\\nusing namespace std;\\nint toDecimal(int oct) { int dec = 0, base = 1; while(oct > 0) { dec += (oct%10) * base; base *= 8; oct /= 10; } return dec; }\\nint main() { cout<<toDecimal(17); return 0; }","explanation":{"approach":"Each digit multiplied by 8^position.","analogy":"17 = 18 + 71 = 15","steps":["Multiply digits by powers of 8"],"complexity":"Time: O(log n), Space: O(1)"},"testCases":[{"input":"17 (octal)","expectedOutput":"15","explanation":"17 in octal = 15 decimal"},{"input":"10 (octal)","expectedOutput":"8","explanation":"10 in octal = 8 decimal"},{"input":"77 (octal)","expectedOutput":"63","explanation":"77 in octal = 63 decimal"},{"input":"100 (octal)","expectedOutput":"64","explanation":"100 in octal = 64 decimal"}]},{"id":"core17","title":"Hexadecimal to Decimal","description":"Hex string to decimal.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nint toDecimal(char hex[]) { return 0; }\\nint main() { cout<<toDecimal(\\"1A\\"); return 0; }","expectedOutput":"26","solution":"#include <iostream>\\nusing namespace std;\\nint toDecimal(char h[]) { int d=0; for(int i=0; h[i]; i++) { d *= 16; if(h[i]>='0'&&h[i]<='9') d += h[i]-'0'; else d += h[i]-'A'+10; } return d; }\\nint main() { cout<<toDecimal(\\"1A\\"); return 0; }","explanation":{"approach":"Each digit/letter  16^position. A=10, B=11, etc.","analogy":"1A = 116 + 10 = 26","steps":["Parse each char","Multiply by 16","Add digit value"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"\\"1A\\"","expectedOutput":"26","explanation":"1A hex = 26 decimal"},{"input":"\\"FF\\"","expectedOutput":"255","explanation":"FF hex = 255 decimal"},{"input":"\\"10\\"","expectedOutput":"16","explanation":"10 hex = 16 decimal"},{"input":"\\"ABC\\"","expectedOutput":"2748","explanation":"ABC hex = 2748 decimal"}]},{"id":"core18","title":"LCM of Two Numbers","description":"Find LCM.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nint lcm(int a, int b) { return 0; }\\nint main() { cout<<lcm(12,18); return 0; }","expectedOutput":"36","solution":"#include <iostream>\\nusing namespace std;\\nint gcd(int a, int b) { return b==0 ? a : gcd(b, a%b); }\\nint lcm(int a, int b) { return (a * b) / gcd(a, b); }\\nint main() { cout<<lcm(12,18); return 0; }","explanation":{"approach":"LCM = (a  b) / GCD(a, b)","analogy":"LCM is smallest number both divide into.","steps":["Find GCD","LCM = ab / GCD"],"complexity":"Time: O(log n), Space: O(1)"},"testCases":[{"input":"a=12, b=18","expectedOutput":"36","explanation":"LCM(12,18) = 36"},{"input":"a=4, b=6","expectedOutput":"12","explanation":"LCM(4,6) = 12"},{"input":"a=5, b=7","expectedOutput":"35","explanation":"Coprime, LCM = product"},{"input":"a=3, b=9","expectedOutput":"9","explanation":"LCM when one divides other"}]},{"id":"core19","title":"Armstrong Number","description":"Sum of digit^n = number.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isArmstrong(int n) { return false; }\\nint main() { cout<<isArmstrong(153); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\n#include <cmath>\\nbool isArmstrong(int n) { int t=n, d=0, s=0; while(t>0){d++;t/=10;} t=n; while(t>0){s+=pow(t%10,d);t/=10;} return s==n; }\\nint main() { cout<<isArmstrong(153); return 0; }","explanation":{"approach":"Each digit raised to power of total digits, sum = n.","analogy":"153 = 1 + 5 + 3 = 1+125+27 = 153","steps":["Count digits","Sum each digit^count","Check if equals n"],"complexity":"Time: O(log n), Space: O(1)"},"testCases":[{"input":"153","expectedOutput":"1","explanation":"1+5+3 = 153"},{"input":"370","expectedOutput":"1","explanation":"3+7+0 = 370"},{"input":"123","expectedOutput":"0","explanation":"1+2+3  123"},{"input":"9474","expectedOutput":"1","explanation":"9+4+7+4 = 9474"}]},{"id":"core20","title":"Fibonacci Iterative","description":"Nth Fibonacci iteratively.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nint fib(int n) { return 0; }\\nint main() { cout<<fib(10); return 0; }","expectedOutput":"55","solution":"#include <iostream>\\nusing namespace std;\\nint fib(int n) { if(n <= 1) return n; int a=0, b=1; for(int i=2; i<=n; i++) { int c = a+b; a=b; b=c; } return b; }\\nint main() { cout<<fib(10); return 0; }","explanation":{"approach":"Keep two variables, update each iteration.","analogy":"Like climbing stairs - remember last two steps.","steps":["Start a=0, b=1","Loop: c=a+b, shift values"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"n=10","expectedOutput":"55","explanation":"F(10) = 55"},{"input":"n=0","expectedOutput":"0","explanation":"F(0) = 0"},{"input":"n=20","expectedOutput":"6765","explanation":"F(20) = 6765"},{"input":"n=1","expectedOutput":"1","explanation":"F(1) = 1"}]},{"id":"core21","title":"Sum of Divisors","description":"Sum all divisors.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nint sumDivisors(int n) { return 0; }\\nint main() { cout<<sumDivisors(12); return 0; }","expectedOutput":"28","solution":"#include <iostream>\\nusing namespace std;\\nint sumDivisors(int n) { int sum = 0; for(int i = 1; i <= n; i++) if(n % i == 0) sum += i; return sum; }\\nint main() { cout<<sumDivisors(12); return 0; }","explanation":{"approach":"Check each number 1 to n, add if divides evenly.","analogy":"12: 1+2+3+4+6+12 = 28","steps":["Loop 1 to n","If divides, add to sum"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"12","expectedOutput":"28","explanation":"1+2+3+4+6+12=28"},{"input":"6","expectedOutput":"12","explanation":"1+2+3+6=12 (perfect number)"},{"input":"7","expectedOutput":"8","explanation":"Prime: 1+7=8"},{"input":"28","expectedOutput":"56","explanation":"28 is a perfect number"}]},{"id":"core22","title":"Count Divisors","description":"Number of divisors.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nint countDivisors(int n) { return 0; }\\nint main() { cout<<countDivisors(12); return 0; }","expectedOutput":"6","solution":"#include <iostream>\\nusing namespace std;\\nint countDivisors(int n) { int c = 0; for(int i = 1; i <= n; i++) if(n % i == 0) c++; return c; }\\nint main() { cout<<countDivisors(12); return 0; }","explanation":{"approach":"Count numbers that divide n evenly.","analogy":"12 has 6 divisors: 1,2,3,4,6,12","steps":["Loop 1 to n","Count divisors"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"12","expectedOutput":"6","explanation":"Divisors: 1,2,3,4,6,12"},{"input":"7","expectedOutput":"2","explanation":"Prime has only 2 divisors"},{"input":"1","expectedOutput":"1","explanation":"1 has only itself"},{"input":"36","expectedOutput":"9","explanation":"Divisors: 1,2,3,4,6,9,12,18,36"}]},{"id":"core23","title":"Print Primes to N","description":"All primes up to N.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid primes(int n) {}\\nint main() { primes(20); return 0; }","expectedOutput":"2 3 5 7 11 13 17 19","solution":"#include <iostream>\\nusing namespace std;\\nbool isPrime(int n) { if(n<2) return false; for(int i=2;i*i<=n;i++) if(n%i==0) return false; return true; }\\nvoid primes(int n) { bool first=true; for(int i=2;i<=n;i++) if(isPrime(i)) { if(!first) cout<<\\" \\"; cout<<i; first=false; } }\\nint main() { primes(20); return 0; }","explanation":{"approach":"Check each number for primality.","analogy":"Filter out non-primes one by one.","steps":["Loop 2 to n","Check if prime","Print if yes"],"complexity":"Time: O(nn), Space: O(1)"},"testCases":[{"input":"n=20","expectedOutput":"2 3 5 7 11 13 17 19","explanation":"Primes up to 20"},{"input":"n=10","expectedOutput":"2 3 5 7","explanation":"Primes up to 10"},{"input":"n=2","expectedOutput":"2","explanation":"Only 2 up to 2"},{"input":"n=50","expectedOutput":"2 3 5 7 11 13 17 19 23 29 31 37 41 43 47","explanation":"Primes up to 50"}]},{"id":"core24","title":"Next Prime","description":"Find next prime after n.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nint nextPrime(int n) { return 0; }\\nint main() { cout<<nextPrime(10); return 0; }","expectedOutput":"11","solution":"#include <iostream>\\nusing namespace std;\\nbool isPrime(int n) { if(n<2) return false; for(int i=2;i*i<=n;i++) if(n%i==0) return false; return true; }\\nint nextPrime(int n) { n++; while(!isPrime(n)) n++; return n; }\\nint main() { cout<<nextPrime(10); return 0; }","explanation":{"approach":"Keep incrementing and check primality.","analogy":"Start after n, find first prime.","steps":["Increment n","Check if prime","Return when found"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"n=10","expectedOutput":"11","explanation":"Next prime after 10 is 11"},{"input":"n=13","expectedOutput":"17","explanation":"Next prime after 13 is 17"},{"input":"n=1","expectedOutput":"2","explanation":"First prime is 2"},{"input":"n=100","expectedOutput":"101","explanation":"Next prime after 100 is 101"}]}]`),vM=JSON.parse('[{"id":"core26","title":"Merge Sort Recursion","description":"Implement merge sort.","difficulty":"MEDIUM","category":"Recursion","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid mergeSort(int a[], int l, int r) {}\\nint main() { int a[]={38,27,43,3,9,82,10}; mergeSort(a,0,6); for(int i=0;i<7;i++) cout<<a[i]<<\\" \\"; return 0; }","expectedOutput":"3 9 10 27 38 43 82","solution":"#include <iostream>\\nusing namespace std;\\nvoid merge(int a[], int l, int m, int r) { int n1=m-l+1, n2=r-m; int L[n1], R[n2]; for(int i=0;i<n1;i++) L[i]=a[l+i]; for(int i=0;i<n2;i++) R[i]=a[m+1+i]; int i=0,j=0,k=l; while(i<n1 && j<n2) a[k++]=L[i]<=R[j]?L[i++]:R[j++]; while(i<n1) a[k++]=L[i++]; while(j<n2) a[k++]=R[j++]; }\\nvoid mergeSort(int a[], int l, int r) { if(l<r) { int m=(l+r)/2; mergeSort(a,l,m); mergeSort(a,m+1,r); merge(a,l,m,r); } }\\nint main() { int a[]={38,27,43,3,9,82,10}; mergeSort(a,0,6); for(int i=0;i<7;i++) cout<<a[i]<<\\" \\"; return 0; }","explanation":{"approach":"Divide in half, sort each, merge.","analogy":"Split deck, sort each half, merge sorted halves.","steps":["Split at middle","Recursively sort halves","Merge sorted halves"],"complexity":"Time: O(n log n), Space: O(n)"},"testCases":[{"input":"{38,27,43,3,9,82,10}","expectedOutput":"3 9 10 27 38 43 82","explanation":"Sorted array"},{"input":"{5,4,3,2,1}","expectedOutput":"1 2 3 4 5","explanation":"Reverse sorted"},{"input":"{1}","expectedOutput":"1","explanation":"Single element"},{"input":"{1,2,3,4,5}","expectedOutput":"1 2 3 4 5","explanation":"Already sorted"}]},{"id":"core27","title":"Quick Sort Recursion","description":"Implement quick sort.","difficulty":"MEDIUM","category":"Recursion","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid quickSort(int a[], int l, int r) {}\\nint main() { int a[]={10,7,8,9,1,5}; quickSort(a,0,5); for(int i=0;i<6;i++) cout<<a[i]<<\\" \\"; return 0; }","expectedOutput":"1 5 7 8 9 10","solution":"#include <iostream>\\nusing namespace std;\\nint partition(int a[], int l, int r) { int p=a[r], i=l-1; for(int j=l;j<r;j++) if(a[j]<p) { i++; swap(a[i],a[j]); } swap(a[i+1],a[r]); return i+1; }\\nvoid quickSort(int a[], int l, int r) { if(l<r) { int p=partition(a,l,r); quickSort(a,l,p-1); quickSort(a,p+1,r); } }\\nint main() { int a[]={10,7,8,9,1,5}; quickSort(a,0,5); for(int i=0;i<6;i++) cout<<a[i]<<\\" \\"; return 0; }","explanation":{"approach":"Pick pivot, partition around it, recurse.","analogy":"Put smaller left, larger right, repeat.","steps":["Choose pivot (last element)","Partition so smaller on left","Recurse on both sides"],"complexity":"Time: O(n log n) avg, Space: O(log n)"},"testCases":[{"input":"{10,7,8,9,1,5}","expectedOutput":"1 5 7 8 9 10","explanation":"Sorted array"},{"input":"{1,2,3}","expectedOutput":"1 2 3","explanation":"Already sorted"},{"input":"{3,3,3}","expectedOutput":"3 3 3","explanation":"All same"},{"input":"{9,8,7,6,5,4,3,2,1}","expectedOutput":"1 2 3 4 5 6 7 8 9","explanation":"Large reverse sorted"}]},{"id":"core28","title":"Count Paths in Grid","description":"Paths from top-left to bottom-right.","difficulty":"EASY","category":"Recursion","starterCode":"#include <iostream>\\nusing namespace std;\\nint countPaths(int m, int n) { return 0; }\\nint main() { cout<<countPaths(3,3); return 0; }","expectedOutput":"6","solution":"#include <iostream>\\nusing namespace std;\\nint countPaths(int m, int n) { if(m==1 || n==1) return 1; return countPaths(m-1,n) + countPaths(m,n-1); }\\nint main() { cout<<countPaths(3,3); return 0; }","explanation":{"approach":"Can only go right or down.","analogy":"Count ways to navigate grid.","steps":["Base: edge cells have 1 path","Each cell = paths from left + paths from above"],"complexity":"Time: O(2^(m+n)), Space: O(m+n)"},"testCases":[{"input":"m=3, n=3","expectedOutput":"6","explanation":"6 unique paths"},{"input":"m=2, n=2","expectedOutput":"2","explanation":"2 paths"},{"input":"m=1, n=5","expectedOutput":"1","explanation":"Only one path along edge"},{"input":"m=4, n=4","expectedOutput":"20","explanation":"C(6,3) = 20 paths"}]},{"id":"core29","title":"Ways to Climb Stairs","description":"1 or 2 steps at a time.","difficulty":"EASY","category":"Recursion","starterCode":"#include <iostream>\\nusing namespace std;\\nint climbStairs(int n) { return 0; }\\nint main() { cout<<climbStairs(5); return 0; }","expectedOutput":"8","solution":"#include <iostream>\\nusing namespace std;\\nint climbStairs(int n) { if(n<=2) return n; return climbStairs(n-1)+climbStairs(n-2); }\\nint main() { cout<<climbStairs(5); return 0; }","explanation":{"approach":"Fibonacci pattern - reach n from n-1 or n-2.","analogy":"Take 1 step from n-1 or 2 steps from n-2.","steps":["Base: 1 step=1 way, 2 steps=2 ways","f(n) = f(n-1) + f(n-2)"],"complexity":"Time: O(2^n), Space: O(n)"},"testCases":[{"input":"n=5","expectedOutput":"8","explanation":"8 ways to climb 5 stairs"},{"input":"n=3","expectedOutput":"3","explanation":"3 ways: 1+1+1, 1+2, 2+1"},{"input":"n=1","expectedOutput":"1","explanation":"Only one way"},{"input":"n=10","expectedOutput":"89","explanation":"89 ways for 10 stairs"}]},{"id":"core30","title":"Sieve of Eratosthenes","description":"Find all primes up to n.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid sieve(int n) {}\\nint main() { sieve(30); return 0; }","expectedOutput":"2 3 5 7 11 13 17 19 23 29","solution":"#include <iostream>\\nusing namespace std;\\nvoid sieve(int n) { bool p[n+1]; for(int i=0;i<=n;i++) p[i]=true; p[0]=p[1]=false; for(int i=2;i*i<=n;i++) if(p[i]) for(int j=i*i;j<=n;j+=i) p[j]=false; for(int i=2;i<=n;i++) if(p[i]) cout<<i<<\\" \\"; }\\nint main() { sieve(30); return 0; }","explanation":{"approach":"Mark multiples of each prime as composite.","analogy":"Cross out multiples, remaining are prime.","steps":["Assume all prime","For each prime, mark multiples","Print unmarked"],"complexity":"Time: O(n log log n), Space: O(n)"},"testCases":[{"input":"n=30","expectedOutput":"2 3 5 7 11 13 17 19 23 29","explanation":"Primes up to 30"},{"input":"n=10","expectedOutput":"2 3 5 7","explanation":"Primes up to 10"},{"input":"n=2","expectedOutput":"2","explanation":"Smallest prime"},{"input":"n=50","expectedOutput":"2 3 5 7 11 13 17 19 23 29 31 37 41 43 47","explanation":"Primes up to 50"}]},{"id":"core31","title":"Euclidean GCD","description":"Greatest common divisor.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nint gcd(int a, int b) { return 0; }\\nint main() { cout<<gcd(48,18); return 0; }","expectedOutput":"6","solution":"#include <iostream>\\nusing namespace std;\\nint gcd(int a, int b) { while(b) { int t=b; b=a%b; a=t; } return a; }\\nint main() { cout<<gcd(48,18); return 0; }","explanation":{"approach":"gcd(a,b) = gcd(b, a mod b).","analogy":"Keep taking remainders until 0.","steps":["Replace larger with remainder","Repeat until one is 0"],"complexity":"Time: O(log min(a,b)), Space: O(1)"},"testCases":[{"input":"a=48, b=18","expectedOutput":"6","explanation":"GCD(48,18) = 6"},{"input":"a=7, b=3","expectedOutput":"1","explanation":"Coprime numbers"},{"input":"a=12, b=12","expectedOutput":"12","explanation":"Same numbers"},{"input":"a=0, b=5","expectedOutput":"5","explanation":"GCD with 0"}]},{"id":"core32","title":"Modular Exponentiation","description":"Calculate (x^n) mod m.","difficulty":"MEDIUM","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nlong long modPow(long long x, long long n, long long m) { return 0; }\\nint main() { cout<<modPow(2,10,1000); return 0; }","expectedOutput":"24","solution":"#include <iostream>\\nusing namespace std;\\nlong long modPow(long long x, long long n, long long m) { long long res=1; x%=m; while(n>0) { if(n&1) res=res*x%m; n>>=1; x=x*x%m; } return res; }\\nint main() { cout<<modPow(2,10,1000); return 0; }","explanation":{"approach":"Square-and-multiply algorithm.","analogy":"Use binary representation of exponent.","steps":["If bit is 1, multiply result","Square base each iteration"],"complexity":"Time: O(log n), Space: O(1)"},"testCases":[{"input":"x=2, n=10, m=1000","expectedOutput":"24","explanation":"2^10 mod 1000 = 1024 mod 1000 = 24"},{"input":"x=3, n=5, m=7","expectedOutput":"5","explanation":"243 mod 7 = 5"},{"input":"x=2, n=0, m=10","expectedOutput":"1","explanation":"Any^0 = 1"},{"input":"x=10, n=9, m=6","expectedOutput":"4","explanation":"10^9 mod 6 = 4"}]},{"id":"core33","title":"Extended Euclidean","description":"Find x, y for ax + by = gcd.","difficulty":"MEDIUM","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nint extGCD(int a, int b, int &x, int &y) { return 0; }\\nint main() { int x,y; cout<<extGCD(30,20,x,y)<<\\" \\"<<x<<\\" \\"<<y; return 0; }","expectedOutput":"10 1 -1","solution":"#include <iostream>\\nusing namespace std;\\nint extGCD(int a, int b, int &x, int &y) { if(b==0) { x=1; y=0; return a; } int x1,y1; int g=extGCD(b,a%b,x1,y1); x=y1; y=x1-(a/b)*y1; return g; }\\nint main() { int x,y; cout<<extGCD(30,20,x,y)<<\\" \\"<<x<<\\" \\"<<y; return 0; }","explanation":{"approach":"Work backwards from base case.","analogy":"Express gcd as linear combination.","steps":["Base: gcd(a,0), x=1, y=0","Work back: x=y1, y=x1-(a/b)*y1"],"complexity":"Time: O(log min(a,b)), Space: O(log min(a,b))"},"testCases":[{"input":"a=30, b=20","expectedOutput":"10 1 -1","explanation":"30*1 + 20*(-1) = 10"},{"input":"a=35, b=15","expectedOutput":"5 1 -2","explanation":"35*1 + 15*(-2) = 5"},{"input":"a=7, b=5","expectedOutput":"1 -2 3","explanation":"7*(-2) + 5*3 = 1"},{"input":"a=15, b=10","expectedOutput":"5 1 -1","explanation":"15*1 + 10*(-1) = 5"}]},{"id":"core34","title":"Modular Inverse","description":"Find x where ax  1 (mod m).","difficulty":"MEDIUM","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nint modInverse(int a, int m) { return 0; }\\nint main() { cout<<modInverse(3,7); return 0; }","expectedOutput":"5","solution":"#include <iostream>\\nusing namespace std;\\nint extGCD(int a, int b, int &x, int &y) { if(b==0) { x=1; y=0; return a; } int x1,y1; int g=extGCD(b,a%b,x1,y1); x=y1; y=x1-(a/b)*y1; return g; }\\nint modInverse(int a, int m) { int x,y; extGCD(a,m,x,y); return (x%m+m)%m; }\\nint main() { cout<<modInverse(3,7); return 0; }","explanation":{"approach":"Use extended Euclidean algorithm.","analogy":"Find x such that ax gives remainder 1.","steps":["Use extGCD to find coefficients","Return x mod m"],"complexity":"Time: O(log m), Space: O(log m)"},"testCases":[{"input":"a=3, m=7","expectedOutput":"5","explanation":"3*5 = 15  1 (mod 7)"},{"input":"a=2, m=5","expectedOutput":"3","explanation":"2*3 = 6  1 (mod 5)"},{"input":"a=7, m=11","expectedOutput":"8","explanation":"7*8 = 56  1 (mod 11)"},{"input":"a=4, m=13","expectedOutput":"10","explanation":"4*10 = 40  1 (mod 13)"}]},{"id":"core35","title":"Chinese Remainder Theorem","description":"Find x satisfying system.","difficulty":"HARD","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nint crt(int r[], int m[], int n) { return 0; }\\nint main() { int r[]={2,3,2}, m[]={3,5,7}; cout<<crt(r,m,3); return 0; }","expectedOutput":"23","solution":"#include <iostream>\\nusing namespace std;\\nint extGCD(int a, int b, int &x, int &y) { if(b==0) { x=1; y=0; return a; } int x1,y1; int g=extGCD(b,a%b,x1,y1); x=y1; y=x1-(a/b)*y1; return g; }\\nint crt(int r[], int m[], int n) { int M=1; for(int i=0;i<n;i++) M*=m[i]; int res=0; for(int i=0;i<n;i++) { int Mi=M/m[i], x, y; extGCD(Mi,m[i],x,y); res=(res+r[i]*Mi*x)%M; } return (res%M+M)%M; }\\nint main() { int r[]={2,3,2}, m[]={3,5,7}; cout<<crt(r,m,3); return 0; }","explanation":{"approach":"Combine remainders using modular inverses.","analogy":"Find x satisfying multiple mod conditions.","steps":["Compute product M","For each: x += r[i] * M/m[i] * inverse"],"complexity":"Time: O(n log M), Space: O(1)"},"testCases":[{"input":"r={2,3,2}, m={3,5,7}","expectedOutput":"23","explanation":"23 mod 3=2, 23 mod 5=3, 23 mod 7=2"},{"input":"r={1,2}, m={3,5}","expectedOutput":"7","explanation":"7 mod 3=1, 7 mod 5=2"},{"input":"r={0,0}, m={2,3}","expectedOutput":"0","explanation":"0 satisfies both"},{"input":"r={1,1,1}, m={2,3,5}","expectedOutput":"1","explanation":"1 mod 2=1, 1 mod 3=1, 1 mod 5=1"}]}]'),bM=JSON.parse(`[{"id":"core31","title":"Climbing Stairs","description":"You are climbing a staircase with n steps. Each time you can climb 1 or 2 steps. How many distinct ways can you climb to the top?","difficulty":"EASY","category":"Dynamic Programming","starterCode":"#include <iostream>\\nusing namespace std;\\nint climbStairs(int n) { return 0; }\\nint main() { cout << climbStairs(4); return 0; }","expectedOutput":"5","solution":"#include <iostream>\\nusing namespace std;\\nint climbStairs(int n) {\\n    if(n <= 2) return n;\\n    int prev2 = 1, prev1 = 2;\\n    for(int i = 3; i <= n; i++) {\\n        int curr = prev1 + prev2;\\n        prev2 = prev1;\\n        prev1 = curr;\\n    }\\n    return prev1;\\n}\\nint main() { cout << climbStairs(4); return 0; }","explanation":{"approach":"Fibonacci-like DP. ways(n) = ways(n-1) + ways(n-2).","steps":["Base: 1 way for step 1, 2 ways for step 2","Each step = sum of prev two"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"n=4","expectedOutput":"5","explanation":"1+1+1+1, 1+1+2, 1+2+1, 2+1+1, 2+2"},{"input":"n=2","expectedOutput":"2","explanation":"1+1 or 2"},{"input":"n=1","expectedOutput":"1","explanation":"Only 1 step"},{"input":"n=5","expectedOutput":"8","explanation":"Fibonacci pattern"}]},{"id":"core32","title":"Coin Change","description":"Given coin denominations and target amount, find minimum coins needed. Return -1 if impossible.","difficulty":"MEDIUM","category":"Dynamic Programming","starterCode":"#include <iostream>\\nusing namespace std;\\nint coinChange(int coins[], int n, int amount) { return -1; }\\nint main() { int c[] = {1, 2, 5}; cout << coinChange(c, 3, 11); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nint coinChange(int coins[], int n, int amount) {\\n    int dp[amount + 1];\\n    for(int i = 0; i <= amount; i++) dp[i] = amount + 1;\\n    dp[0] = 0;\\n    for(int a = 1; a <= amount; a++) {\\n        for(int i = 0; i < n; i++) {\\n            if(coins[i] <= a)\\n                dp[a] = min(dp[a], dp[a - coins[i]] + 1);\\n        }\\n    }\\n    return dp[amount] > amount ? -1 : dp[amount];\\n}\\nint main() { int c[] = {1, 2, 5}; cout << coinChange(c, 3, 11); return 0; }","explanation":{"approach":"DP. dp[a] = min coins for amount a.","steps":["dp[0] = 0","For each amount, try each coin"],"complexity":"Time: O(amount  n), Space: O(amount)"},"testCases":[{"input":"coins=[1,2,5], amount=11","expectedOutput":"3","explanation":"5+5+1=11"},{"input":"coins=[2], amount=3","expectedOutput":"-1","explanation":"Impossible"},{"input":"coins=[1], amount=0","expectedOutput":"0","explanation":"No coins needed"},{"input":"coins=[1,5,10], amount=10","expectedOutput":"1","explanation":"Use one 10"}]},{"id":"core33","title":"Longest Common Subsequence","description":"Find length of longest common subsequence of two strings.","difficulty":"MEDIUM","category":"Dynamic Programming","starterCode":"#include <iostream>\\nusing namespace std;\\nint longestCommonSubsequence(char a[], char b[]) { return 0; }\\nint main() { cout << longestCommonSubsequence(\\"abcde\\", \\"ace\\"); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nint longestCommonSubsequence(char a[], char b[]) {\\n    int m = 0, n = 0;\\n    while(a[m]) m++;\\n    while(b[n]) n++;\\n    int dp[m + 1][n + 1];\\n    for(int i = 0; i <= m; i++) dp[i][0] = 0;\\n    for(int j = 0; j <= n; j++) dp[0][j] = 0;\\n    for(int i = 1; i <= m; i++) {\\n        for(int j = 1; j <= n; j++) {\\n            if(a[i-1] == b[j-1]) dp[i][j] = dp[i-1][j-1] + 1;\\n            else dp[i][j] = max(dp[i-1][j], dp[i][j-1]);\\n        }\\n    }\\n    return dp[m][n];\\n}\\nint main() { cout << longestCommonSubsequence(\\"abcde\\", \\"ace\\"); return 0; }","explanation":{"approach":"2D DP. Match chars or take max of skipping either.","steps":["If chars match, extend","Else max of skipping one"],"complexity":"Time: O(m  n), Space: O(m  n)"},"testCases":[{"input":"a='abcde', b='ace'","expectedOutput":"3","explanation":"LCS is 'ace'"},{"input":"a='abc', b='abc'","expectedOutput":"3","explanation":"Identical strings"},{"input":"a='abc', b='def'","expectedOutput":"0","explanation":"No common chars"},{"input":"a='', b='abc'","expectedOutput":"0","explanation":"Empty string"}]},{"id":"core34","title":"Word Break","description":"Can string be segmented into dictionary words?","difficulty":"MEDIUM","category":"Dynamic Programming","starterCode":"#include <iostream>\\nusing namespace std;\\nbool wordBreak(char s[], char* dict[], int n) { return false; }\\nint main() { char* d[] = {\\"leet\\", \\"code\\"}; cout << wordBreak(\\"leetcode\\", d, 2); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool match(char s[], int start, int end, char word[]) {\\n    int i = 0;\\n    for(int j = start; j < end; j++, i++)\\n        if(word[i] == 0 || s[j] != word[i]) return false;\\n    return word[i] == 0;\\n}\\nbool wordBreak(char s[], char* dict[], int n) {\\n    int len = 0; while(s[len]) len++;\\n    bool dp[len + 1];\\n    for(int i = 0; i <= len; i++) dp[i] = false;\\n    dp[0] = true;\\n    for(int i = 1; i <= len; i++) {\\n        for(int j = 0; j < i; j++) {\\n            if(dp[j]) {\\n                for(int w = 0; w < n; w++)\\n                    if(match(s, j, i, dict[w])) dp[i] = true;\\n            }\\n        }\\n    }\\n    return dp[len];\\n}\\nint main() { char* d[] = {\\"leet\\", \\"code\\"}; cout << wordBreak(\\"leetcode\\", d, 2); return 0; }","explanation":{"approach":"DP. dp[i] = can s[0..i-1] be segmented?","steps":["Check all positions","Match dictionary words"],"complexity":"Time: O(n  m  L), Space: O(n)"},"testCases":[{"input":"s='leetcode', dict=['leet','code']","expectedOutput":"1","explanation":"leet+code"},{"input":"s='applepenapple', dict=['apple','pen']","expectedOutput":"1","explanation":"apple+pen+apple"},{"input":"s='catsandog', dict=['cats','dog','sand']","expectedOutput":"0","explanation":"Cannot segment"},{"input":"s='', dict=['a']","expectedOutput":"1","explanation":"Empty string valid"}]},{"id":"core35","title":"House Robber","description":"Max money from houses, can't rob adjacent.","difficulty":"MEDIUM","category":"Dynamic Programming","starterCode":"#include <iostream>\\nusing namespace std;\\nint rob(int nums[], int n) { return 0; }\\nint main() { int h[] = {2, 7, 9, 3, 1}; cout << rob(h, 5); return 0; }","expectedOutput":"12","solution":"#include <iostream>\\nusing namespace std;\\nint rob(int nums[], int n) {\\n    if(n == 0) return 0;\\n    if(n == 1) return nums[0];\\n    int prev2 = nums[0];\\n    int prev1 = max(nums[0], nums[1]);\\n    for(int i = 2; i < n; i++) {\\n        int curr = max(prev1, prev2 + nums[i]);\\n        prev2 = prev1;\\n        prev1 = curr;\\n    }\\n    return prev1;\\n}\\nint main() { int h[] = {2, 7, 9, 3, 1}; cout << rob(h, 5); return 0; }","explanation":{"approach":"DP. Skip or rob current house.","steps":["Either skip (prev1) or rob (prev2 + nums[i])"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"[2,7,9,3,1]","expectedOutput":"12","explanation":"2+9+1=12"},{"input":"[1,2,3,1]","expectedOutput":"4","explanation":"1+3=4"},{"input":"[5]","expectedOutput":"5","explanation":"Single house"},{"input":"[2,1,1,2]","expectedOutput":"4","explanation":"2+2=4"}]},{"id":"core36","title":"Maximum Product Subarray","description":"Find contiguous subarray with largest product.","difficulty":"MEDIUM","category":"Dynamic Programming","starterCode":"#include <iostream>\\nusing namespace std;\\nint maxProduct(int nums[], int n) { return 0; }\\nint main() { int a[] = {2, 3, -2, 4}; cout << maxProduct(a, 4); return 0; }","expectedOutput":"6","solution":"#include <iostream>\\nusing namespace std;\\nint maxProduct(int nums[], int n) {\\n    int maxProd = nums[0], currMax = nums[0], currMin = nums[0];\\n    for(int i = 1; i < n; i++) {\\n        if(nums[i] < 0) { int t = currMax; currMax = currMin; currMin = t; }\\n        currMax = max(nums[i], currMax * nums[i]);\\n        currMin = min(nums[i], currMin * nums[i]);\\n        maxProd = max(maxProd, currMax);\\n    }\\n    return maxProd;\\n}\\nint main() { int a[] = {2, 3, -2, 4}; cout << maxProduct(a, 4); return 0; }","explanation":{"approach":"Track both max and min (for negative  negative).","steps":["Swap max/min on negative","Update both"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"[2,3,-2,4]","expectedOutput":"6","explanation":"23=6"},{"input":"[-2,0,-1]","expectedOutput":"0","explanation":"0 breaks product"},{"input":"[-2,3,-4]","expectedOutput":"24","explanation":"-23-4=24"},{"input":"[2]","expectedOutput":"2","explanation":"Single element"}]},{"id":"core37","title":"Longest Increasing Subsequence","description":"Find length of LIS (not contiguous).","difficulty":"MEDIUM","category":"Dynamic Programming","starterCode":"#include <iostream>\\nusing namespace std;\\nint lengthOfLIS(int nums[], int n) { return 0; }\\nint main() { int a[] = {10, 9, 2, 5, 3, 7, 101, 18}; cout << lengthOfLIS(a, 8); return 0; }","expectedOutput":"4","solution":"#include <iostream>\\nusing namespace std;\\nint lengthOfLIS(int nums[], int n) {\\n    if(n == 0) return 0;\\n    int dp[n];\\n    for(int i = 0; i < n; i++) dp[i] = 1;\\n    for(int i = 1; i < n; i++) {\\n        for(int j = 0; j < i; j++) {\\n            if(nums[j] < nums[i])\\n                dp[i] = max(dp[i], dp[j] + 1);\\n        }\\n    }\\n    int maxLen = 0;\\n    for(int i = 0; i < n; i++) maxLen = max(maxLen, dp[i]);\\n    return maxLen;\\n}\\nint main() { int a[] = {10, 9, 2, 5, 3, 7, 101, 18}; cout << lengthOfLIS(a, 8); return 0; }","explanation":{"approach":"dp[i] = LIS ending at i.","steps":["Check all previous smaller elements"],"complexity":"Time: O(n), Space: O(n)"},"testCases":[{"input":"[10,9,2,5,3,7,101,18]","expectedOutput":"4","explanation":"2,3,7,101 or 2,5,7,101"},{"input":"[0,1,0,3,2,3]","expectedOutput":"4","explanation":"0,1,2,3"},{"input":"[7,7,7,7]","expectedOutput":"1","explanation":"All same"},{"input":"[1,2,3]","expectedOutput":"3","explanation":"Already sorted"}]},{"id":"core38","title":"0/1 Knapsack","description":"Max value in knapsack with capacity W.","difficulty":"MEDIUM","category":"Dynamic Programming","starterCode":"#include <iostream>\\nusing namespace std;\\nint knapsack(int W, int wt[], int val[], int n) { return 0; }\\nint main() { int w[] = {1, 2, 3}; int v[] = {10, 15, 40}; cout << knapsack(5, w, v, 3); return 0; }","expectedOutput":"55","solution":"#include <iostream>\\nusing namespace std;\\nint knapsack(int W, int wt[], int val[], int n) {\\n    int dp[n + 1][W + 1];\\n    for(int i = 0; i <= n; i++) {\\n        for(int w = 0; w <= W; w++) {\\n            if(i == 0 || w == 0) dp[i][w] = 0;\\n            else if(wt[i-1] <= w)\\n                dp[i][w] = max(val[i-1] + dp[i-1][w - wt[i-1]], dp[i-1][w]);\\n            else dp[i][w] = dp[i-1][w];\\n        }\\n    }\\n    return dp[n][W];\\n}\\nint main() { int w[] = {1, 2, 3}; int v[] = {10, 15, 40}; cout << knapsack(5, w, v, 3); return 0; }","explanation":{"approach":"2D DP. Include or exclude each item.","steps":["For each item and capacity, take max of include/exclude"],"complexity":"Time: O(n  W), Space: O(n  W)"},"testCases":[{"input":"W=5, w=[1,2,3], v=[10,15,40]","expectedOutput":"55","explanation":"Items 0,2 (10+40+15 capacity fit)"},{"input":"W=0, w=[1], v=[10]","expectedOutput":"0","explanation":"No capacity"},{"input":"W=10, w=[5,4,6], v=[10,40,30]","expectedOutput":"50","explanation":"Items 1,0"},{"input":"W=3, w=[4], v=[100]","expectedOutput":"0","explanation":"Item too heavy"}]},{"id":"core39","title":"Unique Paths","description":"Count paths in mn grid (only right/down).","difficulty":"MEDIUM","category":"Dynamic Programming","starterCode":"#include <iostream>\\nusing namespace std;\\nint uniquePaths(int m, int n) { return 0; }\\nint main() { cout << uniquePaths(3, 7); return 0; }","expectedOutput":"28","solution":"#include <iostream>\\nusing namespace std;\\nint uniquePaths(int m, int n) {\\n    int dp[m][n];\\n    for(int j = 0; j < n; j++) dp[0][j] = 1;\\n    for(int i = 0; i < m; i++) dp[i][0] = 1;\\n    for(int i = 1; i < m; i++)\\n        for(int j = 1; j < n; j++)\\n            dp[i][j] = dp[i-1][j] + dp[i][j-1];\\n    return dp[m-1][n-1];\\n}\\nint main() { cout << uniquePaths(3, 7); return 0; }","explanation":{"approach":"dp[i][j] = paths from top + paths from left.","steps":["First row/col = 1","Each cell = sum of above and left"],"complexity":"Time: O(m  n), Space: O(m  n)"},"testCases":[{"input":"m=3, n=7","expectedOutput":"28","explanation":"Combinatorial"},{"input":"m=3, n=2","expectedOutput":"3","explanation":"RRD, RDR, DRR"},{"input":"m=1, n=1","expectedOutput":"1","explanation":"Already at end"},{"input":"m=2, n=2","expectedOutput":"2","explanation":"RD or DR"}]},{"id":"core40","title":"Jump Game","description":"Can you reach last index?","difficulty":"MEDIUM","category":"Dynamic Programming","starterCode":"#include <iostream>\\nusing namespace std;\\nbool canJump(int nums[], int n) { return false; }\\nint main() { int a[] = {2, 3, 1, 1, 4}; cout << canJump(a, 5); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool canJump(int nums[], int n) {\\n    int maxReach = 0;\\n    for(int i = 0; i < n; i++) {\\n        if(i > maxReach) return false;\\n        maxReach = max(maxReach, i + nums[i]);\\n        if(maxReach >= n - 1) return true;\\n    }\\n    return true;\\n}\\nint main() { int a[] = {2, 3, 1, 1, 4}; cout << canJump(a, 5); return 0; }","explanation":{"approach":"Greedy. Track max reachable index.","steps":["Update max reach at each position"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"[2,3,1,1,4]","expectedOutput":"1","explanation":"Jump 12end"},{"input":"[3,2,1,0,4]","expectedOutput":"0","explanation":"Stuck at index 3"},{"input":"[0]","expectedOutput":"1","explanation":"Already at end"},{"input":"[2,0,0]","expectedOutput":"1","explanation":"Jump directly"}]}]`),SM=JSON.parse(`[{"id":"core46","title":"N Queens Count","description":"Count N-Queens solutions.","difficulty":"HARD","category":"Backtracking","starterCode":"#include <iostream>\\nusing namespace std;\\nint solveNQueens(int n) { return 0; }\\nint main() { cout<<solveNQueens(4); return 0; }","expectedOutput":"2","solution":"#include <iostream>\\nusing namespace std;\\nint cnt; bool col[20],d1[40],d2[40];\\nvoid solve(int r, int n) { if(r==n){cnt++;return;} for(int c=0;c<n;c++) if(!col[c]&&!d1[r-c+n]&&!d2[r+c]) { col[c]=d1[r-c+n]=d2[r+c]=1; solve(r+1,n); col[c]=d1[r-c+n]=d2[r+c]=0; } }\\nint solveNQueens(int n) { cnt=0; solve(0,n); return cnt; }\\nint main() { cout<<solveNQueens(4); return 0; }","explanation":{"approach":"Backtracking with column and diagonal tracking.","steps":["Place queen in each valid column","Check column and diagonals"],"complexity":"Time: O(n!), Space: O(n)"},"testCases":[{"input":"n=4","expectedOutput":"2","explanation":"Two distinct solutions"},{"input":"n=1","expectedOutput":"1","explanation":"Single cell, single queen"},{"input":"n=8","expectedOutput":"92","explanation":"Classic 8-queens"},{"input":"n=2","expectedOutput":"0","explanation":"No valid arrangement"}]},{"id":"core47","title":"Sudoku Solver","description":"Solve sudoku puzzle.","difficulty":"HARD","category":"Backtracking","starterCode":"#include <iostream>\\nusing namespace std;\\nbool solveSudoku(int b[][9]) { return false; }\\nint main() { int b[9][9]={{5,3,0,0,7,0,0,0,0},{6,0,0,1,9,5,0,0,0},{0,9,8,0,0,0,0,6,0},{8,0,0,0,6,0,0,0,3},{4,0,0,8,0,3,0,0,1},{7,0,0,0,2,0,0,0,6},{0,6,0,0,0,0,2,8,0},{0,0,0,4,1,9,0,0,5},{0,0,0,0,8,0,0,7,9}}; cout<<solveSudoku(b); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isValid(int b[][9], int r, int c, int n) { for(int i=0;i<9;i++) if(b[r][i]==n||b[i][c]==n) return false; int br=r-r%3, bc=c-c%3; for(int i=0;i<3;i++) for(int j=0;j<3;j++) if(b[br+i][bc+j]==n) return false; return true; }\\nbool solve(int b[][9]) { for(int r=0;r<9;r++) for(int c=0;c<9;c++) if(b[r][c]==0) { for(int n=1;n<=9;n++) if(isValid(b,r,c,n)) { b[r][c]=n; if(solve(b)) return true; b[r][c]=0; } return false; } return true; }\\nbool solveSudoku(int b[][9]) { return solve(b); }\\nint main() { int b[9][9]={{5,3,0,0,7,0,0,0,0},{6,0,0,1,9,5,0,0,0},{0,9,8,0,0,0,0,6,0},{8,0,0,0,6,0,0,0,3},{4,0,0,8,0,3,0,0,1},{7,0,0,0,2,0,0,0,6},{0,6,0,0,0,0,2,8,0},{0,0,0,4,1,9,0,0,5},{0,0,0,0,8,0,0,7,9}}; cout<<solveSudoku(b); return 0; }","explanation":{"approach":"Backtracking with constraint checking.","steps":["Find empty cell","Try 1-9","Backtrack if invalid"],"complexity":"Time: O(9^81), Space: O(81)"},"testCases":[{"input":"Valid sudoku puzzle","expectedOutput":"1","explanation":"Solvable puzzle"},{"input":"Already solved sudoku","expectedOutput":"1","explanation":"No empty cells"},{"input":"Easy puzzle (few blanks)","expectedOutput":"1","explanation":"Quick solve"},{"input":"Hard puzzle (many blanks)","expectedOutput":"1","explanation":"More backtracking"}]},{"id":"core48","title":"Generate Parentheses","description":"All valid parentheses for n pairs.","difficulty":"MEDIUM","category":"Backtracking","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid generate(int n) {}\\nint main() { generate(3); return 0; }","expectedOutput":"((()))(()())(())()(())()(())","solution":"#include <iostream>\\nusing namespace std;\\nvoid gen(char s[], int i, int o, int c, int n) { if(i==2*n) { s[i]=0; cout<<s; return; } if(o<n) { s[i]='('; gen(s,i+1,o+1,c,n); } if(c<o) { s[i]=')'; gen(s,i+1,o,c+1,n); } }\\nvoid generate(int n) { char s[20]; gen(s,0,0,0,n); }\\nint main() { generate(3); return 0; }","explanation":{"approach":"Track open and close counts.","steps":["Add ( if open < n","Add ) if close < open"],"complexity":"Time: O(4^n/n), Space: O(n)"},"testCases":[{"input":"n=3","expectedOutput":"((()))(()())(())()(())()(())","explanation":"5 combinations for 3 pairs"},{"input":"n=1","expectedOutput":"()","explanation":"Only one way"},{"input":"n=2","expectedOutput":"(())()()","explanation":"Two combinations"},{"input":"n=0","expectedOutput":"","explanation":"No parentheses"}]},{"id":"core49","title":"Combination Sum","description":"Find combinations summing to target (can reuse).","difficulty":"MEDIUM","category":"Backtracking","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid combSum(int a[], int n, int t) {}\\nint main() { int a[]={2,3,6,7}; combSum(a,4,7); return 0; }","expectedOutput":"2 2 3 7","solution":"#include <iostream>\\nusing namespace std;\\nvoid solve(int a[], int n, int t, int i, int c[], int k) { if(t==0) { for(int j=0;j<k;j++) cout<<c[j]<<\\" \\"; return; } if(t<0||i>=n) return; c[k]=a[i]; solve(a,n,t-a[i],i,c,k+1); solve(a,n,t,i+1,c,k); }\\nvoid combSum(int a[], int n, int t) { int c[20]; solve(a,n,t,0,c,0); }\\nint main() { int a[]={2,3,6,7}; combSum(a,4,7); return 0; }","explanation":{"approach":"Include (possibly multiple) or skip.","steps":["Include current, stay at index","Or skip to next"],"complexity":"Time: O(2^target), Space: O(target)"},"testCases":[{"input":"a=[2,3,6,7], t=7","expectedOutput":"2 2 3 7","explanation":"2+2+3=7 and 7=7"},{"input":"a=[2,3,5], t=8","expectedOutput":"2 2 2 2 2 3 3 3 5","explanation":"Multiple combos"},{"input":"a=[2], t=1","expectedOutput":"","explanation":"No valid combination"},{"input":"a=[1], t=2","expectedOutput":"1 1","explanation":"Use 1 twice"}]},{"id":"core50","title":"Permutations","description":"Generate all permutations of array.","difficulty":"MEDIUM","category":"Backtracking","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid permute(int a[], int n) {}\\nint main() { int a[]={1,2,3}; permute(a,3); return 0; }","expectedOutput":"1 2 3 1 3 2 2 1 3 2 3 1 3 2 1 3 1 2","solution":"#include <iostream>\\nusing namespace std;\\nvoid perm(int a[], int l, int r) { if(l==r) { for(int i=0;i<=r;i++) cout<<a[i]<<\\" \\"; return; } for(int i=l;i<=r;i++) { swap(a[l],a[i]); perm(a,l+1,r); swap(a[l],a[i]); } }\\nvoid permute(int a[], int n) { perm(a,0,n-1); }\\nint main() { int a[]={1,2,3}; permute(a,3); return 0; }","explanation":{"approach":"Swap each element to front, permute rest.","steps":["Swap current with each position","Recurse on rest"],"complexity":"Time: O(n!), Space: O(n)"},"testCases":[{"input":"[1,2,3]","expectedOutput":"6 permutations","explanation":"3!=6 arrangements"},{"input":"[1,2]","expectedOutput":"1 2 2 1","explanation":"2 permutations"},{"input":"[1]","expectedOutput":"1","explanation":"Single element"},{"input":"[1,2,3,4]","expectedOutput":"24 permutations","explanation":"4!=24"}]},{"id":"core51","title":"Word Search","description":"Find word in character grid.","difficulty":"MEDIUM","category":"Backtracking","starterCode":"#include <iostream>\\nusing namespace std;\\nbool exist(char b[][4], int r, int c, char w[]) { return false; }\\nint main() { char b[][4]={{'A','B','C','E'},{'S','F','C','S'},{'A','D','E','E'}}; cout<<exist(b,3,4,\\"ABCCED\\"); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool dfs(char b[][4], int r, int c, int i, int j, char w[], int k) { if(!w[k]) return true; if(i<0||i>=r||j<0||j>=c||b[i][j]!=w[k]) return false; char t=b[i][j]; b[i][j]='#'; bool f=dfs(b,r,c,i+1,j,w,k+1)||dfs(b,r,c,i-1,j,w,k+1)||dfs(b,r,c,i,j+1,w,k+1)||dfs(b,r,c,i,j-1,w,k+1); b[i][j]=t; return f; }\\nbool exist(char b[][4], int r, int c, char w[]) { for(int i=0;i<r;i++) for(int j=0;j<c;j++) if(dfs(b,r,c,i,j,w,0)) return true; return false; }\\nint main() { char b[][4]={{'A','B','C','E'},{'S','F','C','S'},{'A','D','E','E'}}; cout<<exist(b,3,4,\\"ABCCED\\"); return 0; }","explanation":{"approach":"DFS from each cell, mark visited.","steps":["Try each starting cell","DFS in 4 directions"],"complexity":"Time: O(rc4^L), Space: O(L)"},"testCases":[{"input":"grid with 'ABCCED'","expectedOutput":"1","explanation":"Word exists"},{"input":"grid with 'SEE'","expectedOutput":"1","explanation":"Another word"},{"input":"grid with 'ABCB'","expectedOutput":"0","explanation":"Can't reuse cells"},{"input":"single cell 'A', word='A'","expectedOutput":"1","explanation":"Match"}]},{"id":"core52","title":"Palindrome Partitioning","description":"Find all palindrome partitions of string.","difficulty":"MEDIUM","category":"Backtracking","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid partition(char s[]) {}\\nint main() { partition(\\"aab\\"); return 0; }","expectedOutput":"a a b aa b","solution":"#include <iostream>\\nusing namespace std;\\nbool isPalin(char s[], int l, int r) { while(l<r) if(s[l++]!=s[r--]) return false; return true; }\\nvoid solve(char s[], int start, char cur[][10], int k, int n) { if(start>=n) { for(int i=0;i<k;i++) cout<<cur[i]<<\\" \\"; return; } for(int end=start;end<n;end++) if(isPalin(s,start,end)) { int len=0; for(int i=start;i<=end;i++) cur[k][len++]=s[i]; cur[k][len]=0; solve(s,end+1,cur,k+1,n); } }\\nvoid partition(char s[]) { int n=0; while(s[n]) n++; char cur[10][10]; solve(s,0,cur,0,n); }\\nint main() { partition(\\"aab\\"); return 0; }","explanation":{"approach":"Try all palindrome substrings.","steps":["For each position, try all palindrome cuts"],"complexity":"Time: O(n  2^n), Space: O(n)"},"testCases":[{"input":"s='aab'","expectedOutput":"[a,a,b] [aa,b]","explanation":"Two valid partitions"},{"input":"s='a'","expectedOutput":"[a]","explanation":"Single char"},{"input":"s='aba'","expectedOutput":"[a,b,a] [aba]","explanation":"Whole string is palindrome"},{"input":"s='abc'","expectedOutput":"[a,b,c]","explanation":"No multi-char palindromes"}]},{"id":"core53","title":"Letter Combinations","description":"Phone number letter combinations.","difficulty":"MEDIUM","category":"Backtracking","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid letterCombos(char d[]) {}\\nint main() { letterCombos(\\"23\\"); return 0; }","expectedOutput":"ad ae af bd be bf cd ce cf","solution":"#include <iostream>\\nusing namespace std;\\nconst char* map[]={\\"abc\\",\\"def\\",\\"ghi\\",\\"jkl\\",\\"mno\\",\\"pqrs\\",\\"tuv\\",\\"wxyz\\"};\\nvoid solve(char d[], int i, char r[], int k, int n) { if(i==n) { r[k]=0; cout<<r<<\\" \\"; return; } const char* letters=map[d[i]-'2']; for(int j=0;letters[j];j++) { r[k]=letters[j]; solve(d,i+1,r,k+1,n); } }\\nvoid letterCombos(char d[]) { int n=0; while(d[n]) n++; if(n==0) return; char r[10]; solve(d,0,r,0,n); }\\nint main() { letterCombos(\\"23\\"); return 0; }","explanation":{"approach":"Map digits to letters, generate combos.","steps":["Map each digit to letters","Try each letter, recurse"],"complexity":"Time: O(4^n), Space: O(n)"},"testCases":[{"input":"d='23'","expectedOutput":"ad ae af bd be bf cd ce cf","explanation":"9 combinations"},{"input":"d='2'","expectedOutput":"a b c","explanation":"3 letters for digit 2"},{"input":"d=''","expectedOutput":"","explanation":"Empty input"},{"input":"d='7'","expectedOutput":"p q r s","explanation":"4 letters for digit 7"}]},{"id":"core54","title":"Subsets II","description":"Generate subsets with duplicates.","difficulty":"MEDIUM","category":"Backtracking","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid subsetsWithDup(int a[], int n) {}\\nint main() { int a[]={1,2,2}; subsetsWithDup(a,3); return 0; }","expectedOutput":"{} {1} {1 2} {1 2 2} {2} {2 2}","solution":"#include <iostream>\\nusing namespace std;\\nvoid solve(int a[], int n, int i, int c[], int k) { cout<<\\"{\\"; for(int j=0;j<k;j++) cout<<(j?\\" \\":\\"\\")<<c[j]; cout<<\\"} \\"; for(int j=i;j<n;j++) { if(j>i && a[j]==a[j-1]) continue; c[k]=a[j]; solve(a,n,j+1,c,k+1); } }\\nvoid subsetsWithDup(int a[], int n) { for(int i=0;i<n-1;i++) for(int j=0;j<n-i-1;j++) if(a[j]>a[j+1]) swap(a[j],a[j+1]); int c[10]; solve(a,n,0,c,0); }\\nint main() { int a[]={1,2,2}; subsetsWithDup(a,3); return 0; }","explanation":{"approach":"Sort and skip consecutive duplicates.","steps":["Sort array","Skip if same as previous at same level"],"complexity":"Time: O(2^n), Space: O(n)"},"testCases":[{"input":"[1,2,2]","expectedOutput":"6 unique subsets","explanation":"Handles duplicates"},{"input":"[0]","expectedOutput":"{} {0}","explanation":"Single element"},{"input":"[1,1,1]","expectedOutput":"{} {1} {1,1} {1,1,1}","explanation":"All same"},{"input":"[1,2,3]","expectedOutput":"8 subsets","explanation":"No dups, all combos"}]},{"id":"core55","title":"Combination Sum III","description":"Find k numbers from 1-9 summing to n.","difficulty":"MEDIUM","category":"Backtracking","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid combSum3(int k, int n) {}\\nint main() { combSum3(3,9); return 0; }","expectedOutput":"1 2 6 1 3 5 2 3 4","solution":"#include <iostream>\\nusing namespace std;\\nvoid solve(int k, int n, int start, int c[], int cnt) { if(cnt==k && n==0) { for(int i=0;i<k;i++) cout<<c[i]<<\\" \\"; return; } if(cnt>=k||n<=0) return; for(int i=start;i<=9;i++) { c[cnt]=i; solve(k,n-i,i+1,c,cnt+1); } }\\nvoid combSum3(int k, int n) { int c[10]; solve(k,n,1,c,0); }\\nint main() { combSum3(3,9); return 0; }","explanation":{"approach":"Pick k numbers from 1-9 summing to n.","steps":["Try each number 1-9","Track count and sum"],"complexity":"Time: O(C(9,k)), Space: O(k)"},"testCases":[{"input":"k=3, n=9","expectedOutput":"[1,2,6] [1,3,5] [2,3,4]","explanation":"Three combos"},{"input":"k=3, n=7","expectedOutput":"[1,2,4]","explanation":"Only one combo"},{"input":"k=2, n=18","expectedOutput":"","explanation":"Max is 8+9=17"},{"input":"k=1, n=5","expectedOutput":"[5]","explanation":"Single number"}]}]`),wM=JSON.parse(`[{"id":"core51","title":"Valid Sudoku","description":"Check if a 99 Sudoku board is valid (no duplicates in rows, columns, or 33 boxes).","difficulty":"MEDIUM","category":"Matrix","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isValidSudoku(char board[][9]) { return false; }\\nint main() { cout << \\"Check Sudoku\\"; return 0; }","expectedOutput":"Check Sudoku","solution":"#include <iostream>\\nusing namespace std;\\nbool isValidSudoku(char board[][9]) {\\n    for(int i = 0; i < 9; i++) {\\n        bool row[10] = {}, col[10] = {}, box[10] = {};\\n        for(int j = 0; j < 9; j++) {\\n            if(board[i][j] != '.') {\\n                int d = board[i][j] - '0';\\n                if(row[d]) return false;\\n                row[d] = true;\\n            }\\n            if(board[j][i] != '.') {\\n                int d = board[j][i] - '0';\\n                if(col[d]) return false;\\n                col[d] = true;\\n            }\\n            int boxRow = 3 * (i / 3) + j / 3;\\n            int boxCol = 3 * (i % 3) + j % 3;\\n            if(board[boxRow][boxCol] != '.') {\\n                int d = board[boxRow][boxCol] - '0';\\n                if(box[d]) return false;\\n                box[d] = true;\\n            }\\n        }\\n    }\\n    return true;\\n}\\nint main() { cout << \\"Check Sudoku\\"; return 0; }","explanation":{"approach":"Check each row, column, and 33 box for duplicates.","steps":["Track seen digits with boolean arrays","Check all three in one pass"],"complexity":"Time: O(81), Space: O(1)"},"testCases":[{"input":"Valid partial sudoku","expectedOutput":"1","explanation":"No rule violations"},{"input":"Duplicate in row","expectedOutput":"0","explanation":"Same digit twice in row"},{"input":"Duplicate in column","expectedOutput":"0","explanation":"Same digit twice in column"},{"input":"Duplicate in 3x3 box","expectedOutput":"0","explanation":"Same digit in sub-box"}]},{"id":"core52","title":"Rotate Image","description":"Rotate nn matrix 90 clockwise in-place.","difficulty":"MEDIUM","category":"Matrix","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid rotate(int m[][3], int n) {}\\nint main() { int m[][3] = {{1,2,3}, {4,5,6}, {7,8,9}}; rotate(m, 3); for(int i=0;i<3;i++) for(int j=0;j<3;j++) cout << m[i][j] << \\" \\"; return 0; }","expectedOutput":"7 4 1 8 5 2 9 6 3","solution":"#include <iostream>\\nusing namespace std;\\nvoid rotate(int m[][3], int n) {\\n    for(int i = 0; i < n; i++)\\n        for(int j = i; j < n; j++)\\n            swap(m[i][j], m[j][i]);\\n    for(int i = 0; i < n; i++) {\\n        int l = 0, r = n - 1;\\n        while(l < r) swap(m[i][l++], m[i][r--]);\\n    }\\n}\\nint main() { int m[][3] = {{1,2,3}, {4,5,6}, {7,8,9}}; rotate(m, 3); for(int i=0;i<3;i++) for(int j=0;j<3;j++) cout << m[i][j] << \\" \\"; return 0; }","explanation":{"approach":"Transpose then reverse each row.","steps":["Swap m[i][j] with m[j][i]","Reverse each row"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"3x3 matrix [[1,2,3],[4,5,6],[7,8,9]]","expectedOutput":"7 4 1 8 5 2 9 6 3","explanation":"90 clockwise rotation"},{"input":"1x1 matrix [[1]]","expectedOutput":"1","explanation":"Single element unchanged"},{"input":"2x2 matrix [[1,2],[3,4]]","expectedOutput":"3 1 4 2","explanation":"Simple 2x2 rotation"},{"input":"4x4 matrix","expectedOutput":"Rotated 4x4","explanation":"Larger matrix works"}]},{"id":"core53","title":"Set Matrix Zeroes","description":"If element is 0, set entire row and column to 0. Use O(1) space.","difficulty":"MEDIUM","category":"Matrix","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid setZeroes(int m[][3], int rows, int cols) {}\\nint main() { int m[][3] = {{1,1,1}, {1,0,1}, {1,1,1}}; setZeroes(m, 3, 3); for(int i=0;i<3;i++) for(int j=0;j<3;j++) cout << m[i][j] << \\" \\"; return 0; }","expectedOutput":"1 0 1 0 0 0 1 0 1","solution":"#include <iostream>\\nusing namespace std;\\nvoid setZeroes(int m[][3], int rows, int cols) {\\n    bool firstRowZero = false, firstColZero = false;\\n    for(int j = 0; j < cols; j++) if(m[0][j] == 0) firstRowZero = true;\\n    for(int i = 0; i < rows; i++) if(m[i][0] == 0) firstColZero = true;\\n    for(int i = 1; i < rows; i++)\\n        for(int j = 1; j < cols; j++)\\n            if(m[i][j] == 0) { m[i][0] = 0; m[0][j] = 0; }\\n    for(int i = 1; i < rows; i++)\\n        for(int j = 1; j < cols; j++)\\n            if(m[i][0] == 0 || m[0][j] == 0) m[i][j] = 0;\\n    if(firstRowZero) for(int j = 0; j < cols; j++) m[0][j] = 0;\\n    if(firstColZero) for(int i = 0; i < rows; i++) m[i][0] = 0;\\n}\\nint main() { int m[][3] = {{1,1,1}, {1,0,1}, {1,1,1}}; setZeroes(m, 3, 3); for(int i=0;i<3;i++) for(int j=0;j<3;j++) cout << m[i][j] << \\" \\"; return 0; }","explanation":{"approach":"Use first row/column as markers.","steps":["Mark rows/cols to zero","Apply markers","Handle first row/col"],"complexity":"Time: O(mn), Space: O(1)"},"testCases":[{"input":"[[1,1,1],[1,0,1],[1,1,1]]","expectedOutput":"1 0 1 0 0 0 1 0 1","explanation":"Middle zero spreads"},{"input":"[[0,1,2],[3,4,5],[6,7,8]]","expectedOutput":"All first row/col zero","explanation":"Corner zero"},{"input":"[[1,2,3],[4,5,6]]","expectedOutput":"Same matrix","explanation":"No zeros"},{"input":"[[0,0],[0,0]]","expectedOutput":"All zeros","explanation":"All already zero"}]},{"id":"core54","title":"Search 2D Matrix","description":"Search in sorted matrix (rows sorted, each row starts larger than previous row ends).","difficulty":"MEDIUM","category":"Binary Search","starterCode":"#include <iostream>\\nusing namespace std;\\nbool searchMatrix(int m[][4], int rows, int cols, int target) { return false; }\\nint main() { int m[][4] = {{1,3,5,7}, {10,11,16,20}, {23,30,34,60}}; cout << searchMatrix(m, 3, 4, 3); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool searchMatrix(int m[][4], int rows, int cols, int target) {\\n    int left = 0, right = rows * cols - 1;\\n    while(left <= right) {\\n        int mid = (left + right) / 2;\\n        int val = m[mid / cols][mid % cols];\\n        if(val == target) return true;\\n        if(val < target) left = mid + 1;\\n        else right = mid - 1;\\n    }\\n    return false;\\n}\\nint main() { int m[][4] = {{1,3,5,7}, {10,11,16,20}, {23,30,34,60}}; cout << searchMatrix(m, 3, 4, 3); return 0; }","explanation":{"approach":"Treat as 1D sorted array, binary search.","steps":["Index i maps to (i/cols, i%cols)","Standard binary search"],"complexity":"Time: O(log(mn)), Space: O(1)"},"testCases":[{"input":"matrix, target=3","expectedOutput":"1","explanation":"3 found in first row"},{"input":"matrix, target=13","expectedOutput":"0","explanation":"13 not in matrix"},{"input":"matrix, target=60","expectedOutput":"1","explanation":"Last element"},{"input":"matrix, target=1","expectedOutput":"1","explanation":"First element"}]},{"id":"core55","title":"Search 2D Matrix II","description":"Search in matrix where each row AND column is sorted (rows don't continue each other).","difficulty":"MEDIUM","category":"Binary Search","starterCode":"#include <iostream>\\nusing namespace std;\\nbool searchMatrix(int m[][5], int rows, int cols, int target) { return false; }\\nint main() { int mx[][5] = {{1,4,7,11,15}, {2,5,8,12,19}, {3,6,9,16,22}, {10,13,14,17,24}, {18,21,23,26,30}}; cout << searchMatrix(mx, 5, 5, 5); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool searchMatrix(int m[][5], int rows, int cols, int target) {\\n    int row = 0, col = cols - 1;\\n    while(row < rows && col >= 0) {\\n        if(m[row][col] == target) return true;\\n        if(m[row][col] > target) col--;\\n        else row++;\\n    }\\n    return false;\\n}\\nint main() { int mx[][5] = {{1,4,7,11,15}, {2,5,8,12,19}, {3,6,9,16,22}, {10,13,14,17,24}, {18,21,23,26,30}}; cout << searchMatrix(mx, 5, 5, 5); return 0; }","explanation":{"approach":"Start from top-right, eliminate row or column each step.","steps":["If too big, go left","If too small, go down"],"complexity":"Time: O(m+n), Space: O(1)"},"testCases":[{"input":"5x5 matrix, target=5","expectedOutput":"1","explanation":"5 found"},{"input":"5x5 matrix, target=20","expectedOutput":"0","explanation":"20 not in matrix"},{"input":"5x5 matrix, target=1","expectedOutput":"1","explanation":"Top-left corner"},{"input":"5x5 matrix, target=30","expectedOutput":"1","explanation":"Bottom-right corner"}]},{"id":"core56","title":"Word Search","description":"Find if word exists in grid using adjacent cells (no reuse).","difficulty":"MEDIUM","category":"Backtracking","starterCode":"#include <iostream>\\nusing namespace std;\\nbool exist(char board[][4], int m, int n, char word[]) { return false; }\\nint main() { char b[][4] = {{\\"ABCE\\"}, {\\"SFCS\\"}, {\\"ADEE\\"}}; cout << exist(b, 3, 4, \\"ABCCED\\"); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool dfs(char board[][4], int m, int n, char word[], int i, int j, int k) {\\n    if(word[k] == 0) return true;\\n    if(i < 0 || i >= m || j < 0 || j >= n) return false;\\n    if(board[i][j] != word[k]) return false;\\n    char temp = board[i][j];\\n    board[i][j] = '#';\\n    bool found = dfs(board, m, n, word, i+1, j, k+1) ||\\n                 dfs(board, m, n, word, i-1, j, k+1) ||\\n                 dfs(board, m, n, word, i, j+1, k+1) ||\\n                 dfs(board, m, n, word, i, j-1, k+1);\\n    board[i][j] = temp;\\n    return found;\\n}\\nbool exist(char board[][4], int m, int n, char word[]) {\\n    for(int i = 0; i < m; i++)\\n        for(int j = 0; j < n; j++)\\n            if(dfs(board, m, n, word, i, j, 0)) return true;\\n    return false;\\n}\\nint main() { char b[][4] = {{\\"ABCE\\"}, {\\"SFCS\\"}, {\\"ADEE\\"}}; cout << exist(b, 3, 4, \\"ABCCED\\"); return 0; }","explanation":{"approach":"DFS with backtracking from each cell.","steps":["Try each starting cell","DFS in 4 directions","Mark visited, restore on backtrack"],"complexity":"Time: O(mn4^L), Space: O(L)"},"testCases":[{"input":"grid, word='ABCCED'","expectedOutput":"1","explanation":"Path exists"},{"input":"grid, word='SEE'","expectedOutput":"1","explanation":"Another valid path"},{"input":"grid, word='ABCB'","expectedOutput":"0","explanation":"Can't reuse cell"},{"input":"grid, word='Z'","expectedOutput":"0","explanation":"Letter not in grid"}]},{"id":"core57","title":"N-Queens","description":"Count ways to place n queens on nn board with no attacks.","difficulty":"HARD","category":"Backtracking","starterCode":"#include <iostream>\\nusing namespace std;\\nint totalNQueens(int n) { return 0; }\\nint main() { cout << totalNQueens(4); return 0; }","expectedOutput":"2","solution":"#include <iostream>\\nusing namespace std;\\nint count;\\nbool col[10], diag1[20], diag2[20];\\nvoid solve(int row, int n) {\\n    if(row == n) { count++; return; }\\n    for(int c = 0; c < n; c++) {\\n        if(!col[c] && !diag1[row-c+n] && !diag2[row+c]) {\\n            col[c] = diag1[row-c+n] = diag2[row+c] = true;\\n            solve(row + 1, n);\\n            col[c] = diag1[row-c+n] = diag2[row+c] = false;\\n        }\\n    }\\n}\\nint totalNQueens(int n) {\\n    count = 0;\\n    for(int i = 0; i < 10; i++) col[i] = false;\\n    for(int i = 0; i < 20; i++) diag1[i] = diag2[i] = false;\\n    solve(0, n);\\n    return count;\\n}\\nint main() { cout << totalNQueens(4); return 0; }","explanation":{"approach":"Backtracking row by row, track columns and diagonals.","steps":["Place queen, check column/diagonals free","Recurse, backtrack"],"complexity":"Time: O(n!), Space: O(n)"},"testCases":[{"input":"n=4","expectedOutput":"2","explanation":"Two valid arrangements"},{"input":"n=1","expectedOutput":"1","explanation":"Single queen, single cell"},{"input":"n=8","expectedOutput":"92","explanation":"Classic 8-queens"},{"input":"n=2","expectedOutput":"0","explanation":"No valid solution"}]},{"id":"core58","title":"Sudoku Solver","description":"Solve a Sudoku puzzle by filling empty cells.","difficulty":"HARD","category":"Backtracking","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid solveSudoku(char board[][9]) {}\\nint main() { cout << \\"Sudoku Solver\\"; return 0; }","expectedOutput":"Sudoku Solver","solution":"#include <iostream>\\nusing namespace std;\\nbool isValid(char board[][9], int row, int col, char c) {\\n    for(int i = 0; i < 9; i++) {\\n        if(board[row][i] == c) return false;\\n        if(board[i][col] == c) return false;\\n        int boxRow = 3 * (row / 3) + i / 3;\\n        int boxCol = 3 * (col / 3) + i % 3;\\n        if(board[boxRow][boxCol] == c) return false;\\n    }\\n    return true;\\n}\\nbool solve(char board[][9]) {\\n    for(int i = 0; i < 9; i++) {\\n        for(int j = 0; j < 9; j++) {\\n            if(board[i][j] == '.') {\\n                for(char c = '1'; c <= '9'; c++) {\\n                    if(isValid(board, i, j, c)) {\\n                        board[i][j] = c;\\n                        if(solve(board)) return true;\\n                        board[i][j] = '.';\\n                    }\\n                }\\n                return false;\\n            }\\n        }\\n    }\\n    return true;\\n}\\nvoid solveSudoku(char board[][9]) { solve(board); }\\nint main() { cout << \\"Sudoku Solver\\"; return 0; }","explanation":{"approach":"Backtracking: try digits 1-9 in empty cells.","steps":["Find empty cell","Try valid digits","Backtrack if stuck"],"complexity":"Time: O(9^empty_cells), Space: O(81)"},"testCases":[{"input":"Valid solvable puzzle","expectedOutput":"Solved board","explanation":"Standard sudoku"},{"input":"Easy puzzle (few blanks)","expectedOutput":"Solved quickly","explanation":"Less backtracking"},{"input":"Hard puzzle (many blanks)","expectedOutput":"Solved","explanation":"More backtracking"},{"input":"Already solved","expectedOutput":"Same board","explanation":"No changes needed"}]},{"id":"core59","title":"Generate Parentheses","description":"Generate all valid combinations of n pairs of parentheses.","difficulty":"MEDIUM","category":"Backtracking","starterCode":"#include <iostream>\\nusing namespace std;\\nint count;\\nvoid generateParenthesis(int n) {}\\nint main() { generateParenthesis(3); return 0; }","expectedOutput":"5","solution":"#include <iostream>\\nusing namespace std;\\nint count;\\nvoid generate(int open, int close, int n) {\\n    if(open == n && close == n) { count++; return; }\\n    if(open < n) generate(open + 1, close, n);\\n    if(close < open) generate(open, close + 1, n);\\n}\\nvoid generateParenthesis(int n) {\\n    count = 0;\\n    generate(0, 0, n);\\n    cout << count;\\n}\\nint main() { generateParenthesis(3); return 0; }","explanation":{"approach":"Add ( if open<n, add ) if close<open.","steps":["Track open and close counts","Build valid strings only"],"complexity":"Time: O(4^n/n), Space: O(n)"},"testCases":[{"input":"n=3","expectedOutput":"5","explanation":"5 valid combinations"},{"input":"n=1","expectedOutput":"1","explanation":"Just ()"},{"input":"n=2","expectedOutput":"2","explanation":"(()) and ()()"},{"input":"n=4","expectedOutput":"14","explanation":"Catalan number"}]},{"id":"core60","title":"Permutations","description":"Generate all permutations of distinct integers array.","difficulty":"MEDIUM","category":"Backtracking","starterCode":"#include <iostream>\\nusing namespace std;\\nint count;\\nvoid permute(int nums[], int n) {}\\nint main() { int a[] = {1, 2, 3}; permute(a, 3); return 0; }","expectedOutput":"6","solution":"#include <iostream>\\nusing namespace std;\\nint count;\\nvoid backtrack(int nums[], int n, int start) {\\n    if(start == n) { count++; return; }\\n    for(int i = start; i < n; i++) {\\n        swap(nums[start], nums[i]);\\n        backtrack(nums, n, start + 1);\\n        swap(nums[start], nums[i]);\\n    }\\n}\\nvoid permute(int nums[], int n) {\\n    count = 0;\\n    backtrack(nums, n, 0);\\n    cout << count;\\n}\\nint main() { int a[] = {1, 2, 3}; permute(a, 3); return 0; }","explanation":{"approach":"Swap each element to current position, recurse.","steps":["Swap, recurse for rest, swap back"],"complexity":"Time: O(nn!), Space: O(n)"},"testCases":[{"input":"[1,2,3]","expectedOutput":"6","explanation":"3! = 6 permutations"},{"input":"[1]","expectedOutput":"1","explanation":"Single element"},{"input":"[1,2]","expectedOutput":"2","explanation":"2! = 2"},{"input":"[1,2,3,4]","expectedOutput":"24","explanation":"4! = 24"}]}]`),CM=JSON.parse(`[{"id":"core61","title":"Merge Intervals","description":"Merge all overlapping intervals into non-overlapping intervals.","difficulty":"MEDIUM","category":"Intervals","starterCode":"#include <iostream>\\nusing namespace std;\\nint merge(int intervals[][2], int n) { return 0; }\\nint main() { int in[][2] = {{1,3}, {2,6}, {8,10}, {15,18}}; cout << merge(in, 4); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nint merge(int intervals[][2], int n) {\\n    for(int i = 0; i < n - 1; i++)\\n        for(int j = 0; j < n - i - 1; j++)\\n            if(intervals[j][0] > intervals[j+1][0]) {\\n                swap(intervals[j][0], intervals[j+1][0]);\\n                swap(intervals[j][1], intervals[j+1][1]);\\n            }\\n    int merged = 1, lastEnd = intervals[0][1];\\n    for(int i = 1; i < n; i++) {\\n        if(intervals[i][0] <= lastEnd)\\n            lastEnd = max(lastEnd, intervals[i][1]);\\n        else { merged++; lastEnd = intervals[i][1]; }\\n    }\\n    return merged;\\n}\\nint main() { int in[][2] = {{1,3}, {2,6}, {8,10}, {15,18}}; cout << merge(in, 4); return 0; }","explanation":{"approach":"Sort by start, merge overlapping by extending end.","steps":["Sort by start time","Extend end if overlap, else new interval"],"complexity":"Time: O(n log n), Space: O(1)"},"testCases":[{"input":"[[1,3],[2,6],[8,10],[15,18]]","expectedOutput":"3","explanation":"[1,6],[8,10],[15,18]"},{"input":"[[1,4],[4,5]]","expectedOutput":"1","explanation":"Adjacent intervals merge"},{"input":"[[1,4],[0,4]]","expectedOutput":"1","explanation":"Overlapping merge to [0,4]"},{"input":"[[1,2],[3,4]]","expectedOutput":"2","explanation":"No overlap"}]},{"id":"core62","title":"Insert Interval","description":"Insert new interval into sorted non-overlapping list, merge if needed.","difficulty":"MEDIUM","category":"Intervals","starterCode":"#include <iostream>\\nusing namespace std;\\nint insert(int intervals[][2], int n, int newI[]) { return 0; }\\nint main() { int in[][2] = {{1,2}, {3,5}, {6,7}, {8,10}, {12,16}}; int ni[] = {4, 8}; cout << insert(in, 5, ni); return 0; }","expectedOutput":"4","solution":"#include <iostream>\\nusing namespace std;\\nint insert(int intervals[][2], int n, int newI[]) {\\n    int result[20][2], k = 0, i = 0;\\n    while(i < n && intervals[i][1] < newI[0]) {\\n        result[k][0] = intervals[i][0]; result[k][1] = intervals[i][1]; k++; i++;\\n    }\\n    while(i < n && intervals[i][0] <= newI[1]) {\\n        newI[0] = min(newI[0], intervals[i][0]);\\n        newI[1] = max(newI[1], intervals[i][1]); i++;\\n    }\\n    result[k][0] = newI[0]; result[k][1] = newI[1]; k++;\\n    while(i < n) {\\n        result[k][0] = intervals[i][0]; result[k][1] = intervals[i][1]; k++; i++;\\n    }\\n    return k;\\n}\\nint main() { int in[][2] = {{1,2}, {3,5}, {6,7}, {8,10}, {12,16}}; int ni[] = {4, 8}; cout << insert(in, 5, ni); return 0; }","explanation":{"approach":"Three phases: before, merge overlapping, after.","steps":["Add intervals ending before new starts","Merge overlapping","Add remaining"],"complexity":"Time: O(n), Space: O(n)"},"testCases":[{"input":"intervals + [4,8]","expectedOutput":"4","explanation":"Merges [3,5],[6,7],[8,10] into [3,10]"},{"input":"intervals + [0,0]","expectedOutput":"6","explanation":"Insert at beginning"},{"input":"[[1,5]] + [2,3]","expectedOutput":"1","explanation":"Fully contained"},{"input":"[[1,5]] + [6,8]","expectedOutput":"2","explanation":"No overlap"}]},{"id":"core63","title":"Meeting Rooms II","description":"Find minimum conference rooms needed for all meetings.","difficulty":"MEDIUM","category":"Intervals","starterCode":"#include <iostream>\\nusing namespace std;\\nint minMeetingRooms(int intervals[][2], int n) { return 0; }\\nint main() { int in[][2] = {{0,30}, {5,10}, {15,20}}; cout << minMeetingRooms(in, 3); return 0; }","expectedOutput":"2","solution":"#include <iostream>\\nusing namespace std;\\nint minMeetingRooms(int intervals[][2], int n) {\\n    int starts[n], ends[n];\\n    for(int i = 0; i < n; i++) { starts[i] = intervals[i][0]; ends[i] = intervals[i][1]; }\\n    for(int i = 0; i < n-1; i++) for(int j = 0; j < n-i-1; j++) {\\n        if(starts[j] > starts[j+1]) swap(starts[j], starts[j+1]);\\n        if(ends[j] > ends[j+1]) swap(ends[j], ends[j+1]);\\n    }\\n    int rooms = 0, endPtr = 0;\\n    for(int i = 0; i < n; i++) {\\n        if(starts[i] < ends[endPtr]) rooms++;\\n        else endPtr++;\\n    }\\n    return rooms;\\n}\\nint main() { int in[][2] = {{0,30}, {5,10}, {15,20}}; cout << minMeetingRooms(in, 3); return 0; }","explanation":{"approach":"Sort starts and ends separately, count overlapping.","steps":["Sort both arrays","Two pointers to count max concurrent"],"complexity":"Time: O(n log n), Space: O(n)"},"testCases":[{"input":"[[0,30],[5,10],[15,20]]","expectedOutput":"2","explanation":"Two meetings overlap at time 5"},{"input":"[[7,10],[2,4]]","expectedOutput":"1","explanation":"No overlap, one room"},{"input":"[[0,5],[5,10],[10,15]]","expectedOutput":"1","explanation":"Sequential meetings"},{"input":"[[0,10],[0,10],[0,10]]","expectedOutput":"3","explanation":"All overlap"}]},{"id":"core64","title":"Non-overlapping Intervals","description":"Find minimum intervals to remove to make rest non-overlapping.","difficulty":"MEDIUM","category":"Intervals","starterCode":"#include <iostream>\\nusing namespace std;\\nint eraseOverlapIntervals(int intervals[][2], int n) { return 0; }\\nint main() { int in[][2] = {{1,2}, {2,3}, {3,4}, {1,3}}; cout << eraseOverlapIntervals(in, 4); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nint eraseOverlapIntervals(int intervals[][2], int n) {\\n    if(n == 0) return 0;\\n    for(int i = 0; i < n-1; i++) for(int j = 0; j < n-i-1; j++)\\n        if(intervals[j][1] > intervals[j+1][1]) {\\n            swap(intervals[j][0], intervals[j+1][0]);\\n            swap(intervals[j][1], intervals[j+1][1]);\\n        }\\n    int keep = 1, lastEnd = intervals[0][1];\\n    for(int i = 1; i < n; i++)\\n        if(intervals[i][0] >= lastEnd) { keep++; lastEnd = intervals[i][1]; }\\n    return n - keep;\\n}\\nint main() { int in[][2] = {{1,2}, {2,3}, {3,4}, {1,3}}; cout << eraseOverlapIntervals(in, 4); return 0; }","explanation":{"approach":"Greedy: sort by end, keep non-overlapping.","steps":["Sort by end time","Keep intervals ending earliest"],"complexity":"Time: O(n log n), Space: O(1)"},"testCases":[{"input":"[[1,2],[2,3],[3,4],[1,3]]","expectedOutput":"1","explanation":"Remove [1,3]"},{"input":"[[1,2],[1,2],[1,2]]","expectedOutput":"2","explanation":"Keep only one"},{"input":"[[1,2],[2,3]]","expectedOutput":"0","explanation":"Already non-overlapping"},{"input":"[[1,100],[11,22],[1,11],[2,12]]","expectedOutput":"2","explanation":"Remove two"}]},{"id":"core65","title":"Linked List Cycle Detection","description":"Detect if linked list has a cycle using O(1) space.","difficulty":"EASY","category":"Linked Lists","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int val; Node* next; Node(int x): val(x), next(0) {} };\\nbool hasCycle(Node* head) { return false; }\\nint main() { Node* h = new Node(1); h->next = new Node(2); h->next->next = h; cout << hasCycle(h); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int val; Node* next; Node(int x): val(x), next(0) {} };\\nbool hasCycle(Node* head) {\\n    if(!head || !head->next) return false;\\n    Node* slow = head;\\n    Node* fast = head;\\n    while(fast && fast->next) {\\n        slow = slow->next;\\n        fast = fast->next->next;\\n        if(slow == fast) return true;\\n    }\\n    return false;\\n}\\nint main() { Node* h = new Node(1); h->next = new Node(2); h->next->next = h; cout << hasCycle(h); return 0; }","explanation":{"approach":"Floyd's Tortoise and Hare: slow and fast pointers meet in cycle.","steps":["Slow moves 1 step, fast moves 2 steps","If they meet, cycle exists"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"Cycle: 1->2->1","expectedOutput":"1","explanation":"Cycle detected"},{"input":"No cycle: 1->2->3","expectedOutput":"0","explanation":"No cycle"},{"input":"Single node, no cycle","expectedOutput":"0","explanation":"No next"},{"input":"Self loop: 1->1","expectedOutput":"1","explanation":"Node points to itself"}]},{"id":"core66","title":"Reverse Linked List","description":"Reverse a singly linked list in-place.","difficulty":"EASY","category":"Linked Lists","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int val; Node* next; Node(int x): val(x), next(0) {} };\\nNode* reverseList(Node* head) { return nullptr; }\\nvoid print(Node* h) { while(h) { cout << h->val << \\" \\"; h = h->next; } }\\nint main() { Node* h = new Node(1); h->next = new Node(2); h->next->next = new Node(3); h = reverseList(h); print(h); return 0; }","expectedOutput":"3 2 1","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int val; Node* next; Node(int x): val(x), next(0) {} };\\nNode* reverseList(Node* head) {\\n    Node* prev = nullptr;\\n    Node* curr = head;\\n    while(curr) {\\n        Node* next = curr->next;\\n        curr->next = prev;\\n        prev = curr;\\n        curr = next;\\n    }\\n    return prev;\\n}\\nvoid print(Node* h) { while(h) { cout << h->val << \\" \\"; h = h->next; } }\\nint main() { Node* h = new Node(1); h->next = new Node(2); h->next->next = new Node(3); h = reverseList(h); print(h); return 0; }","explanation":{"approach":"Iteratively reverse each link.","steps":["Save next","Reverse link","Move pointers forward"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"1->2->3","expectedOutput":"3 2 1","explanation":"Reversed"},{"input":"1","expectedOutput":"1","explanation":"Single node unchanged"},{"input":"1->2","expectedOutput":"2 1","explanation":"Two nodes swapped"},{"input":"null","expectedOutput":"null","explanation":"Empty list"}]},{"id":"core67","title":"Merge Two Sorted Lists","description":"Merge two sorted linked lists into one sorted list.","difficulty":"EASY","category":"Linked Lists","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int val; Node* next; Node(int x): val(x), next(0) {} };\\nNode* mergeTwoLists(Node* l1, Node* l2) { return nullptr; }\\nvoid print(Node* h) { while(h) { cout << h->val << \\" \\"; h = h->next; } }\\nint main() { Node* a = new Node(1); a->next = new Node(3); Node* b = new Node(2); b->next = new Node(4); print(mergeTwoLists(a, b)); return 0; }","expectedOutput":"1 2 3 4","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int val; Node* next; Node(int x): val(x), next(0) {} };\\nNode* mergeTwoLists(Node* l1, Node* l2) {\\n    Node dummy(0);\\n    Node* tail = &dummy;\\n    while(l1 && l2) {\\n        if(l1->val <= l2->val) { tail->next = l1; l1 = l1->next; }\\n        else { tail->next = l2; l2 = l2->next; }\\n        tail = tail->next;\\n    }\\n    tail->next = l1 ? l1 : l2;\\n    return dummy.next;\\n}\\nvoid print(Node* h) { while(h) { cout << h->val << \\" \\"; h = h->next; } }\\nint main() { Node* a = new Node(1); a->next = new Node(3); Node* b = new Node(2); b->next = new Node(4); print(mergeTwoLists(a, b)); return 0; }","explanation":{"approach":"Compare heads, take smaller, attach remaining.","steps":["Use dummy head","Compare and link smaller","Attach rest"],"complexity":"Time: O(m+n), Space: O(1)"},"testCases":[{"input":"1->3, 2->4","expectedOutput":"1 2 3 4","explanation":"Interleaved merge"},{"input":"null, 1->2","expectedOutput":"1 2","explanation":"One empty"},{"input":"1->2, 3->4","expectedOutput":"1 2 3 4","explanation":"No interleaving"},{"input":"2->4, 1->3","expectedOutput":"1 2 3 4","explanation":"Order doesn't matter"}]},{"id":"core68","title":"Remove Nth Node From End","description":"Remove nth node from end of linked list in one pass.","difficulty":"MEDIUM","category":"Linked Lists","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int val; Node* next; Node(int x): val(x), next(0) {} };\\nNode* removeNthFromEnd(Node* head, int n) { return nullptr; }\\nvoid print(Node* h) { while(h) { cout << h->val << \\" \\"; h = h->next; } }\\nint main() { Node* h = new Node(1); h->next = new Node(2); h->next->next = new Node(3); h->next->next->next = new Node(4); h = removeNthFromEnd(h, 2); print(h); return 0; }","expectedOutput":"1 2 4","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int val; Node* next; Node(int x): val(x), next(0) {} };\\nNode* removeNthFromEnd(Node* head, int n) {\\n    Node dummy(0); dummy.next = head;\\n    Node* first = &dummy;\\n    Node* second = &dummy;\\n    for(int i = 0; i <= n; i++) first = first->next;\\n    while(first) { first = first->next; second = second->next; }\\n    second->next = second->next->next;\\n    return dummy.next;\\n}\\nvoid print(Node* h) { while(h) { cout << h->val << \\" \\"; h = h->next; } }\\nint main() { Node* h = new Node(1); h->next = new Node(2); h->next->next = new Node(3); h->next->next->next = new Node(4); h = removeNthFromEnd(h, 2); print(h); return 0; }","explanation":{"approach":"Two pointers with n-gap between them.","steps":["Move first n+1 steps ahead","Move both until first reaches end","Remove"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"1->2->3->4, n=2","expectedOutput":"1 2 4","explanation":"Remove 3rd node (2nd from end)"},{"input":"1, n=1","expectedOutput":"null","explanation":"Remove only node"},{"input":"1->2, n=1","expectedOutput":"1","explanation":"Remove last"},{"input":"1->2, n=2","expectedOutput":"2","explanation":"Remove first"}]},{"id":"core69","title":"Flatten Binary Tree to Linked List","description":"Flatten binary tree to linked list using right pointers (pre-order).","difficulty":"MEDIUM","category":"Trees","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct TreeNode { int val; TreeNode *left, *right; TreeNode(int x): val(x), left(0), right(0) {} };\\nvoid flatten(TreeNode* root) {}\\nvoid print(TreeNode* r) { while(r) { cout << r->val << \\" \\"; r = r->right; } }\\nint main() { TreeNode* r = new TreeNode(1); r->left = new TreeNode(2); r->right = new TreeNode(5); flatten(r); print(r); return 0; }","expectedOutput":"1 2 5","solution":"#include <iostream>\\nusing namespace std;\\nstruct TreeNode { int val; TreeNode *left, *right; TreeNode(int x): val(x), left(0), right(0) {} };\\nvoid flatten(TreeNode* root) {\\n    TreeNode* curr = root;\\n    while(curr) {\\n        if(curr->left) {\\n            TreeNode* rightmost = curr->left;\\n            while(rightmost->right) rightmost = rightmost->right;\\n            rightmost->right = curr->right;\\n            curr->right = curr->left;\\n            curr->left = nullptr;\\n        }\\n        curr = curr->right;\\n    }\\n}\\nvoid print(TreeNode* r) { while(r) { cout << r->val << \\" \\"; r = r->right; } }\\nint main() { TreeNode* r = new TreeNode(1); r->left = new TreeNode(2); r->right = new TreeNode(5); flatten(r); print(r); return 0; }","explanation":{"approach":"Move left subtree to right, connect old right to end of left.","steps":["Find rightmost of left subtree","Connect to right","Move left to right"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"Tree with left and right","expectedOutput":"1 2 5","explanation":"Pre-order flattening"},{"input":"Single node","expectedOutput":"1","explanation":"Already flat"},{"input":"Only left children","expectedOutput":"Pre-order list","explanation":"Linked list of lefts"},{"input":"Only right children","expectedOutput":"Same list","explanation":"Already linked via right"}]},{"id":"core70","title":"Lowest Common Ancestor","description":"Find LCA of two nodes in binary tree.","difficulty":"MEDIUM","category":"Trees","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct TreeNode { int val; TreeNode *left, *right; TreeNode(int x): val(x), left(0), right(0) {} };\\nTreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { return nullptr; }\\nint main() { TreeNode* r = new TreeNode(3); r->left = new TreeNode(5); r->right = new TreeNode(1); cout << lowestCommonAncestor(r, r->left, r->right)->val; return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nstruct TreeNode { int val; TreeNode *left, *right; TreeNode(int x): val(x), left(0), right(0) {} };\\nTreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n    if(!root || root == p || root == q) return root;\\n    TreeNode* left = lowestCommonAncestor(root->left, p, q);\\n    TreeNode* right = lowestCommonAncestor(root->right, p, q);\\n    if(left && right) return root;\\n    return left ? left : right;\\n}\\nint main() { TreeNode* r = new TreeNode(3); r->left = new TreeNode(5); r->right = new TreeNode(1); cout << lowestCommonAncestor(r, r->left, r->right)->val; return 0; }","explanation":{"approach":"Recursive: if both found on different sides, current is LCA.","steps":["If root is p/q, return root","Search both subtrees","If both found, root is LCA"],"complexity":"Time: O(n), Space: O(h)"},"testCases":[{"input":"p=5, q=1","expectedOutput":"3","explanation":"Root is LCA"},{"input":"p=5, q=4 (4 is child of 5)","expectedOutput":"5","explanation":"5 is LCA"},{"input":"Same node p=q=5","expectedOutput":"5","explanation":"Node is its own ancestor"},{"input":"Deep nodes","expectedOutput":"Their common ancestor","explanation":"Find deepest common"}]}]`),_M=JSON.parse(`[{"id":"core71","title":"Level Order Traversal","description":"BFS level-by-level traversal of binary tree.","difficulty":"MEDIUM","category":"Trees","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct TreeNode { int val; TreeNode *left, *right; TreeNode(int x): val(x), left(0), right(0) {} };\\nvoid levelOrder(TreeNode* root) {}\\nint main() { TreeNode* r = new TreeNode(3); r->left = new TreeNode(9); r->right = new TreeNode(20); levelOrder(r); return 0; }","expectedOutput":"3 9 20","solution":"#include <iostream>\\nusing namespace std;\\nstruct TreeNode { int val; TreeNode *left, *right; TreeNode(int x): val(x), left(0), right(0) {} };\\nvoid levelOrder(TreeNode* root) {\\n    if(!root) return;\\n    TreeNode* queue[100];\\n    int front = 0, back = 0;\\n    queue[back++] = root;\\n    while(front < back) {\\n        TreeNode* node = queue[front++];\\n        cout << node->val << \\" \\";\\n        if(node->left) queue[back++] = node->left;\\n        if(node->right) queue[back++] = node->right;\\n    }\\n}\\nint main() { TreeNode* r = new TreeNode(3); r->left = new TreeNode(9); r->right = new TreeNode(20); levelOrder(r); return 0; }","explanation":{"approach":"BFS using queue, process level by level.","steps":["Enqueue root","Dequeue, print, enqueue children","Repeat"],"complexity":"Time: O(n), Space: O(n)"},"testCases":[{"input":"Tree: 3->9,20","expectedOutput":"3 9 20","explanation":"Level 0: 3, Level 1: 9,20"},{"input":"Single node","expectedOutput":"1","explanation":"Only root"},{"input":"Empty tree","expectedOutput":"","explanation":"Nothing to traverse"},{"input":"Full binary tree","expectedOutput":"1 2 3 4 5 6 7","explanation":"All levels"}]},{"id":"core72","title":"Validate Binary Search Tree","description":"Check if tree is valid BST (left < root < right for all nodes).","difficulty":"MEDIUM","category":"Trees","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct TreeNode { int val; TreeNode *left, *right; TreeNode(int x): val(x), left(0), right(0) {} };\\nbool isValidBST(TreeNode* root) { return false; }\\nint main() { TreeNode* r = new TreeNode(2); r->left = new TreeNode(1); r->right = new TreeNode(3); cout << isValidBST(r); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nstruct TreeNode { int val; TreeNode *left, *right; TreeNode(int x): val(x), left(0), right(0) {} };\\nbool validate(TreeNode* node, long minVal, long maxVal) {\\n    if(!node) return true;\\n    if(node->val <= minVal || node->val >= maxVal) return false;\\n    return validate(node->left, minVal, node->val) &&\\n           validate(node->right, node->val, maxVal);\\n}\\nbool isValidBST(TreeNode* root) {\\n    return validate(root, LONG_MIN, LONG_MAX);\\n}\\nint main() { TreeNode* r = new TreeNode(2); r->left = new TreeNode(1); r->right = new TreeNode(3); cout << isValidBST(r); return 0; }","explanation":{"approach":"Recursively validate with min/max bounds.","steps":["Node must be within (min, max)","Update bounds when going left/right"],"complexity":"Time: O(n), Space: O(h)"},"testCases":[{"input":"Valid BST: 2->1,3","expectedOutput":"1","explanation":"1<2<3, valid"},{"input":"Invalid: 5->1,4->3,6","expectedOutput":"0","explanation":"6>5 in left subtree"},{"input":"Single node","expectedOutput":"1","explanation":"Always valid"},{"input":"Equal values","expectedOutput":"0","explanation":"BST requires strict inequality"}]},{"id":"core73","title":"Construct Binary Tree from Preorder and Inorder","description":"Build tree from preorder and inorder traversal arrays.","difficulty":"MEDIUM","category":"Trees","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct TreeNode { int val; TreeNode *left, *right; TreeNode(int x): val(x), left(0), right(0) {} };\\nTreeNode* buildTree(int pre[], int in[], int n) { return nullptr; }\\nint main() { int pre[] = {3, 9, 20}; int in[] = {9, 3, 20}; TreeNode* r = buildTree(pre, in, 3); cout << r->val; return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nstruct TreeNode { int val; TreeNode *left, *right; TreeNode(int x): val(x), left(0), right(0) {} };\\nint preIdx;\\nTreeNode* build(int pre[], int in[], int inStart, int inEnd) {\\n    if(inStart > inEnd) return nullptr;\\n    int rootVal = pre[preIdx++];\\n    TreeNode* root = new TreeNode(rootVal);\\n    int inIdx = inStart;\\n    for(int i = inStart; i <= inEnd; i++)\\n        if(in[i] == rootVal) { inIdx = i; break; }\\n    root->left = build(pre, in, inStart, inIdx - 1);\\n    root->right = build(pre, in, inIdx + 1, inEnd);\\n    return root;\\n}\\nTreeNode* buildTree(int pre[], int in[], int n) {\\n    preIdx = 0;\\n    return build(pre, in, 0, n - 1);\\n}\\nint main() { int pre[] = {3, 9, 20}; int in[] = {9, 3, 20}; TreeNode* r = buildTree(pre, in, 3); cout << r->val; return 0; }","explanation":{"approach":"Preorder gives root, inorder splits left/right subtrees.","steps":["First preorder element is root","Find in inorder to split","Recurse"],"complexity":"Time: O(n), Space: O(n)"},"testCases":[{"input":"pre=[3,9,20], in=[9,3,20]","expectedOutput":"3","explanation":"Root is 3"},{"input":"Single element","expectedOutput":"1","explanation":"Only root"},{"input":"Left-skewed tree","expectedOutput":"Root value","explanation":"All nodes on left"},{"input":"Right-skewed tree","expectedOutput":"Root value","explanation":"All nodes on right"}]},{"id":"core74","title":"Kth Smallest in BST","description":"Find kth smallest element in BST (1-indexed).","difficulty":"MEDIUM","category":"Trees","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct TreeNode { int val; TreeNode *left, *right; TreeNode(int x): val(x), left(0), right(0) {} };\\nint kthSmallest(TreeNode* root, int k) { return 0; }\\nint main() { TreeNode* r = new TreeNode(3); r->left = new TreeNode(1); r->right = new TreeNode(4); r->left->right = new TreeNode(2); cout << kthSmallest(r, 1); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nstruct TreeNode { int val; TreeNode *left, *right; TreeNode(int x): val(x), left(0), right(0) {} };\\nint count, result;\\nvoid inorder(TreeNode* node, int k) {\\n    if(!node || count >= k) return;\\n    inorder(node->left, k);\\n    count++;\\n    if(count == k) { result = node->val; return; }\\n    inorder(node->right, k);\\n}\\nint kthSmallest(TreeNode* root, int k) {\\n    count = 0; result = 0;\\n    inorder(root, k);\\n    return result;\\n}\\nint main() { TreeNode* r = new TreeNode(3); r->left = new TreeNode(1); r->right = new TreeNode(4); r->left->right = new TreeNode(2); cout << kthSmallest(r, 1); return 0; }","explanation":{"approach":"Inorder traversal gives sorted order in BST.","steps":["Inorder visits nodes in ascending order","Count until k"],"complexity":"Time: O(h+k), Space: O(h)"},"testCases":[{"input":"BST, k=1","expectedOutput":"1","explanation":"Smallest element"},{"input":"BST, k=3","expectedOutput":"3","explanation":"Third smallest"},{"input":"Single node, k=1","expectedOutput":"5","explanation":"Only element"},{"input":"BST, k=n","expectedOutput":"Largest","explanation":"Last in inorder"}]},{"id":"core75","title":"Binary Tree Maximum Path Sum","description":"Find maximum sum path in tree (can start/end anywhere).","difficulty":"HARD","category":"Trees","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct TreeNode { int val; TreeNode *left, *right; TreeNode(int x): val(x), left(0), right(0) {} };\\nint maxPathSum(TreeNode* root) { return 0; }\\nint main() { TreeNode* r = new TreeNode(-10); r->left = new TreeNode(9); r->right = new TreeNode(20); cout << maxPathSum(r); return 0; }","expectedOutput":"29","solution":"#include <iostream>\\nusing namespace std;\\nstruct TreeNode { int val; TreeNode *left, *right; TreeNode(int x): val(x), left(0), right(0) {} };\\nint maxSum;\\nint maxGain(TreeNode* node) {\\n    if(!node) return 0;\\n    int leftGain = max(0, maxGain(node->left));\\n    int rightGain = max(0, maxGain(node->right));\\n    int pathSum = node->val + leftGain + rightGain;\\n    maxSum = max(maxSum, pathSum);\\n    return node->val + max(leftGain, rightGain);\\n}\\nint maxPathSum(TreeNode* root) {\\n    maxSum = -1000000000;\\n    maxGain(root);\\n    return maxSum;\\n}\\nint main() { TreeNode* r = new TreeNode(-10); r->left = new TreeNode(9); r->right = new TreeNode(20); cout << maxPathSum(r); return 0; }","explanation":{"approach":"At each node, compute path through it, track global max.","steps":["Ignore negative paths (use 0)","Update global max","Return single-side gain to parent"],"complexity":"Time: O(n), Space: O(h)"},"testCases":[{"input":"-10->9,20->15,7","expectedOutput":"42","explanation":"15+20+7"},{"input":"1->2,3","expectedOutput":"6","explanation":"2+1+3"},{"input":"Single node -3","expectedOutput":"-3","explanation":"Only path"},{"input":"All negative","expectedOutput":"Least negative","explanation":"Must include one node"}]},{"id":"core76","title":"Serialize and Deserialize Binary Tree","description":"Convert tree to string and back.","difficulty":"HARD","category":"Trees","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct TreeNode { int val; TreeNode *left, *right; TreeNode(int x): val(x), left(0), right(0) {} };\\nvoid serialize(TreeNode* root) {}\\nint main() { TreeNode* r = new TreeNode(1); r->left = new TreeNode(2); r->right = new TreeNode(3); serialize(r); return 0; }","expectedOutput":"1 2 # # 3 # #","solution":"#include <iostream>\\nusing namespace std;\\nstruct TreeNode { int val; TreeNode *left, *right; TreeNode(int x): val(x), left(0), right(0) {} };\\nvoid serialize(TreeNode* root) {\\n    if(!root) { cout << \\"# \\"; return; }\\n    cout << root->val << \\" \\";\\n    serialize(root->left);\\n    serialize(root->right);\\n}\\nint main() { TreeNode* r = new TreeNode(1); r->left = new TreeNode(2); r->right = new TreeNode(3); serialize(r); return 0; }","explanation":{"approach":"Preorder with null markers.","steps":["Output value or # for null","Preorder traversal"],"complexity":"Time: O(n), Space: O(n)"},"testCases":[{"input":"Tree 1->2,3","expectedOutput":"1 2 # # 3 # #","explanation":"Preorder with nulls"},{"input":"Empty tree","expectedOutput":"#","explanation":"Just null marker"},{"input":"Single node","expectedOutput":"1 # #","explanation":"Root with null children"},{"input":"Left-only tree","expectedOutput":"1 2 3 # # # #","explanation":"Chain left"}]},{"id":"core77","title":"Word Ladder","description":"Shortest transformation from beginWord to endWord, changing one letter at a time.","difficulty":"HARD","category":"BFS","starterCode":"#include <iostream>\\nusing namespace std;\\nint ladderLength(char beginWord[], char endWord[], char* wordList[], int n) { return 0; }\\nint main() { char* words[] = {\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"}; cout << ladderLength(\\"hit\\", \\"cog\\", words, 6); return 0; }","expectedOutput":"5","solution":"#include <iostream>\\nusing namespace std;\\nbool differs(char a[], char b[]) {\\n    int diff = 0;\\n    for(int i = 0; a[i] && b[i]; i++)\\n        if(a[i] != b[i]) diff++;\\n    return diff == 1;\\n}\\nbool equals(char a[], char b[]) {\\n    for(int i = 0; a[i] || b[i]; i++)\\n        if(a[i] != b[i]) return false;\\n    return true;\\n}\\nint ladderLength(char beginWord[], char endWord[], char* wordList[], int n) {\\n    char* queue[100]; int dist[100] = {}; bool visited[100] = {};\\n    int front = 0, back = 0;\\n    queue[back] = beginWord; dist[back++] = 1;\\n    while(front < back) {\\n        char* curr = queue[front]; int d = dist[front++];\\n        if(equals(curr, endWord)) return d;\\n        for(int i = 0; i < n; i++)\\n            if(!visited[i] && differs(curr, wordList[i])) {\\n                visited[i] = true;\\n                queue[back] = wordList[i]; dist[back++] = d + 1;\\n            }\\n    }\\n    return 0;\\n}\\nint main() { char* words[] = {\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"}; cout << ladderLength(\\"hit\\", \\"cog\\", words, 6); return 0; }","explanation":{"approach":"BFS on word graph, edges connect words differing by one letter.","steps":["BFS from beginWord","Find words differing by 1 letter","Return distance when endWord found"],"complexity":"Time: O(nL), Space: O(n)"},"testCases":[{"input":"hit->cog","expectedOutput":"5","explanation":"hit->hot->dot->dog->cog"},{"input":"hit->cog, no cog in list","expectedOutput":"0","explanation":"No path"},{"input":"Same start and end","expectedOutput":"1","explanation":"Already there"},{"input":"Direct connection","expectedOutput":"2","explanation":"One step"}]},{"id":"core78","title":"Number of Islands","description":"Count connected components of '1's (land) in 2D grid.","difficulty":"MEDIUM","category":"DFS","starterCode":"#include <iostream>\\nusing namespace std;\\nint numIslands(char grid[][5], int m, int n) { return 0; }\\nint main() { char g[][5] = {{\\"11110\\"}, {\\"11010\\"}, {\\"11000\\"}, {\\"00000\\"}}; cout << numIslands(g, 4, 5); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nvoid dfs(char grid[][5], int m, int n, int i, int j) {\\n    if(i < 0 || i >= m || j < 0 || j >= n || grid[i][j] != '1') return;\\n    grid[i][j] = '0';\\n    dfs(grid, m, n, i+1, j); dfs(grid, m, n, i-1, j);\\n    dfs(grid, m, n, i, j+1); dfs(grid, m, n, i, j-1);\\n}\\nint numIslands(char grid[][5], int m, int n) {\\n    int count = 0;\\n    for(int i = 0; i < m; i++)\\n        for(int j = 0; j < n; j++)\\n            if(grid[i][j] == '1') { count++; dfs(grid, m, n, i, j); }\\n    return count;\\n}\\nint main() { char g[][5] = {{\\"11110\\"}, {\\"11010\\"}, {\\"11000\\"}, {\\"00000\\"}}; cout << numIslands(g, 4, 5); return 0; }","explanation":{"approach":"DFS to sink each island when found.","steps":["Find '1'","Count++, DFS to mark all connected as visited"],"complexity":"Time: O(mn), Space: O(mn)"},"testCases":[{"input":"One large island","expectedOutput":"1","explanation":"All connected"},{"input":"3 separate islands","expectedOutput":"3","explanation":"Three components"},{"input":"All water","expectedOutput":"0","explanation":"No land"},{"input":"Diagonal doesn't connect","expectedOutput":"4","explanation":"Corners are separate"}]},{"id":"core79","title":"Course Schedule","description":"Check if all courses can be completed (no circular dependencies).","difficulty":"MEDIUM","category":"Graph","starterCode":"#include <iostream>\\nusing namespace std;\\nbool canFinish(int numCourses, int prereq[][2], int n) { return false; }\\nint main() { int p[][2] = {{1, 0}}; cout << canFinish(2, p, 1); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nint adj[10][10], adjSize[10] = {};\\nint state[10];\\nbool hasCycle(int node) {\\n    if(state[node] == 1) return true;\\n    if(state[node] == 2) return false;\\n    state[node] = 1;\\n    for(int i = 0; i < adjSize[node]; i++)\\n        if(hasCycle(adj[node][i])) return true;\\n    state[node] = 2;\\n    return false;\\n}\\nbool canFinish(int numCourses, int prereq[][2], int n) {\\n    for(int i = 0; i < numCourses; i++) adjSize[i] = 0;\\n    for(int i = 0; i < n; i++) {\\n        int a = prereq[i][0], b = prereq[i][1];\\n        adj[b][adjSize[b]++] = a;\\n    }\\n    for(int i = 0; i < numCourses; i++) state[i] = 0;\\n    for(int i = 0; i < numCourses; i++)\\n        if(hasCycle(i)) return false;\\n    return true;\\n}\\nint main() { int p[][2] = {{1, 0}}; cout << canFinish(2, p, 1); return 0; }","explanation":{"approach":"Detect cycle in directed graph using DFS with 3 states.","steps":["0=unvisited, 1=visiting, 2=done","If hit node with state=1, cycle"],"complexity":"Time: O(V+E), Space: O(V)"},"testCases":[{"input":"2 courses, 1->0","expectedOutput":"1","explanation":"Take 0 then 1"},{"input":"Cycle: 0->1->0","expectedOutput":"0","explanation":"Impossible"},{"input":"No prerequisites","expectedOutput":"1","explanation":"All independent"},{"input":"Chain: 0->1->2->3","expectedOutput":"1","explanation":"Valid order exists"}]},{"id":"core80","title":"Clone Graph","description":"Deep copy an undirected graph.","difficulty":"MEDIUM","category":"Graph","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int val; Node* adj[10]; int n; Node(): val(0), n(0) {} Node(int v): val(v), n(0) {} };\\nNode* cloneGraph(Node* node) { return nullptr; }\\nint main() { Node* n = new Node(1); cout << \\"Clone Graph\\"; return 0; }","expectedOutput":"Clone Graph","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int val; Node* adj[10]; int n; Node(): val(0), n(0) {} Node(int v): val(v), n(0) {} };\\nNode* cloned[101] = {};\\nNode* cloneGraph(Node* node) {\\n    if(!node) return nullptr;\\n    if(cloned[node->val]) return cloned[node->val];\\n    Node* copy = new Node(node->val);\\n    cloned[node->val] = copy;\\n    for(int i = 0; i < node->n; i++)\\n        copy->adj[copy->n++] = cloneGraph(node->adj[i]);\\n    return copy;\\n}\\nint main() { Node* n = new Node(1); cout << \\"Clone Graph\\"; return 0; }","explanation":{"approach":"DFS with hash map to track originalclone.","steps":["If already cloned, return clone","Create clone, recurse on neighbors"],"complexity":"Time: O(V+E), Space: O(V)"},"testCases":[{"input":"4-node cycle graph","expectedOutput":"Cloned graph","explanation":"Deep copy with same structure"},{"input":"Single node","expectedOutput":"Single node copy","explanation":"Clone 1 node"},{"input":"Empty graph","expectedOutput":"null","explanation":"Nothing to clone"},{"input":"Complete graph K4","expectedOutput":"Cloned K4","explanation":"All connections preserved"}]}]`),TM=JSON.parse(`[{"id":"rec1","title":"Tower of Hanoi","description":"Move n disks.","difficulty":"MEDIUM","category":"Recursion","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid hanoi(int n, char from, char to, char aux) {}\\nint main() { hanoi(3,'A','C','B'); return 0; }","expectedOutput":"A->C A->B C->B A->C B->A B->C A->C","solution":"#include <iostream>\\nusing namespace std;\\nvoid hanoi(int n, char from, char to, char aux) { if(n==1) { cout<<from<<\\"->\\"<<to<<\\" \\"; return; } hanoi(n-1,from,aux,to); cout<<from<<\\"->\\"<<to<<\\" \\"; hanoi(n-1,aux,to,from); }\\nint main() { hanoi(3,'A','C','B'); return 0; }","explanation":{"approach":"Move n-1 disks to aux, move biggest to target, move n-1 from aux to target.","analogy":"Move all but biggest aside, move biggest, put others back.","steps":["Move n-1 to auxiliary","Move largest to target","Move n-1 from aux to target"],"complexity":"Time: O(2^n), Space: O(n)"},"testCases":[{"input":"n=3, A->C","expectedOutput":"A->C A->B C->B A->C B->A B->C A->C","explanation":"7 moves for 3 disks"},{"input":"n=2, A->C","expectedOutput":"A->B A->C B->C","explanation":"3 moves for 2 disks"},{"input":"n=1, A->C","expectedOutput":"A->C","explanation":"1 move for 1 disk"},{"input":"n=4, A->C","expectedOutput":"15 moves","explanation":"2^4 - 1 = 15 moves for 4 disks"}]},{"id":"rec2","title":"Subsets","description":"Generate all subsets.","difficulty":"MEDIUM","category":"Recursion","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid subsets(int a[], int n, int i, int sub[], int k) {}\\nint main() { int a[]={1,2,3}, s[10]; subsets(a,3,0,s,0); return 0; }","expectedOutput":"1 2 3 1 2 1 3 2 3 1 2 3","solution":"#include <iostream>\\nusing namespace std;\\nvoid subsets(int a[], int n, int i, int sub[], int k) { if(i==n) { for(int j=0;j<k;j++) cout<<sub[j]<<\\" \\"; return; } sub[k]=a[i]; subsets(a,n,i+1,sub,k+1); subsets(a,n,i+1,sub,k); }\\nint main() { int a[]={1,2,3}, s[10]; subsets(a,3,0,s,0); return 0; }","explanation":{"approach":"For each element: include or exclude.","analogy":"Binary choice for each item.","steps":["Include current, recurse","Exclude current, recurse"],"complexity":"Time: O(2^n), Space: O(n)"},"testCases":[{"input":"{1,2,3}","expectedOutput":"{},{1},{2},{3},{1,2},{1,3},{2,3},{1,2,3}","explanation":"8 subsets including empty"},{"input":"{1,2}","expectedOutput":"{},{1},{2},{1,2}","explanation":"4 subsets"},{"input":"{1}","expectedOutput":"{},{1}","explanation":"2 subsets"},{"input":"{}","expectedOutput":"{}","explanation":"Only empty subset"}]},{"id":"rec3","title":"Permutations","description":"Generate all permutations.","difficulty":"MEDIUM","category":"Recursion","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid permute(int a[], int l, int r) {}\\nint main() { int a[]={1,2,3}; permute(a,0,2); return 0; }","expectedOutput":"1 2 3 1 3 2 2 1 3 2 3 1 3 2 1 3 1 2","solution":"#include <iostream>\\nusing namespace std;\\nvoid permute(int a[], int l, int r) { if(l==r) { for(int i=0;i<=r;i++) cout<<a[i]<<\\" \\"; return; } for(int i=l;i<=r;i++) { swap(a[l],a[i]); permute(a,l+1,r); swap(a[l],a[i]); } }\\nint main() { int a[]={1,2,3}; permute(a,0,2); return 0; }","explanation":{"approach":"Swap each element to first position, recurse on rest.","analogy":"Try each person as leader, arrange rest.","steps":["Swap current with each after","Recurse on remaining","Swap back"],"complexity":"Time: O(n!), Space: O(n)"},"testCases":[{"input":"{1,2,3}","expectedOutput":"123,132,213,231,312,321","explanation":"6 permutations (3!)"},{"input":"{1,2}","expectedOutput":"12,21","explanation":"2 permutations (2!)"},{"input":"{1}","expectedOutput":"1","explanation":"1 permutation (1!)"},{"input":"{1,2,3,4}","expectedOutput":"24 permutations","explanation":"4! = 24 permutations"}]},{"id":"rec4","title":"Binary Search Recursive","description":"Binary search using recursion.","difficulty":"EASY","category":"Recursion","starterCode":"#include <iostream>\\nusing namespace std;\\nint bSearch(int a[], int l, int r, int x) { return -1; }\\nint main() { int a[]={1,3,5,7,9}; cout<<bSearch(a,0,4,5); return 0; }","expectedOutput":"2","solution":"#include <iostream>\\nusing namespace std;\\nint bSearch(int a[], int l, int r, int x) { if(l>r) return -1; int m=(l+r)/2; if(a[m]==x) return m; if(a[m]>x) return bSearch(a,l,m-1,x); return bSearch(a,m+1,r,x); }\\nint main() { int a[]={1,3,5,7,9}; cout<<bSearch(a,0,4,5); return 0; }","explanation":{"approach":"Check middle, recurse on appropriate half.","analogy":"Divide and conquer search.","steps":["Check middle","If less, go left half","If more, go right half"],"complexity":"Time: O(log n), Space: O(log n)"},"testCases":[{"input":"{1,3,5,7,9}, x=5","expectedOutput":"2","explanation":"Found at index 2"},{"input":"{1,3,5,7,9}, x=1","expectedOutput":"0","explanation":"Found at index 0"},{"input":"{1,3,5,7,9}, x=10","expectedOutput":"-1","explanation":"Not found"},{"input":"{1,3,5,7,9}, x=9","expectedOutput":"4","explanation":"Found at last index"}]},{"id":"rec5","title":"String Reversal Recursive","description":"Reverse string recursively.","difficulty":"EASY","category":"Recursion","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid reverse(char s[], int l, int r) {}\\nint main() { char s[]=\\"hello\\"; reverse(s,0,4); cout<<s; return 0; }","expectedOutput":"olleh","solution":"#include <iostream>\\nusing namespace std;\\nvoid reverse(char s[], int l, int r) { if(l>=r) return; swap(s[l],s[r]); reverse(s,l+1,r-1); }\\nint main() { char s[]=\\"hello\\"; reverse(s,0,4); cout<<s; return 0; }","explanation":{"approach":"Swap ends, recurse on middle.","analogy":"Mirror the outer, then inner.","steps":["Swap first and last","Recurse on middle portion"],"complexity":"Time: O(n), Space: O(n)"},"testCases":[{"input":"\\"hello\\"","expectedOutput":"olleh","explanation":"Reversed string"},{"input":"\\"a\\"","expectedOutput":"a","explanation":"Single char unchanged"},{"input":"\\"ab\\"","expectedOutput":"ba","explanation":"Two chars swapped"},{"input":"\\"racecar\\"","expectedOutput":"racecar","explanation":"Palindrome stays same"}]},{"id":"rec6","title":"Combination Sum","description":"Find combinations summing to target.","difficulty":"MEDIUM","category":"Recursion","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid combSum(int a[], int n, int t, int i, int cur[], int k) {}\\nint main() { int a[]={2,3,6,7}, c[10]; combSum(a,4,7,0,c,0); return 0; }","expectedOutput":"2 2 3 7","solution":"#include <iostream>\\nusing namespace std;\\nvoid combSum(int a[], int n, int t, int i, int cur[], int k) { if(t==0) { for(int j=0;j<k;j++) cout<<cur[j]<<\\" \\"; return; } if(t<0||i>=n) return; cur[k]=a[i]; combSum(a,n,t-a[i],i,cur,k+1); combSum(a,n,t,i+1,cur,k); }\\nint main() { int a[]={2,3,6,7}, c[10]; combSum(a,4,7,0,c,0); return 0; }","explanation":{"approach":"Include current (possibly multiple times) or move to next.","analogy":"Try using each coin repeatedly.","steps":["Include current, stay at same index","Or skip to next index"],"complexity":"Time: O(2^n), Space: O(target)"},"testCases":[{"input":"{2,3,6,7}, target=7","expectedOutput":"[2,2,3],[7]","explanation":"Two combinations sum to 7"},{"input":"{2,3,5}, target=8","expectedOutput":"[2,2,2,2],[2,3,3],[3,5]","explanation":"Three combinations"},{"input":"{2}, target=1","expectedOutput":"","explanation":"No combination possible"},{"input":"{1}, target=3","expectedOutput":"[1,1,1]","explanation":"Only one way with 1s"}]},{"id":"rec7","title":"N-th Catalan","description":"Calculate Catalan number.","difficulty":"MEDIUM","category":"Recursion","starterCode":"#include <iostream>\\nusing namespace std;\\nint catalan(int n) { return 0; }\\nint main() { cout<<catalan(5); return 0; }","expectedOutput":"42","solution":"#include <iostream>\\nusing namespace std;\\nint catalan(int n) { if(n<=1) return 1; int c=0; for(int i=0;i<n;i++) c+=catalan(i)*catalan(n-1-i); return c; }\\nint main() { cout<<catalan(5); return 0; }","explanation":{"approach":"C(n) = sum of C(i)  C(n-1-i) for all i.","analogy":"Count valid parentheses combinations.","steps":["Base: C(0)=C(1)=1","C(n) = sum over all splits"],"complexity":"Time: O(4^n), Space: O(n)"},"testCases":[{"input":"n=5","expectedOutput":"42","explanation":"C(5) = 42"},{"input":"n=3","expectedOutput":"5","explanation":"C(3) = 5"},{"input":"n=0","expectedOutput":"1","explanation":"C(0) = 1"},{"input":"n=4","expectedOutput":"14","explanation":"C(4) = 14"}]},{"id":"rec8","title":"Josephus Problem","description":"Find survivor position.","difficulty":"MEDIUM","category":"Recursion","starterCode":"#include <iostream>\\nusing namespace std;\\nint josephus(int n, int k) { return 0; }\\nint main() { cout<<josephus(7,3); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nint josephus(int n, int k) { if(n==1) return 0; return (josephus(n-1,k)+k)%n; }\\nint main() { cout<<josephus(7,3); return 0; }","explanation":{"approach":"f(n,k) = (f(n-1,k)+k) mod n.","analogy":"After elimination, positions shift.","steps":["Base: 1 person, position 0","Add k and mod by n"],"complexity":"Time: O(n), Space: O(n)"},"testCases":[{"input":"n=7, k=3","expectedOutput":"3","explanation":"Survivor at position 3 (0-indexed)"},{"input":"n=5, k=2","expectedOutput":"2","explanation":"Survivor at position 2"},{"input":"n=1, k=1","expectedOutput":"0","explanation":"Only one person survives"},{"input":"n=10, k=2","expectedOutput":"4","explanation":"Even skip pattern survivor"}]},{"id":"rec9","title":"Flood Fill","description":"Fill connected region.","difficulty":"MEDIUM","category":"Recursion","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid floodFill(int img[][5], int r, int c, int sr, int sc, int nc) {}\\nint main() { int img[][5]={{1,1,1},{1,1,0},{1,0,1}}; floodFill(img,3,3,1,1,2); cout<<img[1][1]; return 0; }","expectedOutput":"2","solution":"#include <iostream>\\nusing namespace std;\\nvoid fill(int img[][5], int r, int c, int i, int j, int oc, int nc) { if(i<0||i>=r||j<0||j>=c||img[i][j]!=oc) return; img[i][j]=nc; fill(img,r,c,i+1,j,oc,nc); fill(img,r,c,i-1,j,oc,nc); fill(img,r,c,i,j+1,oc,nc); fill(img,r,c,i,j-1,oc,nc); }\\nvoid floodFill(int img[][5], int r, int c, int sr, int sc, int nc) { int oc=img[sr][sc]; if(oc!=nc) fill(img,r,c,sr,sc,oc,nc); }\\nint main() { int img[][5]={{1,1,1},{1,1,0},{1,0,1}}; floodFill(img,3,3,1,1,2); cout<<img[1][1]; return 0; }","explanation":{"approach":"DFS to fill all connected same-color cells.","analogy":"Paint bucket tool in image editor.","steps":["Change current cell","Recurse to 4 neighbors"],"complexity":"Time: O(rc), Space: O(rc)"},"testCases":[{"input":"grid, start=(1,1), color=2","expectedOutput":"2","explanation":"Center cell filled with 2"},{"input":"all 1s, start=(0,0), color=2","expectedOutput":"all 2s","explanation":"Entire grid filled"},{"input":"same old and new color","expectedOutput":"unchanged","explanation":"No fill needed"},{"input":"isolated cell, start=(0,0), color=3","expectedOutput":"3","explanation":"Only starting cell changes"}]},{"id":"rec10","title":"Rat in a Maze","description":"Find path through maze.","difficulty":"MEDIUM","category":"Recursion","starterCode":"#include <iostream>\\nusing namespace std;\\nbool solveMaze(int m[][4], int n) { return false; }\\nint main() { int m[][4]={{1,0,0,0},{1,1,0,1},{0,1,0,0},{1,1,1,1}}; cout<<solveMaze(m,4); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool solve(int m[][4], int n, int x, int y, int sol[][4]) { if(x==n-1&&y==n-1&&m[x][y]==1){sol[x][y]=1;return true;} if(x>=0&&x<n&&y>=0&&y<n&&m[x][y]==1&&sol[x][y]==0) { sol[x][y]=1; if(solve(m,n,x+1,y,sol)) return true; if(solve(m,n,x,y+1,sol)) return true; sol[x][y]=0; } return false; }\\nbool solveMaze(int m[][4], int n) { int sol[4][4]={}; return solve(m,n,0,0,sol); }\\nint main() { int m[][4]={{1,0,0,0},{1,1,0,1},{0,1,0,0},{1,1,1,1}}; cout<<solveMaze(m,4); return 0; }","explanation":{"approach":"Try down and right, backtrack if stuck.","analogy":"Try each path, undo and try another if blocked.","steps":["Mark current as part of path","Try down, then right","Backtrack if neither works"],"complexity":"Time: O(2^(n)), Space: O(n)"},"testCases":[{"input":"4x4 maze with path","expectedOutput":"1","explanation":"Path exists from (0,0) to (3,3)"},{"input":"blocked maze","expectedOutput":"0","explanation":"No path exists"},{"input":"1x1 with 1","expectedOutput":"1","explanation":"Already at destination"},{"input":"direct diagonal path","expectedOutput":"1","explanation":"Staircase path exists"}]}]`),NM=JSON.parse(`[{"id":"rec11","title":"N-th Tribonacci","description":"T(n) = T(n-1)+T(n-2)+T(n-3).","difficulty":"EASY","category":"Recursion","starterCode":"#include <iostream>\\nusing namespace std;\\nint tribonacci(int n) { return 0; }\\nint main() { cout<<tribonacci(7); return 0; }","expectedOutput":"13","solution":"#include <iostream>\\nusing namespace std;\\nint tribonacci(int n) { if(n==0) return 0; if(n<=2) return 1; return tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3); }\\nint main() { cout<<tribonacci(7); return 0; }","explanation":{"approach":"Like Fibonacci but with 3 terms.","analogy":"Sum of previous three.","steps":["Base: T(0)=0, T(1)=T(2)=1","T(n)=T(n-1)+T(n-2)+T(n-3)"],"complexity":"Time: O(3^n), Space: O(n)"},"testCases":[{"input":"n=7","expectedOutput":"13","explanation":"T(7) = 13"},{"input":"n=4","expectedOutput":"4","explanation":"T(4) = 0+1+1+2 = 4"},{"input":"n=0","expectedOutput":"0","explanation":"Base case T(0) = 0"},{"input":"n=25","expectedOutput":"1389537","explanation":"Large Tribonacci number"}]},{"id":"rec12","title":"Power Set Recursive","description":"Generate all subsets recursively.","difficulty":"MEDIUM","category":"Recursion","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid powerSet(int a[], int n) {}\\nint main() { int a[]={1,2}; powerSet(a,2); return 0; }","expectedOutput":"{} {1} {1 2} {2}","solution":"#include <iostream>\\nusing namespace std;\\nvoid gen(int a[], int n, int i, int cur[], int k) { if(i==n) { cout<<\\"{\\"; for(int j=0;j<k;j++) cout<<(j?\\" \\":\\"\\")<<cur[j]; cout<<\\"} \\"; return; } gen(a,n,i+1,cur,k); cur[k]=a[i]; gen(a,n,i+1,cur,k+1); }\\nvoid powerSet(int a[], int n) { int cur[10]; gen(a,n,0,cur,0); }\\nint main() { int a[]={1,2}; powerSet(a,2); return 0; }","explanation":{"approach":"Include or exclude each element.","analogy":"Binary choice for each.","steps":["For each element, choose include or not","Recurse to next element"],"complexity":"Time: O(2^n), Space: O(n)"},"testCases":[{"input":"{1,2}","expectedOutput":"{} {1} {2} {1,2}","explanation":"4 subsets"},{"input":"{1}","expectedOutput":"{} {1}","explanation":"2 subsets"},{"input":"{}","expectedOutput":"{}","explanation":"Only empty set"},{"input":"{1,2,3}","expectedOutput":"8 subsets","explanation":"2^3 = 8 subsets"}]},{"id":"rec13","title":"String Permutations","description":"All permutations of string.","difficulty":"MEDIUM","category":"Recursion","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid permute(char s[]) {}\\nint main() { char s[]=\\"ABC\\"; permute(s); return 0; }","expectedOutput":"ABC ACB BAC BCA CBA CAB","solution":"#include <iostream>\\nusing namespace std;\\nvoid perm(char s[], int l, int r) { if(l==r) { cout<<s<<\\" \\"; return; } for(int i=l;i<=r;i++) { swap(s[l],s[i]); perm(s,l+1,r); swap(s[l],s[i]); } }\\nvoid permute(char s[]) { int n=0; while(s[n]) n++; perm(s,0,n-1); }\\nint main() { char s[]=\\"ABC\\"; permute(s); return 0; }","explanation":{"approach":"Swap each char to front, permute rest.","analogy":"Try each as first letter.","steps":["Swap current with each position","Recurse","Swap back"],"complexity":"Time: O(n!), Space: O(n)"},"testCases":[{"input":"\\"ABC\\"","expectedOutput":"ABC ACB BAC BCA CBA CAB","explanation":"6 permutations"},{"input":"\\"AB\\"","expectedOutput":"AB BA","explanation":"2 permutations"},{"input":"\\"A\\"","expectedOutput":"A","explanation":"Single char"},{"input":"\\"ABCD\\"","expectedOutput":"24 permutations","explanation":"4! = 24 permutations"}]},{"id":"rec14","title":"Count Paths in Maze","description":"Paths from top-left to bottom-right.","difficulty":"MEDIUM","category":"Recursion","starterCode":"#include <iostream>\\nusing namespace std;\\nint countPaths(int r, int c) { return 0; }\\nint main() { cout<<countPaths(3,3); return 0; }","expectedOutput":"6","solution":"#include <iostream>\\nusing namespace std;\\nint countPaths(int r, int c) { if(r==1||c==1) return 1; return countPaths(r-1,c)+countPaths(r,c-1); }\\nint main() { cout<<countPaths(3,3); return 0; }","explanation":{"approach":"Sum of paths from left and above.","analogy":"Can only move right or down.","steps":["Base: edge has 1 path","paths(r,c) = paths(r-1,c) + paths(r,c-1)"],"complexity":"Time: O(2^(r+c)), Space: O(r+c)"},"testCases":[{"input":"r=3, c=3","expectedOutput":"6","explanation":"6 paths in 3x3 grid"},{"input":"r=2, c=2","expectedOutput":"2","explanation":"2 paths in 2x2 grid"},{"input":"r=1, c=5","expectedOutput":"1","explanation":"Only 1 path along edge"},{"input":"r=4, c=4","expectedOutput":"20","explanation":"C(6,3) = 20 paths"}]},{"id":"rec15","title":"Palindrome Partition Count","description":"Min cuts for palindrome partition.","difficulty":"HARD","category":"Recursion","starterCode":"#include <iostream>\\nusing namespace std;\\nint minCut(char s[]) { return 0; }\\nint main() { cout<<minCut(\\"aab\\"); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isPalin(char s[], int l, int r) { while(l<r) if(s[l++]!=s[r--]) return false; return true; }\\nint solve(char s[], int i, int n) { if(i>=n||isPalin(s,i,n-1)) return 0; int mn=1e9; for(int j=i;j<n-1;j++) if(isPalin(s,i,j)) mn=min(mn,1+solve(s,j+1,n)); return mn; }\\nint minCut(char s[]) { int n=0; while(s[n]) n++; return solve(s,0,n); }\\nint main() { cout<<minCut(\\"aab\\"); return 0; }","explanation":{"approach":"Try all palindrome prefixes.","analogy":"Cut after each palindrome prefix.","steps":["If rest is palindrome, no more cuts","Else try each palindrome prefix, cut, recurse"],"complexity":"Time: O(n  2^n), Space: O(n)"},"testCases":[{"input":"\\"aab\\"","expectedOutput":"1","explanation":"aa|b - 1 cut"},{"input":"\\"a\\"","expectedOutput":"0","explanation":"Already palindrome"},{"input":"\\"abc\\"","expectedOutput":"2","explanation":"a|b|c - 2 cuts"},{"input":"\\"aba\\"","expectedOutput":"0","explanation":"Already palindrome"}]},{"id":"rec16","title":"Word Break Recursive","description":"Can string be segmented.","difficulty":"MEDIUM","category":"Recursion","starterCode":"#include <iostream>\\nusing namespace std;\\nbool wordBreak(char s[], char dict[][10], int n) { return false; }\\nint main() { char dict[][10]={\\"apple\\",\\"pen\\"}; cout<<wordBreak(\\"applepenapple\\",dict,2); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool eq(char a[], char b[], int len) { for(int i=0;i<len;i++) if(a[i]!=b[i]) return false; return !b[len]; }\\nbool solve(char s[], int start, char dict[][10], int n, int slen) { if(start==slen) return true; for(int end=start+1;end<=slen;end++) for(int i=0;i<n;i++) if(eq(s+start,dict[i],end-start)) if(solve(s,end,dict,n,slen)) return true; return false; }\\nbool wordBreak(char s[], char dict[][10], int n) { int slen=0; while(s[slen]) slen++; return solve(s,0,dict,n,slen); }\\nint main() { char dict[][10]={\\"apple\\",\\"pen\\"}; cout<<wordBreak(\\"applepenapple\\",dict,2); return 0; }","explanation":{"approach":"Try matching each dictionary word.","analogy":"Spell out with dictionary words.","steps":["Try each word as prefix","If match, recurse on rest"],"complexity":"Time: O(2^n), Space: O(n)"},"testCases":[{"input":"\\"applepenapple\\", dict=[apple,pen]","expectedOutput":"1","explanation":"apple+pen+apple"},{"input":"\\"catsandog\\", dict=[cats,dog,sand,and,cat]","expectedOutput":"0","explanation":"Cannot segment"},{"input":"\\"abc\\", dict=[a,b,c]","expectedOutput":"1","explanation":"a+b+c"},{"input":"\\"leetcode\\", dict=[leet,code]","expectedOutput":"1","explanation":"leet+code"}]},{"id":"rec17","title":"Decode Ways Recursive","description":"Number of decodings.","difficulty":"MEDIUM","category":"Recursion","starterCode":"#include <iostream>\\nusing namespace std;\\nint numDecodings(char s[]) { return 0; }\\nint main() { cout<<numDecodings(\\"226\\"); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nint solve(char s[], int i, int n) { if(i==n) return 1; if(s[i]=='0') return 0; int ways=solve(s,i+1,n); if(i+1<n) { int two=(s[i]-'0')*10+(s[i+1]-'0'); if(two>=10 && two<=26) ways+=solve(s,i+2,n); } return ways; }\\nint numDecodings(char s[]) { int n=0; while(s[n]) n++; return solve(s,0,n); }\\nint main() { cout<<numDecodings(\\"226\\"); return 0; }","explanation":{"approach":"Take 1 or 2 digits.","analogy":"Decode as single or pair.","steps":["Take single digit (1-9)","Take two digits (10-26)"],"complexity":"Time: O(2^n), Space: O(n)"},"testCases":[{"input":"\\"226\\"","expectedOutput":"3","explanation":"2,2,6 OR 22,6 OR 2,26"},{"input":"\\"12\\"","expectedOutput":"2","explanation":"1,2 OR 12"},{"input":"\\"06\\"","expectedOutput":"0","explanation":"Leading 0 invalid"},{"input":"\\"11106\\"","expectedOutput":"2","explanation":"1,1,10,6 OR 11,10,6"}]},{"id":"rec18","title":"Unique BSTs Count","description":"Number of unique BSTs.","difficulty":"MEDIUM","category":"Recursion","starterCode":"#include <iostream>\\nusing namespace std;\\nint numTrees(int n) { return 0; }\\nint main() { cout<<numTrees(3); return 0; }","expectedOutput":"5","solution":"#include <iostream>\\nusing namespace std;\\nint numTrees(int n) { if(n<=1) return 1; int total=0; for(int i=1;i<=n;i++) total+=numTrees(i-1)*numTrees(n-i); return total; }\\nint main() { cout<<numTrees(3); return 0; }","explanation":{"approach":"Each node as root, count subtrees.","analogy":"Catalan number structure.","steps":["For each root i","Left has i-1 nodes, right has n-i"],"complexity":"Time: O(3^n), Space: O(n)"},"testCases":[{"input":"n=3","expectedOutput":"5","explanation":"5 unique BST structures"},{"input":"n=1","expectedOutput":"1","explanation":"Single node"},{"input":"n=4","expectedOutput":"14","explanation":"Catalan(4) = 14"},{"input":"n=5","expectedOutput":"42","explanation":"Catalan(5) = 42"}]},{"id":"rec19","title":"Kth Symbol in Grammar","description":"Find kth symbol in row n.","difficulty":"MEDIUM","category":"Recursion","starterCode":"#include <iostream>\\nusing namespace std;\\nint kthGrammar(int n, int k) { return 0; }\\nint main() { cout<<kthGrammar(4,5); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nint kthGrammar(int n, int k) { if(n==1) return 0; int parent=kthGrammar(n-1,(k+1)/2); return k%2==1 ? parent : 1-parent; }\\nint main() { cout<<kthGrammar(4,5); return 0; }","explanation":{"approach":"Find parent symbol, flip if needed.","analogy":"001, 110.","steps":["Find parent at position (k+1)/2","If k odd, same as parent; else flip"],"complexity":"Time: O(n), Space: O(n)"},"testCases":[{"input":"n=4, k=5","expectedOutput":"1","explanation":"Row 4: 0110100110010110, k=5 is 1"},{"input":"n=1, k=1","expectedOutput":"0","explanation":"First row is just 0"},{"input":"n=2, k=2","expectedOutput":"1","explanation":"Row 2 is 01, k=2 is 1"},{"input":"n=3, k=1","expectedOutput":"0","explanation":"Row 3 is 0110, k=1 is 0"}]},{"id":"rec20","title":"Different Ways to Add Parens","description":"All possible results.","difficulty":"MEDIUM","category":"Recursion","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid diffWays(char e[]) {}\\nint main() { diffWays(\\"2*3-4*5\\"); return 0; }","expectedOutput":"-34 -10 -14 -10 10","solution":"#include <iostream>\\nusing namespace std;\\nvoid solve(char e[], int l, int r, int res[], int *k) { bool hasOp=false; for(int i=l;i<=r;i++) { if(e[i]=='+'||e[i]=='-'||e[i]=='*') { hasOp=true; int left[100],right[100],lk=0,rk=0; solve(e,l,i-1,left,&lk); solve(e,i+1,r,right,&rk); for(int a=0;a<lk;a++) for(int b=0;b<rk;b++) { int v; if(e[i]=='+') v=left[a]+right[b]; else if(e[i]=='-') v=left[a]-right[b]; else v=left[a]*right[b]; res[(*k)++]=v; } } } if(!hasOp) { int v=0; for(int i=l;i<=r;i++) v=v*10+(e[i]-'0'); res[(*k)++]=v; } }\\nvoid diffWays(char e[]) { int n=0; while(e[n]) n++; int res[100], k=0; solve(e,0,n-1,res,&k); for(int i=0;i<k;i++) cout<<res[i]<<\\" \\"; }\\nint main() { diffWays(\\"2*3-4*5\\"); return 0; }","explanation":{"approach":"Split at each operator.","analogy":"Divide and conquer at operators.","steps":["For each operator, split","Combine results of subexpressions"],"complexity":"Time: O(4^n/n), Space: O(4^n/n)"},"testCases":[{"input":"\\"2*3-4*5\\"","expectedOutput":"-34 -10 -14 -10 10","explanation":"5 different results"},{"input":"\\"2-1-1\\"","expectedOutput":"0 2","explanation":"(2-1)-1=0 or 2-(1-1)=2"},{"input":"\\"2+3\\"","expectedOutput":"5","explanation":"Single result"},{"input":"\\"2+3*4\\"","expectedOutput":"14 20","explanation":"2+(3*4)=14 or (2+3)*4=20"}]}]`),kM=JSON.parse(`[{"id":"bit1","title":"Check if Even","description":"Using bit operation.","difficulty":"EASY","category":"Bit Manipulation","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isEven(int n) { return false; }\\nint main() { cout<<isEven(10); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isEven(int n) { return (n & 1) == 0; }\\nint main() { cout<<isEven(10); return 0; }","explanation":{"approach":"Last bit is 0 for even numbers.","steps":["AND with 1","If result is 0, it's even"],"complexity":"Time: O(1), Space: O(1)"},"testCases":[{"input":"n=10","expectedOutput":"1","explanation":"10 is even (binary 1010)"},{"input":"n=7","expectedOutput":"0","explanation":"7 is odd (binary 111)"},{"input":"n=0","expectedOutput":"1","explanation":"0 is even"},{"input":"n=1024","expectedOutput":"1","explanation":"2^10 is even"}]},{"id":"bit2","title":"Check if Odd","description":"Using bit operation.","difficulty":"EASY","category":"Bit Manipulation","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isOdd(int n) { return false; }\\nint main() { cout<<isOdd(7); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isOdd(int n) { return (n & 1) == 1; }\\nint main() { cout<<isOdd(7); return 0; }","explanation":{"approach":"Last bit is 1 for odd numbers.","steps":["AND with 1","If result is 1, it's odd"],"complexity":"Time: O(1), Space: O(1)"},"testCases":[{"input":"n=7","expectedOutput":"1","explanation":"7 is odd (binary 111)"},{"input":"n=8","expectedOutput":"0","explanation":"8 is even"},{"input":"n=1","expectedOutput":"1","explanation":"1 is odd"},{"input":"n=0","expectedOutput":"0","explanation":"0 is even"}]},{"id":"bit3","title":"Count Set Bits","description":"Count 1s in binary.","difficulty":"EASY","category":"Bit Manipulation","starterCode":"#include <iostream>\\nusing namespace std;\\nint countSetBits(int n) { return 0; }\\nint main() { cout<<countSetBits(13); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nint countSetBits(int n) { int c = 0; while(n) { c += n & 1; n >>= 1; } return c; }\\nint main() { cout<<countSetBits(13); return 0; }","explanation":{"approach":"Check last bit, shift right, repeat.","steps":["Check last bit","Shift right","Count 1s"],"complexity":"Time: O(log n), Space: O(1)"},"testCases":[{"input":"n=13","expectedOutput":"3","explanation":"13=1101 has three 1s"},{"input":"n=7","expectedOutput":"3","explanation":"7=111 has three 1s"},{"input":"n=16","expectedOutput":"1","explanation":"16=10000 has one 1"},{"input":"n=0","expectedOutput":"0","explanation":"0 has no set bits"}]},{"id":"bit4","title":"Check Power of 2","description":"Is number power of 2.","difficulty":"EASY","category":"Bit Manipulation","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isPowerOf2(int n) { return false; }\\nint main() { cout<<isPowerOf2(16); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isPowerOf2(int n) { return n > 0 && (n & (n-1)) == 0; }\\nint main() { cout<<isPowerOf2(16); return 0; }","explanation":{"approach":"Power of 2 has exactly one 1 bit.","steps":["n & (n-1) removes lowest set bit","If 0, only one bit was set"],"complexity":"Time: O(1), Space: O(1)"},"testCases":[{"input":"n=16","expectedOutput":"1","explanation":"16=10000, single bit"},{"input":"n=15","expectedOutput":"0","explanation":"15=1111, multiple bits"},{"input":"n=1","expectedOutput":"1","explanation":"2^0=1"},{"input":"n=0","expectedOutput":"0","explanation":"0 is not power of 2"}]},{"id":"bit5","title":"Toggle Kth Bit","description":"Flip the kth bit.","difficulty":"EASY","category":"Bit Manipulation","starterCode":"#include <iostream>\\nusing namespace std;\\nint toggleBit(int n, int k) { return 0; }\\nint main() { cout<<toggleBit(13,1); return 0; }","expectedOutput":"15","solution":"#include <iostream>\\nusing namespace std;\\nint toggleBit(int n, int k) { return n ^ (1 << k); }\\nint main() { cout<<toggleBit(13,1); return 0; }","explanation":{"approach":"XOR with 1 at position k flips that bit.","steps":["Create mask: 1 << k","XOR with n"],"complexity":"Time: O(1), Space: O(1)"},"testCases":[{"input":"n=13, k=1","expectedOutput":"15","explanation":"11011111"},{"input":"n=10, k=0","expectedOutput":"11","explanation":"10101011"},{"input":"n=8, k=3","expectedOutput":"0","explanation":"10000000"},{"input":"n=0, k=2","expectedOutput":"4","explanation":"0100"}]},{"id":"bit6","title":"Set Kth Bit","description":"Set kth bit to 1.","difficulty":"EASY","category":"Bit Manipulation","starterCode":"#include <iostream>\\nusing namespace std;\\nint setBit(int n, int k) { return 0; }\\nint main() { cout<<setBit(10,0); return 0; }","expectedOutput":"11","solution":"#include <iostream>\\nusing namespace std;\\nint setBit(int n, int k) { return n | (1 << k); }\\nint main() { cout<<setBit(10,0); return 0; }","explanation":{"approach":"OR with 1 at position k sets that bit.","steps":["Create mask: 1 << k","OR with n"],"complexity":"Time: O(1), Space: O(1)"},"testCases":[{"input":"n=10, k=0","expectedOutput":"11","explanation":"10101011"},{"input":"n=0, k=3","expectedOutput":"8","explanation":"01000"},{"input":"n=15, k=2","expectedOutput":"15","explanation":"Already set"},{"input":"n=1, k=4","expectedOutput":"17","explanation":"110001"}]},{"id":"bit7","title":"Clear Kth Bit","description":"Set kth bit to 0.","difficulty":"EASY","category":"Bit Manipulation","starterCode":"#include <iostream>\\nusing namespace std;\\nint clearBit(int n, int k) { return 0; }\\nint main() { cout<<clearBit(15,1); return 0; }","expectedOutput":"13","solution":"#include <iostream>\\nusing namespace std;\\nint clearBit(int n, int k) { return n & ~(1 << k); }\\nint main() { cout<<clearBit(15,1); return 0; }","explanation":{"approach":"AND with inverted mask clears that bit.","steps":["Create mask: ~(1 << k)","AND with n"],"complexity":"Time: O(1), Space: O(1)"},"testCases":[{"input":"n=15, k=1","expectedOutput":"13","explanation":"11111101"},{"input":"n=8, k=3","expectedOutput":"0","explanation":"10000000"},{"input":"n=10, k=0","expectedOutput":"10","explanation":"Already 0 at k=0"},{"input":"n=7, k=2","expectedOutput":"3","explanation":"111011"}]},{"id":"bit8","title":"Check Kth Bit","description":"Is kth bit set.","difficulty":"EASY","category":"Bit Manipulation","starterCode":"#include <iostream>\\nusing namespace std;\\nbool checkBit(int n, int k) { return false; }\\nint main() { cout<<checkBit(13,2); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool checkBit(int n, int k) { return (n >> k) & 1; }\\nint main() { cout<<checkBit(13,2); return 0; }","explanation":{"approach":"Shift right k positions, check last bit.","steps":["Shift n right by k","AND with 1"],"complexity":"Time: O(1), Space: O(1)"},"testCases":[{"input":"n=13, k=2","expectedOutput":"1","explanation":"1101, bit 2=1"},{"input":"n=13, k=1","expectedOutput":"0","explanation":"1101, bit 1=0"},{"input":"n=8, k=3","expectedOutput":"1","explanation":"1000, bit 3=1"},{"input":"n=0, k=0","expectedOutput":"0","explanation":"No bits set"}]},{"id":"bit9","title":"Swap Two Numbers","description":"Swap without temp using XOR.","difficulty":"EASY","category":"Bit Manipulation","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid swap(int &a, int &b) {}\\nint main() { int a=5, b=10; swap(a,b); cout<<a<<\\" \\"<<b; return 0; }","expectedOutput":"10 5","solution":"#include <iostream>\\nusing namespace std;\\nvoid swap(int &a, int &b) { a = a ^ b; b = a ^ b; a = a ^ b; }\\nint main() { int a=5, b=10; swap(a,b); cout<<a<<\\" \\"<<b; return 0; }","explanation":{"approach":"XOR trick swaps without temp variable.","steps":["a ^= b","b ^= a","a ^= b"],"complexity":"Time: O(1), Space: O(1)"},"testCases":[{"input":"a=5, b=10","expectedOutput":"10 5","explanation":"Values swapped"},{"input":"a=0, b=100","expectedOutput":"100 0","explanation":"Works with 0"},{"input":"a=7, b=7","expectedOutput":"7 7","explanation":"Same values stay same"},{"input":"a=1, b=2","expectedOutput":"2 1","explanation":"Simple swap"}]},{"id":"bit10","title":"Find Single Number","description":"One appears once, others twice.","difficulty":"EASY","category":"Bit Manipulation","starterCode":"#include <iostream>\\nusing namespace std;\\nint singleNumber(int a[], int n) { return 0; }\\nint main() { int a[]={2,1,4,5,2,4,1}; cout<<singleNumber(a,7); return 0; }","expectedOutput":"5","solution":"#include <iostream>\\nusing namespace std;\\nint singleNumber(int a[], int n) { int r = 0; for(int i = 0; i < n; i++) r ^= a[i]; return r; }\\nint main() { int a[]={2,1,4,5,2,4,1}; cout<<singleNumber(a,7); return 0; }","explanation":{"approach":"XOR all: pairs cancel, single remains.","steps":["XOR all elements","Pairs cancel out"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"[2,1,4,5,2,4,1]","expectedOutput":"5","explanation":"5 appears once"},{"input":"[1,1,2]","expectedOutput":"2","explanation":"2 is unique"},{"input":"[7]","expectedOutput":"7","explanation":"Single element"},{"input":"[3,3,7,7,9]","expectedOutput":"9","explanation":"9 is unique"}]},{"id":"bit11","title":"Rightmost Set Bit","description":"Position of rightmost 1.","difficulty":"EASY","category":"Bit Manipulation","starterCode":"#include <iostream>\\nusing namespace std;\\nint rightmostSetBit(int n) { return 0; }\\nint main() { cout<<rightmostSetBit(12); return 0; }","expectedOutput":"2","solution":"#include <iostream>\\nusing namespace std;\\nint rightmostSetBit(int n) { int pos = 0; while((n & 1) == 0) { n >>= 1; pos++; } return pos; }\\nint main() { cout<<rightmostSetBit(12); return 0; }","explanation":{"approach":"Shift right until last bit is 1.","steps":["Shift until bit is 1","Count shifts"],"complexity":"Time: O(log n), Space: O(1)"},"testCases":[{"input":"n=12","expectedOutput":"2","explanation":"1100, first 1 at pos 2"},{"input":"n=1","expectedOutput":"0","explanation":"1, first 1 at pos 0"},{"input":"n=16","expectedOutput":"4","explanation":"10000, pos 4"},{"input":"n=6","expectedOutput":"1","explanation":"110, pos 1"}]},{"id":"bit12","title":"Turn Off Rightmost Bit","description":"Clear rightmost 1.","difficulty":"EASY","category":"Bit Manipulation","starterCode":"#include <iostream>\\nusing namespace std;\\nint turnOffRightmost(int n) { return 0; }\\nint main() { cout<<turnOffRightmost(12); return 0; }","expectedOutput":"8","solution":"#include <iostream>\\nusing namespace std;\\nint turnOffRightmost(int n) { return n & (n - 1); }\\nint main() { cout<<turnOffRightmost(12); return 0; }","explanation":{"approach":"n & (n-1) clears rightmost set bit.","steps":["n-1 flips from rightmost 1","AND removes that bit"],"complexity":"Time: O(1), Space: O(1)"},"testCases":[{"input":"n=12","expectedOutput":"8","explanation":"11001000"},{"input":"n=7","expectedOutput":"6","explanation":"111110"},{"input":"n=8","expectedOutput":"0","explanation":"10000"},{"input":"n=15","expectedOutput":"14","explanation":"11111110"}]}]`),EM=JSON.parse('[{"id":"logic1","title":"Josephus Problem","description":"Find the position of the last survivor in elimination game.","difficulty":"MEDIUM","category":"Logic","starterCode":"#include <iostream>\\nusing namespace std;\\nint josephus(int n, int k) { return 0; }\\nint main() { cout<<josephus(5,2); return 0; }","expectedOutput":"2","solution":"#include <iostream>\\nusing namespace std;\\nint josephus(int n, int k) { if(n==1) return 0; return (josephus(n-1,k)+k)%n; }\\nint main() { cout<<josephus(5,2); return 0; }","explanation":{"approach":"Recursive formula: f(n,k) = (f(n-1,k)+k) mod n.","steps":["Base: 1 person at position 0","Recurse with shifted positions"],"complexity":"Time: O(n), Space: O(n)"},"testCases":[{"input":"n=5, k=2","expectedOutput":"2","explanation":"Position 2 survives (0-indexed)"},{"input":"n=7, k=3","expectedOutput":"3","explanation":"Every 3rd eliminated"},{"input":"n=1, k=1","expectedOutput":"0","explanation":"Single person survives"},{"input":"n=10, k=1","expectedOutput":"9","explanation":"k=1 means last survives"}]},{"id":"logic2","title":"Tower of Hanoi Steps","description":"Calculate minimum moves to solve Tower of Hanoi.","difficulty":"EASY","category":"Logic","starterCode":"#include <iostream>\\nusing namespace std;\\nint hanoiMoves(int n) { return 0; }\\nint main() { cout<<hanoiMoves(3); return 0; }","expectedOutput":"7","solution":"#include <iostream>\\nusing namespace std;\\nint hanoiMoves(int n) { return (1<<n)-1; }\\nint main() { cout<<hanoiMoves(3); return 0; }","explanation":{"approach":"Formula: 2^n - 1 moves needed.","steps":["Each disk doubles complexity","Total = 2^n - 1"],"complexity":"Time: O(1), Space: O(1)"},"testCases":[{"input":"n=3","expectedOutput":"7","explanation":"2^3-1=7 moves"},{"input":"n=1","expectedOutput":"1","explanation":"Single disk = 1 move"},{"input":"n=4","expectedOutput":"15","explanation":"2^4-1=15"},{"input":"n=5","expectedOutput":"31","explanation":"2^5-1=31"}]},{"id":"logic3","title":"Egg Drop Problem","description":"Find minimum tries needed with 2 eggs for n floors.","difficulty":"MEDIUM","category":"Logic","starterCode":"#include <iostream>\\nusing namespace std;\\nint eggDrop(int n) { return 0; }\\nint main() { cout<<eggDrop(10); return 0; }","expectedOutput":"4","solution":"#include <iostream>\\nusing namespace std;\\nint eggDrop(int n) { int tries=1; while(tries*(tries+1)/2<n) tries++; return tries; }\\nint main() { cout<<eggDrop(10); return 0; }","explanation":{"approach":"Find k where k(k+1)/2 >= n floors.","steps":["With k tries, can cover k(k+1)/2 floors","Find smallest valid k"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"n=10","expectedOutput":"4","explanation":"4*5/2=10 floors covered"},{"input":"n=100","expectedOutput":"14","explanation":"14*15/2=105>=100"},{"input":"n=1","expectedOutput":"1","explanation":"1 floor = 1 try"},{"input":"n=36","expectedOutput":"8","explanation":"8*9/2=36"}]},{"id":"logic4","title":"Water Jug Problem","description":"Check if target liters can be measured with two jugs.","difficulty":"MEDIUM","category":"Logic","starterCode":"#include <iostream>\\nusing namespace std;\\nbool canMeasure(int x, int y, int z) { return false; }\\nint main() { cout<<canMeasure(3,5,4); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nint gcd(int a, int b) { return b==0?a:gcd(b,a%b); }\\nbool canMeasure(int x, int y, int z) { return z<=x+y && z%gcd(x,y)==0; }\\nint main() { cout<<canMeasure(3,5,4); return 0; }","explanation":{"approach":"Possible if z divides gcd(x,y) and z <= x+y.","steps":["Check z <= total capacity","Check z divisible by gcd"],"complexity":"Time: O(log min(x,y)), Space: O(1)"},"testCases":[{"input":"x=3, y=5, z=4","expectedOutput":"1","explanation":"gcd(3,5)=1, 4%1=0"},{"input":"x=2, y=6, z=5","expectedOutput":"0","explanation":"gcd=2, 5%20"},{"input":"x=1, y=1, z=2","expectedOutput":"1","explanation":"Use both jugs"},{"input":"x=3, y=5, z=9","expectedOutput":"0","explanation":"z > x+y"}]},{"id":"logic5","title":"Monty Hall Problem","description":"Should you switch doors in the Monty Hall game?","difficulty":"EASY","category":"Logic","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid montyHall() {}\\nint main() { montyHall(); return 0; }","expectedOutput":"Switch","solution":"#include <iostream>\\nusing namespace std;\\nvoid montyHall() { cout<<\\"Switch\\"; }\\nint main() { montyHall(); return 0; }","explanation":{"approach":"Switching wins 2/3 of the time.","steps":["Initial choice: 1/3 chance","Switching: 2/3 chance","Always switch!"],"complexity":"Time: O(1), Space: O(1)"},"testCases":[{"input":"Standard game","expectedOutput":"Switch","explanation":"Switch wins 2/3"},{"input":"3 doors, 1 prize","expectedOutput":"Switch","explanation":"Classic Monty Hall"},{"input":"Host reveals goat","expectedOutput":"Switch","explanation":"Still 2/3 by switching"},{"input":"Any scenario","expectedOutput":"Switch","explanation":"Math always favors switch"}]},{"id":"logic6","title":"Birthday Paradox","description":"Find minimum people for >50% chance of shared birthday.","difficulty":"EASY","category":"Logic","starterCode":"#include <iostream>\\nusing namespace std;\\nint birthdayParadox() { return 0; }\\nint main() { cout<<birthdayParadox(); return 0; }","expectedOutput":"23","solution":"#include <iostream>\\nusing namespace std;\\nint birthdayParadox() { double p=1; int n=0; while(p>0.5) { n++; p*=(365.0-n+1)/365; } return n; }\\nint main() { cout<<birthdayParadox(); return 0; }","explanation":{"approach":"Calculate probability of all different birthdays.","steps":["P(all different) = 365/365  364/365  ...","Find when P < 0.5"],"complexity":"Time: O(1), Space: O(1)"},"testCases":[{"input":"50% threshold","expectedOutput":"23","explanation":"23 people = >50% match"},{"input":"Standard calculation","expectedOutput":"23","explanation":"Famous result"},{"input":"365 days","expectedOutput":"23","explanation":"Counterintuitive but true"},{"input":"Probability math","expectedOutput":"23","explanation":"Birthday paradox constant"}]},{"id":"logic7","title":"Prisoner Hat Problem","description":"Maximum prisoners saved with optimal strategy.","difficulty":"EASY","category":"Logic","starterCode":"#include <iostream>\\nusing namespace std;\\nint maxSaves(int n) { return 0; }\\nint main() { cout<<maxSaves(10); return 0; }","expectedOutput":"9","solution":"#include <iostream>\\nusing namespace std;\\nint maxSaves(int n) { return n-1; }\\nint main() { cout<<maxSaves(10); return 0; }","explanation":{"approach":"First person encodes parity, guarantees n-1 saves.","steps":["First says parity of black hats","Others deduce their color"],"complexity":"Time: O(1), Space: O(1)"},"testCases":[{"input":"n=10","expectedOutput":"9","explanation":"9 guaranteed saves"},{"input":"n=100","expectedOutput":"99","explanation":"First sacrifices for info"},{"input":"n=2","expectedOutput":"1","explanation":"First tells second"},{"input":"n=1","expectedOutput":"0","explanation":"No info possible with 1"}]},{"id":"logic8","title":"Bridge Crossing Problem","description":"Minimum time for 4 people to cross bridge at night.","difficulty":"MEDIUM","category":"Logic","starterCode":"#include <iostream>\\nusing namespace std;\\nint bridgeCrossing(int a, int b, int c, int d) { return 0; }\\nint main() { cout<<bridgeCrossing(1,2,5,10); return 0; }","expectedOutput":"17","solution":"#include <iostream>\\nusing namespace std;\\nint bridgeCrossing(int a, int b, int c, int d) { int t[4]={a,b,c,d}; for(int i=0;i<4;i++) for(int j=i+1;j<4;j++) if(t[i]>t[j]) swap(t[i],t[j]); return min(2*t[1]+t[0]+t[3], t[0]+2*t[1]+t[2]+t[3]); }\\nint main() { cout<<bridgeCrossing(1,2,5,10); return 0; }","explanation":{"approach":"Compare: fast shuttles vs pair slowest together.","steps":["Strategy 1: fastest shuttles everyone","Strategy 2: pair slowest"],"complexity":"Time: O(1), Space: O(1)"},"testCases":[{"input":"1,2,5,10","expectedOutput":"17","explanation":"Optimal: 1+2 go, 1 back, 5+10 go, 2 back, 1+2 go"},{"input":"1,2,3,4","expectedOutput":"10","explanation":"Smaller difference"},{"input":"1,1,1,1","expectedOutput":"4","explanation":"All same speed"},{"input":"1,5,5,5","expectedOutput":"16","explanation":"One fast, three slow"}]},{"id":"logic9","title":"Fake Ball Weighing","description":"Minimum weighings to find one fake ball among n.","difficulty":"EASY","category":"Logic","starterCode":"#include <iostream>\\nusing namespace std;\\nint minWeighings(int n) { return 0; }\\nint main() { cout<<minWeighings(9); return 0; }","expectedOutput":"2","solution":"#include <iostream>\\nusing namespace std;\\nint minWeighings(int n) { int w=0; while(n>1) { n=(n+2)/3; w++; } return w; }\\nint main() { cout<<minWeighings(9); return 0; }","explanation":{"approach":"Divide into 3 groups, eliminate 2/3 each weighing.","steps":["Each weighing divides by 3","log(n) weighings needed"],"complexity":"Time: O(log n), Space: O(1)"},"testCases":[{"input":"n=9","expectedOutput":"2","explanation":"9->3->1 in 2 weighings"},{"input":"n=27","expectedOutput":"3","explanation":"27->9->3->1"},{"input":"n=3","expectedOutput":"1","explanation":"One weighing enough"},{"input":"n=1","expectedOutput":"0","explanation":"Only one ball, no weighing"}]},{"id":"logic10","title":"Chessboard Rice Problem","description":"Total rice grains on chessboard (doubling each square).","difficulty":"EASY","category":"Logic","starterCode":"#include <iostream>\\nusing namespace std;\\nlong long totalRice(int n) { return 0; }\\nint main() { cout<<totalRice(8); return 0; }","expectedOutput":"255","solution":"#include <iostream>\\nusing namespace std;\\nlong long totalRice(int n) { return (1LL<<n)-1; }\\nint main() { cout<<totalRice(8); return 0; }","explanation":{"approach":"Sum of geometric series: 2^n - 1.","steps":["Each square doubles previous","Total = 2^n - 1"],"complexity":"Time: O(1), Space: O(1)"},"testCases":[{"input":"n=8","expectedOutput":"255","explanation":"2^8-1=255"},{"input":"n=64","expectedOutput":"18446744073709551615","explanation":"Full chessboard"},{"input":"n=1","expectedOutput":"1","explanation":"Just first square"},{"input":"n=10","expectedOutput":"1023","explanation":"2^10-1"}]}]'),AM=JSON.parse(`[{"id":"arr11","title":"Kadane's Algorithm","description":"Find maximum sum contiguous subarray.","difficulty":"MEDIUM","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nint maxSubArray(int a[], int n) { return 0; }\\nint main() { int a[]={-2,1,-3,4,-1,2,1,-5,4}; cout<<maxSubArray(a,9); return 0; }","expectedOutput":"6","solution":"#include <iostream>\\nusing namespace std;\\nint maxSubArray(int a[], int n) { int mx=a[0],cur=a[0]; for(int i=1;i<n;i++) { cur=max(a[i],cur+a[i]); mx=max(mx,cur); } return mx; }\\nint main() { int a[]={-2,1,-3,4,-1,2,1,-5,4}; cout<<maxSubArray(a,9); return 0; }","explanation":{"approach":"Track current and max sum, extend or restart at each position.","steps":["cur = max(a[i], cur + a[i])","mx = max(mx, cur)"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"[-2,1,-3,4,-1,2,1,-5,4]","expectedOutput":"6","explanation":"Subarray [4,-1,2,1] = 6"},{"input":"[1]","expectedOutput":"1","explanation":"Single element"},{"input":"[-1,-2,-3]","expectedOutput":"-1","explanation":"All negative, pick least"},{"input":"[5,4,-1,7,8]","expectedOutput":"23","explanation":"Entire array"}]},{"id":"arr12","title":"Merge Sorted Arrays","description":"Merge two sorted arrays into one sorted array.","difficulty":"EASY","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid merge(int a[], int m, int b[], int n, int c[]) {}\\nint main() { int a[]={1,3,5}, b[]={2,4,6}, c[6]; merge(a,3,b,3,c); for(int i=0;i<6;i++) cout<<c[i]<<\\" \\"; return 0; }","expectedOutput":"1 2 3 4 5 6","solution":"#include <iostream>\\nusing namespace std;\\nvoid merge(int a[], int m, int b[], int n, int c[]) { int i=0,j=0,k=0; while(i<m && j<n) c[k++]=a[i]<b[j]?a[i++]:b[j++]; while(i<m) c[k++]=a[i++]; while(j<n) c[k++]=b[j++]; }\\nint main() { int a[]={1,3,5}, b[]={2,4,6}, c[6]; merge(a,3,b,3,c); for(int i=0;i<6;i++) cout<<c[i]<<\\" \\"; return 0; }","explanation":{"approach":"Two pointer merge: compare and pick smaller.","steps":["Compare elements","Pick smaller, advance that pointer","Copy remaining"],"complexity":"Time: O(m+n), Space: O(m+n)"},"testCases":[{"input":"[1,3,5] + [2,4,6]","expectedOutput":"1 2 3 4 5 6","explanation":"Interleaved merge"},{"input":"[1,2,3] + []","expectedOutput":"1 2 3","explanation":"One empty"},{"input":"[1] + [2]","expectedOutput":"1 2","explanation":"Single elements"},{"input":"[1,2] + [3,4]","expectedOutput":"1 2 3 4","explanation":"No interleaving"}]},{"id":"arr13","title":"Intersection of Two Arrays","description":"Find common unique elements between two arrays.","difficulty":"EASY","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid intersection(int a[], int m, int b[], int n) {}\\nint main() { int a[]={1,2,2,1}, b[]={2,2}; intersection(a,4,b,2); return 0; }","expectedOutput":"2","solution":"#include <iostream>\\nusing namespace std;\\nvoid intersection(int a[], int m, int b[], int n) { bool seen[1001]={}; for(int i=0;i<m;i++) seen[a[i]]=true; bool printed[1001]={}; for(int i=0;i<n;i++) if(seen[b[i]] && !printed[b[i]]) { cout<<b[i]<<\\" \\"; printed[b[i]]=true; } }\\nint main() { int a[]={1,2,2,1}, b[]={2,2}; intersection(a,4,b,2); return 0; }","explanation":{"approach":"Hash set: mark first array, find in second.","steps":["Mark all elements of a","Print elements of b that exist in a"],"complexity":"Time: O(m+n), Space: O(m)"},"testCases":[{"input":"[1,2,2,1]  [2,2]","expectedOutput":"2","explanation":"Common element is 2"},{"input":"[4,9,5]  [9,4,9,8,4]","expectedOutput":"9 4","explanation":"Two common elements"},{"input":"[1,2,3]  [4,5,6]","expectedOutput":"","explanation":"No common"},{"input":"[1,1,1]  [1]","expectedOutput":"1","explanation":"Deduplicated"}]},{"id":"arr14","title":"Union of Two Arrays","description":"Find all unique elements from both arrays.","difficulty":"EASY","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid unionArr(int a[], int m, int b[], int n) {}\\nint main() { int a[]={1,2,3}, b[]={2,3,4,5}; unionArr(a,3,b,4); return 0; }","expectedOutput":"1 2 3 4 5","solution":"#include <iostream>\\nusing namespace std;\\nvoid unionArr(int a[], int m, int b[], int n) { bool seen[1001]={}; for(int i=0;i<m;i++) if(!seen[a[i]]) { cout<<a[i]<<\\" \\"; seen[a[i]]=true; } for(int i=0;i<n;i++) if(!seen[b[i]]) { cout<<b[i]<<\\" \\"; seen[b[i]]=true; } }\\nint main() { int a[]={1,2,3}, b[]={2,3,4,5}; unionArr(a,3,b,4); return 0; }","explanation":{"approach":"Track all seen, print unseen from both.","steps":["Print unseen from a","Print unseen from b"],"complexity":"Time: O(m+n), Space: O(m+n)"},"testCases":[{"input":"[1,2,3]  [2,3,4,5]","expectedOutput":"1 2 3 4 5","explanation":"Combined unique"},{"input":"[1,1,1]  [2,2,2]","expectedOutput":"1 2","explanation":"Deduplicated"},{"input":"[]  [1,2,3]","expectedOutput":"1 2 3","explanation":"One empty"},{"input":"[5,6]  [1,2]","expectedOutput":"5 6 1 2","explanation":"No overlap"}]},{"id":"arr15","title":"Leaders in Array","description":"Find elements greater than all to their right.","difficulty":"EASY","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid leaders(int a[], int n) {}\\nint main() { int a[]={16,17,4,3,5,2}; leaders(a,6); return 0; }","expectedOutput":"17 5 2","solution":"#include <iostream>\\nusing namespace std;\\nvoid leaders(int a[], int n) { int mx=a[n-1]; int res[n], k=0; res[k++]=mx; for(int i=n-2;i>=0;i--) if(a[i]>mx) { mx=a[i]; res[k++]=mx; } for(int i=k-1;i>=0;i--) cout<<res[i]<<\\" \\"; }\\nint main() { int a[]={16,17,4,3,5,2}; leaders(a,6); return 0; }","explanation":{"approach":"Scan from right tracking max.","steps":["Track max from right","If current > max, it's a leader"],"complexity":"Time: O(n), Space: O(n)"},"testCases":[{"input":"[16,17,4,3,5,2]","expectedOutput":"17 5 2","explanation":"17>all right, 5>2, 2 is last"},{"input":"[1,2,3,4,5]","expectedOutput":"5","explanation":"Only last is leader"},{"input":"[5,4,3,2,1]","expectedOutput":"5 4 3 2 1","explanation":"All are leaders"},{"input":"[7]","expectedOutput":"7","explanation":"Single element is leader"}]},{"id":"arr16","title":"Next Greater Element","description":"Find next larger element for each position.","difficulty":"MEDIUM","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid nextGreater(int a[], int n) {}\\nint main() { int a[]={4,5,2,25}; nextGreater(a,4); return 0; }","expectedOutput":"5 25 25 -1","solution":"#include <iostream>\\nusing namespace std;\\nvoid nextGreater(int a[], int n) { int stk[n],top=-1,res[n]; for(int i=n-1;i>=0;i--) { while(top>=0 && stk[top]<=a[i]) top--; res[i]=top<0?-1:stk[top]; stk[++top]=a[i]; } for(int i=0;i<n;i++) cout<<res[i]<<\\" \\"; }\\nint main() { int a[]={4,5,2,25}; nextGreater(a,4); return 0; }","explanation":{"approach":"Monotonic stack keeps larger elements.","steps":["Pop while stack top <= current","Top is next greater"],"complexity":"Time: O(n), Space: O(n)"},"testCases":[{"input":"[4,5,2,25]","expectedOutput":"5 25 25 -1","explanation":"4->5, 5->25, 2->25, 25->none"},{"input":"[13,7,6,12]","expectedOutput":"-1 12 12 -1","explanation":"For 7 and 6, next greater is 12"},{"input":"[1,2,3,4]","expectedOutput":"2 3 4 -1","explanation":"Each has next as greater"},{"input":"[4,3,2,1]","expectedOutput":"-1 -1 -1 -1","explanation":"Decreasing, no greater"}]},{"id":"arr17","title":"Rotate Array by K","description":"Rotate array k positions to the right.","difficulty":"MEDIUM","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid rotate(int a[], int n, int k) {}\\nint main() { int a[]={1,2,3,4,5,6,7}; rotate(a,7,3); for(int i=0;i<7;i++) cout<<a[i]<<\\" \\"; return 0; }","expectedOutput":"5 6 7 1 2 3 4","solution":"#include <iostream>\\nusing namespace std;\\nvoid rev(int a[], int l, int r) { while(l<r) swap(a[l++],a[r--]); }\\nvoid rotate(int a[], int n, int k) { k%=n; rev(a,0,n-1); rev(a,0,k-1); rev(a,k,n-1); }\\nint main() { int a[]={1,2,3,4,5,6,7}; rotate(a,7,3); for(int i=0;i<7;i++) cout<<a[i]<<\\" \\"; return 0; }","explanation":{"approach":"Three reversals: all, first k, last n-k.","steps":["Reverse entire array","Reverse first k","Reverse rest"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"[1,2,3,4,5,6,7], k=3","expectedOutput":"5 6 7 1 2 3 4","explanation":"Last 3 move to front"},{"input":"[1,2,3], k=1","expectedOutput":"3 1 2","explanation":"Last moves to front"},{"input":"[1,2,3], k=3","expectedOutput":"1 2 3","explanation":"Full rotation = no change"},{"input":"[-1,-100,3,99], k=2","expectedOutput":"3 99 -1 -100","explanation":"With negatives"}]},{"id":"arr18","title":"Move Zeros to End","description":"Move all zeros to end while maintaining order of non-zeros.","difficulty":"EASY","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid moveZeros(int a[], int n) {}\\nint main() { int a[]={0,1,0,3,12}; moveZeros(a,5); for(int i=0;i<5;i++) cout<<a[i]<<\\" \\"; return 0; }","expectedOutput":"1 3 12 0 0","solution":"#include <iostream>\\nusing namespace std;\\nvoid moveZeros(int a[], int n) { int j=0; for(int i=0;i<n;i++) if(a[i]!=0) swap(a[i],a[j++]); }\\nint main() { int a[]={0,1,0,3,12}; moveZeros(a,5); for(int i=0;i<5;i++) cout<<a[i]<<\\" \\"; return 0; }","explanation":{"approach":"Swap non-zeros to front position.","steps":["Keep pointer for next non-zero position","Swap when non-zero found"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"[0,1,0,3,12]","expectedOutput":"1 3 12 0 0","explanation":"Non-zeros first"},{"input":"[0]","expectedOutput":"0","explanation":"Single zero"},{"input":"[1,2,3]","expectedOutput":"1 2 3","explanation":"No zeros"},{"input":"[0,0,0,1]","expectedOutput":"1 0 0 0","explanation":"Many zeros"}]},{"id":"arr19","title":"Subarray with Given Sum","description":"Find contiguous subarray summing to target.","difficulty":"MEDIUM","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid subarraySum(int a[], int n, int target) {}\\nint main() { int a[]={1,4,20,3,10,5}; subarraySum(a,6,33); return 0; }","expectedOutput":"2 4","solution":"#include <iostream>\\nusing namespace std;\\nvoid subarraySum(int a[], int n, int target) { int s=0,start=0; for(int i=0;i<n;i++) { s+=a[i]; while(s>target && start<i) s-=a[start++]; if(s==target) { cout<<start<<\\" \\"<<i; return; } } }\\nint main() { int a[]={1,4,20,3,10,5}; subarraySum(a,6,33); return 0; }","explanation":{"approach":"Sliding window: expand right, shrink left.","steps":["Add right element","Shrink left while sum too big"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"[1,4,20,3,10,5], sum=33","expectedOutput":"2 4","explanation":"20+3+10=33"},{"input":"[1,4], sum=0","expectedOutput":"-1","explanation":"No subarray"},{"input":"[1,4,0,0,3,10,5], sum=7","expectedOutput":"3 5","explanation":"0+0+3+10... wait"},{"input":"[15], sum=15","expectedOutput":"0 0","explanation":"Single element"}]},{"id":"arr20","title":"Trapping Rain Water","description":"Calculate water trapped between bars after rain.","difficulty":"HARD","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nint trap(int h[], int n) { return 0; }\\nint main() { int h[]={0,1,0,2,1,0,1,3,2,1,2,1}; cout<<trap(h,12); return 0; }","expectedOutput":"6","solution":"#include <iostream>\\nusing namespace std;\\nint trap(int h[], int n) { int l=0,r=n-1,lm=0,rm=0,w=0; while(l<r) { if(h[l]<h[r]) { if(h[l]>=lm) lm=h[l]; else w+=lm-h[l]; l++; } else { if(h[r]>=rm) rm=h[r]; else w+=rm-h[r]; r--; } } return w; }\\nint main() { int h[]={0,1,0,2,1,0,1,3,2,1,2,1}; cout<<trap(h,12); return 0; }","explanation":{"approach":"Two pointers with left/right max tracking.","steps":["Water at position = min(leftMax,rightMax) - height","Move smaller side"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"[0,1,0,2,1,0,1,3,2,1,2,1]","expectedOutput":"6","explanation":"Classic example"},{"input":"[4,2,0,3,2,5]","expectedOutput":"9","explanation":"Wider basin"},{"input":"[1,2,3,4,5]","expectedOutput":"0","explanation":"Ascending, no trap"},{"input":"[5,4,3,2,1]","expectedOutput":"0","explanation":"Descending, no trap"}]}]`),jM=JSON.parse(`[{"id":"str11","title":"Longest Substring Without Repeat","description":"Longest unique char substring.","difficulty":"MEDIUM","category":"Strings","starterCode":"#include <iostream>\\nusing namespace std;\\nint lengthOfLongestSubstring(char s[]) { return 0; }\\nint main() { cout<<lengthOfLongestSubstring(\\"abcabcbb\\"); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nint lengthOfLongestSubstring(char s[]) { int seen[256]={}; int mx=0,l=0; for(int r=0;s[r];r++) { while(seen[(int)s[r]]) { seen[(int)s[l]]=0; l++; } seen[(int)s[r]]=1; mx=max(mx,r-l+1); } return mx; }\\nint main() { cout<<lengthOfLongestSubstring(\\"abcabcbb\\"); return 0; }","explanation":{"approach":"Sliding window with char set.","analogy":"Shrink when duplicate found.","steps":["Expand right","Shrink left on duplicate"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"\\"abcabcbb\\"","expectedOutput":"3","explanation":"abc is longest unique substring"},{"input":"\\"bbbbb\\"","expectedOutput":"1","explanation":"Only single char unique"},{"input":"\\"pwwkew\\"","expectedOutput":"3","explanation":"wke is longest"},{"input":"\\"\\"","expectedOutput":"0","explanation":"Empty string"}]},{"id":"str12","title":"Valid Palindrome","description":"Check if palindrome ignoring non-alnum.","difficulty":"EASY","category":"Strings","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isPalindrome(char s[]) { return false; }\\nint main() { cout<<isPalindrome(\\"A man a plan a canal Panama\\"); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isAlnum(char c) { return (c>='a'&&c<='z')||(c>='A'&&c<='Z')||(c>='0'&&c<='9'); }\\nchar lower(char c) { return c>='A'&&c<='Z'?c+32:c; }\\nbool isPalindrome(char s[]) { int n=0; while(s[n]) n++; int l=0,r=n-1; while(l<r) { while(l<r && !isAlnum(s[l])) l++; while(l<r && !isAlnum(s[r])) r--; if(lower(s[l])!=lower(s[r])) return false; l++; r--; } return true; }\\nint main() { cout<<isPalindrome(\\"A man a plan a canal Panama\\"); return 0; }","explanation":{"approach":"Two pointers, skip non-alphanumeric.","analogy":"Compare letters only.","steps":["Skip non-alnum characters","Compare lowercase"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"\\"A man a plan a canal Panama\\"","expectedOutput":"1","explanation":"Valid palindrome ignoring spaces/case"},{"input":"\\"race a car\\"","expectedOutput":"0","explanation":"Not a palindrome"},{"input":"\\" \\"","expectedOutput":"1","explanation":"Empty after filtering is palindrome"},{"input":"\\"Was it a car or a cat I saw\\"","expectedOutput":"1","explanation":"Another valid palindrome"}]},{"id":"str13","title":"String Compression","description":"Compress consecutive chars.","difficulty":"MEDIUM","category":"Strings","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid compress(char s[]) {}\\nint main() { char s[]=\\"aabcccccaaa\\"; compress(s); return 0; }","expectedOutput":"a2b1c5a3","solution":"#include <iostream>\\nusing namespace std;\\nvoid compress(char s[]) { int n=0; while(s[n]) n++; int i=0; while(i<n) { char c=s[i]; int cnt=0; while(i<n && s[i]==c) { cnt++; i++; } cout<<c<<cnt; } }\\nint main() { char s[]=\\"aabcccccaaa\\"; compress(s); return 0; }","explanation":{"approach":"Count consecutive characters.","analogy":"Run-length encoding.","steps":["Count same character runs","Print char and count"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"\\"aabcccccaaa\\"","expectedOutput":"a2b1c5a3","explanation":"Compressed form"},{"input":"\\"abc\\"","expectedOutput":"a1b1c1","explanation":"No compression benefit"},{"input":"\\"aaa\\"","expectedOutput":"a3","explanation":"All same characters"},{"input":"\\"aaabbbccc\\"","expectedOutput":"a3b3c3","explanation":"Three groups of three"}]},{"id":"str14","title":"Multiply Strings","description":"Multiply two number strings.","difficulty":"MEDIUM","category":"Strings","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid multiply(char n1[], char n2[]) {}\\nint main() { multiply(\\"123\\",\\"456\\"); return 0; }","expectedOutput":"56088","solution":"#include <iostream>\\nusing namespace std;\\nvoid multiply(char n1[], char n2[]) { int l1=0,l2=0; while(n1[l1]) l1++; while(n2[l2]) l2++; int res[l1+l2]={}; for(int i=l1-1;i>=0;i--) for(int j=l2-1;j>=0;j--) { int mul=(n1[i]-'0')*(n2[j]-'0'); int p1=i+j,p2=i+j+1; int sum=mul+res[p2]; res[p2]=sum%10; res[p1]+=sum/10; } int i=0; while(i<l1+l2 && res[i]==0) i++; if(i==l1+l2) { cout<<0; return; } while(i<l1+l2) cout<<res[i++]; }\\nint main() { multiply(\\"123\\",\\"456\\"); return 0; }","explanation":{"approach":"Digit by digit multiplication.","analogy":"Grade school multiplication.","steps":["Multiply each pair of digits","Position result correctly","Handle carries"],"complexity":"Time: O(mn), Space: O(m+n)"},"testCases":[{"input":"\\"123\\"  \\"456\\"","expectedOutput":"56088","explanation":"123 * 456 = 56088"},{"input":"\\"2\\"  \\"3\\"","expectedOutput":"6","explanation":"Simple multiplication"},{"input":"\\"0\\"  \\"12345\\"","expectedOutput":"0","explanation":"Zero times anything"},{"input":"\\"999\\"  \\"999\\"","expectedOutput":"998001","explanation":"Large multiplication with carries"}]},{"id":"str15","title":"Add Binary","description":"Add two binary strings.","difficulty":"EASY","category":"Strings","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid addBinary(char a[], char b[]) {}\\nint main() { addBinary(\\"11\\",\\"1\\"); return 0; }","expectedOutput":"100","solution":"#include <iostream>\\nusing namespace std;\\nvoid addBinary(char a[], char b[]) { int la=0,lb=0; while(a[la]) la++; while(b[lb]) lb++; char res[la+lb+2]; int k=0,c=0; int i=la-1,j=lb-1; while(i>=0 || j>=0 || c) { int sum=c; if(i>=0) sum+=a[i--]-'0'; if(j>=0) sum+=b[j--]-'0'; res[k++]='0'+sum%2; c=sum/2; } for(int t=k-1;t>=0;t--) cout<<res[t]; }\\nint main() { addBinary(\\"11\\",\\"1\\"); return 0; }","explanation":{"approach":"Add with carry from right.","analogy":"Binary addition.","steps":["Add bits and carry","Store result in reverse"],"complexity":"Time: O(max(m,n)), Space: O(max(m,n))"},"testCases":[{"input":"\\"11\\" + \\"1\\"","expectedOutput":"100","explanation":"3 + 1 = 4 in binary"},{"input":"\\"1010\\" + \\"1011\\"","expectedOutput":"10101","explanation":"10 + 11 = 21"},{"input":"\\"0\\" + \\"0\\"","expectedOutput":"0","explanation":"Zero plus zero"},{"input":"\\"1111\\" + \\"1111\\"","expectedOutput":"11110","explanation":"15 + 15 = 30"}]},{"id":"str16","title":"ZigZag Conversion","description":"Rearrange in zigzag pattern.","difficulty":"MEDIUM","category":"Strings","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid convert(char s[], int numRows) {}\\nint main() { convert(\\"PAYPALISHIRING\\",3); return 0; }","expectedOutput":"PAHNAPLSIIGYIR","solution":"#include <iostream>\\nusing namespace std;\\nvoid convert(char s[], int numRows) { if(numRows==1) { cout<<s; return; } char rows[numRows][100]; int len[numRows]={}; int row=0,dir=1; for(int i=0;s[i];i++) { rows[row][len[row]++]=s[i]; if(row==0) dir=1; else if(row==numRows-1) dir=-1; row+=dir; } for(int i=0;i<numRows;i++) for(int j=0;j<len[i];j++) cout<<rows[i][j]; }\\nint main() { convert(\\"PAYPALISHIRING\\",3); return 0; }","explanation":{"approach":"Simulate zigzag placement.","analogy":"Move down then up cyclically.","steps":["Place chars in rows","Change direction at boundaries"],"complexity":"Time: O(n), Space: O(n)"},"testCases":[{"input":"\\"PAYPALISHIRING\\", numRows=3","expectedOutput":"PAHNAPLSIIGYIR","explanation":"3-row zigzag"},{"input":"\\"PAYPALISHIRING\\", numRows=4","expectedOutput":"PINALSIGYAHRPI","explanation":"4-row zigzag"},{"input":"\\"A\\", numRows=1","expectedOutput":"A","explanation":"Single char unchanged"},{"input":"\\"AB\\", numRows=1","expectedOutput":"AB","explanation":"Single row unchanged"}]},{"id":"str17","title":"Longest Common Prefix","description":"Find common prefix.","difficulty":"EASY","category":"Strings","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid longestCommonPrefix(char strs[][20], int n) {}\\nint main() { char strs[][20]={\\"flower\\",\\"flow\\",\\"flight\\"}; longestCommonPrefix(strs,3); return 0; }","expectedOutput":"fl","solution":"#include <iostream>\\nusing namespace std;\\nvoid longestCommonPrefix(char strs[][20], int n) { if(n==0) return; for(int i=0;strs[0][i];i++) { for(int j=1;j<n;j++) if(strs[j][i]!=strs[0][i]) { strs[0][i]=0; cout<<strs[0]; return; } } cout<<strs[0]; }\\nint main() { char strs[][20]={\\"flower\\",\\"flow\\",\\"flight\\"}; longestCommonPrefix(strs,3); return 0; }","explanation":{"approach":"Compare char by char.","analogy":"Stop at first mismatch.","steps":["For each position","Check if all strings match"],"complexity":"Time: O(S), Space: O(1)"},"testCases":[{"input":"[flower,flow,flight]","expectedOutput":"fl","explanation":"Common prefix is fl"},{"input":"[dog,racecar,car]","expectedOutput":"","explanation":"No common prefix"},{"input":"[interspecies,interstellar,interstate]","expectedOutput":"inters","explanation":"Common prefix inters"},{"input":"[abc,abc,abc]","expectedOutput":"abc","explanation":"Identical strings"}]},{"id":"str18","title":"Find and Replace Pattern","description":"Words matching pattern.","difficulty":"MEDIUM","category":"Strings","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid findAndReplacePattern(char words[][10], int n, char pattern[]) {}\\nint main() { char words[][10]={\\"abc\\",\\"deq\\",\\"mee\\",\\"aqq\\",\\"dkd\\",\\"ccc\\"}; findAndReplacePattern(words,6,\\"abb\\"); return 0; }","expectedOutput":"mee aqq","solution":"#include <iostream>\\nusing namespace std;\\nbool match(char w[], char p[]) { int w2p[26]={},p2w[26]={}; for(int i=0;i<26;i++) { w2p[i]=-1; p2w[i]=-1; } for(int i=0;w[i];i++) { int wc=w[i]-'a',pc=p[i]-'a'; if(w2p[wc]==-1) w2p[wc]=pc; if(p2w[pc]==-1) p2w[pc]=wc; if(w2p[wc]!=pc || p2w[pc]!=wc) return false; } return true; }\\nvoid findAndReplacePattern(char words[][10], int n, char pattern[]) { for(int i=0;i<n;i++) if(match(words[i],pattern)) cout<<words[i]<<\\" \\"; }\\nint main() { char words[][10]={\\"abc\\",\\"deq\\",\\"mee\\",\\"aqq\\",\\"dkd\\",\\"ccc\\"}; findAndReplacePattern(words,6,\\"abb\\"); return 0; }","explanation":{"approach":"Bijection mapping check.","analogy":"One-to-one correspondence.","steps":["Map word chars to pattern chars","Check consistency both ways"],"complexity":"Time: O(nm), Space: O(26)"},"testCases":[{"input":"words, pattern=\\"abb\\"","expectedOutput":"mee aqq","explanation":"m->a,e->b and a->a,q->b"},{"input":"[a,b,c], pattern=\\"a\\"","expectedOutput":"a b c","explanation":"All single chars match"},{"input":"[aa,bb,cc], pattern=\\"xy\\"","expectedOutput":"","explanation":"No bijection possible"},{"input":"[abc,xyz], pattern=\\"abc\\"","expectedOutput":"abc xyz","explanation":"Both have unique chars"}]},{"id":"str19","title":"Integer to Roman","description":"Convert int to roman numeral.","difficulty":"MEDIUM","category":"Strings","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid intToRoman(int num) {}\\nint main() { intToRoman(1994); return 0; }","expectedOutput":"MCMXCIV","solution":"#include <iostream>\\nusing namespace std;\\nvoid intToRoman(int num) { int vals[]={1000,900,500,400,100,90,50,40,10,9,5,4,1}; char* syms[]={\\"M\\",\\"CM\\",\\"D\\",\\"CD\\",\\"C\\",\\"XC\\",\\"L\\",\\"XL\\",\\"X\\",\\"IX\\",\\"V\\",\\"IV\\",\\"I\\"}; for(int i=0;i<13;i++) while(num>=vals[i]) { cout<<syms[i]; num-=vals[i]; } }\\nint main() { intToRoman(1994); return 0; }","explanation":{"approach":"Greedy from largest value.","analogy":"Subtract largest possible each time.","steps":["Match largest value","Append symbol, subtract"],"complexity":"Time: O(1), Space: O(1)"},"testCases":[{"input":"1994","expectedOutput":"MCMXCIV","explanation":"M=1000, CM=900, XC=90, IV=4"},{"input":"58","expectedOutput":"LVIII","explanation":"L=50, V=5, III=3"},{"input":"3","expectedOutput":"III","explanation":"Three I's"},{"input":"3999","expectedOutput":"MMMCMXCIX","explanation":"Maximum valid Roman numeral"}]},{"id":"str20","title":"Roman to Integer","description":"Convert roman to int.","difficulty":"EASY","category":"Strings","starterCode":"#include <iostream>\\nusing namespace std;\\nint romanToInt(char s[]) { return 0; }\\nint main() { cout<<romanToInt(\\"MCMXCIV\\"); return 0; }","expectedOutput":"1994","solution":"#include <iostream>\\nusing namespace std;\\nint val(char c) { if(c=='M') return 1000; if(c=='D') return 500; if(c=='C') return 100; if(c=='L') return 50; if(c=='X') return 10; if(c=='V') return 5; if(c=='I') return 1; return 0; }\\nint romanToInt(char s[]) { int res=0; for(int i=0;s[i];i++) { if(s[i+1] && val(s[i])<val(s[i+1])) res-=val(s[i]); else res+=val(s[i]); } return res; }\\nint main() { cout<<romanToInt(\\"MCMXCIV\\"); return 0; }","explanation":{"approach":"Subtract if smaller before larger.","analogy":"IV = 5 - 1 = 4.","steps":["If current < next, subtract","Else add"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"\\"MCMXCIV\\"","expectedOutput":"1994","explanation":"1000+900+90+4"},{"input":"\\"III\\"","expectedOutput":"3","explanation":"1+1+1"},{"input":"\\"IV\\"","expectedOutput":"4","explanation":"5-1=4"},{"input":"\\"MMMCMXCIX\\"","expectedOutput":"3999","explanation":"Maximum Roman numeral value"}]}]`),MM=JSON.parse('[{"id":"dp11","title":"Rod Cutting","description":"Max profit from rod pieces.","difficulty":"MEDIUM","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint cutRod(int prices[], int n) { return 0; }\\nint main() { int prices[]={1,5,8,9,10,17,17,20}; cout<<cutRod(prices,8); return 0; }","expectedOutput":"22","solution":"#include <iostream>\\nusing namespace std;\\nint cutRod(int prices[], int n) { int dp[n+1]={}; for(int i=1;i<=n;i++) for(int j=1;j<=i;j++) dp[i]=max(dp[i],prices[j-1]+dp[i-j]); return dp[n]; }\\nint main() { int prices[]={1,5,8,9,10,17,17,20}; cout<<cutRod(prices,8); return 0; }","explanation":{"approach":"DP - max value for each length.","analogy":"Try all first cut positions.","steps":["dp[i] = max profit for length i","Try cutting at each position"],"complexity":"Time: O(n), Space: O(n)"},"testCases":[{"input":"prices={1,5,8,9,10,17,17,20}, n=8","expectedOutput":"22","explanation":"Cut into 2+6 for max profit"},{"input":"prices={3,5,8,9,10,17,17,20}, n=4","expectedOutput":"12","explanation":"Four pieces of length 1"},{"input":"prices={1,5}, n=2","expectedOutput":"5","explanation":"Keep whole rod"},{"input":"prices={1,5,8}, n=3","expectedOutput":"8","explanation":"Keep rod of length 3"}]},{"id":"dp12","title":"Matrix Chain Multiplication","description":"Min operations to multiply matrices.","difficulty":"HARD","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint matrixChain(int dims[], int n) { return 0; }\\nint main() { int dims[]={10,30,5,60}; cout<<matrixChain(dims,4); return 0; }","expectedOutput":"4500","solution":"#include <iostream>\\nusing namespace std;\\nint matrixChain(int dims[], int n) { int m=n-1; int dp[m][m]; for(int i=0;i<m;i++) dp[i][i]=0; for(int len=2;len<=m;len++) for(int i=0;i<=m-len;i++) { int j=i+len-1; dp[i][j]=1e9; for(int k=i;k<j;k++) dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+1][j]+dims[i]*dims[k+1]*dims[j+1]); } return dp[0][m-1]; }\\nint main() { int dims[]={10,30,5,60}; cout<<matrixChain(dims,4); return 0; }","explanation":{"approach":"DP on ranges.","analogy":"Find optimal split point.","steps":["dp[i][j] = min ops for i to j","Try all split points k"],"complexity":"Time: O(n), Space: O(n)"},"testCases":[{"input":"dims={10,30,5,60}","expectedOutput":"4500","explanation":"Optimal parenthesization"},{"input":"dims={40,20,30,10,30}","expectedOutput":"26000","explanation":"5 matrices"},{"input":"dims={1,2,3}","expectedOutput":"6","explanation":"Two 1xN matrices"},{"input":"dims={10,20,30}","expectedOutput":"6000","explanation":"Two matrices: 10x20 * 20x30"}]},{"id":"dp13","title":"Egg Drop","description":"Min trials for k eggs, n floors.","difficulty":"HARD","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint eggDrop(int k, int n) { return 0; }\\nint main() { cout<<eggDrop(2,10); return 0; }","expectedOutput":"4","solution":"#include <iostream>\\nusing namespace std;\\nint eggDrop(int k, int n) { int dp[k+1][n+1]; for(int i=0;i<=k;i++) { dp[i][0]=0; dp[i][1]=1; } for(int j=0;j<=n;j++) dp[1][j]=j; for(int i=2;i<=k;i++) for(int j=2;j<=n;j++) { dp[i][j]=j; for(int x=1;x<=j;x++) dp[i][j]=min(dp[i][j],1+max(dp[i-1][x-1],dp[i][j-x])); } return dp[k][n]; }\\nint main() { cout<<eggDrop(2,10); return 0; }","explanation":{"approach":"DP - min trials for eggs and floors.","analogy":"Try dropping from each floor.","steps":["dp[k][n] = min trials for k eggs, n floors","Try dropping from each floor x"],"complexity":"Time: O(k  n), Space: O(kn)"},"testCases":[{"input":"k=2, n=10","expectedOutput":"4","explanation":"4 trials needed with 2 eggs"},{"input":"k=1, n=5","expectedOutput":"5","explanation":"Linear search with 1 egg"},{"input":"k=2, n=6","expectedOutput":"3","explanation":"3 trials for 6 floors"},{"input":"k=3, n=14","expectedOutput":"4","explanation":"More eggs allow fewer trials"}]},{"id":"dp14","title":"Longest Bitonic Subseq","description":"Longest increasing then decreasing.","difficulty":"MEDIUM","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint longestBitonic(int a[], int n) { return 0; }\\nint main() { int a[]={1,11,2,10,4,5,2,1}; cout<<longestBitonic(a,8); return 0; }","expectedOutput":"6","solution":"#include <iostream>\\nusing namespace std;\\nint longestBitonic(int a[], int n) { int lis[n],lds[n]; for(int i=0;i<n;i++) { lis[i]=1; for(int j=0;j<i;j++) if(a[j]<a[i]) lis[i]=max(lis[i],lis[j]+1); } for(int i=n-1;i>=0;i--) { lds[i]=1; for(int j=n-1;j>i;j--) if(a[j]<a[i]) lds[i]=max(lds[i],lds[j]+1); } int mx=0; for(int i=0;i<n;i++) mx=max(mx,lis[i]+lds[i]-1); return mx; }\\nint main() { int a[]={1,11,2,10,4,5,2,1}; cout<<longestBitonic(a,8); return 0; }","explanation":{"approach":"LIS from left + LDS from right.","analogy":"Peak at each position.","steps":["Compute LIS ending at each i","Compute LDS starting at each i","Max of lis[i] + lds[i] - 1"],"complexity":"Time: O(n), Space: O(n)"},"testCases":[{"input":"{1,11,2,10,4,5,2,1}","expectedOutput":"6","explanation":"1,2,10,4,2,1 or similar"},{"input":"{1,2,3,4,5}","expectedOutput":"5","explanation":"Increasing only is valid"},{"input":"{5,4,3,2,1}","expectedOutput":"5","explanation":"Decreasing only is valid"},{"input":"{1,3,5,3,1}","expectedOutput":"5","explanation":"Perfect bitonic with peak at 5"}]},{"id":"dp15","title":"Palindrome Partitioning","description":"Min cuts for palindrome partition.","difficulty":"HARD","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint minCut(char s[]) { return 0; }\\nint main() { cout<<minCut(\\"aab\\"); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nint minCut(char s[]) { int n=0; while(s[n]) n++; bool isPalin[n][n]={}; for(int i=0;i<n;i++) isPalin[i][i]=true; for(int len=2;len<=n;len++) for(int i=0;i<=n-len;i++) { int j=i+len-1; if(s[i]==s[j]) isPalin[i][j]=(len==2)|isPalin[i+1][j-1]; } int dp[n]; for(int i=0;i<n;i++) { if(isPalin[0][i]) dp[i]=0; else { dp[i]=i; for(int j=1;j<=i;j++) if(isPalin[j][i]) dp[i]=min(dp[i],dp[j-1]+1); } } return dp[n-1]; }\\nint main() { cout<<minCut(\\"aab\\"); return 0; }","explanation":{"approach":"DP with palindrome precomputation.","analogy":"Min cuts to make all parts palindromes.","steps":["Precompute all palindrome substrings","dp[i] = min cuts for s[0..i]"],"complexity":"Time: O(n), Space: O(n)"},"testCases":[{"input":"\\"aab\\"","expectedOutput":"1","explanation":"Cut: aa|b"},{"input":"\\"a\\"","expectedOutput":"0","explanation":"Already palindrome"},{"input":"\\"ab\\"","expectedOutput":"1","explanation":"Cut: a|b"},{"input":"\\"aba\\"","expectedOutput":"0","explanation":"Already a palindrome, no cuts needed"}]},{"id":"dp16","title":"Longest Zigzag","description":"Longest alternating subsequence.","difficulty":"MEDIUM","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint longestZigzag(int a[], int n) { return 0; }\\nint main() { int a[]={1,7,4,9,2,5}; cout<<longestZigzag(a,6); return 0; }","expectedOutput":"6","solution":"#include <iostream>\\nusing namespace std;\\nint longestZigzag(int a[], int n) { int up[n],down[n]; up[0]=down[0]=1; for(int i=1;i<n;i++) { up[i]=down[i]=1; for(int j=0;j<i;j++) { if(a[i]>a[j]) up[i]=max(up[i],down[j]+1); if(a[i]<a[j]) down[i]=max(down[i],up[j]+1); } } int mx=1; for(int i=0;i<n;i++) mx=max(mx,max(up[i],down[i])); return mx; }\\nint main() { int a[]={1,7,4,9,2,5}; cout<<longestZigzag(a,6); return 0; }","explanation":{"approach":"Track up and down endings.","analogy":"Alternate up then down.","steps":["up[i] = zigzag ending up at i","down[i] = zigzag ending down at i"],"complexity":"Time: O(n), Space: O(n)"},"testCases":[{"input":"{1,7,4,9,2,5}","expectedOutput":"6","explanation":"Entire array is zigzag"},{"input":"{1,2,3,4,5}","expectedOutput":"2","explanation":"Only pairs zigzag"},{"input":"{10,22,9,33,49,50,31,60}","expectedOutput":"6","explanation":"Valid zigzag sequence"},{"input":"{1,5,1,5,1}","expectedOutput":"5","explanation":"Perfect zigzag pattern"}]},{"id":"dp17","title":"Count Palindromic Substrings","description":"Count all palindromic substrings.","difficulty":"MEDIUM","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint countSubstrings(char s[]) { return 0; }\\nint main() { cout<<countSubstrings(\\"aaa\\"); return 0; }","expectedOutput":"6","solution":"#include <iostream>\\nusing namespace std;\\nint countSubstrings(char s[]) { int n=0; while(s[n]) n++; int cnt=0; for(int i=0;i<n;i++) { int l=i,r=i; while(l>=0 && r<n && s[l]==s[r]) { cnt++; l--; r++; } l=i; r=i+1; while(l>=0 && r<n && s[l]==s[r]) { cnt++; l--; r++; } } return cnt; }\\nint main() { cout<<countSubstrings(\\"aaa\\"); return 0; }","explanation":{"approach":"Expand around each center.","analogy":"Try odd and even length palindromes.","steps":["For each center, expand","Count all palindromes found"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"\\"aaa\\"","expectedOutput":"6","explanation":"a,a,a,aa,aa,aaa"},{"input":"\\"abc\\"","expectedOutput":"3","explanation":"Only single chars"},{"input":"\\"aba\\"","expectedOutput":"4","explanation":"a,b,a,aba"},{"input":"\\"abba\\"","expectedOutput":"6","explanation":"a,b,b,a,bb,abba"}]},{"id":"dp18","title":"Optimal BST","description":"Min search cost BST.","difficulty":"HARD","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint optimalBST(int keys[], int freq[], int n) { return 0; }\\nint main() { int keys[]={10,12,20}; int freq[]={34,8,50}; cout<<optimalBST(keys,freq,3); return 0; }","expectedOutput":"142","solution":"#include <iostream>\\nusing namespace std;\\nint optimalBST(int keys[], int freq[], int n) { int dp[n][n], sum[n][n]; for(int i=0;i<n;i++) { dp[i][i]=freq[i]; sum[i][i]=freq[i]; } for(int len=2;len<=n;len++) for(int i=0;i<=n-len;i++) { int j=i+len-1; dp[i][j]=1e9; sum[i][j]=sum[i][j-1]+freq[j]; for(int r=i;r<=j;r++) { int c=sum[i][j]+(r>i?dp[i][r-1]:0)+(r<j?dp[r+1][j]:0); dp[i][j]=min(dp[i][j],c); } } return dp[0][n-1]; }\\nint main() { int keys[]={10,12,20}; int freq[]={34,8,50}; cout<<optimalBST(keys,freq,3); return 0; }","explanation":{"approach":"DP on ranges, try each as root.","analogy":"Min expected search cost.","steps":["dp[i][j] = min cost for keys i to j","Try each key as root"],"complexity":"Time: O(n), Space: O(n)"},"testCases":[{"input":"keys={10,12,20}, freq={34,8,50}","expectedOutput":"142","explanation":"Optimal BST structure"},{"input":"keys={10,12}, freq={50,25}","expectedOutput":"100","explanation":"Two keys"},{"input":"keys={1}, freq={10}","expectedOutput":"10","explanation":"Single key"},{"input":"keys={1,2,3}, freq={10,10,10}","expectedOutput":"50","explanation":"Equal frequencies"}]},{"id":"dp19","title":"Maximum Product Subarray","description":"Max product contiguous.","difficulty":"MEDIUM","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint maxProduct(int a[], int n) { return 0; }\\nint main() { int a[]={2,3,-2,4}; cout<<maxProduct(a,4); return 0; }","expectedOutput":"6","solution":"#include <iostream>\\nusing namespace std;\\nint maxProduct(int a[], int n) { int mx=a[0],mn=a[0],res=a[0]; for(int i=1;i<n;i++) { if(a[i]<0) swap(mx,mn); mx=max(a[i],mx*a[i]); mn=min(a[i],mn*a[i]); res=max(res,mx); } return res; }\\nint main() { int a[]={2,3,-2,4}; cout<<maxProduct(a,4); return 0; }","explanation":{"approach":"Track max and min products.","analogy":"Negative  negative = positive.","steps":["Track both max and min at each position","Swap on negative"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"{2,3,-2,4}","expectedOutput":"6","explanation":"2*3=6"},{"input":"{-2,0,-1}","expectedOutput":"0","explanation":"Zero is maximum"},{"input":"{-2,3,-4}","expectedOutput":"24","explanation":"-2*3*-4=24"},{"input":"{-1,-2,-3}","expectedOutput":"6","explanation":"-2*-3=6"}]},{"id":"dp20","title":"Coin Change Count","description":"Number of ways to make amount.","difficulty":"MEDIUM","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint coinChangeWays(int coins[], int n, int amt) { return 0; }\\nint main() { int coins[]={1,2,5}; cout<<coinChangeWays(coins,3,5); return 0; }","expectedOutput":"4","solution":"#include <iostream>\\nusing namespace std;\\nint coinChangeWays(int coins[], int n, int amt) { int dp[amt+1]={}; dp[0]=1; for(int i=0;i<n;i++) for(int j=coins[i];j<=amt;j++) dp[j]+=dp[j-coins[i]]; return dp[amt]; }\\nint main() { int coins[]={1,2,5}; cout<<coinChangeWays(coins,3,5); return 0; }","explanation":{"approach":"DP - count ways for each amount.","analogy":"Unbounded knapsack variation.","steps":["Process each coin","Add ways using that coin"],"complexity":"Time: O(n  amt), Space: O(amt)"},"testCases":[{"input":"coins={1,2,5}, amt=5","expectedOutput":"4","explanation":"5=5,2+2+1,2+1+1+1,1+1+1+1+1"},{"input":"coins={2}, amt=3","expectedOutput":"0","explanation":"Cannot make 3 with only 2"},{"input":"coins={1}, amt=5","expectedOutput":"1","explanation":"Only one way with 1s"},{"input":"coins={1,2}, amt=4","expectedOutput":"3","explanation":"4=2+2,2+1+1,1+1+1+1"}]}]'),RM=JSON.parse(`[{"id":"graph11","title":"Clone Graph","description":"Deep copy undirected graph.","difficulty":"MEDIUM","category":"Graph","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node* adj[10]; int sz; Node(int x):v(x),sz(0){} };\\nNode* cloneGraph(Node* n) { return nullptr; }\\nint main() { cout<<\\"Graph cloned\\"; return 0; }","expectedOutput":"Graph cloned","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node* adj[10]; int sz; Node(int x):v(x),sz(0){} };\\nNode* vis[101]={};\\nNode* cloneGraph(Node* n) { if(!n) return 0; if(vis[n->v]) return vis[n->v]; Node* c=new Node(n->v); vis[n->v]=c; for(int i=0;i<n->sz;i++) c->adj[c->sz++]=cloneGraph(n->adj[i]); return c; }\\nint main() { cout<<\\"Graph cloned\\"; return 0; }","explanation":{"approach":"DFS with visited map.","analogy":"Clone nodes, link cloned neighbors.","steps":["Clone node if not visited","Recurse on neighbors"],"complexity":"Time: O(V+E), Space: O(V)"},"testCases":[{"input":"[[2,4],[1,3],[2,4],[1,3]]","expectedOutput":"Graph cloned","explanation":"4 nodes cloned with edges"},{"input":"[[]]","expectedOutput":"Graph cloned","explanation":"Single node no neighbors"},{"input":"[]","expectedOutput":"","explanation":"Empty graph"},{"input":"[[2],[1]]","expectedOutput":"Graph cloned","explanation":"Two nodes connected"}]},{"id":"graph12","title":"Course Schedule II","description":"Return course order.","difficulty":"MEDIUM","category":"Graph","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid findOrder(int n, int pre[][2], int m) {}\\nint main() { int pre[][2]={{1,0},{2,0},{3,1},{3,2}}; findOrder(4,pre,4); return 0; }","expectedOutput":"0 1 2 3","solution":"#include <iostream>\\nusing namespace std;\\nint adj[100][100],deg[100],sz[100];\\nvoid findOrder(int n, int pre[][2], int m) { for(int i=0;i<n;i++) { sz[i]=0; deg[i]=0; } for(int i=0;i<m;i++) { adj[pre[i][1]][sz[pre[i][1]]++]=pre[i][0]; deg[pre[i][0]]++; } int q[100],f=0,r=0; for(int i=0;i<n;i++) if(deg[i]==0) q[r++]=i; while(f<r) { int u=q[f++]; cout<<u<<\\" \\"; for(int i=0;i<sz[u];i++) if(--deg[adj[u][i]]==0) q[r++]=adj[u][i]; } }\\nint main() { int pre[][2]={{1,0},{2,0},{3,1},{3,2}}; findOrder(4,pre,4); return 0; }","explanation":{"approach":"Topological sort.","analogy":"Process courses with satisfied prereqs.","steps":["Build graph and in-degrees","BFS from zero-degree nodes"],"complexity":"Time: O(V+E), Space: O(V+E)"},"testCases":[{"input":"n=4, prereqs=[[1,0],[2,0],[3,1],[3,2]]","expectedOutput":"0 1 2 3","explanation":"Valid topological order"},{"input":"n=2, prereqs=[[1,0]]","expectedOutput":"0 1","explanation":"Simple dependency"},{"input":"n=1, prereqs=[]","expectedOutput":"0","explanation":"No prerequisites"},{"input":"n=3, prereqs=[[1,0],[2,1]]","expectedOutput":"0 1 2","explanation":"Linear dependency chain"}]},{"id":"graph13","title":"Redundant Connection","description":"Remove edge to make tree.","difficulty":"MEDIUM","category":"Graph","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid findRedundant(int edges[][2], int n) {}\\nint main() { int edges[][2]={{1,2},{1,3},{2,3}}; findRedundant(edges,3); return 0; }","expectedOutput":"2 3","solution":"#include <iostream>\\nusing namespace std;\\nint parent[100];\\nint find(int x) { if(parent[x]!=x) parent[x]=find(parent[x]); return parent[x]; }\\nvoid findRedundant(int edges[][2], int n) { for(int i=0;i<=n;i++) parent[i]=i; for(int i=0;i<n;i++) { int u=edges[i][0],v=edges[i][1]; int pu=find(u),pv=find(v); if(pu==pv) { cout<<u<<\\" \\"<<v; return; } parent[pu]=pv; } }\\nint main() { int edges[][2]={{1,2},{1,3},{2,3}}; findRedundant(edges,3); return 0; }","explanation":{"approach":"Union-Find for cycle detection.","analogy":"Edge creating cycle is redundant.","steps":["Union edges","If same parent, cycle found"],"complexity":"Time: O(n (n)), Space: O(n)"},"testCases":[{"input":"[[1,2],[1,3],[2,3]]","expectedOutput":"2 3","explanation":"Edge 2-3 creates cycle"},{"input":"[[1,2],[2,3],[3,4],[1,4],[1,5]]","expectedOutput":"1 4","explanation":"Edge 1-4 creates cycle"},{"input":"[[1,2],[1,3]]","expectedOutput":"","explanation":"No redundant edge"},{"input":"[[1,2],[2,3],[3,1]]","expectedOutput":"3 1","explanation":"Triangle cycle"}]},{"id":"graph14","title":"Min Height Trees","description":"Find roots for min height.","difficulty":"MEDIUM","category":"Graph","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid findMinHeightTrees(int n, int edges[][2], int m) {}\\nint main() { int edges[][2]={{1,0},{1,2},{1,3}}; findMinHeightTrees(4,edges,3); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nvoid findMinHeightTrees(int n, int edges[][2], int m) { if(n==1) { cout<<0; return; } int adj[100][100],sz[100]={},deg[100]={}; for(int i=0;i<m;i++) { adj[edges[i][0]][sz[edges[i][0]]++]=edges[i][1]; adj[edges[i][1]][sz[edges[i][1]]++]=edges[i][0]; deg[edges[i][0]]++; deg[edges[i][1]]++; } int q[100],f=0,r=0; for(int i=0;i<n;i++) if(deg[i]==1) q[r++]=i; int rem=n; while(rem>2) { int size=r-f; rem-=size; for(int i=0;i<size;i++) { int u=q[f++]; for(int j=0;j<sz[u];j++) if(--deg[adj[u][j]]==1) q[r++]=adj[u][j]; } } while(f<r) cout<<q[f++]<<\\" \\"; }\\nint main() { int edges[][2]={{1,0},{1,2},{1,3}}; findMinHeightTrees(4,edges,3); return 0; }","explanation":{"approach":"Peel leaves layer by layer.","analogy":"Center nodes are min height roots.","steps":["Remove leaves iteratively","Remaining 1-2 nodes are roots"],"complexity":"Time: O(V+E), Space: O(V)"},"testCases":[{"input":"n=4, edges=[[1,0],[1,2],[1,3]]","expectedOutput":"1","explanation":"Node 1 is center"},{"input":"n=6, edges=[[0,3],[1,3],[2,3],[4,3],[5,4]]","expectedOutput":"3 4","explanation":"Two center nodes"},{"input":"n=1, edges=[]","expectedOutput":"0","explanation":"Single node"},{"input":"n=2, edges=[[0,1]]","expectedOutput":"0 1","explanation":"Both nodes are centers"}]},{"id":"graph15","title":"Graph Valid Tree","description":"Check if valid tree.","difficulty":"MEDIUM","category":"Graph","starterCode":"#include <iostream>\\nusing namespace std;\\nbool validTree(int n, int edges[][2], int m) { return false; }\\nint main() { int edges[][2]={{0,1},{0,2},{0,3},{1,4}}; cout<<validTree(5,edges,4); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nint parent[100];\\nint find(int x) { if(parent[x]!=x) parent[x]=find(parent[x]); return parent[x]; }\\nbool validTree(int n, int edges[][2], int m) { if(m!=n-1) return false; for(int i=0;i<n;i++) parent[i]=i; for(int i=0;i<m;i++) { int pu=find(edges[i][0]),pv=find(edges[i][1]); if(pu==pv) return false; parent[pu]=pv; } return true; }\\nint main() { int edges[][2]={{0,1},{0,2},{0,3},{1,4}}; cout<<validTree(5,edges,4); return 0; }","explanation":{"approach":"n-1 edges and no cycle.","analogy":"Tree = connected acyclic.","steps":["Must have n-1 edges","No cycle (Union-Find)"],"complexity":"Time: O(n (n)), Space: O(n)"},"testCases":[{"input":"n=5, edges=[[0,1],[0,2],[0,3],[1,4]]","expectedOutput":"1","explanation":"Valid tree"},{"input":"n=5, edges=[[0,1],[1,2],[2,3],[1,3],[1,4]]","expectedOutput":"0","explanation":"Has cycle"},{"input":"n=1, edges=[]","expectedOutput":"1","explanation":"Single node is tree"},{"input":"n=4, edges=[[0,1],[2,3]]","expectedOutput":"0","explanation":"Not connected"}]},{"id":"graph16","title":"Network Delay Time","description":"Time for all nodes to receive signal.","difficulty":"MEDIUM","category":"Graph","starterCode":"#include <iostream>\\nusing namespace std;\\nint networkDelay(int times[][3], int n, int m, int k) { return -1; }\\nint main() { int times[][3]={{2,1,1},{2,3,1},{3,4,1}}; cout<<networkDelay(times,4,3,2); return 0; }","expectedOutput":"2","solution":"#include <iostream>\\nusing namespace std;\\nint networkDelay(int times[][3], int n, int m, int k) { int dist[n+1]; for(int i=0;i<=n;i++) dist[i]=1e9; dist[k]=0; for(int i=0;i<n-1;i++) for(int j=0;j<m;j++) if(dist[times[j][0]]!=1e9) dist[times[j][1]]=min(dist[times[j][1]],dist[times[j][0]]+times[j][2]); int mx=0; for(int i=1;i<=n;i++) mx=max(mx,dist[i]); return mx>=1e9?-1:mx; }\\nint main() { int times[][3]={{2,1,1},{2,3,1},{3,4,1}}; cout<<networkDelay(times,4,3,2); return 0; }","explanation":{"approach":"Bellman-Ford shortest paths.","analogy":"Signal propagation time.","steps":["Relax all edges n-1 times","Return max distance"],"complexity":"Time: O(VE), Space: O(V)"},"testCases":[{"input":"times=[[2,1,1],[2,3,1],[3,4,1]], n=4, k=2","expectedOutput":"2","explanation":"Max time to reach node 4"},{"input":"times=[[1,2,1]], n=2, k=1","expectedOutput":"1","explanation":"Direct edge"},{"input":"times=[[1,2,1]], n=2, k=2","expectedOutput":"-1","explanation":"Cannot reach node 1"},{"input":"times=[[1,2,1],[2,3,2],[1,3,4]], n=3, k=1","expectedOutput":"3","explanation":"Shorter path via node 2"}]},{"id":"graph17","title":"Cheapest Flights K Stops","description":"Cheapest path with at most k stops.","difficulty":"MEDIUM","category":"Graph","starterCode":"#include <iostream>\\nusing namespace std;\\nint findCheapest(int n, int flights[][3], int m, int src, int dst, int k) { return -1; }\\nint main() { int flights[][3]={{0,1,100},{1,2,100},{0,2,500}}; cout<<findCheapest(3,flights,3,0,2,1); return 0; }","expectedOutput":"200","solution":"#include <iostream>\\nusing namespace std;\\nint findCheapest(int n, int flights[][3], int m, int src, int dst, int k) { int dist[n]; for(int i=0;i<n;i++) dist[i]=1e9; dist[src]=0; for(int i=0;i<=k;i++) { int temp[n]; for(int j=0;j<n;j++) temp[j]=dist[j]; for(int j=0;j<m;j++) if(dist[flights[j][0]]!=1e9) temp[flights[j][1]]=min(temp[flights[j][1]],dist[flights[j][0]]+flights[j][2]); for(int j=0;j<n;j++) dist[j]=temp[j]; } return dist[dst]>=1e9?-1:dist[dst]; }\\nint main() { int flights[][3]={{0,1,100},{1,2,100},{0,2,500}}; cout<<findCheapest(3,flights,3,0,2,1); return 0; }","explanation":{"approach":"Bellman-Ford with k+1 relaxations.","analogy":"At most k+1 edges allowed.","steps":["Relax k+1 times","Use temp array to avoid extra hops"],"complexity":"Time: O(kE), Space: O(V)"},"testCases":[{"input":"flights, src=0, dst=2, k=1","expectedOutput":"200","explanation":"0->1->2 costs 200"},{"input":"flights, src=0, dst=2, k=0","expectedOutput":"500","explanation":"Direct flight only"},{"input":"no path to dst","expectedOutput":"-1","explanation":"Unreachable"},{"input":"flights, src=0, dst=0, k=0","expectedOutput":"0","explanation":"Already at destination"}]},{"id":"graph18","title":"Reconstruct Itinerary","description":"Build itinerary from tickets.","difficulty":"HARD","category":"Graph","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid findItinerary(char tickets[][2][4], int n) {}\\nint main() { char tickets[][2][4]={{\\"MUC\\",\\"LHR\\"},{\\"JFK\\",\\"MUC\\"},{\\"SFO\\",\\"SJC\\"},{\\"LHR\\",\\"SFO\\"}}; findItinerary(tickets,4); return 0; }","expectedOutput":"JFK MUC LHR SFO SJC","solution":"#include <iostream>\\nusing namespace std;\\nchar result[10][4]; int ri=0;\\nvoid dfs(char cur[], char tickets[][2][4], bool used[], int n) { result[ri][0]=cur[0]; result[ri][1]=cur[1]; result[ri][2]=cur[2]; result[ri++][3]=0; for(int i=0;i<n;i++) if(!used[i] && tickets[i][0][0]==cur[0] && tickets[i][0][1]==cur[1] && tickets[i][0][2]==cur[2]) { used[i]=true; dfs(tickets[i][1],tickets,used,n); } }\\nvoid findItinerary(char tickets[][2][4], int n) { bool used[n]={}; ri=0; dfs(\\"JFK\\",tickets,used,n); for(int i=0;i<ri;i++) cout<<result[i]<<\\" \\"; }\\nint main() { char tickets[][2][4]={{\\"MUC\\",\\"LHR\\"},{\\"JFK\\",\\"MUC\\"},{\\"SFO\\",\\"SJC\\"},{\\"LHR\\",\\"SFO\\"}}; findItinerary(tickets,4); return 0; }","explanation":{"approach":"DFS from JFK.","analogy":"Use all tickets in order.","steps":["Start from JFK","DFS using each ticket once"],"complexity":"Time: O(E), Space: O(E)"},"testCases":[{"input":"[[MUC,LHR],[JFK,MUC],[SFO,SJC],[LHR,SFO]]","expectedOutput":"JFK MUC LHR SFO SJC","explanation":"Valid itinerary"},{"input":"[[JFK,SFO],[JFK,ATL],[SFO,ATL],[ATL,JFK],[ATL,SFO]]","expectedOutput":"JFK ATL JFK SFO ATL SFO","explanation":"Multiple paths, lexical order"},{"input":"[[JFK,NYC]]","expectedOutput":"JFK NYC","explanation":"Single ticket"},{"input":"[[JFK,LAX],[LAX,SFO]]","expectedOutput":"JFK LAX SFO","explanation":"Two connected tickets"}]},{"id":"graph19","title":"Swim in Rising Water","description":"Min time to reach bottom-right.","difficulty":"HARD","category":"Graph","starterCode":"#include <iostream>\\nusing namespace std;\\nint swimInWater(int grid[][3], int n) { return 0; }\\nint main() { int grid[][3]={{0,2,1},{1,3,4},{2,5,0}}; cout<<swimInWater(grid,3); return 0; }","expectedOutput":"5","solution":"#include <iostream>\\nusing namespace std;\\nint swimInWater(int grid[][3], int n) { int dist[n][n]; bool vis[n][n]={}; for(int i=0;i<n;i++) for(int j=0;j<n;j++) dist[i][j]=1e9; dist[0][0]=grid[0][0]; int dx[]={1,-1,0,0},dy[]={0,0,1,-1}; while(!vis[n-1][n-1]) { int mi=-1,mj=-1,mn=1e9; for(int i=0;i<n;i++) for(int j=0;j<n;j++) if(!vis[i][j] && dist[i][j]<mn) { mn=dist[i][j]; mi=i; mj=j; } vis[mi][mj]=true; for(int d=0;d<4;d++) { int ni=mi+dx[d],nj=mj+dy[d]; if(ni>=0 && ni<n && nj>=0 && nj<n && !vis[ni][nj]) dist[ni][nj]=min(dist[ni][nj],max(dist[mi][mj],grid[ni][nj])); } } return dist[n-1][n-1]; }\\nint main() { int grid[][3]={{0,2,1},{1,3,4},{2,5,0}}; cout<<swimInWater(grid,3); return 0; }","explanation":{"approach":"Dijkstra with max along path.","analogy":"Wait for water to reach max cell.","steps":["Min of max heights on path","Dijkstra-like approach"],"complexity":"Time: O(n log n), Space: O(n)"},"testCases":[{"input":"[[0,2,1],[1,3,4],[2,5,0]]","expectedOutput":"5","explanation":"Wait until water level 5"},{"input":"[[0,1],[2,3]]","expectedOutput":"3","explanation":"Must pass through 3"},{"input":"[[0]]","expectedOutput":"0","explanation":"Already at destination"},{"input":"[[0,1,2],[3,4,5],[6,7,8]]","expectedOutput":"8","explanation":"Must reach corner with value 8"}]},{"id":"graph20","title":"Alien Dictionary","description":"Order of alien alphabet.","difficulty":"HARD","category":"Graph","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid alienOrder(char words[][10], int n) {}\\nint main() { char words[][10]={\\"wrt\\",\\"wrf\\",\\"er\\",\\"ett\\",\\"rftt\\"}; alienOrder(words,5); return 0; }","expectedOutput":"wertf","solution":"#include <iostream>\\nusing namespace std;\\nvoid alienOrder(char words[][10], int n) { int adj[26][26]={},deg[26]={},sz[26]={}; bool exists[26]={}; for(int i=0;i<n;i++) for(int j=0;words[i][j];j++) exists[words[i][j]-'a']=true; for(int i=0;i<n-1;i++) { int j=0; while(words[i][j] && words[i][j]==words[i+1][j]) j++; if(words[i][j] && words[i+1][j]) { int u=words[i][j]-'a',v=words[i+1][j]-'a'; adj[u][sz[u]++]=v; deg[v]++; } } int q[26],f=0,r=0; for(int i=0;i<26;i++) if(exists[i] && deg[i]==0) q[r++]=i; while(f<r) { int u=q[f++]; cout<<(char)('a'+u); for(int i=0;i<sz[u];i++) if(--deg[adj[u][i]]==0) q[r++]=adj[u][i]; } }\\nint main() { char words[][10]={\\"wrt\\",\\"wrf\\",\\"er\\",\\"ett\\",\\"rftt\\"}; alienOrder(words,5); return 0; }","explanation":{"approach":"Topological sort from comparisons.","analogy":"Letter order from word order.","steps":["Build graph from adjacent word differences","Topological sort"],"complexity":"Time: O(C), Space: O(1)"},"testCases":[{"input":"[wrt,wrf,er,ett,rftt]","expectedOutput":"wertf","explanation":"Valid alien order"},{"input":"[z,x]","expectedOutput":"zx","explanation":"z comes before x"},{"input":"[z,x,z]","expectedOutput":"","explanation":"Invalid order (cycle)"},{"input":"[abc,ab]","expectedOutput":"","explanation":"Invalid - longer word before shorter prefix"}]}]`),DM=JSON.parse('[{"id":"tree11","title":"Same Tree","description":"Check if two trees are same.","difficulty":"EASY","category":"Trees","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nbool isSame(Node* p, Node* q) { return false; }\\nint main() { Node* p=new Node(1); p->l=new Node(2); p->r=new Node(3); Node* q=new Node(1); q->l=new Node(2); q->r=new Node(3); cout<<isSame(p,q); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nbool isSame(Node* p, Node* q) { if(!p && !q) return true; if(!p || !q) return false; return p->v==q->v && isSame(p->l,q->l) && isSame(p->r,q->r); }\\nint main() { Node* p=new Node(1); p->l=new Node(2); p->r=new Node(3); Node* q=new Node(1); q->l=new Node(2); q->r=new Node(3); cout<<isSame(p,q); return 0; }","explanation":{"approach":"Recursive comparison.","analogy":"Both null or both equal.","steps":["Base: both null = same","Check value and recurse on children"],"complexity":"Time: O(n), Space: O(h)"},"testCases":[{"input":"p=[1,2,3], q=[1,2,3]","expectedOutput":"1","explanation":"Identical trees"},{"input":"p=[1,2], q=[1,null,2]","expectedOutput":"0","explanation":"Different structure"},{"input":"p=[], q=[]","expectedOutput":"1","explanation":"Both empty"},{"input":"p=[1,2,1], q=[1,1,2]","expectedOutput":"0","explanation":"Same values, different positions"}]},{"id":"tree12","title":"Subtree of Another","description":"Is t a subtree of s.","difficulty":"EASY","category":"Trees","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nbool isSubtree(Node* s, Node* t) { return false; }\\nint main() { Node* s=new Node(3); s->l=new Node(4); s->r=new Node(5); s->l->l=new Node(1); s->l->r=new Node(2); Node* t=new Node(4); t->l=new Node(1); t->r=new Node(2); cout<<isSubtree(s,t); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nbool same(Node* a, Node* b) { if(!a && !b) return true; if(!a || !b) return false; return a->v==b->v && same(a->l,b->l) && same(a->r,b->r); }\\nbool isSubtree(Node* s, Node* t) { if(!s) return false; if(same(s,t)) return true; return isSubtree(s->l,t) || isSubtree(s->r,t); }\\nint main() { Node* s=new Node(3); s->l=new Node(4); s->r=new Node(5); s->l->l=new Node(1); s->l->r=new Node(2); Node* t=new Node(4); t->l=new Node(1); t->r=new Node(2); cout<<isSubtree(s,t); return 0; }","explanation":{"approach":"Check each node as root.","analogy":"Find matching subtree.","steps":["If trees same, return true","Check left and right subtrees"],"complexity":"Time: O(mn), Space: O(h)"},"testCases":[{"input":"s=[3,4,5,1,2], t=[4,1,2]","expectedOutput":"1","explanation":"t is subtree of s"},{"input":"s=[3,4,5,1,2,null,null,null,null,0], t=[4,1,2]","expectedOutput":"0","explanation":"Not exact match"},{"input":"s=[1], t=[1]","expectedOutput":"1","explanation":"Single node match"},{"input":"s=[1,2,3], t=[2]","expectedOutput":"1","explanation":"t is a leaf in s"}]},{"id":"tree13","title":"Invert Binary Tree","description":"Mirror the tree.","difficulty":"EASY","category":"Trees","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nNode* invertTree(Node* r) { return nullptr; }\\nvoid print(Node* r) { if(!r) return; cout<<r->v<<\\" \\"; print(r->l); print(r->r); }\\nint main() { Node* r=new Node(4); r->l=new Node(2); r->r=new Node(7); r->l->l=new Node(1); r->l->r=new Node(3); r=invertTree(r); print(r); return 0; }","expectedOutput":"4 7 2 3 1","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nNode* invertTree(Node* r) { if(!r) return 0; Node* t=r->l; r->l=invertTree(r->r); r->r=invertTree(t); return r; }\\nvoid print(Node* r) { if(!r) return; cout<<r->v<<\\" \\"; print(r->l); print(r->r); }\\nint main() { Node* r=new Node(4); r->l=new Node(2); r->r=new Node(7); r->l->l=new Node(1); r->l->r=new Node(3); r=invertTree(r); print(r); return 0; }","explanation":{"approach":"Swap children recursively.","analogy":"Mirror image.","steps":["Swap left and right","Recurse on children"],"complexity":"Time: O(n), Space: O(h)"},"testCases":[{"input":"[4,2,7,1,3]","expectedOutput":"4 7 2 3 1","explanation":"Tree mirrored"},{"input":"[2,1,3]","expectedOutput":"2 3 1","explanation":"Simple inversion"},{"input":"[]","expectedOutput":"","explanation":"Empty tree"},{"input":"[1]","expectedOutput":"1","explanation":"Single node unchanged"}]},{"id":"tree14","title":"Max Path Sum","description":"Maximum path sum in tree.","difficulty":"HARD","category":"Trees","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nint maxPathSum(Node* r) { return 0; }\\nint main() { Node* r=new Node(-10); r->l=new Node(9); r->r=new Node(20); r->r->l=new Node(15); r->r->r=new Node(7); cout<<maxPathSum(r); return 0; }","expectedOutput":"42","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nint maxSum;\\nint solve(Node* r) { if(!r) return 0; int l=max(0,solve(r->l)); int ri=max(0,solve(r->r)); maxSum=max(maxSum,l+ri+r->v); return r->v+max(l,ri); }\\nint maxPathSum(Node* r) { maxSum=-1e9; solve(r); return maxSum; }\\nint main() { Node* r=new Node(-10); r->l=new Node(9); r->r=new Node(20); r->r->l=new Node(15); r->r->r=new Node(7); cout<<maxPathSum(r); return 0; }","explanation":{"approach":"DFS returning max single path.","analogy":"Path through node as turning point.","steps":["Return max path going up","Update global with path through node"],"complexity":"Time: O(n), Space: O(h)"},"testCases":[{"input":"[-10,9,20,null,null,15,7]","expectedOutput":"42","explanation":"15+20+7=42"},{"input":"[1,2,3]","expectedOutput":"6","explanation":"2+1+3=6"},{"input":"[-3]","expectedOutput":"-3","explanation":"Single negative node"},{"input":"[5,4,8,11,null,13,4]","expectedOutput":"48","explanation":"11+4+5+8+13+4 or similar path"}]},{"id":"tree15","title":"Build Tree from Preorder Inorder","description":"Construct tree from traversals.","difficulty":"MEDIUM","category":"Trees","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nNode* buildTree(int pre[], int in[], int n) { return nullptr; }\\nvoid post(Node* r) { if(!r) return; post(r->l); post(r->r); cout<<r->v<<\\" \\"; }\\nint main() { int pre[]={3,9,20,15,7}; int in[]={9,3,15,20,7}; Node* r=buildTree(pre,in,5); post(r); return 0; }","expectedOutput":"9 15 7 20 3","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nint idx=0;\\nNode* build(int pre[], int in[], int l, int r) { if(l>r) return 0; Node* root=new Node(pre[idx++]); int mid=l; while(in[mid]!=root->v) mid++; root->l=build(pre,in,l,mid-1); root->r=build(pre,in,mid+1,r); return root; }\\nNode* buildTree(int pre[], int in[], int n) { idx=0; return build(pre,in,0,n-1); }\\nvoid post(Node* r) { if(!r) return; post(r->l); post(r->r); cout<<r->v<<\\" \\"; }\\nint main() { int pre[]={3,9,20,15,7}; int in[]={9,3,15,20,7}; Node* r=buildTree(pre,in,5); post(r); return 0; }","explanation":{"approach":"Root from preorder, split inorder.","analogy":"Preorder gives root, inorder splits.","steps":["First preorder element is root","Find in inorder to get left and right subtrees"],"complexity":"Time: O(n), Space: O(n)"},"testCases":[{"input":"pre=[3,9,20,15,7], in=[9,3,15,20,7]","expectedOutput":"9 15 7 20 3","explanation":"Reconstructed tree postorder"},{"input":"pre=[1,2], in=[2,1]","expectedOutput":"2 1","explanation":"Left child only"},{"input":"pre=[1], in=[1]","expectedOutput":"1","explanation":"Single node"},{"input":"pre=[1,2,3], in=[2,1,3]","expectedOutput":"2 3 1","explanation":"Balanced tree"}]},{"id":"tree16","title":"Populating Next Right","description":"Connect same level nodes.","difficulty":"MEDIUM","category":"Trees","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r,*next; Node(int x):v(x),l(0),r(0),next(0){} };\\nNode* connect(Node* root) { return nullptr; }\\nint main() { Node* r=new Node(1); r->l=new Node(2); r->r=new Node(3); r->l->l=new Node(4); r->l->r=new Node(5); r->r->r=new Node(7); connect(r); cout<<r->l->next->v<<\\" \\"<<r->l->r->next->v; return 0; }","expectedOutput":"3 7","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r,*next; Node(int x):v(x),l(0),r(0),next(0){} };\\nNode* connect(Node* root) { Node* cur=root; while(cur) { Node dummy(0), *tail=&dummy; while(cur) { if(cur->l) { tail->next=cur->l; tail=tail->next; } if(cur->r) { tail->next=cur->r; tail=tail->next; } cur=cur->next; } cur=dummy.next; } return root; }\\nint main() { Node* r=new Node(1); r->l=new Node(2); r->r=new Node(3); r->l->l=new Node(4); r->l->r=new Node(5); r->r->r=new Node(7); connect(r); cout<<r->l->next->v<<\\" \\"<<r->l->r->next->v; return 0; }","explanation":{"approach":"Level by level linking.","analogy":"Use next pointers for traversal.","steps":["Process each level using next","Link children as you go"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"[1,2,3,4,5,null,7]","expectedOutput":"3 7","explanation":"2->next=3, 5->next=7"},{"input":"[1,2,3]","expectedOutput":"3","explanation":"2->next=3"},{"input":"[]","expectedOutput":"","explanation":"Empty tree"},{"input":"[1,2,3,4,5,6,7]","expectedOutput":"3 5","explanation":"Perfect binary tree linking"}]},{"id":"tree17","title":"Count Good Nodes","description":"Nodes >= all ancestors.","difficulty":"MEDIUM","category":"Trees","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nint goodNodes(Node* r) { return 0; }\\nint main() { Node* r=new Node(3); r->l=new Node(1); r->r=new Node(4); r->l->l=new Node(3); r->r->l=new Node(1); r->r->r=new Node(5); cout<<goodNodes(r); return 0; }","expectedOutput":"4","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nint cnt=0;\\nvoid dfs(Node* r, int mx) { if(!r) return; if(r->v>=mx) cnt++; mx=max(mx,r->v); dfs(r->l,mx); dfs(r->r,mx); }\\nint goodNodes(Node* r) { cnt=0; dfs(r,-1e9); return cnt; }\\nint main() { Node* r=new Node(3); r->l=new Node(1); r->r=new Node(4); r->l->l=new Node(3); r->r->l=new Node(1); r->r->r=new Node(5); cout<<goodNodes(r); return 0; }","explanation":{"approach":"DFS tracking max ancestor.","analogy":"Good if >= all above.","steps":["Track max on path","Count if current >= max"],"complexity":"Time: O(n), Space: O(h)"},"testCases":[{"input":"[3,1,4,3,null,1,5]","expectedOutput":"4","explanation":"Nodes 3,3,4,5 are good"},{"input":"[3,3,null,4,2]","expectedOutput":"3","explanation":"3,3,4 are good"},{"input":"[1]","expectedOutput":"1","explanation":"Root is always good"},{"input":"[2,null,4,null,6]","expectedOutput":"3","explanation":"Increasing path, all good"}]},{"id":"tree18","title":"Binary Tree Paths","description":"All root-to-leaf paths.","difficulty":"EASY","category":"Trees","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nvoid binaryTreePaths(Node* r) {}\\nint main() { Node* r=new Node(1); r->l=new Node(2); r->r=new Node(3); r->l->r=new Node(5); binaryTreePaths(r); return 0; }","expectedOutput":"1->2->5 1->3","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nvoid dfs(Node* r, int path[], int len) { if(!r) return; path[len++]=r->v; if(!r->l && !r->r) { for(int i=0;i<len;i++) cout<<(i?\\"->\\":\\"\\")<<path[i]; cout<<\\" \\"; } dfs(r->l,path,len); dfs(r->r,path,len); }\\nvoid binaryTreePaths(Node* r) { int path[100]; dfs(r,path,0); }\\nint main() { Node* r=new Node(1); r->l=new Node(2); r->r=new Node(3); r->l->r=new Node(5); binaryTreePaths(r); return 0; }","explanation":{"approach":"DFS building path.","analogy":"Collect nodes on path to leaf.","steps":["Add current to path","At leaf, print path","Recurse on children"],"complexity":"Time: O(n), Space: O(h)"},"testCases":[{"input":"[1,2,3,null,5]","expectedOutput":"1->2->5 1->3","explanation":"Two paths"},{"input":"[1]","expectedOutput":"1","explanation":"Single node is a path"},{"input":"[1,2,null]","expectedOutput":"1->2","explanation":"Left-only path"},{"input":"[1,2,3,4,5]","expectedOutput":"1->2->4 1->2->5 1->3","explanation":"Three paths"}]},{"id":"tree19","title":"Diameter of Binary Tree","description":"Longest path between nodes.","difficulty":"EASY","category":"Trees","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nint diameterOfBinaryTree(Node* r) { return 0; }\\nint main() { Node* r=new Node(1); r->l=new Node(2); r->r=new Node(3); r->l->l=new Node(4); r->l->r=new Node(5); cout<<diameterOfBinaryTree(r); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nint diam=0;\\nint height(Node* r) { if(!r) return 0; int l=height(r->l); int ri=height(r->r); diam=max(diam,l+ri); return 1+max(l,ri); }\\nint diameterOfBinaryTree(Node* r) { diam=0; height(r); return diam; }\\nint main() { Node* r=new Node(1); r->l=new Node(2); r->r=new Node(3); r->l->l=new Node(4); r->l->r=new Node(5); cout<<diameterOfBinaryTree(r); return 0; }","explanation":{"approach":"Diameter = left height + right height.","analogy":"Path through each node.","steps":["Compute height recursively","Track max left + right heights"],"complexity":"Time: O(n), Space: O(h)"},"testCases":[{"input":"[1,2,3,4,5]","expectedOutput":"3","explanation":"Path 4-2-1-3 or 5-2-1-3"},{"input":"[1,2]","expectedOutput":"1","explanation":"Just one edge"},{"input":"[1]","expectedOutput":"0","explanation":"No edges"},{"input":"[1,2,null,3,null,4]","expectedOutput":"3","explanation":"Chain path 4-3-2-1"}]},{"id":"tree20","title":"Sum Root to Leaf","description":"Sum of all root-to-leaf numbers.","difficulty":"MEDIUM","category":"Trees","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nint sumNumbers(Node* r) { return 0; }\\nint main() { Node* r=new Node(1); r->l=new Node(2); r->r=new Node(3); cout<<sumNumbers(r); return 0; }","expectedOutput":"25","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nint dfs(Node* r, int num) { if(!r) return 0; num=num*10+r->v; if(!r->l && !r->r) return num; return dfs(r->l,num)+dfs(r->r,num); }\\nint sumNumbers(Node* r) { return dfs(r,0); }\\nint main() { Node* r=new Node(1); r->l=new Node(2); r->r=new Node(3); cout<<sumNumbers(r); return 0; }","explanation":{"approach":"Build number on path.","analogy":"Path 1->2 = number 12.","steps":["num = num  10 + node value","At leaf, return num","Sum all leaf numbers"],"complexity":"Time: O(n), Space: O(h)"},"testCases":[{"input":"[1,2,3]","expectedOutput":"25","explanation":"12+13=25"},{"input":"[4,9,0,5,1]","expectedOutput":"1026","explanation":"495+491+40=1026"},{"input":"[0]","expectedOutput":"0","explanation":"Single zero"},{"input":"[1,0,1,0,1,0,1]","expectedOutput":"422","explanation":"100+101+100+101=402"}]}]'),IM=JSON.parse(`[{"id":"fun1","title":"Two Sum","description":"Find indices summing to target.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid twoSum(int a[], int n, int t) {}\\nint main() { int a[]={2,7,11,15}; twoSum(a,4,9); return 0; }","expectedOutput":"0 1","solution":"#include <iostream>\\nusing namespace std;\\nvoid twoSum(int a[], int n, int t) {\\n    for(int i = 0; i < n; i++) {\\n        for(int j = i + 1; j < n; j++) {\\n            if(a[i] + a[j] == t) {\\n                cout << i << \\" \\" << j;\\n                return;\\n            }\\n        }\\n    }\\n}\\nint main() { int a[]={2,7,11,15}; twoSum(a,4,9); return 0; }","explanation":{"approach":"Check every pair of numbers.","steps":["For each element, check all elements after it","If sum equals target, print indices"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"arr=[2,7,11,15], target=9","expectedOutput":"0 1","explanation":"2+7=9, indices 0 and 1"},{"input":"arr=[3,2,4], target=6","expectedOutput":"1 2","explanation":"2+4=6"},{"input":"arr=[3,3], target=6","expectedOutput":"0 1","explanation":"Both 3s sum to 6"},{"input":"arr=[1,2,3,4,5], target=9","expectedOutput":"3 4","explanation":"4+5=9"}]},{"id":"fun2","title":"Reverse Array","description":"Reverse array in-place.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid reverse(int a[], int n) {}\\nint main() { int a[]={1,2,3,4,5}; reverse(a,5); for(int i=0;i<5;i++) cout<<a[i]<<\\" \\"; return 0; }","expectedOutput":"5 4 3 2 1","solution":"#include <iostream>\\nusing namespace std;\\nvoid reverse(int a[], int n) {\\n    int left = 0, right = n - 1;\\n    while(left < right) {\\n        int temp = a[left];\\n        a[left] = a[right];\\n        a[right] = temp;\\n        left++;\\n        right--;\\n    }\\n}\\nint main() { int a[]={1,2,3,4,5}; reverse(a,5); for(int i=0;i<5;i++) cout<<a[i]<<\\" \\"; return 0; }","explanation":{"approach":"Two pointers from both ends, swap and move inward.","steps":["Put pointers at start and end","Swap elements","Move pointers toward center"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"arr=[1,2,3,4,5]","expectedOutput":"5 4 3 2 1","explanation":"Reverse odd-length array"},{"input":"arr=[1,2,3,4]","expectedOutput":"4 3 2 1","explanation":"Reverse even-length array"},{"input":"arr=[1]","expectedOutput":"1","explanation":"Single element unchanged"},{"input":"arr=[1,2]","expectedOutput":"2 1","explanation":"Two elements swapped"}]},{"id":"fun3","title":"Find Maximum","description":"Find max element.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint findMax(int a[], int n) { return 0; }\\nint main() { int a[]={3,7,1,9,2}; cout<<findMax(a,5); return 0; }","expectedOutput":"9","solution":"#include <iostream>\\nusing namespace std;\\nint findMax(int a[], int n) {\\n    int maxVal = a[0];\\n    for(int i = 1; i < n; i++) {\\n        if(a[i] > maxVal) {\\n            maxVal = a[i];\\n        }\\n    }\\n    return maxVal;\\n}\\nint main() { int a[]={3,7,1,9,2}; cout<<findMax(a,5); return 0; }","explanation":{"approach":"Assume first is max, compare with rest.","steps":["Start with first element as max","Compare each element","Update max if larger found"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"arr=[3,7,1,9,2]","expectedOutput":"9","explanation":"9 is the largest"},{"input":"arr=[-5,-2,-8]","expectedOutput":"-2","explanation":"-2 is largest negative"},{"input":"arr=[5]","expectedOutput":"5","explanation":"Single element"},{"input":"arr=[5,5,5,5]","expectedOutput":"5","explanation":"All same values"}]},{"id":"fun4","title":"Find Minimum","description":"Find min element.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint findMin(int a[], int n) { return 0; }\\nint main() { int a[]={3,7,1,9,2}; cout<<findMin(a,5); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nint findMin(int a[], int n) {\\n    int minVal = a[0];\\n    for(int i = 1; i < n; i++) {\\n        if(a[i] < minVal) {\\n            minVal = a[i];\\n        }\\n    }\\n    return minVal;\\n}\\nint main() { int a[]={3,7,1,9,2}; cout<<findMin(a,5); return 0; }","explanation":{"approach":"Assume first is min, compare with rest.","steps":["Start with first element as min","Compare each element","Update min if smaller found"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"arr=[3,7,1,9,2]","expectedOutput":"1","explanation":"1 is the smallest"},{"input":"arr=[-5,-2,-8]","expectedOutput":"-8","explanation":"-8 is smallest"},{"input":"arr=[5]","expectedOutput":"5","explanation":"Single element"},{"input":"arr=[10,10,10]","expectedOutput":"10","explanation":"All same values"}]},{"id":"fun5","title":"Array Sum","description":"Sum all elements.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint sum(int a[], int n) { return 0; }\\nint main() { int a[]={1,2,3,4,5}; cout<<sum(a,5); return 0; }","expectedOutput":"15","solution":"#include <iostream>\\nusing namespace std;\\nint sum(int a[], int n) {\\n    int total = 0;\\n    for(int i = 0; i < n; i++) {\\n        total += a[i];\\n    }\\n    return total;\\n}\\nint main() { int a[]={1,2,3,4,5}; cout<<sum(a,5); return 0; }","explanation":{"approach":"Start with 0, add each element.","steps":["Initialize sum to 0","Loop through array","Add each element to sum"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"arr=[1,2,3,4,5]","expectedOutput":"15","explanation":"1+2+3+4+5=15"},{"input":"arr=[10,20,30]","expectedOutput":"60","explanation":"10+20+30=60"},{"input":"arr=[-1,-2,3]","expectedOutput":"0","explanation":"-1-2+3=0"},{"input":"arr=[100]","expectedOutput":"100","explanation":"Single element"}]},{"id":"fun6","title":"Array Average","description":"Calculate average.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\ndouble average(int a[], int n) { return 0; }\\nint main() { int a[]={10,20,30,40,50}; cout<<average(a,5); return 0; }","expectedOutput":"30","solution":"#include <iostream>\\nusing namespace std;\\ndouble average(int a[], int n) {\\n    int total = 0;\\n    for(int i = 0; i < n; i++) {\\n        total += a[i];\\n    }\\n    return (double)total / n;\\n}\\nint main() { int a[]={10,20,30,40,50}; cout<<average(a,5); return 0; }","explanation":{"approach":"Sum all elements, divide by count.","steps":["Calculate sum","Divide by n","Return average"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"arr=[10,20,30,40,50]","expectedOutput":"30","explanation":"150/5=30"},{"input":"arr=[1,2,3,4]","expectedOutput":"2.5","explanation":"10/4=2.5"},{"input":"arr=[5]","expectedOutput":"5","explanation":"Single element"},{"input":"arr=[0,0,0,0]","expectedOutput":"0","explanation":"All zeros"}]},{"id":"fun7","title":"Count Even","description":"Count even numbers.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint countEven(int a[], int n) { return 0; }\\nint main() { int a[]={1,2,3,4,5,6}; cout<<countEven(a,6); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nint countEven(int a[], int n) {\\n    int count = 0;\\n    for(int i = 0; i < n; i++) {\\n        if(a[i] % 2 == 0) {\\n            count++;\\n        }\\n    }\\n    return count;\\n}\\nint main() { int a[]={1,2,3,4,5,6}; cout<<countEven(a,6); return 0; }","explanation":{"approach":"Check if each number is divisible by 2.","steps":["For each element","Check if num % 2 == 0","If yes, increment count"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"arr=[1,2,3,4,5,6]","expectedOutput":"3","explanation":"2,4,6 are even"},{"input":"arr=[1,3,5,7]","expectedOutput":"0","explanation":"No even numbers"},{"input":"arr=[2,4,6,8]","expectedOutput":"4","explanation":"All even"},{"input":"arr=[0,1,2]","expectedOutput":"2","explanation":"0 and 2 are even"}]},{"id":"fun8","title":"Count Odd","description":"Count odd numbers.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint countOdd(int a[], int n) { return 0; }\\nint main() { int a[]={1,2,3,4,5,6}; cout<<countOdd(a,6); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nint countOdd(int a[], int n) {\\n    int count = 0;\\n    for(int i = 0; i < n; i++) {\\n        if(a[i] % 2 != 0) {\\n            count++;\\n        }\\n    }\\n    return count;\\n}\\nint main() { int a[]={1,2,3,4,5,6}; cout<<countOdd(a,6); return 0; }","explanation":{"approach":"Check if each number has remainder when divided by 2.","steps":["For each element","Check if num % 2 != 0","If yes, increment count"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"arr=[1,2,3,4,5,6]","expectedOutput":"3","explanation":"1,3,5 are odd"},{"input":"arr=[1,3,5,7]","expectedOutput":"4","explanation":"All odd"},{"input":"arr=[2,4,6,8]","expectedOutput":"0","explanation":"No odd numbers"},{"input":"arr=[0,1]","expectedOutput":"1","explanation":"Only 1 is odd"}]},{"id":"fun9","title":"Swap Two Numbers","description":"Swap using temp.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint main() { int a=5, b=10; int t=a; a=b; b=t; cout<<a<<\\" \\"<<b; return 0; }","expectedOutput":"10 5","solution":"#include <iostream>\\nusing namespace std;\\nint main() {\\n    int a = 5, b = 10;\\n    int temp = a;\\n    a = b;\\n    b = temp;\\n    cout << a << \\" \\" << b;\\n    return 0;\\n}","explanation":{"approach":"Use temporary variable to hold one value during swap.","steps":["Store a in temp","Copy b into a","Copy temp into b"],"complexity":"Time: O(1), Space: O(1)"},"testCases":[{"input":"a=5, b=10","expectedOutput":"10 5","explanation":"Values swapped"},{"input":"a=0, b=1","expectedOutput":"1 0","explanation":"Swap with zero"},{"input":"a=-5, b=5","expectedOutput":"5 -5","explanation":"Swap negative"},{"input":"a=7, b=7","expectedOutput":"7 7","explanation":"Same values"}]},{"id":"fun10","title":"Check Positive","description":"Is number positive.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isPositive(int n) { return false; }\\nint main() { cout<<isPositive(5); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isPositive(int n) {\\n    return n > 0;\\n}\\nint main() { cout<<isPositive(5); return 0; }","explanation":{"approach":"Check if number is greater than zero.","steps":["Compare n with 0","Return true if n > 0"],"complexity":"Time: O(1), Space: O(1)"},"testCases":[{"input":"n=5","expectedOutput":"1","explanation":"5 is positive"},{"input":"n=-5","expectedOutput":"0","explanation":"-5 is not positive"},{"input":"n=0","expectedOutput":"0","explanation":"0 is not positive"},{"input":"n=100","expectedOutput":"1","explanation":"100 is positive"}]},{"id":"fun11","title":"Check Negative","description":"Is number negative.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isNegative(int n) { return false; }\\nint main() { cout<<isNegative(-5); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isNegative(int n) {\\n    return n < 0;\\n}\\nint main() { cout<<isNegative(-5); return 0; }","explanation":{"approach":"Check if number is less than zero.","steps":["Compare n with 0","Return true if n < 0"],"complexity":"Time: O(1), Space: O(1)"},"testCases":[{"input":"n=-5","expectedOutput":"1","explanation":"-5 is negative"},{"input":"n=5","expectedOutput":"0","explanation":"5 is not negative"},{"input":"n=0","expectedOutput":"0","explanation":"0 is not negative"},{"input":"n=-100","expectedOutput":"1","explanation":"-100 is negative"}]},{"id":"fun12","title":"Find Largest of Three","description":"Max of three numbers.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint largest(int a, int b, int c) { return 0; }\\nint main() { cout<<largest(5,9,3); return 0; }","expectedOutput":"9","solution":"#include <iostream>\\nusing namespace std;\\nint largest(int a, int b, int c) {\\n    if(a >= b && a >= c) return a;\\n    if(b >= a && b >= c) return b;\\n    return c;\\n}\\nint main() { cout<<largest(5,9,3); return 0; }","explanation":{"approach":"Compare each with the other two.","steps":["Check if a is largest","Check if b is largest","Otherwise c is largest"],"complexity":"Time: O(1), Space: O(1)"},"testCases":[{"input":"a=5, b=9, c=3","expectedOutput":"9","explanation":"9 is largest"},{"input":"a=10, b=5, c=3","expectedOutput":"10","explanation":"a is largest"},{"input":"a=1, b=1, c=1","expectedOutput":"1","explanation":"All equal"},{"input":"a=-1, b=-2, c=-3","expectedOutput":"-1","explanation":"-1 is largest negative"}]},{"id":"fun13","title":"Find Smallest of Three","description":"Min of three numbers.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint smallest(int a, int b, int c) { return 0; }\\nint main() { cout<<smallest(5,9,3); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nint smallest(int a, int b, int c) {\\n    if(a <= b && a <= c) return a;\\n    if(b <= a && b <= c) return b;\\n    return c;\\n}\\nint main() { cout<<smallest(5,9,3); return 0; }","explanation":{"approach":"Compare each with the other two.","steps":["Check if a is smallest","Check if b is smallest","Otherwise c is smallest"],"complexity":"Time: O(1), Space: O(1)"},"testCases":[{"input":"a=5, b=9, c=3","expectedOutput":"3","explanation":"3 is smallest"},{"input":"a=1, b=5, c=3","expectedOutput":"1","explanation":"a is smallest"},{"input":"a=7, b=7, c=7","expectedOutput":"7","explanation":"All equal"},{"input":"a=-1, b=-2, c=-3","expectedOutput":"-3","explanation":"-3 is smallest"}]},{"id":"fun14","title":"Check Divisible","description":"Check divisibility.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isDivisible(int a, int b) { return false; }\\nint main() { cout<<isDivisible(10,5); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isDivisible(int a, int b) {\\n    return a % b == 0;\\n}\\nint main() { cout<<isDivisible(10,5); return 0; }","explanation":{"approach":"Use modulo - if remainder is 0, it's divisible.","steps":["Calculate a % b","Return true if remainder is 0"],"complexity":"Time: O(1), Space: O(1)"},"testCases":[{"input":"a=10, b=5","expectedOutput":"1","explanation":"10 is divisible by 5"},{"input":"a=10, b=3","expectedOutput":"0","explanation":"10 not divisible by 3"},{"input":"a=12, b=4","expectedOutput":"1","explanation":"12 divisible by 4"},{"input":"a=7, b=7","expectedOutput":"1","explanation":"Any number divisible by itself"}]},{"id":"fun15","title":"Factorial Loop","description":"Factorial using loop.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint factorial(int n) { return 0; }\\nint main() { cout<<factorial(5); return 0; }","expectedOutput":"120","solution":"#include <iostream>\\nusing namespace std;\\nint factorial(int n) {\\n    int result = 1;\\n    for(int i = 1; i <= n; i++) {\\n        result *= i;\\n    }\\n    return result;\\n}\\nint main() { cout<<factorial(5); return 0; }","explanation":{"approach":"Multiply all numbers from 1 to n.","steps":["Start with 1","Multiply by each number up to n"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"n=5","expectedOutput":"120","explanation":"5!=120"},{"input":"n=0","expectedOutput":"1","explanation":"0!=1 by definition"},{"input":"n=1","expectedOutput":"1","explanation":"1!=1"},{"input":"n=6","expectedOutput":"720","explanation":"6!=720"}]},{"id":"fun16","title":"Sum of Digits","description":"Sum all digits.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint digitSum(int n) { return 0; }\\nint main() { cout<<digitSum(1234); return 0; }","expectedOutput":"10","solution":"#include <iostream>\\nusing namespace std;\\nint digitSum(int n) {\\n    int sum = 0;\\n    while(n > 0) {\\n        sum += n % 10;\\n        n /= 10;\\n    }\\n    return sum;\\n}\\nint main() { cout<<digitSum(1234); return 0; }","explanation":{"approach":"Extract each digit and add to sum.","steps":["Get last digit with %10","Add to sum","Remove digit with /10"],"complexity":"Time: O(log n), Space: O(1)"},"testCases":[{"input":"n=1234","expectedOutput":"10","explanation":"1+2+3+4=10"},{"input":"n=999","expectedOutput":"27","explanation":"9+9+9=27"},{"input":"n=100","expectedOutput":"1","explanation":"1+0+0=1"},{"input":"n=5","expectedOutput":"5","explanation":"Single digit"}]},{"id":"fun17","title":"Count Digits","description":"Number of digits.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint countDigits(int n) { return 0; }\\nint main() { cout<<countDigits(12345); return 0; }","expectedOutput":"5","solution":"#include <iostream>\\nusing namespace std;\\nint countDigits(int n) {\\n    int count = 0;\\n    while(n > 0) {\\n        count++;\\n        n /= 10;\\n    }\\n    return count;\\n}\\nint main() { cout<<countDigits(12345); return 0; }","explanation":{"approach":"Divide by 10 and count iterations.","steps":["Divide by 10","Increment count","Repeat until 0"],"complexity":"Time: O(log n), Space: O(1)"},"testCases":[{"input":"n=12345","expectedOutput":"5","explanation":"5 digits"},{"input":"n=1","expectedOutput":"1","explanation":"1 digit"},{"input":"n=1000","expectedOutput":"4","explanation":"4 digits"},{"input":"n=99","expectedOutput":"2","explanation":"2 digits"}]},{"id":"fun18","title":"Reverse Number","description":"Reverse digits.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint reverse(int n) { return 0; }\\nint main() { cout<<reverse(12345); return 0; }","expectedOutput":"54321","solution":"#include <iostream>\\nusing namespace std;\\nint reverse(int n) {\\n    int reversed = 0;\\n    while(n > 0) {\\n        reversed = reversed * 10 + n % 10;\\n        n /= 10;\\n    }\\n    return reversed;\\n}\\nint main() { cout<<reverse(12345); return 0; }","explanation":{"approach":"Build new number from end digits.","steps":["Get last digit","Add to reversed*10","Remove last digit"],"complexity":"Time: O(log n), Space: O(1)"},"testCases":[{"input":"n=12345","expectedOutput":"54321","explanation":"Reversed"},{"input":"n=100","expectedOutput":"1","explanation":"Leading zeros dropped"},{"input":"n=7","expectedOutput":"7","explanation":"Single digit unchanged"},{"input":"n=1234","expectedOutput":"4321","explanation":"Even digits reversed"}]},{"id":"fun19","title":"Check Palindrome Number","description":"Is number palindrome.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isPalindrome(int n) { return false; }\\nint main() { cout<<isPalindrome(12321); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isPalindrome(int n) {\\n    int original = n, reversed = 0;\\n    while(n > 0) {\\n        reversed = reversed * 10 + n % 10;\\n        n /= 10;\\n    }\\n    return original == reversed;\\n}\\nint main() { cout<<isPalindrome(12321); return 0; }","explanation":{"approach":"Reverse number and compare to original.","steps":["Save original","Reverse the number","Compare"],"complexity":"Time: O(log n), Space: O(1)"},"testCases":[{"input":"n=12321","expectedOutput":"1","explanation":"Reads same both ways"},{"input":"n=12345","expectedOutput":"0","explanation":"Not a palindrome"},{"input":"n=11","expectedOutput":"1","explanation":"Two same digits"},{"input":"n=1","expectedOutput":"1","explanation":"Single digit is palindrome"}]},{"id":"fun20","title":"Check Perfect Square","description":"Is perfect square.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isPerfectSquare(int n) { return false; }\\nint main() { cout<<isPerfectSquare(16); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isPerfectSquare(int n) {\\n    int root = 1;\\n    while(root * root < n) root++;\\n    return root * root == n;\\n}\\nint main() { cout<<isPerfectSquare(16); return 0; }","explanation":{"approach":"Find integer whose square equals n.","steps":["Start with 1","Increment until root>=n","Check if root==n"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"n=16","expectedOutput":"1","explanation":"4=16"},{"input":"n=14","expectedOutput":"0","explanation":"Not a perfect square"},{"input":"n=1","expectedOutput":"1","explanation":"1=1"},{"input":"n=25","expectedOutput":"1","explanation":"5=25"}]},{"id":"fun21","title":"Print Pattern Stars","description":"Right triangle of stars.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid pattern(int n) {}\\nint main() { pattern(4); return 0; }","expectedOutput":"* ** *** ****","solution":"#include <iostream>\\nusing namespace std;\\nvoid pattern(int n) {\\n    for(int i = 1; i <= n; i++) {\\n        for(int j = 1; j <= i; j++) {\\n            cout << \\"*\\";\\n        }\\n        if(i < n) cout << \\" \\";\\n    }\\n}\\nint main() { pattern(4); return 0; }","explanation":{"approach":"Nested loops - outer for rows, inner for stars.","steps":["Row 1: 1 star","Row 2: 2 stars","Continue to n"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"n=4","expectedOutput":"* ** *** ****","explanation":"Triangle with 4 rows"},{"input":"n=1","expectedOutput":"*","explanation":"Single star"},{"input":"n=3","expectedOutput":"* ** ***","explanation":"3 rows"},{"input":"n=2","expectedOutput":"* **","explanation":"2 rows"}]},{"id":"fun22","title":"Print Pattern Inverted","description":"Inverted triangle.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid pattern(int n) {}\\nint main() { pattern(4); return 0; }","expectedOutput":"**** *** ** *","solution":"#include <iostream>\\nusing namespace std;\\nvoid pattern(int n) {\\n    for(int i = n; i >= 1; i--) {\\n        for(int j = 1; j <= i; j++) {\\n            cout << \\"*\\";\\n        }\\n        if(i > 1) cout << \\" \\";\\n    }\\n}\\nint main() { pattern(4); return 0; }","explanation":{"approach":"Start from n stars, decrease each row.","steps":["Row 1: n stars","Row 2: n-1 stars","Continue to 1"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"n=4","expectedOutput":"**** *** ** *","explanation":"Inverted 4-row triangle"},{"input":"n=1","expectedOutput":"*","explanation":"Single star"},{"input":"n=3","expectedOutput":"*** ** *","explanation":"3 rows inverted"},{"input":"n=2","expectedOutput":"** *","explanation":"2 rows inverted"}]},{"id":"fun23","title":"Check Prime","description":"Is number prime.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isPrime(int n) { return false; }\\nint main() { cout<<isPrime(7); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isPrime(int n) {\\n    if(n < 2) return false;\\n    for(int i = 2; i * i <= n; i++) {\\n        if(n % i == 0) return false;\\n    }\\n    return true;\\n}\\nint main() { cout<<isPrime(7); return 0; }","explanation":{"approach":"Check divisibility up to sqrt(n).","steps":["If n<2, not prime","Check divisors from 2 to n","If any divide evenly, not prime"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"n=7","expectedOutput":"1","explanation":"7 is prime"},{"input":"n=4","expectedOutput":"0","explanation":"4=22, not prime"},{"input":"n=1","expectedOutput":"0","explanation":"1 is not prime"},{"input":"n=13","expectedOutput":"1","explanation":"13 is prime"}]},{"id":"fun24","title":"Fibonacci Loop","description":"Nth Fibonacci number.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint fib(int n) { return 0; }\\nint main() { cout<<fib(6); return 0; }","expectedOutput":"8","solution":"#include <iostream>\\nusing namespace std;\\nint fib(int n) {\\n    if(n <= 1) return n;\\n    int a = 0, b = 1;\\n    for(int i = 2; i <= n; i++) {\\n        int c = a + b;\\n        a = b;\\n        b = c;\\n    }\\n    return b;\\n}\\nint main() { cout<<fib(6); return 0; }","explanation":{"approach":"Each number is sum of previous two.","steps":["Start with 0, 1","Add to get next","Repeat n times"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"n=6","expectedOutput":"8","explanation":"Fib(6)=8 (0,1,1,2,3,5,8)"},{"input":"n=0","expectedOutput":"0","explanation":"Fib(0)=0"},{"input":"n=1","expectedOutput":"1","explanation":"Fib(1)=1"},{"input":"n=10","expectedOutput":"55","explanation":"Fib(10)=55"}]},{"id":"fun25","title":"GCD Euclidean","description":"Greatest Common Divisor.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint gcd(int a, int b) { return 0; }\\nint main() { cout<<gcd(48,18); return 0; }","expectedOutput":"6","solution":"#include <iostream>\\nusing namespace std;\\nint gcd(int a, int b) {\\n    while(b != 0) {\\n        int t = b;\\n        b = a % b;\\n        a = t;\\n    }\\n    return a;\\n}\\nint main() { cout<<gcd(48,18); return 0; }","explanation":{"approach":"Euclidean algorithm: repeatedly take remainder.","steps":["Replace (a,b) with (b, a%b)","Repeat until b=0","a is the GCD"],"complexity":"Time: O(log min(a,b)), Space: O(1)"},"testCases":[{"input":"a=48, b=18","expectedOutput":"6","explanation":"GCD(48,18)=6"},{"input":"a=100, b=25","expectedOutput":"25","explanation":"25 divides 100"},{"input":"a=17, b=13","expectedOutput":"1","explanation":"Coprime numbers"},{"input":"a=12, b=12","expectedOutput":"12","explanation":"Same numbers"}]}]`),LM=JSON.parse(`[{"id":"fun26","title":"Nth Term AP","description":"Find nth term of AP.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint nthAP(int a, int d, int n) { return 0; }\\nint main() { cout<<nthAP(2,3,5); return 0; }","expectedOutput":"14","solution":"#include <iostream>\\nusing namespace std;\\nint nthAP(int a, int d, int n) {\\n    return a + (n-1) * d;\\n}\\nint main() { cout<<nthAP(2,3,5); return 0; }","explanation":{"approach":"Use formula: nth term = a + (n-1)d","steps":["First term + (n-1) * common difference"],"complexity":"Time: O(1), Space: O(1)"},"testCases":[{"input":"a=2, d=3, n=5","expectedOutput":"14","explanation":"2,5,8,11,14 - 5th term is 14"},{"input":"a=1, d=1, n=10","expectedOutput":"10","explanation":"1,2,3...10"},{"input":"a=5, d=0, n=3","expectedOutput":"5","explanation":"All terms same when d=0"},{"input":"a=10, d=-2, n=4","expectedOutput":"4","explanation":"10,8,6,4"}]},{"id":"fun27","title":"Nth Term GP","description":"Find nth term of GP.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint nthGP(int a, int r, int n) { return 0; }\\nint main() { cout<<nthGP(2,3,4); return 0; }","expectedOutput":"54","solution":"#include <iostream>\\nusing namespace std;\\nint nthGP(int a, int r, int n) {\\n    int result = a;\\n    for(int i = 1; i < n; i++) result *= r;\\n    return result;\\n}\\nint main() { cout<<nthGP(2,3,4); return 0; }","explanation":{"approach":"Multiply first term by ratio (n-1) times.","steps":["nth term = a  r^(n-1)"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"a=2, r=3, n=4","expectedOutput":"54","explanation":"2,6,18,54"},{"input":"a=1, r=2, n=5","expectedOutput":"16","explanation":"1,2,4,8,16"},{"input":"a=5, r=1, n=10","expectedOutput":"5","explanation":"All terms same when r=1"},{"input":"a=3, r=2, n=1","expectedOutput":"3","explanation":"First term is a"}]},{"id":"fun28","title":"Power Function","description":"Calculate x^n.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint power(int x, int n) { return 0; }\\nint main() { cout<<power(2,10); return 0; }","expectedOutput":"1024","solution":"#include <iostream>\\nusing namespace std;\\nint power(int x, int n) {\\n    int result = 1;\\n    for(int i = 0; i < n; i++) result *= x;\\n    return result;\\n}\\nint main() { cout<<power(2,10); return 0; }","explanation":{"approach":"Multiply x by itself n times.","steps":["Start with 1","Multiply by x, n times"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"x=2, n=10","expectedOutput":"1024","explanation":"2^10=1024"},{"input":"x=3, n=4","expectedOutput":"81","explanation":"3^4=81"},{"input":"x=5, n=0","expectedOutput":"1","explanation":"Any^0=1"},{"input":"x=10, n=3","expectedOutput":"1000","explanation":"10^3=1000"}]},{"id":"fun29","title":"Cube of Number","description":"Calculate n^3.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint cube(int n) { return 0; }\\nint main() { cout<<cube(5); return 0; }","expectedOutput":"125","solution":"#include <iostream>\\nusing namespace std;\\nint cube(int n) {\\n    return n * n * n;\\n}\\nint main() { cout<<cube(5); return 0; }","explanation":{"approach":"Multiply n by itself 3 times.","steps":["Return n  n  n"],"complexity":"Time: O(1), Space: O(1)"},"testCases":[{"input":"n=5","expectedOutput":"125","explanation":"5=125"},{"input":"n=2","expectedOutput":"8","explanation":"2=8"},{"input":"n=0","expectedOutput":"0","explanation":"0=0"},{"input":"n=10","expectedOutput":"1000","explanation":"10=1000"}]},{"id":"fun30","title":"Square Root Integer","description":"Floor of square root.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint mySqrt(int n) { return 0; }\\nint main() { cout<<mySqrt(26); return 0; }","expectedOutput":"5","solution":"#include <iostream>\\nusing namespace std;\\nint mySqrt(int n) {\\n    int i = 1;\\n    while(i * i <= n) i++;\\n    return i - 1;\\n}\\nint main() { cout<<mySqrt(26); return 0; }","explanation":{"approach":"Find largest i where i  n.","steps":["Increment i while i  n","Return i-1"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"n=26","expectedOutput":"5","explanation":"5=25, 6=36, so floor is 5"},{"input":"n=16","expectedOutput":"4","explanation":"Perfect square"},{"input":"n=1","expectedOutput":"1","explanation":"1=1"},{"input":"n=100","expectedOutput":"10","explanation":"100=10"}]},{"id":"fun31","title":"Calculate Percentage","description":"Find percentage.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\ndouble percentage(int obtained, int total) { return 0; }\\nint main() { cout<<percentage(45,50); return 0; }","expectedOutput":"90","solution":"#include <iostream>\\nusing namespace std;\\ndouble percentage(int obtained, int total) {\\n    return (obtained * 100.0) / total;\\n}\\nint main() { cout<<percentage(45,50); return 0; }","explanation":{"approach":"(Obtained/Total)  100","steps":["Divide obtained by total","Multiply by 100"],"complexity":"Time: O(1), Space: O(1)"},"testCases":[{"input":"obtained=45, total=50","expectedOutput":"90","explanation":"45/50*100=90%"},{"input":"obtained=50, total=100","expectedOutput":"50","explanation":"Half is 50%"},{"input":"obtained=100, total=100","expectedOutput":"100","explanation":"100%"},{"input":"obtained=25, total=50","expectedOutput":"50","explanation":"Half"}]},{"id":"fun32","title":"Simple Interest","description":"Calculate SI.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\ndouble simpleInterest(int p, int r, int t) { return 0; }\\nint main() { cout<<simpleInterest(1000,5,2); return 0; }","expectedOutput":"100","solution":"#include <iostream>\\nusing namespace std;\\ndouble simpleInterest(int p, int r, int t) {\\n    return (p * r * t) / 100.0;\\n}\\nint main() { cout<<simpleInterest(1000,5,2); return 0; }","explanation":{"approach":"SI = (P  R  T) / 100","steps":["Multiply PRT","Divide by 100"],"complexity":"Time: O(1), Space: O(1)"},"testCases":[{"input":"p=1000, r=5, t=2","expectedOutput":"100","explanation":"1000*5*2/100=100"},{"input":"p=5000, r=10, t=1","expectedOutput":"500","explanation":"5000*10*1/100=500"},{"input":"p=1000, r=0, t=5","expectedOutput":"0","explanation":"0% rate=0 interest"},{"input":"p=2000, r=5, t=3","expectedOutput":"300","explanation":"2000*5*3/100=300"}]},{"id":"fun33","title":"Celsius to Fahrenheit","description":"Temperature conversion.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\ndouble toFahrenheit(double c) { return 0; }\\nint main() { cout<<toFahrenheit(0); return 0; }","expectedOutput":"32","solution":"#include <iostream>\\nusing namespace std;\\ndouble toFahrenheit(double c) {\\n    return c * 9.0/5.0 + 32;\\n}\\nint main() { cout<<toFahrenheit(0); return 0; }","explanation":{"approach":"F = C  (9/5) + 32","steps":["Multiply by 9/5","Add 32"],"complexity":"Time: O(1), Space: O(1)"},"testCases":[{"input":"c=0","expectedOutput":"32","explanation":"0C = 32F (freezing)"},{"input":"c=100","expectedOutput":"212","explanation":"100C = 212F (boiling)"},{"input":"c=-40","expectedOutput":"-40","explanation":"-40C = -40F (same!)"},{"input":"c=37","expectedOutput":"98.6","explanation":"Body temperature"}]},{"id":"fun34","title":"Fahrenheit to Celsius","description":"Temperature conversion.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\ndouble toCelsius(double f) { return 0; }\\nint main() { cout<<toCelsius(32); return 0; }","expectedOutput":"0","solution":"#include <iostream>\\nusing namespace std;\\ndouble toCelsius(double f) {\\n    return (f - 32) * 5.0/9.0;\\n}\\nint main() { cout<<toCelsius(32); return 0; }","explanation":{"approach":"C = (F - 32)  (5/9)","steps":["Subtract 32","Multiply by 5/9"],"complexity":"Time: O(1), Space: O(1)"},"testCases":[{"input":"f=32","expectedOutput":"0","explanation":"32F = 0C"},{"input":"f=212","expectedOutput":"100","explanation":"212F = 100C"},{"input":"f=-40","expectedOutput":"-40","explanation":"-40F = -40C"},{"input":"f=98.6","expectedOutput":"37","explanation":"Body temp"}]},{"id":"fun35","title":"Area of Circle","description":"Calculate area.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\n#include <iomanip>\\nusing namespace std;\\ndouble areaCircle(double r) { return 0; }\\nint main() { cout<<fixed<<setprecision(2)<<areaCircle(7); return 0; }","expectedOutput":"153.94","solution":"#include <iostream>\\n#include <iomanip>\\nusing namespace std;\\ndouble areaCircle(double r) {\\n    return 3.14159 * r * r;\\n}\\nint main() { cout<<fixed<<setprecision(2)<<areaCircle(7); return 0; }","explanation":{"approach":"Area =   r","steps":["Square radius","Multiply by "],"complexity":"Time: O(1), Space: O(1)"},"testCases":[{"input":"r=7","expectedOutput":"153.94","explanation":"7=153.94"},{"input":"r=1","expectedOutput":"3.14","explanation":"1=3.14"},{"input":"r=10","expectedOutput":"314.16","explanation":"100"},{"input":"r=0","expectedOutput":"0","explanation":"Zero radius"}]},{"id":"fun36","title":"Area of Triangle","description":"Using base and height.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\ndouble areaTriangle(double b, double h) { return 0; }\\nint main() { cout<<areaTriangle(10,5); return 0; }","expectedOutput":"25","solution":"#include <iostream>\\nusing namespace std;\\ndouble areaTriangle(double b, double h) {\\n    return 0.5 * b * h;\\n}\\nint main() { cout<<areaTriangle(10,5); return 0; }","explanation":{"approach":"Area =   base  height","steps":["Multiply base by height","Divide by 2"],"complexity":"Time: O(1), Space: O(1)"},"testCases":[{"input":"b=10, h=5","expectedOutput":"25","explanation":"105=25"},{"input":"b=6, h=8","expectedOutput":"24","explanation":"68=24"},{"input":"b=3, h=4","expectedOutput":"6","explanation":"34=6"},{"input":"b=0, h=10","expectedOutput":"0","explanation":"Zero base"}]},{"id":"fun37","title":"Area of Rectangle","description":"Length times width.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint areaRect(int l, int w) { return 0; }\\nint main() { cout<<areaRect(10,5); return 0; }","expectedOutput":"50","solution":"#include <iostream>\\nusing namespace std;\\nint areaRect(int l, int w) {\\n    return l * w;\\n}\\nint main() { cout<<areaRect(10,5); return 0; }","explanation":{"approach":"Area = length  width","steps":["Multiply length by width"],"complexity":"Time: O(1), Space: O(1)"},"testCases":[{"input":"l=10, w=5","expectedOutput":"50","explanation":"105=50"},{"input":"l=7, w=7","expectedOutput":"49","explanation":"Square: 77=49"},{"input":"l=1, w=100","expectedOutput":"100","explanation":"1100=100"},{"input":"l=0, w=10","expectedOutput":"0","explanation":"Zero length"}]},{"id":"fun38","title":"Perimeter of Rectangle","description":"Sum of all sides.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint perimeterRect(int l, int w) { return 0; }\\nint main() { cout<<perimeterRect(10,5); return 0; }","expectedOutput":"30","solution":"#include <iostream>\\nusing namespace std;\\nint perimeterRect(int l, int w) {\\n    return 2 * (l + w);\\n}\\nint main() { cout<<perimeterRect(10,5); return 0; }","explanation":{"approach":"Perimeter = 2  (length + width)","steps":["Add length and width","Multiply by 2"],"complexity":"Time: O(1), Space: O(1)"},"testCases":[{"input":"l=10, w=5","expectedOutput":"30","explanation":"2(10+5)=30"},{"input":"l=7, w=7","expectedOutput":"28","explanation":"Square: 47=28"},{"input":"l=1, w=1","expectedOutput":"4","explanation":"Unit square"},{"input":"l=0, w=5","expectedOutput":"10","explanation":"25=10"}]},{"id":"fun39","title":"Check Leap Year","description":"Is year a leap year.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isLeapYear(int y) { return false; }\\nint main() { cout<<isLeapYear(2024); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isLeapYear(int y) {\\n    return (y%4==0 && y%100!=0) || y%400==0;\\n}\\nint main() { cout<<isLeapYear(2024); return 0; }","explanation":{"approach":"Divisible by 4 but not 100, or divisible by 400.","steps":["Check if divisible by 400","Or divisible by 4 but not 100"],"complexity":"Time: O(1), Space: O(1)"},"testCases":[{"input":"y=2024","expectedOutput":"1","explanation":"Divisible by 4, not by 100"},{"input":"y=2000","expectedOutput":"1","explanation":"Divisible by 400"},{"input":"y=1900","expectedOutput":"0","explanation":"Divisible by 100 but not 400"},{"input":"y=2023","expectedOutput":"0","explanation":"Not divisible by 4"}]},{"id":"fun40","title":"Days in Month","description":"Number of days.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint daysInMonth(int m) { return 0; }\\nint main() { cout<<daysInMonth(2); return 0; }","expectedOutput":"28","solution":"#include <iostream>\\nusing namespace std;\\nint daysInMonth(int m) {\\n    int days[]={31,28,31,30,31,30,31,31,30,31,30,31};\\n    return days[m-1];\\n}\\nint main() { cout<<daysInMonth(2); return 0; }","explanation":{"approach":"Lookup table for days in each month.","steps":["Use array with days per month","Return days[month-1]"],"complexity":"Time: O(1), Space: O(1)"},"testCases":[{"input":"m=2","expectedOutput":"28","explanation":"February (non-leap)"},{"input":"m=1","expectedOutput":"31","explanation":"January"},{"input":"m=4","expectedOutput":"30","explanation":"April has 30"},{"input":"m=12","expectedOutput":"31","explanation":"December"}]},{"id":"fun41","title":"LCM of Two","description":"Least Common Multiple.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint lcm(int a, int b) { return 0; }\\nint main() { cout<<lcm(4,6); return 0; }","expectedOutput":"12","solution":"#include <iostream>\\nusing namespace std;\\nint gcd(int a, int b) {\\n    while(b) { int t=b; b=a%b; a=t; }\\n    return a;\\n}\\nint lcm(int a, int b) {\\n    return (a / gcd(a,b)) * b;\\n}\\nint main() { cout<<lcm(4,6); return 0; }","explanation":{"approach":"LCM = (a  b) / GCD(a,b)","steps":["Find GCD","LCM = a/gcd * b"],"complexity":"Time: O(log min(a,b)), Space: O(1)"},"testCases":[{"input":"a=4, b=6","expectedOutput":"12","explanation":"LCM(4,6)=12"},{"input":"a=3, b=5","expectedOutput":"15","explanation":"Coprime: 35=15"},{"input":"a=12, b=8","expectedOutput":"24","explanation":"LCM(12,8)=24"},{"input":"a=7, b=7","expectedOutput":"7","explanation":"Same numbers"}]},{"id":"fun42","title":"HCF of Two","description":"Highest Common Factor.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint hcf(int a, int b) { return 0; }\\nint main() { cout<<hcf(48,18); return 0; }","expectedOutput":"6","solution":"#include <iostream>\\nusing namespace std;\\nint hcf(int a, int b) {\\n    while(b) { int t=b; b=a%b; a=t; }\\n    return a;\\n}\\nint main() { cout<<hcf(48,18); return 0; }","explanation":{"approach":"Euclidean algorithm.","steps":["Replace (a,b) with (b, a%b)","Repeat until b=0"],"complexity":"Time: O(log min(a,b)), Space: O(1)"},"testCases":[{"input":"a=48, b=18","expectedOutput":"6","explanation":"GCD(48,18)=6"},{"input":"a=100, b=25","expectedOutput":"25","explanation":"25 divides 100"},{"input":"a=17, b=13","expectedOutput":"1","explanation":"Coprime"},{"input":"a=12, b=12","expectedOutput":"12","explanation":"Same numbers"}]},{"id":"fun43","title":"Sum First N Natural","description":"1+2+3+...+n.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint sumN(int n) { return 0; }\\nint main() { cout<<sumN(10); return 0; }","expectedOutput":"55","solution":"#include <iostream>\\nusing namespace std;\\nint sumN(int n) {\\n    return n * (n + 1) / 2;\\n}\\nint main() { cout<<sumN(10); return 0; }","explanation":{"approach":"Formula: n(n+1)/2","steps":["Use Gauss formula"],"complexity":"Time: O(1), Space: O(1)"},"testCases":[{"input":"n=10","expectedOutput":"55","explanation":"1+2+...+10=55"},{"input":"n=1","expectedOutput":"1","explanation":"Just 1"},{"input":"n=100","expectedOutput":"5050","explanation":"Famous result"},{"input":"n=5","expectedOutput":"15","explanation":"1+2+3+4+5=15"}]},{"id":"fun44","title":"Sum of Squares","description":"1+2+...+n.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint sumSquares(int n) { return 0; }\\nint main() { cout<<sumSquares(5); return 0; }","expectedOutput":"55","solution":"#include <iostream>\\nusing namespace std;\\nint sumSquares(int n) {\\n    return n * (n + 1) * (2*n + 1) / 6;\\n}\\nint main() { cout<<sumSquares(5); return 0; }","explanation":{"approach":"Formula: n(n+1)(2n+1)/6","steps":["Apply formula"],"complexity":"Time: O(1), Space: O(1)"},"testCases":[{"input":"n=5","expectedOutput":"55","explanation":"1+4+9+16+25=55"},{"input":"n=3","expectedOutput":"14","explanation":"1+4+9=14"},{"input":"n=1","expectedOutput":"1","explanation":"Just 1=1"},{"input":"n=10","expectedOutput":"385","explanation":"Sum of first 10 squares"}]},{"id":"fun45","title":"Sum of Cubes","description":"1+2+...+n.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint sumCubes(int n) { return 0; }\\nint main() { cout<<sumCubes(4); return 0; }","expectedOutput":"100","solution":"#include <iostream>\\nusing namespace std;\\nint sumCubes(int n) {\\n    int s = n * (n + 1) / 2;\\n    return s * s;\\n}\\nint main() { cout<<sumCubes(4); return 0; }","explanation":{"approach":"Sum of cubes = (sum of n)","steps":["Calculate sum of n first","Square it"],"complexity":"Time: O(1), Space: O(1)"},"testCases":[{"input":"n=4","expectedOutput":"100","explanation":"1+8+27+64=100=(1+2+3+4)"},{"input":"n=3","expectedOutput":"36","explanation":"1+8+27=36=6"},{"input":"n=1","expectedOutput":"1","explanation":"1=1"},{"input":"n=5","expectedOutput":"225","explanation":"(1+2+3+4+5)=225"}]},{"id":"fun46","title":"Print 1 to N","description":"Print numbers 1 to n.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid printN(int n) {}\\nint main() { printN(5); return 0; }","expectedOutput":"1 2 3 4 5","solution":"#include <iostream>\\nusing namespace std;\\nvoid printN(int n) {\\n    for(int i=1;i<=n;i++) cout<<i<<\\" \\";\\n}\\nint main() { printN(5); return 0; }","explanation":{"approach":"Simple loop from 1 to n.","steps":["Loop i from 1 to n","Print i"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"n=5","expectedOutput":"1 2 3 4 5","explanation":"Print 1 to 5"},{"input":"n=1","expectedOutput":"1","explanation":"Single number"},{"input":"n=10","expectedOutput":"1 2 3 4 5 6 7 8 9 10","explanation":"1 to 10"},{"input":"n=3","expectedOutput":"1 2 3","explanation":"Print 1 to 3"}]},{"id":"fun47","title":"Print N to 1","description":"Print countdown.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid printReverse(int n) {}\\nint main() { printReverse(5); return 0; }","expectedOutput":"5 4 3 2 1","solution":"#include <iostream>\\nusing namespace std;\\nvoid printReverse(int n) {\\n    for(int i=n;i>=1;i--) cout<<i<<\\" \\";\\n}\\nint main() { printReverse(5); return 0; }","explanation":{"approach":"Loop from n down to 1.","steps":["Loop i from n to 1","Print i"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"n=5","expectedOutput":"5 4 3 2 1","explanation":"Countdown from 5"},{"input":"n=1","expectedOutput":"1","explanation":"Single number"},{"input":"n=10","expectedOutput":"10 9 8 7 6 5 4 3 2 1","explanation":"10 to 1"},{"input":"n=3","expectedOutput":"3 2 1","explanation":"3 to 1"}]},{"id":"fun48","title":"Print Odd Numbers","description":"Odd numbers 1 to n.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid printOdds(int n) {}\\nint main() { printOdds(10); return 0; }","expectedOutput":"1 3 5 7 9","solution":"#include <iostream>\\nusing namespace std;\\nvoid printOdds(int n) {\\n    for(int i=1;i<=n;i+=2) cout<<i<<\\" \\";\\n}\\nint main() { printOdds(10); return 0; }","explanation":{"approach":"Start at 1, increment by 2.","steps":["Start i=1","Print i, then i+=2"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"n=10","expectedOutput":"1 3 5 7 9","explanation":"Odds up to 10"},{"input":"n=5","expectedOutput":"1 3 5","explanation":"Odds up to 5"},{"input":"n=1","expectedOutput":"1","explanation":"Just 1"},{"input":"n=15","expectedOutput":"1 3 5 7 9 11 13 15","explanation":"Odds to 15"}]},{"id":"fun49","title":"Print Even Numbers","description":"Even numbers 2 to n.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid printEvens(int n) {}\\nint main() { printEvens(10); return 0; }","expectedOutput":"2 4 6 8 10","solution":"#include <iostream>\\nusing namespace std;\\nvoid printEvens(int n) {\\n    for(int i=2;i<=n;i+=2) cout<<i<<\\" \\";\\n}\\nint main() { printEvens(10); return 0; }","explanation":{"approach":"Start at 2, increment by 2.","steps":["Start i=2","Print i, then i+=2"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"n=10","expectedOutput":"2 4 6 8 10","explanation":"Evens up to 10"},{"input":"n=6","expectedOutput":"2 4 6","explanation":"Evens up to 6"},{"input":"n=2","expectedOutput":"2","explanation":"Just 2"},{"input":"n=1","expectedOutput":"","explanation":"No evens"}]},{"id":"fun50","title":"Multiplication Table","description":"Print table of n.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid table(int n) {}\\nint main() { table(5); return 0; }","expectedOutput":"5 10 15 20 25 30 35 40 45 50","solution":"#include <iostream>\\nusing namespace std;\\nvoid table(int n) {\\n    for(int i=1;i<=10;i++) cout<<n*i<<\\" \\";\\n}\\nint main() { table(5); return 0; }","explanation":{"approach":"Loop 1 to 10, print ni.","steps":["For i from 1 to 10","Print ni"],"complexity":"Time: O(1), Space: O(1)"},"testCases":[{"input":"n=5","expectedOutput":"5 10 15 20 25 30 35 40 45 50","explanation":"5's table"},{"input":"n=7","expectedOutput":"7 14 21 28 35 42 49 56 63 70","explanation":"7's table"},{"input":"n=1","expectedOutput":"1 2 3 4 5 6 7 8 9 10","explanation":"1's table"},{"input":"n=10","expectedOutput":"10 20 30 40 50 60 70 80 90 100","explanation":"10's table"}]}]`),PM=JSON.parse(`[{"id":"fun51","title":"Sum of Squares 1 to N","description":"Formula: n(n+1)(2n+1)/6.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint sumSquares(int n) { return 0; }\\nint main() { cout<<sumSquares(5); return 0; }","expectedOutput":"55","solution":"#include <iostream>\\nusing namespace std;\\nint sumSquares(int n) {\\n    return n * (n + 1) * (2 * n + 1) / 6;\\n}\\nint main() { cout<<sumSquares(5); return 0; }","explanation":{"approach":"Formula: n(n+1)(2n+1)/6","steps":["Apply formula directly"],"complexity":"Time: O(1), Space: O(1)"},"testCases":[{"input":"n=5","expectedOutput":"55","explanation":"1+4+9+16+25=55"},{"input":"n=3","expectedOutput":"14","explanation":"1+4+9=14"},{"input":"n=1","expectedOutput":"1","explanation":"1=1"},{"input":"n=10","expectedOutput":"385","explanation":"Sum first 10 squares"}]},{"id":"fun52","title":"Sum of Cubes 1 to N","description":"Formula: (n(n+1)/2).","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint sumCubes(int n) { return 0; }\\nint main() { cout<<sumCubes(5); return 0; }","expectedOutput":"225","solution":"#include <iostream>\\nusing namespace std;\\nint sumCubes(int n) {\\n    int sum = n * (n + 1) / 2;\\n    return sum * sum;\\n}\\nint main() { cout<<sumCubes(5); return 0; }","explanation":{"approach":"Sum of cubes = (sum of n)","steps":["Calculate sum of 1 to n","Square it"],"complexity":"Time: O(1), Space: O(1)"},"testCases":[{"input":"n=5","expectedOutput":"225","explanation":"(1+2+3+4+5)=15=225"},{"input":"n=3","expectedOutput":"36","explanation":"6=36"},{"input":"n=4","expectedOutput":"100","explanation":"10=100"},{"input":"n=1","expectedOutput":"1","explanation":"1=1"}]},{"id":"fun53","title":"Print Odd Numbers","description":"Print odd 1 to N.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid printOdd(int n) {}\\nint main() { printOdd(10); return 0; }","expectedOutput":"1 3 5 7 9","solution":"#include <iostream>\\nusing namespace std;\\nvoid printOdd(int n) {\\n    for(int i = 1; i <= n; i += 2)\\n        cout << i << \\" \\";\\n}\\nint main() { printOdd(10); return 0; }","explanation":{"approach":"Start from 1, increment by 2.","steps":["Loop i=1,3,5..."],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"n=10","expectedOutput":"1 3 5 7 9","explanation":"Odds up to 10"},{"input":"n=5","expectedOutput":"1 3 5","explanation":"Odds up to 5"},{"input":"n=1","expectedOutput":"1","explanation":"Just 1"},{"input":"n=7","expectedOutput":"1 3 5 7","explanation":"Odds to 7"}]},{"id":"fun54","title":"Print Even Numbers","description":"Print even 1 to N.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid printEven(int n) {}\\nint main() { printEven(10); return 0; }","expectedOutput":"2 4 6 8 10","solution":"#include <iostream>\\nusing namespace std;\\nvoid printEven(int n) {\\n    for(int i = 2; i <= n; i += 2)\\n        cout << i << \\" \\";\\n}\\nint main() { printEven(10); return 0; }","explanation":{"approach":"Start from 2, increment by 2.","steps":["Loop i=2,4,6..."],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"n=10","expectedOutput":"2 4 6 8 10","explanation":"Evens up to 10"},{"input":"n=6","expectedOutput":"2 4 6","explanation":"Evens up to 6"},{"input":"n=2","expectedOutput":"2","explanation":"Just 2"},{"input":"n=1","expectedOutput":"","explanation":"No evens below 2"}]},{"id":"fun55","title":"Sum of Even 1 to N","description":"Sum of even numbers.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint sumEven(int n) { return 0; }\\nint main() { cout<<sumEven(10); return 0; }","expectedOutput":"30","solution":"#include <iostream>\\nusing namespace std;\\nint sumEven(int n) {\\n    int sum = 0;\\n    for(int i = 2; i <= n; i += 2) sum += i;\\n    return sum;\\n}\\nint main() { cout<<sumEven(10); return 0; }","explanation":{"approach":"Add all even numbers.","steps":["Sum 2+4+6+..."],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"n=10","expectedOutput":"30","explanation":"2+4+6+8+10=30"},{"input":"n=6","expectedOutput":"12","explanation":"2+4+6=12"},{"input":"n=2","expectedOutput":"2","explanation":"Just 2"},{"input":"n=20","expectedOutput":"110","explanation":"Sum evens to 20"}]},{"id":"fun56","title":"Sum of Odd 1 to N","description":"Sum of odd numbers.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint sumOdd(int n) { return 0; }\\nint main() { cout<<sumOdd(10); return 0; }","expectedOutput":"25","solution":"#include <iostream>\\nusing namespace std;\\nint sumOdd(int n) {\\n    int sum = 0;\\n    for(int i = 1; i <= n; i += 2) sum += i;\\n    return sum;\\n}\\nint main() { cout<<sumOdd(10); return 0; }","explanation":{"approach":"Add all odd numbers.","steps":["Sum 1+3+5+..."],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"n=10","expectedOutput":"25","explanation":"1+3+5+7+9=25"},{"input":"n=5","expectedOutput":"9","explanation":"1+3+5=9"},{"input":"n=1","expectedOutput":"1","explanation":"Just 1"},{"input":"n=9","expectedOutput":"25","explanation":"1+3+5+7+9=25"}]},{"id":"fun57","title":"Product of Digits","description":"Multiply all digits.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint productDigits(int n) { return 0; }\\nint main() { cout<<productDigits(234); return 0; }","expectedOutput":"24","solution":"#include <iostream>\\nusing namespace std;\\nint productDigits(int n) {\\n    int prod = 1;\\n    while(n > 0) {\\n        prod *= n % 10;\\n        n /= 10;\\n    }\\n    return prod;\\n}\\nint main() { cout<<productDigits(234); return 0; }","explanation":{"approach":"Extract and multiply each digit.","steps":["Get digit with %10","Multiply to product"],"complexity":"Time: O(log n), Space: O(1)"},"testCases":[{"input":"n=234","expectedOutput":"24","explanation":"234=24"},{"input":"n=123","expectedOutput":"6","explanation":"123=6"},{"input":"n=105","expectedOutput":"0","explanation":"Contains 0"},{"input":"n=999","expectedOutput":"729","explanation":"999=729"}]},{"id":"fun58","title":"First Digit","description":"Get first digit.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint firstDigit(int n) { return 0; }\\nint main() { cout<<firstDigit(12345); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nint firstDigit(int n) {\\n    while(n >= 10) n /= 10;\\n    return n;\\n}\\nint main() { cout<<firstDigit(12345); return 0; }","explanation":{"approach":"Divide by 10 until single digit.","steps":["Keep dividing until n<10"],"complexity":"Time: O(log n), Space: O(1)"},"testCases":[{"input":"n=12345","expectedOutput":"1","explanation":"First digit is 1"},{"input":"n=9876","expectedOutput":"9","explanation":"First digit is 9"},{"input":"n=5","expectedOutput":"5","explanation":"Single digit"},{"input":"n=100","expectedOutput":"1","explanation":"First digit is 1"}]},{"id":"fun59","title":"Last Digit","description":"Get last digit.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint lastDigit(int n) { return 0; }\\nint main() { cout<<lastDigit(12345); return 0; }","expectedOutput":"5","solution":"#include <iostream>\\nusing namespace std;\\nint lastDigit(int n) {\\n    return n % 10;\\n}\\nint main() { cout<<lastDigit(12345); return 0; }","explanation":{"approach":"Modulo 10 gives last digit.","steps":["Return n % 10"],"complexity":"Time: O(1), Space: O(1)"},"testCases":[{"input":"n=12345","expectedOutput":"5","explanation":"Last digit is 5"},{"input":"n=9870","expectedOutput":"0","explanation":"Last digit is 0"},{"input":"n=7","expectedOutput":"7","explanation":"Single digit"},{"input":"n=100","expectedOutput":"0","explanation":"Ends in 0"}]},{"id":"fun60","title":"Sum First and Last","description":"Sum of first and last digit.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint sumFirstLast(int n) { return 0; }\\nint main() { cout<<sumFirstLast(12345); return 0; }","expectedOutput":"6","solution":"#include <iostream>\\nusing namespace std;\\nint sumFirstLast(int n) {\\n    int last = n % 10;\\n    while(n >= 10) n /= 10;\\n    return n + last;\\n}\\nint main() { cout<<sumFirstLast(12345); return 0; }","explanation":{"approach":"Get first and last, add them.","steps":["Get last with %10","Get first by dividing"],"complexity":"Time: O(log n), Space: O(1)"},"testCases":[{"input":"n=12345","expectedOutput":"6","explanation":"1+5=6"},{"input":"n=98","expectedOutput":"17","explanation":"9+8=17"},{"input":"n=7","expectedOutput":"14","explanation":"7+7=14 (same digit)"},{"input":"n=100","expectedOutput":"1","explanation":"1+0=1"}]},{"id":"fun61","title":"Swap First and Last Digit","description":"Swap first and last.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint swapFirstLast(int n) { return 0; }\\nint main() { cout<<swapFirstLast(12345); return 0; }","expectedOutput":"52341","solution":"#include <iostream>\\nusing namespace std;\\nint swapFirstLast(int n) {\\n    int mult = 1, temp = n;\\n    while(temp >= 10) { mult *= 10; temp /= 10; }\\n    int first = temp, last = n % 10;\\n    return n - first * mult - last + last * mult + first;\\n}\\nint main() { cout<<swapFirstLast(12345); return 0; }","explanation":{"approach":"Calculate positions and swap.","steps":["Find first and last","Swap mathematically"],"complexity":"Time: O(log n), Space: O(1)"},"testCases":[{"input":"n=12345","expectedOutput":"52341","explanation":"Swap 1 and 5"},{"input":"n=98","expectedOutput":"89","explanation":"Swap 9 and 8"},{"input":"n=1234","expectedOutput":"4231","explanation":"Swap 1 and 4"},{"input":"n=5","expectedOutput":"5","explanation":"Single digit unchanged"}]},{"id":"fun62","title":"Remove First Digit","description":"Number without first digit.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint removeFirst(int n) { return 0; }\\nint main() { cout<<removeFirst(12345); return 0; }","expectedOutput":"2345","solution":"#include <iostream>\\nusing namespace std;\\nint removeFirst(int n) {\\n    int mult = 1, temp = n;\\n    while(temp >= 10) { mult *= 10; temp /= 10; }\\n    return n % mult;\\n}\\nint main() { cout<<removeFirst(12345); return 0; }","explanation":{"approach":"Use modulo to remove first digit.","steps":["Find multiplier","Return n % mult"],"complexity":"Time: O(log n), Space: O(1)"},"testCases":[{"input":"n=12345","expectedOutput":"2345","explanation":"Remove 1"},{"input":"n=9876","expectedOutput":"876","explanation":"Remove 9"},{"input":"n=100","expectedOutput":"0","explanation":"10000=0"},{"input":"n=5","expectedOutput":"0","explanation":"Single digit0"}]},{"id":"fun63","title":"Remove Last Digit","description":"Number without last digit.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint removeLast(int n) { return 0; }\\nint main() { cout<<removeLast(12345); return 0; }","expectedOutput":"1234","solution":"#include <iostream>\\nusing namespace std;\\nint removeLast(int n) {\\n    return n / 10;\\n}\\nint main() { cout<<removeLast(12345); return 0; }","explanation":{"approach":"Divide by 10 to remove last.","steps":["Return n / 10"],"complexity":"Time: O(1), Space: O(1)"},"testCases":[{"input":"n=12345","expectedOutput":"1234","explanation":"Remove 5"},{"input":"n=100","expectedOutput":"10","explanation":"Remove 0"},{"input":"n=5","expectedOutput":"0","explanation":"Single digit0"},{"input":"n=99","expectedOutput":"9","explanation":"Remove 9"}]},{"id":"fun64","title":"Check Armstrong","description":"Is Armstrong number.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isArmstrong(int n) { return false; }\\nint main() { cout<<isArmstrong(153); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isArmstrong(int n) {\\n    int sum = 0, temp = n;\\n    int digits = 0, t = n;\\n    while(t > 0) { digits++; t /= 10; }\\n    while(temp > 0) {\\n        int d = temp % 10;\\n        int p = 1;\\n        for(int i=0;i<digits;i++) p *= d;\\n        sum += p;\\n        temp /= 10;\\n    }\\n    return sum == n;\\n}\\nint main() { cout<<isArmstrong(153); return 0; }","explanation":{"approach":"Sum of digits^(num digits) equals number.","steps":["Count digits","Sum each digit^n","Compare to original"],"complexity":"Time: O(log n), Space: O(1)"},"testCases":[{"input":"n=153","expectedOutput":"1","explanation":"1+5+3=153"},{"input":"n=370","expectedOutput":"1","explanation":"3+7+0=370"},{"input":"n=123","expectedOutput":"0","explanation":"1+2+3=36123"},{"input":"n=9474","expectedOutput":"1","explanation":"9+4+7+4=9474"}]},{"id":"fun65","title":"Check Strong Number","description":"Sum of factorials of digits.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isStrong(int n) { return false; }\\nint main() { cout<<isStrong(145); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nint fact(int x) { int f=1; for(int i=2;i<=x;i++) f*=i; return f; }\\nbool isStrong(int n) {\\n    int sum = 0, temp = n;\\n    while(temp > 0) {\\n        sum += fact(temp % 10);\\n        temp /= 10;\\n    }\\n    return sum == n;\\n}\\nint main() { cout<<isStrong(145); return 0; }","explanation":{"approach":"Sum of factorials of each digit equals number.","steps":["Get each digit","Sum their factorials"],"complexity":"Time: O(log n), Space: O(1)"},"testCases":[{"input":"n=145","expectedOutput":"1","explanation":"1!+4!+5!=1+24+120=145"},{"input":"n=40585","expectedOutput":"1","explanation":"Only other strong number"},{"input":"n=123","expectedOutput":"0","explanation":"1!+2!+3!=9123"},{"input":"n=2","expectedOutput":"1","explanation":"2!=2"}]},{"id":"fun66","title":"Check Perfect Number","description":"Sum of divisors equals n.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isPerfect(int n) { return false; }\\nint main() { cout<<isPerfect(28); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isPerfect(int n) {\\n    int sum = 1;\\n    for(int i = 2; i * i <= n; i++) {\\n        if(n % i == 0) {\\n            sum += i;\\n            if(i != n/i) sum += n/i;\\n        }\\n    }\\n    return sum == n && n > 1;\\n}\\nint main() { cout<<isPerfect(28); return 0; }","explanation":{"approach":"Sum of proper divisors equals number.","steps":["Find all divisors","Sum them (excluding n)"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"n=28","expectedOutput":"1","explanation":"1+2+4+7+14=28"},{"input":"n=6","expectedOutput":"1","explanation":"1+2+3=6"},{"input":"n=12","expectedOutput":"0","explanation":"1+2+3+4+6=1612"},{"input":"n=496","expectedOutput":"1","explanation":"Third perfect number"}]},{"id":"fun67","title":"Check Abundant Number","description":"Sum of divisors > n.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isAbundant(int n) { return false; }\\nint main() { cout<<isAbundant(12); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isAbundant(int n) {\\n    int sum = 1;\\n    for(int i = 2; i * i <= n; i++) {\\n        if(n % i == 0) {\\n            sum += i;\\n            if(i != n/i) sum += n/i;\\n        }\\n    }\\n    return sum > n;\\n}\\nint main() { cout<<isAbundant(12); return 0; }","explanation":{"approach":"Sum of proper divisors exceeds number.","steps":["Sum all divisors","Check if > n"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"n=12","expectedOutput":"1","explanation":"1+2+3+4+6=16>12"},{"input":"n=18","expectedOutput":"1","explanation":"1+2+3+6+9=21>18"},{"input":"n=6","expectedOutput":"0","explanation":"Perfect, not abundant"},{"input":"n=7","expectedOutput":"0","explanation":"Prime, deficient"}]},{"id":"fun68","title":"Check Deficient Number","description":"Sum of divisors < n.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isDeficient(int n) { return false; }\\nint main() { cout<<isDeficient(15); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isDeficient(int n) {\\n    int sum = 1;\\n    for(int i = 2; i * i <= n; i++) {\\n        if(n % i == 0) {\\n            sum += i;\\n            if(i != n/i) sum += n/i;\\n        }\\n    }\\n    return sum < n;\\n}\\nint main() { cout<<isDeficient(15); return 0; }","explanation":{"approach":"Sum of proper divisors less than number.","steps":["Sum all divisors","Check if < n"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"n=15","expectedOutput":"1","explanation":"1+3+5=9<15"},{"input":"n=7","expectedOutput":"1","explanation":"Prime: 1<7"},{"input":"n=12","expectedOutput":"0","explanation":"Abundant not deficient"},{"input":"n=21","expectedOutput":"1","explanation":"1+3+7=11<21"}]},{"id":"fun69","title":"Check Harshad Number","description":"Divisible by sum of digits.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isHarshad(int n) { return false; }\\nint main() { cout<<isHarshad(18); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isHarshad(int n) {\\n    int sum = 0, temp = n;\\n    while(temp > 0) { sum += temp % 10; temp /= 10; }\\n    return n % sum == 0;\\n}\\nint main() { cout<<isHarshad(18); return 0; }","explanation":{"approach":"Number divisible by its digit sum.","steps":["Calculate digit sum","Check divisibility"],"complexity":"Time: O(log n), Space: O(1)"},"testCases":[{"input":"n=18","expectedOutput":"1","explanation":"1+8=9, 189=2"},{"input":"n=12","expectedOutput":"1","explanation":"1+2=3, 123=4"},{"input":"n=11","expectedOutput":"0","explanation":"1+1=2, 112int"},{"input":"n=21","expectedOutput":"1","explanation":"2+1=3, 213=7"}]},{"id":"fun70","title":"Check Automorphic","description":"Square ends with number.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isAutomorphic(int n) { return false; }\\nint main() { cout<<isAutomorphic(25); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isAutomorphic(int n) {\\n    int sq = n * n;\\n    int mult = 1, temp = n;\\n    while(temp > 0) { mult *= 10; temp /= 10; }\\n    return sq % mult == n;\\n}\\nint main() { cout<<isAutomorphic(25); return 0; }","explanation":{"approach":"Square of number ends with the number.","steps":["Calculate square","Check if ends with n"],"complexity":"Time: O(log n), Space: O(1)"},"testCases":[{"input":"n=25","expectedOutput":"1","explanation":"25=625 ends in 25"},{"input":"n=76","expectedOutput":"1","explanation":"76=5776 ends in 76"},{"input":"n=5","expectedOutput":"1","explanation":"5=25 ends in 5"},{"input":"n=7","expectedOutput":"0","explanation":"7=49 doesn't end in 7"}]},{"id":"fun71","title":"Nth Prime Number","description":"Find nth prime.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint nthPrime(int n) { return 0; }\\nint main() { cout<<nthPrime(5); return 0; }","expectedOutput":"11","solution":"#include <iostream>\\nusing namespace std;\\nbool isPrime(int x) {\\n    if(x<2) return false;\\n    for(int i=2;i*i<=x;i++) if(x%i==0) return false;\\n    return true;\\n}\\nint nthPrime(int n) {\\n    int count = 0, num = 1;\\n    while(count < n) { num++; if(isPrime(num)) count++; }\\n    return num;\\n}\\nint main() { cout<<nthPrime(5); return 0; }","explanation":{"approach":"Count primes until we reach nth.","steps":["Check each number for primality","Count until n primes found"],"complexity":"Time: O(np), Space: O(1)"},"testCases":[{"input":"n=5","expectedOutput":"11","explanation":"2,3,5,7,11"},{"input":"n=1","expectedOutput":"2","explanation":"First prime"},{"input":"n=10","expectedOutput":"29","explanation":"10th prime"},{"input":"n=3","expectedOutput":"5","explanation":"2,3,5"}]},{"id":"fun72","title":"Prime Factors","description":"Print prime factors.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid primeFactors(int n) {}\\nint main() { primeFactors(12); return 0; }","expectedOutput":"2 2 3","solution":"#include <iostream>\\nusing namespace std;\\nvoid primeFactors(int n) {\\n    for(int i = 2; i * i <= n; i++) {\\n        while(n % i == 0) { cout << i << \\" \\"; n /= i; }\\n    }\\n    if(n > 1) cout << n;\\n}\\nint main() { primeFactors(12); return 0; }","explanation":{"approach":"Divide by smallest factors repeatedly.","steps":["Try dividing by 2,3,5...","Print each factor"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"n=12","expectedOutput":"2 2 3","explanation":"12=223"},{"input":"n=15","expectedOutput":"3 5","explanation":"15=35"},{"input":"n=7","expectedOutput":"7","explanation":"Prime itself"},{"input":"n=100","expectedOutput":"2 2 5 5","explanation":"100=25"}]},{"id":"fun73","title":"Count Divisors","description":"Number of divisors.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint countDivisors(int n) { return 0; }\\nint main() { cout<<countDivisors(12); return 0; }","expectedOutput":"6","solution":"#include <iostream>\\nusing namespace std;\\nint countDivisors(int n) {\\n    int count = 0;\\n    for(int i = 1; i * i <= n; i++) {\\n        if(n % i == 0) {\\n            count++;\\n            if(i != n/i) count++;\\n        }\\n    }\\n    return count;\\n}\\nint main() { cout<<countDivisors(12); return 0; }","explanation":{"approach":"Count divisors up to n.","steps":["For each divisor i","Count i and n/i"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"n=12","expectedOutput":"6","explanation":"1,2,3,4,6,12"},{"input":"n=7","expectedOutput":"2","explanation":"Prime: 1,7"},{"input":"n=1","expectedOutput":"1","explanation":"Only 1"},{"input":"n=36","expectedOutput":"9","explanation":"1,2,3,4,6,9,12,18,36"}]},{"id":"fun74","title":"Sum of Divisors","description":"Sum all divisors.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint sumDivisors(int n) { return 0; }\\nint main() { cout<<sumDivisors(12); return 0; }","expectedOutput":"28","solution":"#include <iostream>\\nusing namespace std;\\nint sumDivisors(int n) {\\n    int sum = 0;\\n    for(int i = 1; i * i <= n; i++) {\\n        if(n % i == 0) {\\n            sum += i;\\n            if(i != n/i) sum += n/i;\\n        }\\n    }\\n    return sum;\\n}\\nint main() { cout<<sumDivisors(12); return 0; }","explanation":{"approach":"Sum divisors up to n.","steps":["For each divisor i","Add i and n/i"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"n=12","expectedOutput":"28","explanation":"1+2+3+4+6+12=28"},{"input":"n=7","expectedOutput":"8","explanation":"1+7=8"},{"input":"n=1","expectedOutput":"1","explanation":"Only 1"},{"input":"n=6","expectedOutput":"12","explanation":"1+2+3+6=12"}]},{"id":"fun75","title":"Product of Divisors","description":"Product of all divisors.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nint productDivisors(int n) { return 0; }\\nint main() { cout<<productDivisors(6); return 0; }","expectedOutput":"36","solution":"#include <iostream>\\nusing namespace std;\\nint productDivisors(int n) {\\n    int prod = 1;\\n    for(int i = 1; i * i <= n; i++) {\\n        if(n % i == 0) {\\n            prod *= i;\\n            if(i != n/i) prod *= n/i;\\n        }\\n    }\\n    return prod;\\n}\\nint main() { cout<<productDivisors(6); return 0; }","explanation":{"approach":"Multiply all divisors.","steps":["Find divisors","Multiply together"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"n=6","expectedOutput":"36","explanation":"1236=36"},{"input":"n=4","expectedOutput":"8","explanation":"124=8"},{"input":"n=1","expectedOutput":"1","explanation":"Only 1"},{"input":"n=12","expectedOutput":"1728","explanation":"Product of divisors"}]}]`),BM=JSON.parse(`[{"id":"fun76","title":"Deficient Number","description":"Sum of divisors < n.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isDeficient(int n) { return false; }\\nint main() { cout<<isDeficient(8); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isDeficient(int n) {\\n    int sum = 0;\\n    for(int i = 1; i < n; i++)\\n        if(n % i == 0) sum += i;\\n    return sum < n;\\n}\\nint main() { cout<<isDeficient(8); return 0; }","explanation":{"approach":"Sum proper divisors, check if < n.","steps":["Find all divisors","Sum them","Check if < n"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"n=8","expectedOutput":"1","explanation":"1+2+4=7<8"},{"input":"n=15","expectedOutput":"1","explanation":"1+3+5=9<15"},{"input":"n=12","expectedOutput":"0","explanation":"Abundant: 1+2+3+4+6=16>12"},{"input":"n=7","expectedOutput":"1","explanation":"Prime: 1<7"}]},{"id":"fun77","title":"Perfect Number","description":"Sum of divisors = n.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isPerfect(int n) { return false; }\\nint main() { cout<<isPerfect(28); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isPerfect(int n) {\\n    int sum = 0;\\n    for(int i = 1; i < n; i++)\\n        if(n % i == 0) sum += i;\\n    return sum == n;\\n}\\nint main() { cout<<isPerfect(28); return 0; }","explanation":{"approach":"Sum proper divisors, check if = n.","steps":["Find all divisors","Sum them"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"n=28","expectedOutput":"1","explanation":"1+2+4+7+14=28"},{"input":"n=6","expectedOutput":"1","explanation":"1+2+3=6"},{"input":"n=12","expectedOutput":"0","explanation":"Sum=1612"},{"input":"n=496","expectedOutput":"1","explanation":"Third perfect number"}]},{"id":"fun78","title":"Amicable Numbers","description":"Check amicable pair.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nbool areAmicable(int a, int b) { return false; }\\nint main() { cout<<areAmicable(220,284); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nint sumDiv(int n) { int s=0; for(int i=1;i<n;i++) if(n%i==0) s+=i; return s; }\\nbool areAmicable(int a, int b) { return sumDiv(a)==b && sumDiv(b)==a; }\\nint main() { cout<<areAmicable(220,284); return 0; }","explanation":{"approach":"Sum of a's divisors = b AND vice versa.","steps":["Calculate divisor sums"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"a=220, b=284","expectedOutput":"1","explanation":"Classic amicable pair"},{"input":"a=1184, b=1210","expectedOutput":"1","explanation":"Another amicable pair"},{"input":"a=10, b=20","expectedOutput":"0","explanation":"Not amicable"},{"input":"a=6, b=6","expectedOutput":"0","explanation":"Perfect but not amicable"}]},{"id":"fun79","title":"Twin Primes","description":"Check twin primes.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nbool areTwinPrimes(int a, int b) { return false; }\\nint main() { cout<<areTwinPrimes(11,13); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isPrime(int n) { if(n<2) return false; for(int i=2;i*i<=n;i++) if(n%i==0) return false; return true; }\\nbool areTwinPrimes(int a, int b) { return isPrime(a) && isPrime(b) && abs(b-a)==2; }\\nint main() { cout<<areTwinPrimes(11,13); return 0; }","explanation":{"approach":"Both prime and differ by 2.","steps":["Check if both prime","Differ by 2"],"complexity":"Time: O(sqrt n), Space: O(1)"},"testCases":[{"input":"a=11, b=13","expectedOutput":"1","explanation":"Both prime, differ by 2"},{"input":"a=3, b=5","expectedOutput":"1","explanation":"Twin primes"},{"input":"a=7, b=11","expectedOutput":"0","explanation":"Differ by 4, not 2"},{"input":"a=4, b=6","expectedOutput":"0","explanation":"Neither is prime"}]},{"id":"fun80","title":"Co-Prime Numbers","description":"GCD is 1.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nbool areCoPrime(int a, int b) { return false; }\\nint main() { cout<<areCoPrime(14,15); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nint gcd(int a, int b) { return b==0 ? a : gcd(b,a%b); }\\nbool areCoPrime(int a, int b) { return gcd(a,b)==1; }\\nint main() { cout<<areCoPrime(14,15); return 0; }","explanation":{"approach":"GCD = 1 means no common factors.","steps":["Calculate GCD"],"complexity":"Time: O(log n), Space: O(1)"},"testCases":[{"input":"a=14, b=15","expectedOutput":"1","explanation":"No common factor"},{"input":"a=8, b=9","expectedOutput":"1","explanation":"Consecutive, coprime"},{"input":"a=12, b=18","expectedOutput":"0","explanation":"GCD=61"},{"input":"a=1, b=100","expectedOutput":"1","explanation":"1 is coprime to all"}]},{"id":"fun81","title":"Kaprekar Number","description":"Parts of square sum to n.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isKaprekar(int n) { return false; }\\nint main() { cout<<isKaprekar(45); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isKaprekar(int n) {\\n    long sq = (long)n * n; int d = 0, t = n;\\n    while(t > 0) { d++; t /= 10; }\\n    int div = 1; for(int i=0;i<d;i++) div *= 10;\\n    return (sq%div + sq/div) == n && sq%div > 0;\\n}\\nint main() { cout<<isKaprekar(45); return 0; }","explanation":{"approach":"Split n^2, parts sum to n.","steps":["Square n","Split","Sum parts"],"complexity":"Time: O(log n), Space: O(1)"},"testCases":[{"input":"n=45","expectedOutput":"1","explanation":"45=2025, 20+25=45"},{"input":"n=9","expectedOutput":"1","explanation":"9=81, 8+1=9"},{"input":"n=297","expectedOutput":"1","explanation":"297=88209, 88+209=297"},{"input":"n=10","expectedOutput":"0","explanation":"100: 10+0=10 but right part is 0"}]},{"id":"fun82","title":"Tech Number","description":"Even digits, halves sum = n.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isTech(int n) { return false; }\\nint main() { cout<<isTech(2025); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isTech(int n) {\\n    int d = 0, t = n; while(t > 0) { d++; t /= 10; }\\n    if(d % 2 != 0) return false;\\n    int div = 1; for(int i=0;i<d/2;i++) div *= 10;\\n    int l = n/div, r = n%div;\\n    return (l+r)*(l+r) == n;\\n}\\nint main() { cout<<isTech(2025); return 0; }","explanation":{"approach":"(half1 + half2) = n.","steps":["Split in half","Sum and square"],"complexity":"Time: O(log n), Space: O(1)"},"testCases":[{"input":"n=2025","expectedOutput":"1","explanation":"(20+25)=45=2025"},{"input":"n=3025","expectedOutput":"1","explanation":"(30+25)=55=3025"},{"input":"n=1234","expectedOutput":"0","explanation":"(12+34)=46=21161234"},{"input":"n=9801","expectedOutput":"1","explanation":"(98+01)=99=9801"}]},{"id":"fun83","title":"Strontio Number","description":"n*4 has same middle digits.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isStrontio(int n) { return false; }\\nint main() { cout<<isStrontio(1111); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isStrontio(int n) {\\n    if(n < 1000 || n > 9999) return false;\\n    int r = n * 4;\\n    return (r/100%10) == (r/10%10);\\n}\\nint main() { cout<<isStrontio(1111); return 0; }","explanation":{"approach":"4-digit, n*4 has same middle digits.","steps":["Multiply by 4","Check middle"],"complexity":"Time: O(1), Space: O(1)"},"testCases":[{"input":"n=1111","expectedOutput":"1","explanation":"1111*4=4444, middle=44"},{"input":"n=2222","expectedOutput":"1","explanation":"2222*4=8888, middle=88"},{"input":"n=1234","expectedOutput":"0","explanation":"1234*4=4936, middle"},{"input":"n=100","expectedOutput":"0","explanation":"Not 4 digits"}]},{"id":"fun84","title":"Xylem Phloem","description":"Sum edge = sum middle.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isXylemPhloem(int n) { return false; }\\nint main() { cout<<isXylemPhloem(1234); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isXylemPhloem(int n) {\\n    int f = n; while(f >= 10) f /= 10;\\n    int l = n % 10, d2 = (n/100)%10, d3 = (n/10)%10;\\n    return f + l == d2 + d3;\\n}\\nint main() { cout<<isXylemPhloem(1234); return 0; }","explanation":{"approach":"Edge digits sum = middle digits sum.","steps":["Get edges","Get middle","Compare"],"complexity":"Time: O(log n), Space: O(1)"},"testCases":[{"input":"n=1234","expectedOutput":"1","explanation":"1+4=5, 2+3=5"},{"input":"n=2332","expectedOutput":"1","explanation":"2+2=4, 3+3=6? No, 2+2=4, 3+3=6"},{"input":"n=1111","expectedOutput":"1","explanation":"1+1=2, 1+1=2"},{"input":"n=1235","expectedOutput":"0","explanation":"1+5=6, 2+3=5"}]},{"id":"fun85","title":"Trimorphic Number","description":"Cube ends with n.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isTrimorphic(int n) { return false; }\\nint main() { cout<<isTrimorphic(4); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isTrimorphic(int n) {\\n    long cube = (long)n*n*n;\\n    int m = 1, t = n; while(t > 0) { m *= 10; t /= 10; }\\n    return cube % m == n;\\n}\\nint main() { cout<<isTrimorphic(4); return 0; }","explanation":{"approach":"n ends with n.","steps":["Cube n","Check ending"],"complexity":"Time: O(log n), Space: O(1)"},"testCases":[{"input":"n=4","expectedOutput":"1","explanation":"4=64 ends in 4"},{"input":"n=5","expectedOutput":"1","explanation":"5=125 ends in 5"},{"input":"n=24","expectedOutput":"1","explanation":"24=13824 ends in 24"},{"input":"n=3","expectedOutput":"0","explanation":"3=27 doesn't end in 3"}]},{"id":"fun86","title":"Peterson Number","description":"Sum of digit factorials = n.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isPeterson(int n) { return false; }\\nint main() { cout<<isPeterson(145); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nint fact(int x) { int f=1; for(int i=2;i<=x;i++) f*=i; return f; }\\nbool isPeterson(int n) { int s=0, t=n; while(t>0){s+=fact(t%10); t/=10;} return s==n; }\\nint main() { cout<<isPeterson(145); return 0; }","explanation":{"approach":"Sum of digit! = n.","steps":["Factorial each digit","Sum"],"complexity":"Time: O(log n), Space: O(1)"},"testCases":[{"input":"n=145","expectedOutput":"1","explanation":"1!+4!+5!=1+24+120=145"},{"input":"n=40585","expectedOutput":"1","explanation":"Only other Peterson number"},{"input":"n=123","expectedOutput":"0","explanation":"1!+2!+3!=9123"},{"input":"n=2","expectedOutput":"1","explanation":"2!=2"}]},{"id":"fun87","title":"Sunny Number","description":"n+1 is perfect square.","difficulty":"EASY","category":"Fundamentals","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isSunny(int n) { return false; }\\nint main() { cout<<isSunny(24); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isSunny(int n) { int r=1; while(r*r<n+1) r++; return r*r==n+1; }\\nint main() { cout<<isSunny(24); return 0; }","explanation":{"approach":"n+1 is perfect square.","steps":["Check if n+1 is square"],"complexity":"Time: O(sqrt n), Space: O(1)"},"testCases":[{"input":"n=24","expectedOutput":"1","explanation":"24+1=25=5"},{"input":"n=8","expectedOutput":"1","explanation":"8+1=9=3"},{"input":"n=10","expectedOutput":"0","explanation":"11 is not square"},{"input":"n=80","expectedOutput":"1","explanation":"80+1=81=9"}]}]`),UM=JSON.parse(`[{"id":"prac1","title":"Hello Name","description":"Print greeting with name.","difficulty":"EASY","category":"Practice","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid greet(char name[]) {}\\nint main() { greet(\\"Alice\\"); return 0; }","expectedOutput":"Hello Alice!","solution":"#include <iostream>\\nusing namespace std;\\nvoid greet(char name[]) { cout<<\\"Hello \\"<<name<<\\"!\\"; }\\nint main() { greet(\\"Alice\\"); return 0; }","explanation":{"approach":"Concatenate greeting with name.","analogy":"Simple string output.","steps":["Print Hello, name, then !"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"\\"Alice\\"","expectedOutput":"Hello Alice!","explanation":"Standard greeting"},{"input":"\\"Bob\\"","expectedOutput":"Hello Bob!","explanation":"Different name"},{"input":"\\"World\\"","expectedOutput":"Hello World!","explanation":"Classic greeting"},{"input":"\\"X\\"","expectedOutput":"Hello X!","explanation":"Single character name"}]},{"id":"prac2","title":"Rectangle Area","description":"Calculate rectangle area.","difficulty":"EASY","category":"Practice","starterCode":"#include <iostream>\\nusing namespace std;\\nint area(int l, int w) { return 0; }\\nint main() { cout<<area(5,3); return 0; }","expectedOutput":"15","solution":"#include <iostream>\\nusing namespace std;\\nint area(int l, int w) { return l*w; }\\nint main() { cout<<area(5,3); return 0; }","explanation":{"approach":"Area = length  width.","analogy":"Count tiles in grid.","steps":["Multiply length by width"],"complexity":"Time: O(1), Space: O(1)"},"testCases":[{"input":"l=5, w=3","expectedOutput":"15","explanation":"5  3 = 15"},{"input":"l=10, w=10","expectedOutput":"100","explanation":"Square 1010"},{"input":"l=1, w=1","expectedOutput":"1","explanation":"Unit square"},{"input":"l=7, w=4","expectedOutput":"28","explanation":"7  4 = 28"}]},{"id":"prac3","title":"Circle Circumference","description":"Calculate circumference.","difficulty":"EASY","category":"Practice","starterCode":"#include <iostream>\\n#include <iomanip>\\nusing namespace std;\\ndouble circumference(double r) { return 0; }\\nint main() { cout<<fixed<<setprecision(2)<<circumference(5); return 0; }","expectedOutput":"31.42","solution":"#include <iostream>\\n#include <iomanip>\\nusing namespace std;\\ndouble circumference(double r) { return 2*3.14159*r; }\\nint main() { cout<<fixed<<setprecision(2)<<circumference(5); return 0; }","explanation":{"approach":"C = 2r.","analogy":"Distance around the circle.","steps":["Multiply 2    radius"],"complexity":"Time: O(1), Space: O(1)"},"testCases":[{"input":"r=5","expectedOutput":"31.42","explanation":"2    5"},{"input":"r=1","expectedOutput":"6.28","explanation":"2    1"},{"input":"r=10","expectedOutput":"62.83","explanation":"2    10"},{"input":"r=0","expectedOutput":"0.00","explanation":"Zero radius"}]},{"id":"prac4","title":"Grade Calculator","description":"Assign letter grade.","difficulty":"EASY","category":"Practice","starterCode":"#include <iostream>\\nusing namespace std;\\nchar grade(int score) { return 'F'; }\\nint main() { cout<<grade(85); return 0; }","expectedOutput":"B","solution":"#include <iostream>\\nusing namespace std;\\nchar grade(int score) { if(score>=90) return 'A'; if(score>=80) return 'B'; if(score>=70) return 'C'; if(score>=60) return 'D'; return 'F'; }\\nint main() { cout<<grade(85); return 0; }","explanation":{"approach":"Check score ranges.","analogy":"Grading scale conversion.","steps":["Check each threshold","Return corresponding grade"],"complexity":"Time: O(1), Space: O(1)"},"testCases":[{"input":"score=85","expectedOutput":"B","explanation":"80-89 is B"},{"input":"score=95","expectedOutput":"A","explanation":"90+ is A"},{"input":"score=55","expectedOutput":"F","explanation":"Below 60 is F"},{"input":"score=70","expectedOutput":"C","explanation":"70-79 is C"}]},{"id":"prac5","title":"Age in Days","description":"Convert years to days.","difficulty":"EASY","category":"Practice","starterCode":"#include <iostream>\\nusing namespace std;\\nint ageDays(int years) { return 0; }\\nint main() { cout<<ageDays(10); return 0; }","expectedOutput":"3650","solution":"#include <iostream>\\nusing namespace std;\\nint ageDays(int years) { return years*365; }\\nint main() { cout<<ageDays(10); return 0; }","explanation":{"approach":"Days = years  365.","analogy":"Convert units.","steps":["Multiply by 365"],"complexity":"Time: O(1), Space: O(1)"},"testCases":[{"input":"years=10","expectedOutput":"3650","explanation":"10  365"},{"input":"years=1","expectedOutput":"365","explanation":"1 year"},{"input":"years=0","expectedOutput":"0","explanation":"Zero years"},{"input":"years=25","expectedOutput":"9125","explanation":"25  365"}]},{"id":"prac6","title":"Tip Calculator","description":"Calculate tip amount.","difficulty":"EASY","category":"Practice","starterCode":"#include <iostream>\\nusing namespace std;\\ndouble tip(double bill, int percent) { return 0; }\\nint main() { cout<<tip(50,20); return 0; }","expectedOutput":"10","solution":"#include <iostream>\\nusing namespace std;\\ndouble tip(double bill, int percent) { return bill*percent/100; }\\nint main() { cout<<tip(50,20); return 0; }","explanation":{"approach":"Tip = bill  percent / 100.","analogy":"Percentage of bill.","steps":["Multiply bill by percentage","Divide by 100"],"complexity":"Time: O(1), Space: O(1)"},"testCases":[{"input":"bill=50, percent=20","expectedOutput":"10","explanation":"50  20% = 10"},{"input":"bill=100, percent=15","expectedOutput":"15","explanation":"100  15% = 15"},{"input":"bill=0, percent=20","expectedOutput":"0","explanation":"No bill, no tip"},{"input":"bill=80, percent=10","expectedOutput":"8","explanation":"80  10% = 8"}]},{"id":"prac7","title":"BMI Calculator","description":"Calculate BMI.","difficulty":"EASY","category":"Practice","starterCode":"#include <iostream>\\n#include <iomanip>\\nusing namespace std;\\ndouble bmi(double w, double h) { return 0; }\\nint main() { cout<<fixed<<setprecision(1)<<bmi(70,1.75); return 0; }","expectedOutput":"22.9","solution":"#include <iostream>\\n#include <iomanip>\\nusing namespace std;\\ndouble bmi(double w, double h) { return w/(h*h); }\\nint main() { cout<<fixed<<setprecision(1)<<bmi(70,1.75); return 0; }","explanation":{"approach":"BMI = weight / height.","analogy":"Body mass index formula.","steps":["Divide weight by height squared"],"complexity":"Time: O(1), Space: O(1)"},"testCases":[{"input":"w=70, h=1.75","expectedOutput":"22.9","explanation":"70 / 1.75  22.9"},{"input":"w=80, h=1.80","expectedOutput":"24.7","explanation":"80 / 1.80  24.7"},{"input":"w=50, h=1.60","expectedOutput":"19.5","explanation":"50 / 1.60  19.5"},{"input":"w=100, h=2.00","expectedOutput":"25.0","explanation":"100 / 2.00 = 25.0"}]},{"id":"prac8","title":"Distance Formula","description":"Distance between two points.","difficulty":"EASY","category":"Practice","starterCode":"#include <iostream>\\n#include <cmath>\\nusing namespace std;\\ndouble distance(int x1, int y1, int x2, int y2) { return 0; }\\nint main() { cout<<distance(0,0,3,4); return 0; }","expectedOutput":"5","solution":"#include <iostream>\\n#include <cmath>\\nusing namespace std;\\ndouble distance(int x1, int y1, int x2, int y2) { return sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1)); }\\nint main() { cout<<distance(0,0,3,4); return 0; }","explanation":{"approach":"d = ((x2-x1) + (y2-y1)).","analogy":"Pythagorean theorem.","steps":["Calculate differences","Square and sum","Take square root"],"complexity":"Time: O(1), Space: O(1)"},"testCases":[{"input":"(0,0) to (3,4)","expectedOutput":"5","explanation":"3-4-5 right triangle"},{"input":"(0,0) to (0,0)","expectedOutput":"0","explanation":"Same point"},{"input":"(1,1) to (4,5)","expectedOutput":"5","explanation":"(9+16) = 5"},{"input":"(0,0) to (5,12)","expectedOutput":"13","explanation":"5-12-13 right triangle"}]},{"id":"prac9","title":"Quadratic Roots","description":"Find roots of ax+bx+c=0.","difficulty":"EASY","category":"Practice","starterCode":"#include <iostream>\\n#include <cmath>\\nusing namespace std;\\nvoid roots(int a, int b, int c) {}\\nint main() { roots(1,-5,6); return 0; }","expectedOutput":"3 2","solution":"#include <iostream>\\n#include <cmath>\\nusing namespace std;\\nvoid roots(int a, int b, int c) { double d=b*b-4*a*c; double r1=(-b+sqrt(d))/(2*a), r2=(-b-sqrt(d))/(2*a); cout<<(int)r1<<\\" \\"<<(int)r2; }\\nint main() { roots(1,-5,6); return 0; }","explanation":{"approach":"Quadratic formula: (-b  (b-4ac)) / 2a.","analogy":"Standard formula from algebra.","steps":["Calculate discriminant","Apply quadratic formula"],"complexity":"Time: O(1), Space: O(1)"},"testCases":[{"input":"a=1, b=-5, c=6","expectedOutput":"3 2","explanation":"x-5x+6 = (x-3)(x-2)"},{"input":"a=1, b=-2, c=1","expectedOutput":"1 1","explanation":"Repeated root"},{"input":"a=1, b=0, c=-4","expectedOutput":"2 -2","explanation":"x = 4"},{"input":"a=1, b=-7, c=12","expectedOutput":"4 3","explanation":"x-7x+12 = (x-4)(x-3)"}]},{"id":"prac10","title":"Check Triangle","description":"Can sides form triangle.","difficulty":"EASY","category":"Practice","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isTriangle(int a, int b, int c) { return false; }\\nint main() { cout<<isTriangle(3,4,5); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isTriangle(int a, int b, int c) { return a+b>c && b+c>a && a+c>b; }\\nint main() { cout<<isTriangle(3,4,5); return 0; }","explanation":{"approach":"Sum of any two sides must exceed third.","analogy":"Triangle inequality theorem.","steps":["Check all three combinations"],"complexity":"Time: O(1), Space: O(1)"},"testCases":[{"input":"a=3, b=4, c=5","expectedOutput":"1","explanation":"Valid triangle"},{"input":"a=1, b=1, c=10","expectedOutput":"0","explanation":"1+1 < 10, invalid"},{"input":"a=5, b=5, c=5","expectedOutput":"1","explanation":"Equilateral triangle"},{"input":"a=1, b=2, c=3","expectedOutput":"0","explanation":"1+2 = 3, degenerate"}]}]`),zM=JSON.parse('[{"id":"prac11","title":"Fahrenheit to Celsius","description":"Convert temperature.","difficulty":"EASY","category":"Practice","starterCode":"#include <iostream>\\nusing namespace std;\\ndouble fToC(double f) { return 0; }\\nint main() { cout<<fToC(98.6); return 0; }","expectedOutput":"37","solution":"#include <iostream>\\nusing namespace std;\\ndouble fToC(double f) { return (f-32)*5/9; }\\nint main() { cout<<(int)fToC(98.6); return 0; }","explanation":{"approach":"C = (F-32)  5/9.","analogy":"Temperature conversion formula.","steps":["Subtract 32","Multiply by 5/9"],"complexity":"Time: O(1), Space: O(1)"},"testCases":[{"input":"f=98.6","expectedOutput":"37","explanation":"Body temperature"},{"input":"f=32","expectedOutput":"0","explanation":"Freezing point"},{"input":"f=212","expectedOutput":"100","explanation":"Boiling point"},{"input":"f=68","expectedOutput":"20","explanation":"Room temperature"}]},{"id":"prac12","title":"Celsius to Fahrenheit","description":"Convert temperature.","difficulty":"EASY","category":"Practice","starterCode":"#include <iostream>\\nusing namespace std;\\ndouble cToF(double c) { return 0; }\\nint main() { cout<<cToF(37); return 0; }","expectedOutput":"98.6","solution":"#include <iostream>\\nusing namespace std;\\ndouble cToF(double c) { return c*9/5+32; }\\nint main() { cout<<cToF(37); return 0; }","explanation":{"approach":"F = C  9/5 + 32.","analogy":"Temperature conversion formula.","steps":["Multiply by 9/5","Add 32"],"complexity":"Time: O(1), Space: O(1)"},"testCases":[{"input":"c=37","expectedOutput":"98.6","explanation":"Body temperature"},{"input":"c=0","expectedOutput":"32","explanation":"Freezing point"},{"input":"c=100","expectedOutput":"212","explanation":"Boiling point"},{"input":"c=-40","expectedOutput":"-40","explanation":"Same in both scales"}]},{"id":"prac13","title":"Simple Interest","description":"Calculate simple interest.","difficulty":"EASY","category":"Practice","starterCode":"#include <iostream>\\nusing namespace std;\\ndouble simpleInterest(double p, double r, double t) { return 0; }\\nint main() { cout<<simpleInterest(1000,5,2); return 0; }","expectedOutput":"100","solution":"#include <iostream>\\nusing namespace std;\\ndouble simpleInterest(double p, double r, double t) { return p*r*t/100; }\\nint main() { cout<<simpleInterest(1000,5,2); return 0; }","explanation":{"approach":"SI = P  R  T / 100.","analogy":"Interest on principal.","steps":["Multiply principal, rate, time","Divide by 100"],"complexity":"Time: O(1), Space: O(1)"},"testCases":[{"input":"P=1000, R=5, T=2","expectedOutput":"100","explanation":"100052/100 = 100"},{"input":"P=5000, R=10, T=1","expectedOutput":"500","explanation":"5000101/100 = 500"},{"input":"P=0, R=5, T=2","expectedOutput":"0","explanation":"No principal, no interest"},{"input":"P=2000, R=7, T=3","expectedOutput":"420","explanation":"200073/100 = 420"}]},{"id":"prac14","title":"Compound Interest","description":"Calculate compound interest.","difficulty":"EASY","category":"Practice","starterCode":"#include <iostream>\\n#include <cmath>\\nusing namespace std;\\ndouble compoundInterest(double p, double r, int t) { return 0; }\\nint main() { cout<<(int)compoundInterest(1000,10,2); return 0; }","expectedOutput":"210","solution":"#include <iostream>\\n#include <cmath>\\nusing namespace std;\\ndouble compoundInterest(double p, double r, int t) { return p*pow(1+r/100,t)-p; }\\nint main() { cout<<(int)compoundInterest(1000,10,2); return 0; }","explanation":{"approach":"CI = P  (1+r/100)^t - P.","analogy":"Interest on interest.","steps":["Calculate amount with compound","Subtract principal"],"complexity":"Time: O(1), Space: O(1)"},"testCases":[{"input":"P=1000, R=10, T=2","expectedOutput":"210","explanation":"10001.21 - 1000 = 210"},{"input":"P=1000, R=10, T=1","expectedOutput":"100","explanation":"Same as simple for T=1"},{"input":"P=0, R=10, T=5","expectedOutput":"0","explanation":"No principal"},{"input":"P=1000, R=5, T=3","expectedOutput":"157","explanation":"Approx 157.625"}]},{"id":"prac15","title":"Area of Triangle","description":"Calculate triangle area.","difficulty":"EASY","category":"Practice","starterCode":"#include <iostream>\\nusing namespace std;\\ndouble triangleArea(double b, double h) { return 0; }\\nint main() { cout<<triangleArea(10,5); return 0; }","expectedOutput":"25","solution":"#include <iostream>\\nusing namespace std;\\ndouble triangleArea(double b, double h) { return 0.5*b*h; }\\nint main() { cout<<triangleArea(10,5); return 0; }","explanation":{"approach":"A = 0.5  base  height.","analogy":"Half of rectangle.","steps":["Multiply base and height","Divide by 2"],"complexity":"Time: O(1), Space: O(1)"},"testCases":[{"input":"b=10, h=5","expectedOutput":"25","explanation":"0.5  10  5 = 25"},{"input":"b=6, h=4","expectedOutput":"12","explanation":"0.5  6  4 = 12"},{"input":"b=0, h=5","expectedOutput":"0","explanation":"Zero base"},{"input":"b=3, h=4","expectedOutput":"6","explanation":"0.5  3  4 = 6"}]},{"id":"prac16","title":"Volume of Cube","description":"Calculate cube volume.","difficulty":"EASY","category":"Practice","starterCode":"#include <iostream>\\nusing namespace std;\\nint cubeVolume(int a) { return 0; }\\nint main() { cout<<cubeVolume(3); return 0; }","expectedOutput":"27","solution":"#include <iostream>\\nusing namespace std;\\nint cubeVolume(int a) { return a*a*a; }\\nint main() { cout<<cubeVolume(3); return 0; }","explanation":{"approach":"V = a.","analogy":"Side cubed.","steps":["Multiply side by itself 3 times"],"complexity":"Time: O(1), Space: O(1)"},"testCases":[{"input":"a=3","expectedOutput":"27","explanation":"3 = 27"},{"input":"a=1","expectedOutput":"1","explanation":"1 = 1"},{"input":"a=10","expectedOutput":"1000","explanation":"10 = 1000"},{"input":"a=5","expectedOutput":"125","explanation":"5 = 125"}]},{"id":"prac17","title":"Volume of Sphere","description":"Calculate sphere volume.","difficulty":"EASY","category":"Practice","starterCode":"#include <iostream>\\n#include <iomanip>\\nusing namespace std;\\ndouble sphereVolume(double r) { return 0; }\\nint main() { cout<<fixed<<setprecision(2)<<sphereVolume(3); return 0; }","expectedOutput":"113.10","solution":"#include <iostream>\\n#include <iomanip>\\nusing namespace std;\\ndouble sphereVolume(double r) { return 4.0/3.0*3.14159*r*r*r; }\\nint main() { cout<<fixed<<setprecision(2)<<sphereVolume(3); return 0; }","explanation":{"approach":"V = 4/3    r.","analogy":"Sphere volume formula.","steps":["Multiply 4/3, , and r"],"complexity":"Time: O(1), Space: O(1)"},"testCases":[{"input":"r=3","expectedOutput":"113.10","explanation":"4/3    27"},{"input":"r=1","expectedOutput":"4.19","explanation":"4/3    1"},{"input":"r=0","expectedOutput":"0.00","explanation":"Zero radius"},{"input":"r=2","expectedOutput":"33.51","explanation":"4/3    8"}]},{"id":"prac18","title":"Perimeter of Rectangle","description":"Calculate rectangle perimeter.","difficulty":"EASY","category":"Practice","starterCode":"#include <iostream>\\nusing namespace std;\\nint rectPerimeter(int l, int w) { return 0; }\\nint main() { cout<<rectPerimeter(5,3); return 0; }","expectedOutput":"16","solution":"#include <iostream>\\nusing namespace std;\\nint rectPerimeter(int l, int w) { return 2*(l+w); }\\nint main() { cout<<rectPerimeter(5,3); return 0; }","explanation":{"approach":"P = 2  (length + width).","analogy":"Sum of all sides.","steps":["Add length and width","Multiply by 2"],"complexity":"Time: O(1), Space: O(1)"},"testCases":[{"input":"l=5, w=3","expectedOutput":"16","explanation":"2  (5+3) = 16"},{"input":"l=10, w=10","expectedOutput":"40","explanation":"Square perimeter"},{"input":"l=0, w=5","expectedOutput":"10","explanation":"Degenerate rectangle"},{"input":"l=7, w=2","expectedOutput":"18","explanation":"2  (7+2) = 18"}]},{"id":"prac19","title":"Hypotenuse","description":"Calculate hypotenuse.","difficulty":"EASY","category":"Practice","starterCode":"#include <iostream>\\n#include <cmath>\\nusing namespace std;\\ndouble hypotenuse(double a, double b) { return 0; }\\nint main() { cout<<hypotenuse(3,4); return 0; }","expectedOutput":"5","solution":"#include <iostream>\\n#include <cmath>\\nusing namespace std;\\ndouble hypotenuse(double a, double b) { return sqrt(a*a+b*b); }\\nint main() { cout<<hypotenuse(3,4); return 0; }","explanation":{"approach":"c = (a + b).","analogy":"Pythagorean theorem.","steps":["Square both sides","Sum and sqrt"],"complexity":"Time: O(1), Space: O(1)"},"testCases":[{"input":"a=3, b=4","expectedOutput":"5","explanation":"3-4-5 triangle"},{"input":"a=5, b=12","expectedOutput":"13","explanation":"5-12-13 triangle"},{"input":"a=0, b=5","expectedOutput":"5","explanation":"One leg is zero"},{"input":"a=8, b=15","expectedOutput":"17","explanation":"8-15-17 triangle"}]},{"id":"prac20","title":"Print Multiplication Table","description":"Print table of n.","difficulty":"EASY","category":"Practice","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid multiTable(int n) {}\\nint main() { multiTable(5); return 0; }","expectedOutput":"5 10 15 20 25 30 35 40 45 50","solution":"#include <iostream>\\nusing namespace std;\\nvoid multiTable(int n) { for(int i=1;i<=10;i++) cout<<n*i<<\\" \\"; }\\nint main() { multiTable(5); return 0; }","explanation":{"approach":"Print ni for i=1 to 10.","analogy":"Multiplication table.","steps":["Loop 1 to 10","Print n  i"],"complexity":"Time: O(1), Space: O(1)"},"testCases":[{"input":"n=5","expectedOutput":"5 10 15 20 25 30 35 40 45 50","explanation":"Table of 5"},{"input":"n=7","expectedOutput":"7 14 21 28 35 42 49 56 63 70","explanation":"Table of 7"},{"input":"n=1","expectedOutput":"1 2 3 4 5 6 7 8 9 10","explanation":"Table of 1"},{"input":"n=12","expectedOutput":"12 24 36 48 60 72 84 96 108 120","explanation":"Table of 12"}]}]'),FM=JSON.parse('[{"id":"prac21","title":"Pointers Swap","description":"Swap using pointers.","difficulty":"EASY","category":"Pointers","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid swapPtr(int *a, int *b) {}\\nint main() { int x=5,y=10; swapPtr(&x,&y); cout<<x<<\\" \\"<<y; return 0; }","expectedOutput":"10 5","solution":"#include <iostream>\\nusing namespace std;\\nvoid swapPtr(int *a, int *b) { int t=*a; *a=*b; *b=t; }\\nint main() { int x=5,y=10; swapPtr(&x,&y); cout<<x<<\\" \\"<<y; return 0; }","explanation":{"approach":"Use pointers to swap values.","analogy":"Dereference to access values.","steps":["Save *a","Assign *b to *a","Assign saved to *b"],"complexity":"Time: O(1), Space: O(1)"},"testCases":[{"input":"x=5, y=10","expectedOutput":"10 5","explanation":"Swapped successfully"},{"input":"x=0, y=0","expectedOutput":"0 0","explanation":"Same values unchanged"},{"input":"x=-1, y=1","expectedOutput":"1 -1","explanation":"Negative and positive swapped"},{"input":"x=100, y=200","expectedOutput":"200 100","explanation":"Larger values swapped"}]},{"id":"prac22","title":"Pointer Arithmetic","description":"Traverse array with pointer.","difficulty":"EASY","category":"Pointers","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid printArr(int *a, int n) {}\\nint main() { int a[]={1,2,3,4,5}; printArr(a,5); return 0; }","expectedOutput":"1 2 3 4 5","solution":"#include <iostream>\\nusing namespace std;\\nvoid printArr(int *a, int n) { for(int i=0;i<n;i++) cout<<*(a+i)<<\\" \\"; }\\nint main() { int a[]={1,2,3,4,5}; printArr(a,5); return 0; }","explanation":{"approach":"Use pointer arithmetic to traverse.","analogy":"a+i points to ith element.","steps":["*(a+i) gives value at index i"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"{1,2,3,4,5}","expectedOutput":"1 2 3 4 5","explanation":"All elements printed"},{"input":"{42}","expectedOutput":"42","explanation":"Single element"},{"input":"{-1,0,1}","expectedOutput":"-1 0 1","explanation":"Mixed values"},{"input":"{10,20,30,40}","expectedOutput":"10 20 30 40","explanation":"Multiple elements"}]},{"id":"prac23","title":"Function Overloading","description":"Overload add function.","difficulty":"EASY","category":"OOP","starterCode":"#include <iostream>\\nusing namespace std;\\nint add2(int a, int b) { return 0; }\\nint add3(int a, int b, int c) { return 0; }\\nint main() { cout<<add2(1,2)<<\\" \\"<<add3(1,2,3); return 0; }","expectedOutput":"3 6","solution":"#include <iostream>\\nusing namespace std;\\nint add2(int a, int b) { return a+b; }\\nint add3(int a, int b, int c) { return a+b+c; }\\nint main() { cout<<add2(1,2)<<\\" \\"<<add3(1,2,3); return 0; }","explanation":{"approach":"Same function name, different parameters.","analogy":"Choose version based on arguments.","steps":["2-param version adds 2","3-param adds 3"],"complexity":"Time: O(1), Space: O(1)"},"testCases":[{"input":"add2(1,2), add3(1,2,3)","expectedOutput":"3 6","explanation":"Both overloads work"},{"input":"add2(0,0)","expectedOutput":"0","explanation":"Zero sum"},{"input":"add3(10,20,30)","expectedOutput":"60","explanation":"Larger values"},{"input":"add2(-5,5)","expectedOutput":"0","explanation":"Opposite numbers"}]},{"id":"prac24","title":"Constructor Example","description":"Class with constructor.","difficulty":"EASY","category":"OOP","starterCode":"#include <iostream>\\nusing namespace std;\\nclass Box { int w,h; public: Box(int w, int h) : w(0), h(0) {} int area() { return 0; } };\\nint main() { Box b(5,3); cout<<b.area(); return 0; }","expectedOutput":"15","solution":"#include <iostream>\\nusing namespace std;\\nclass Box { int w,h; public: Box(int w, int h) : w(w), h(h) {} int area() { return w*h; } };\\nint main() { Box b(5,3); cout<<b.area(); return 0; }","explanation":{"approach":"Initialize members in constructor.","analogy":"Constructor sets up object.","steps":["Constructor initializes w and h","area() returns wh"],"complexity":"Time: O(1), Space: O(1)"},"testCases":[{"input":"Box(5,3)","expectedOutput":"15","explanation":"5  3 = 15"},{"input":"Box(10,10)","expectedOutput":"100","explanation":"Square box"},{"input":"Box(1,1)","expectedOutput":"1","explanation":"Minimum size"},{"input":"Box(7,4)","expectedOutput":"28","explanation":"7  4 = 28"}]},{"id":"prac25","title":"Inheritance Example","description":"Basic inheritance.","difficulty":"EASY","category":"OOP","starterCode":"#include <iostream>\\nusing namespace std;\\nclass Animal { public: void speak() {} };\\nclass Dog : public Animal { public: void speak() {} };\\nint main() { Dog d; d.speak(); return 0; }","expectedOutput":"Woof","solution":"#include <iostream>\\nusing namespace std;\\nclass Animal { public: virtual void speak() { cout<<\\"Sound\\"; } };\\nclass Dog : public Animal { public: void speak() override { cout<<\\"Woof\\"; } };\\nint main() { Dog d; d.speak(); return 0; }","explanation":{"approach":"Child overrides parent method.","analogy":"Dog is-a Animal.","steps":["Dog inherits from Animal","Dog overrides speak()"],"complexity":"Time: O(1), Space: O(1)"},"testCases":[{"input":"Dog d; d.speak()","expectedOutput":"Woof","explanation":"Dog speaks Woof"},{"input":"Animal a; a.speak()","expectedOutput":"Sound","explanation":"Base class sound"},{"input":"polymorphism test","expectedOutput":"Woof","explanation":"Virtual dispatch works"},{"input":"Dog* dp; dp->speak()","expectedOutput":"Woof","explanation":"Pointer to Dog"}]},{"id":"extra11","title":"Minimum Difference BST","description":"Min difference between nodes.","difficulty":"MEDIUM","category":"Trees","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nint minDiff(Node* r) { return 0; }\\nint main() { Node* r=new Node(4); r->l=new Node(2); r->r=new Node(6); r->l->l=new Node(1); r->l->r=new Node(3); cout<<minDiff(r); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nint prev_val=-1,minD=1e9;\\nvoid inorder(Node* r) { if(!r) return; inorder(r->l); if(prev_val>=0) minD=min(minD,r->v-prev_val); prev_val=r->v; inorder(r->r); }\\nint minDiff(Node* r) { prev_val=-1; minD=1e9; inorder(r); return minD; }\\nint main() { Node* r=new Node(4); r->l=new Node(2); r->r=new Node(6); r->l->l=new Node(1); r->l->r=new Node(3); cout<<minDiff(r); return 0; }","explanation":{"approach":"Inorder gives sorted, check consecutive.","analogy":"Adjacent in sorted order.","steps":["Inorder traversal","Track previous and diff"],"complexity":"Time: O(n), Space: O(h)"},"testCases":[{"input":"[4,2,6,1,3]","expectedOutput":"1","explanation":"Min diff between consecutive nodes"},{"input":"[1,null,3,2]","expectedOutput":"1","explanation":"Diff between 1-2 or 2-3"},{"input":"[1,null,5]","expectedOutput":"4","explanation":"Only two nodes"},{"input":"[10,5,15]","expectedOutput":"5","explanation":"Consecutive diffs of 5"}]},{"id":"extra12","title":"Serialize Binary Tree","description":"Encode tree to string.","difficulty":"HARD","category":"Trees","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nvoid serialize(Node* r) {}\\nint main() { Node* r=new Node(1); r->l=new Node(2); r->r=new Node(3); r->r->l=new Node(4); r->r->r=new Node(5); serialize(r); return 0; }","expectedOutput":"1 2 # # 3 4 # # 5 # #","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node *l,*r; Node(int x):v(x),l(0),r(0){} };\\nvoid serialize(Node* r) { if(!r) { cout<<\\"# \\"; return; } cout<<r->v<<\\" \\"; serialize(r->l); serialize(r->r); }\\nint main() { Node* r=new Node(1); r->l=new Node(2); r->r=new Node(3); r->r->l=new Node(4); r->r->r=new Node(5); serialize(r); return 0; }","explanation":{"approach":"Preorder with null markers.","analogy":"Encode structure with placeholders.","steps":["Print value or # for null","Recurse left then right"],"complexity":"Time: O(n), Space: O(n)"},"testCases":[{"input":"[1,2,3,null,null,4,5]","expectedOutput":"1 2 # # 3 4 # # 5 # #","explanation":"Preorder with null markers"},{"input":"[1]","expectedOutput":"1 # #","explanation":"Single node"},{"input":"[]","expectedOutput":"#","explanation":"Empty tree"},{"input":"[1,2,3]","expectedOutput":"1 2 # # 3 # #","explanation":"Complete binary tree"}]},{"id":"extra13","title":"Sliding Window Max","description":"Maximum in each window.","difficulty":"HARD","category":"Sliding Window","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid maxSliding(int a[], int n, int k) {}\\nint main() { int a[]={1,3,-1,-3,5,3,6,7}; maxSliding(a,8,3); return 0; }","expectedOutput":"3 3 5 5 6 7","solution":"#include <iostream>\\nusing namespace std;\\nvoid maxSliding(int a[], int n, int k) { int dq[n],f=0,r=0; for(int i=0;i<n;i++) { while(f<r && dq[f]<=i-k) f++; while(f<r && a[dq[r-1]]<=a[i]) r--; dq[r++]=i; if(i>=k-1) cout<<a[dq[f]]<<\\" \\"; } }\\nint main() { int a[]={1,3,-1,-3,5,3,6,7}; maxSliding(a,8,3); return 0; }","explanation":{"approach":"Monotonic deque.","analogy":"Keep only useful candidates.","steps":["Remove out of window","Remove smaller from back","Front is max"],"complexity":"Time: O(n), Space: O(k)"},"testCases":[{"input":"{1,3,-1,-3,5,3,6,7}, k=3","expectedOutput":"3 3 5 5 6 7","explanation":"Max in each window of 3"},{"input":"{1,2,3,4,5}, k=2","expectedOutput":"2 3 4 5","explanation":"Increasing array"},{"input":"{9,8,7,6}, k=2","expectedOutput":"9 8 7","explanation":"Decreasing array"},{"input":"{1}, k=1","expectedOutput":"1","explanation":"Single element"}]},{"id":"extra14","title":"Subarray Sum K","description":"Count subarrays with sum k.","difficulty":"MEDIUM","category":"Hashing","starterCode":"#include <iostream>\\nusing namespace std;\\nint subarraySum(int a[], int n, int k) { return 0; }\\nint main() { int a[]={1,1,1}; cout<<subarraySum(a,3,2); return 0; }","expectedOutput":"2","solution":"#include <iostream>\\nusing namespace std;\\nint subarraySum(int a[], int n, int k) { int c=0; for(int i=0;i<n;i++) { int s=0; for(int j=i;j<n;j++) { s+=a[j]; if(s==k) c++; } } return c; }\\nint main() { int a[]={1,1,1}; cout<<subarraySum(a,3,2); return 0; }","explanation":{"approach":"Check all subarrays.","analogy":"Count matching sums.","steps":["For each start, sum to each end"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"{1,1,1}, k=2","expectedOutput":"2","explanation":"[0:1] and [1:2] sum to 2"},{"input":"{1,2,3}, k=3","expectedOutput":"2","explanation":"[0:1] and [2] sum to 3"},{"input":"{1}, k=0","expectedOutput":"0","explanation":"No subarray sums to 0"},{"input":"{3,-3,3}, k=3","expectedOutput":"2","explanation":"[0] and [0:2] and [2]"}]},{"id":"extra15","title":"Longest Substring No Repeat","description":"Longest unique char substring.","difficulty":"MEDIUM","category":"Sliding Window","starterCode":"#include <iostream>\\nusing namespace std;\\nint lengthOfLongest(char s[]) { return 0; }\\nint main() { cout<<lengthOfLongest(\\"abcabcbb\\"); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nint lengthOfLongest(char s[]) { int seen[256]={}; int mx=0,l=0; for(int r=0;s[r];r++) { while(seen[(int)s[r]]) { seen[(int)s[l]]=0; l++; } seen[(int)s[r]]=1; mx=max(mx,r-l+1); } return mx; }\\nint main() { cout<<lengthOfLongest(\\"abcabcbb\\"); return 0; }","explanation":{"approach":"Sliding window with set.","analogy":"Shrink when duplicate found.","steps":["Expand right","Shrink left until unique"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"\\"abcabcbb\\"","expectedOutput":"3","explanation":"abc is longest unique"},{"input":"\\"bbbbb\\"","expectedOutput":"1","explanation":"All same chars"},{"input":"\\"pwwkew\\"","expectedOutput":"3","explanation":"wke is longest"},{"input":"\\"\\"","expectedOutput":"0","explanation":"Empty string"}]}]'),qM=JSON.parse('[{"id":"extra1","title":"Binary Search Left Bound","description":"Find first occurrence of target in sorted array.","difficulty":"MEDIUM","category":"Binary Search","starterCode":"#include <iostream>\\nusing namespace std;\\nint leftBound(int a[], int n, int t) { return -1; }\\nint main() { int a[]={1,2,2,2,3}; cout<<leftBound(a,5,2); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nint leftBound(int a[], int n, int t) { int l=0, r=n; while(l<r) { int m=(l+r)/2; if(a[m]<t) l=m+1; else r=m; } return l<n && a[l]==t ? l : -1; }\\nint main() { int a[]={1,2,2,2,3}; cout<<leftBound(a,5,2); return 0; }","explanation":{"approach":"Binary search, keep going left when found.","steps":["If a[m] < t, search right","Else search left (including m)"],"complexity":"Time: O(log n), Space: O(1)"},"testCases":[{"input":"[1,2,2,2,3], t=2","expectedOutput":"1","explanation":"First 2 is at index 1"},{"input":"[1,2,3,4,5], t=3","expectedOutput":"2","explanation":"Unique element"},{"input":"[1,2,3], t=4","expectedOutput":"-1","explanation":"Not found"},{"input":"[2,2,2,2], t=2","expectedOutput":"0","explanation":"All same, first is 0"}]},{"id":"extra2","title":"Binary Search Right Bound","description":"Find last occurrence of target in sorted array.","difficulty":"MEDIUM","category":"Binary Search","starterCode":"#include <iostream>\\nusing namespace std;\\nint rightBound(int a[], int n, int t) { return -1; }\\nint main() { int a[]={1,2,2,2,3}; cout<<rightBound(a,5,2); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nint rightBound(int a[], int n, int t) { int l=0, r=n; while(l<r) { int m=(l+r)/2; if(a[m]<=t) l=m+1; else r=m; } return l-1>=0 && a[l-1]==t ? l-1 : -1; }\\nint main() { int a[]={1,2,2,2,3}; cout<<rightBound(a,5,2); return 0; }","explanation":{"approach":"Binary search, keep going right when found.","steps":["If a[m] <= t, search right","Else search left"],"complexity":"Time: O(log n), Space: O(1)"},"testCases":[{"input":"[1,2,2,2,3], t=2","expectedOutput":"3","explanation":"Last 2 is at index 3"},{"input":"[1,2,3,4,5], t=3","expectedOutput":"2","explanation":"Unique element"},{"input":"[1,2,3], t=0","expectedOutput":"-1","explanation":"Not found"},{"input":"[2,2,2,2], t=2","expectedOutput":"3","explanation":"All same, last is 3"}]},{"id":"extra3","title":"Peak Element","description":"Find any local maximum in array.","difficulty":"MEDIUM","category":"Binary Search","starterCode":"#include <iostream>\\nusing namespace std;\\nint findPeak(int a[], int n) { return -1; }\\nint main() { int a[]={1,2,3,1}; cout<<findPeak(a,4); return 0; }","expectedOutput":"2","solution":"#include <iostream>\\nusing namespace std;\\nint findPeak(int a[], int n) { int l=0, r=n-1; while(l<r) { int m=(l+r)/2; if(a[m]>a[m+1]) r=m; else l=m+1; } return l; }\\nint main() { int a[]={1,2,3,1}; cout<<findPeak(a,4); return 0; }","explanation":{"approach":"Binary search toward larger neighbor.","steps":["If a[m] > a[m+1], go left","Else go right"],"complexity":"Time: O(log n), Space: O(1)"},"testCases":[{"input":"[1,2,3,1]","expectedOutput":"2","explanation":"Peak at index 2 (value 3)"},{"input":"[1,2,1,3,5,6,4]","expectedOutput":"1 or 5","explanation":"Multiple peaks valid"},{"input":"[1]","expectedOutput":"0","explanation":"Single element is peak"},{"input":"[1,2,3,4,5]","expectedOutput":"4","explanation":"Last element is peak"}]},{"id":"extra4","title":"Search in Rotated Array","description":"Binary search in rotated sorted array.","difficulty":"MEDIUM","category":"Binary Search","starterCode":"#include <iostream>\\nusing namespace std;\\nint search(int a[], int n, int t) { return -1; }\\nint main() { int a[]={4,5,6,7,0,1,2}; cout<<search(a,7,0); return 0; }","expectedOutput":"4","solution":"#include <iostream>\\nusing namespace std;\\nint search(int a[], int n, int t) { int l=0, r=n-1; while(l<=r) { int m=(l+r)/2; if(a[m]==t) return m; if(a[l]<=a[m]) { if(a[l]<=t && t<a[m]) r=m-1; else l=m+1; } else { if(a[m]<t && t<=a[r]) l=m+1; else r=m-1; } } return -1; }\\nint main() { int a[]={4,5,6,7,0,1,2}; cout<<search(a,7,0); return 0; }","explanation":{"approach":"Identify sorted half, search in appropriate half.","steps":["Check which half is sorted","If target in sorted half, search there"],"complexity":"Time: O(log n), Space: O(1)"},"testCases":[{"input":"[4,5,6,7,0,1,2], t=0","expectedOutput":"4","explanation":"0 is at index 4"},{"input":"[4,5,6,7,0,1,2], t=3","expectedOutput":"-1","explanation":"Not in array"},{"input":"[1], t=1","expectedOutput":"0","explanation":"Single element found"},{"input":"[3,1], t=1","expectedOutput":"1","explanation":"Two elements rotated"}]},{"id":"extra5","title":"Find Minimum in Rotated","description":"Find minimum element in rotated sorted array.","difficulty":"MEDIUM","category":"Binary Search","starterCode":"#include <iostream>\\nusing namespace std;\\nint findMin(int a[], int n) { return 0; }\\nint main() { int a[]={3,4,5,1,2}; cout<<findMin(a,5); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nint findMin(int a[], int n) { int l=0, r=n-1; while(l<r) { int m=(l+r)/2; if(a[m]>a[r]) l=m+1; else r=m; } return a[l]; }\\nint main() { int a[]={3,4,5,1,2}; cout<<findMin(a,5); return 0; }","explanation":{"approach":"Binary search for rotation point.","steps":["If a[m] > a[r], min is in right half","Else in left half"],"complexity":"Time: O(log n), Space: O(1)"},"testCases":[{"input":"[3,4,5,1,2]","expectedOutput":"1","explanation":"Min is 1"},{"input":"[4,5,6,7,0,1,2]","expectedOutput":"0","explanation":"Min is 0"},{"input":"[1,2,3,4,5]","expectedOutput":"1","explanation":"Not rotated, first is min"},{"input":"[2,1]","expectedOutput":"1","explanation":"Two elements"}]},{"id":"extra6","title":"Square Root Binary Search","description":"Calculate integer square root using binary search.","difficulty":"EASY","category":"Binary Search","starterCode":"#include <iostream>\\nusing namespace std;\\nint mySqrt(int n) { return 0; }\\nint main() { cout<<mySqrt(8); return 0; }","expectedOutput":"2","solution":"#include <iostream>\\nusing namespace std;\\nint mySqrt(int n) { if(n==0) return 0; int l=1, r=n, ans=0; while(l<=r) { int m=l+(r-l)/2; if(m<=n/m) { ans=m; l=m+1; } else r=m-1; } return ans; }\\nint main() { cout<<mySqrt(8); return 0; }","explanation":{"approach":"Binary search for largest x where x*x <= n.","steps":["Check if m*m <= n","If yes, try larger","If no, try smaller"],"complexity":"Time: O(log n), Space: O(1)"},"testCases":[{"input":"n=8","expectedOutput":"2","explanation":"floor(sqrt(8))=2"},{"input":"n=16","expectedOutput":"4","explanation":"Perfect square"},{"input":"n=1","expectedOutput":"1","explanation":"sqrt(1)=1"},{"input":"n=0","expectedOutput":"0","explanation":"sqrt(0)=0"}]},{"id":"extra7","title":"Search 2D Matrix","description":"Search in row-wise and column-wise sorted matrix.","difficulty":"MEDIUM","category":"Binary Search","starterCode":"#include <iostream>\\nusing namespace std;\\nbool searchMatrix(int m[][4], int r, int c, int t) { return false; }\\nint main() { int m[3][4]={{1,3,5,7},{10,11,16,20},{23,30,34,60}}; cout<<searchMatrix(m,3,4,3); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool searchMatrix(int m[][4], int r, int c, int t) { int lo=0, hi=r*c-1; while(lo<=hi) { int mid=(lo+hi)/2; int val=m[mid/c][mid%c]; if(val==t) return true; if(val<t) lo=mid+1; else hi=mid-1; } return false; }\\nint main() { int m[3][4]={{1,3,5,7},{10,11,16,20},{23,30,34,60}}; cout<<searchMatrix(m,3,4,3); return 0; }","explanation":{"approach":"Treat matrix as virtual 1D array.","steps":["Binary search on indices 0 to r*c-1","Convert to row/col: row=mid/c, col=mid%c"],"complexity":"Time: O(log(rc)), Space: O(1)"},"testCases":[{"input":"matrix, t=3","expectedOutput":"1","explanation":"3 found"},{"input":"matrix, t=13","expectedOutput":"0","explanation":"13 not found"},{"input":"[[1]], t=1","expectedOutput":"1","explanation":"Single element"},{"input":"matrix, t=60","expectedOutput":"1","explanation":"Last element"}]},{"id":"extra8","title":"Kth Smallest in Sorted Matrix","description":"Find kth smallest element in row/col sorted matrix.","difficulty":"MEDIUM","category":"Binary Search","starterCode":"#include <iostream>\\nusing namespace std;\\nint kthSmallest(int m[][3], int n, int k) { return 0; }\\nint main() { int m[3][3]={{1,5,9},{10,11,13},{12,13,15}}; cout<<kthSmallest(m,3,5); return 0; }","expectedOutput":"11","solution":"#include <iostream>\\nusing namespace std;\\nint countLE(int m[][3], int n, int mid) { int c=0, col=n-1; for(int row=0;row<n;row++) { while(col>=0 && m[row][col]>mid) col--; c+=col+1; } return c; }\\nint kthSmallest(int m[][3], int n, int k) { int lo=m[0][0], hi=m[n-1][n-1]; while(lo<hi) { int mid=lo+(hi-lo)/2; if(countLE(m,n,mid)>=k) hi=mid; else lo=mid+1; } return lo; }\\nint main() { int m[3][3]={{1,5,9},{10,11,13},{12,13,15}}; cout<<kthSmallest(m,3,5); return 0; }","explanation":{"approach":"Binary search on value range, count elements <= mid.","steps":["Binary search between min and max","Count elements <= mid","Adjust search"],"complexity":"Time: O(n log(max-min)), Space: O(1)"},"testCases":[{"input":"matrix, k=5","expectedOutput":"11","explanation":"5th smallest is 11"},{"input":"matrix, k=1","expectedOutput":"1","explanation":"Smallest is 1"},{"input":"matrix, k=9","expectedOutput":"15","explanation":"Largest in 3x3"},{"input":"[[1,2],[3,4]], k=3","expectedOutput":"3","explanation":"Third smallest"}]},{"id":"extra9","title":"Allocate Minimum Pages","description":"Minimize maximum pages allocated to any student.","difficulty":"HARD","category":"Binary Search","starterCode":"#include <iostream>\\nusing namespace std;\\nint allocateBooks(int a[], int n, int k) { return 0; }\\nint main() { int a[]={12,34,67,90}; cout<<allocateBooks(a,4,2); return 0; }","expectedOutput":"113","solution":"#include <iostream>\\nusing namespace std;\\nbool canAllocate(int a[], int n, int k, int mid) { int s=1, pages=0; for(int i=0;i<n;i++) { if(a[i]>mid) return false; if(pages+a[i]>mid) { s++; pages=a[i]; } else pages+=a[i]; } return s<=k; }\\nint allocateBooks(int a[], int n, int k) { int lo=0, hi=0; for(int i=0;i<n;i++) { lo=max(lo,a[i]); hi+=a[i]; } while(lo<hi) { int mid=(lo+hi)/2; if(canAllocate(a,n,k,mid)) hi=mid; else lo=mid+1; } return lo; }\\nint main() { int a[]={12,34,67,90}; cout<<allocateBooks(a,4,2); return 0; }","explanation":{"approach":"Binary search on answer (max pages per student).","steps":["Search range: max(a[i]) to sum(a)","Check if allocation possible","Minimize maximum"],"complexity":"Time: O(n log sum), Space: O(1)"},"testCases":[{"input":"[12,34,67,90], k=2","expectedOutput":"113","explanation":"[12,34,67] & [90]"},{"input":"[10,20,30,40], k=2","expectedOutput":"60","explanation":"[10,20,30] & [40]"},{"input":"[100], k=1","expectedOutput":"100","explanation":"One book, one student"},{"input":"[10,10,10,10], k=4","expectedOutput":"10","explanation":"One each"}]},{"id":"extra10","title":"Aggressive Cows","description":"Maximize minimum distance between cows.","difficulty":"HARD","category":"Binary Search","starterCode":"#include <iostream>\\nusing namespace std;\\nint aggressiveCows(int pos[], int n, int c) { return 0; }\\nint main() { int pos[]={1,2,4,8,9}; cout<<aggressiveCows(pos,5,3); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nbool canPlace(int pos[], int n, int c, int d) { int cows=1, last=pos[0]; for(int i=1;i<n;i++) if(pos[i]-last>=d) { cows++; last=pos[i]; } return cows>=c; }\\nint aggressiveCows(int pos[], int n, int c) { for(int i=0;i<n-1;i++) for(int j=0;j<n-i-1;j++) if(pos[j]>pos[j+1]) swap(pos[j],pos[j+1]); int lo=1, hi=pos[n-1]-pos[0], ans=0; while(lo<=hi) { int mid=(lo+hi)/2; if(canPlace(pos,n,c,mid)) { ans=mid; lo=mid+1; } else hi=mid-1; } return ans; }\\nint main() { int pos[]={1,2,4,8,9}; cout<<aggressiveCows(pos,5,3); return 0; }","explanation":{"approach":"Binary search on minimum distance between cows.","steps":["Sort positions","Binary search on distance","Check if placeable"],"complexity":"Time: O(n log(max-min)), Space: O(1)"},"testCases":[{"input":"[1,2,4,8,9], c=3","expectedOutput":"3","explanation":"Place at 1,4,8 or 1,4,9"},{"input":"[1,2,3,4,5], c=2","expectedOutput":"4","explanation":"Place at 1,5"},{"input":"[1,5,10], c=2","expectedOutput":"9","explanation":"Place at 1,10"},{"input":"[1,2,3], c=3","expectedOutput":"1","explanation":"All stalls used"}]}]'),HM=JSON.parse(`[{"id":"ext21","title":"Jump Game II","description":"Find minimum jumps to reach end of array.","difficulty":"MEDIUM","category":"Greedy","starterCode":"#include <iostream>\\nusing namespace std;\\nint jump(int nums[], int n) { return 0; }\\nint main() { int a[]={2,3,1,1,4}; cout<<jump(a,5); return 0; }","expectedOutput":"2","solution":"#include <iostream>\\nusing namespace std;\\nint jump(int nums[], int n) { int jumps=0,cur=0,far=0; for(int i=0;i<n-1;i++) { far=max(far,i+nums[i]); if(i==cur) { jumps++; cur=far; } } return jumps; }\\nint main() { int a[]={2,3,1,1,4}; cout<<jump(a,5); return 0; }","explanation":{"approach":"Greedy BFS - track current level end.","steps":["Track farthest reachable","Jump when reaching current end"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"[2,3,1,1,4]","expectedOutput":"2","explanation":"Jump 0->1->4 (2 jumps)"},{"input":"[2,3,0,1,4]","expectedOutput":"2","explanation":"Same path works"},{"input":"[1,1,1,1]","expectedOutput":"3","explanation":"Must jump at each position"},{"input":"[1]","expectedOutput":"0","explanation":"Already at end"}]},{"id":"ext22","title":"Gas Station","description":"Find starting station to complete circular route.","difficulty":"MEDIUM","category":"Greedy","starterCode":"#include <iostream>\\nusing namespace std;\\nint canCompleteCircuit(int gas[], int cost[], int n) { return -1; }\\nint main() { int g[]={1,2,3,4,5}; int c[]={3,4,5,1,2}; cout<<canCompleteCircuit(g,c,5); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nint canCompleteCircuit(int gas[], int cost[], int n) { int total=0,tank=0,start=0; for(int i=0;i<n;i++) { total+=gas[i]-cost[i]; tank+=gas[i]-cost[i]; if(tank<0) { tank=0; start=i+1; } } return total>=0?start:-1; }\\nint main() { int g[]={1,2,3,4,5}; int c[]={3,4,5,1,2}; cout<<canCompleteCircuit(g,c,5); return 0; }","explanation":{"approach":"Track tank and restart point when negative.","steps":["If tank negative, restart from next","Check total feasibility"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"gas=[1,2,3,4,5], cost=[3,4,5,1,2]","expectedOutput":"3","explanation":"Start at station 3"},{"input":"gas=[2,3,4], cost=[3,4,3]","expectedOutput":"-1","explanation":"Not enough gas total"},{"input":"gas=[5,1,2,3,4], cost=[4,4,1,5,1]","expectedOutput":"4","explanation":"Start at last station"},{"input":"gas=[3], cost=[3]","expectedOutput":"0","explanation":"Single station, exact gas"}]},{"id":"ext23","title":"Candy Distribution","description":"Minimum candies to satisfy rating constraints.","difficulty":"HARD","category":"Greedy","starterCode":"#include <iostream>\\nusing namespace std;\\nint candy(int ratings[], int n) { return 0; }\\nint main() { int r[]={1,0,2}; cout<<candy(r,3); return 0; }","expectedOutput":"5","solution":"#include <iostream>\\nusing namespace std;\\nint candy(int ratings[], int n) { int c[n]; for(int i=0;i<n;i++) c[i]=1; for(int i=1;i<n;i++) if(ratings[i]>ratings[i-1]) c[i]=c[i-1]+1; for(int i=n-2;i>=0;i--) if(ratings[i]>ratings[i+1]) c[i]=max(c[i],c[i+1]+1); int sum=0; for(int i=0;i<n;i++) sum+=c[i]; return sum; }\\nint main() { int r[]={1,0,2}; cout<<candy(r,3); return 0; }","explanation":{"approach":"Two-pass greedy: left-to-right then right-to-left.","steps":["Left pass: higher rating gets more than left neighbor","Right pass: same for right"],"complexity":"Time: O(n), Space: O(n)"},"testCases":[{"input":"[1,0,2]","expectedOutput":"5","explanation":"2+1+2=5 candies"},{"input":"[1,2,2]","expectedOutput":"4","explanation":"1+2+1=4"},{"input":"[1,3,2,2,1]","expectedOutput":"7","explanation":"1+2+1+2+1=7"},{"input":"[1]","expectedOutput":"1","explanation":"Single child"}]},{"id":"ext24","title":"Partition Labels","description":"Maximum partitions where each letter appears in one part.","difficulty":"MEDIUM","category":"Greedy","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid partitionLabels(char s[]) {}\\nint main() { partitionLabels(\\"ababcbacadefegdehijhklij\\"); return 0; }","expectedOutput":"9 7 8","solution":"#include <iostream>\\nusing namespace std;\\nvoid partitionLabels(char s[]) { int last[26]={}; int n=0; while(s[n]) { last[s[n]-'a']=n; n++; } int start=0,end=0; for(int i=0;i<n;i++) { end=max(end,last[s[i]-'a']); if(i==end) { cout<<end-start+1<<\\" \\"; start=i+1; } } }\\nint main() { partitionLabels(\\"ababcbacadefegdehijhklij\\"); return 0; }","explanation":{"approach":"Track last occurrence, extend partition.","steps":["Find last occurrence of each char","Extend partition to include all occurrences"],"complexity":"Time: O(n), Space: O(26)"},"testCases":[{"input":"\\"ababcbacadefegdehijhklij\\"","expectedOutput":"9 7 8","explanation":"Three partitions"},{"input":"\\"eccbbbbdec\\"","expectedOutput":"10","explanation":"One partition"},{"input":"\\"abcd\\"","expectedOutput":"1 1 1 1","explanation":"Each letter unique"},{"input":"\\"a\\"","expectedOutput":"1","explanation":"Single letter"}]},{"id":"ext25","title":"Task Scheduler","description":"Minimum time to execute tasks with cooldown.","difficulty":"MEDIUM","category":"Greedy","starterCode":"#include <iostream>\\nusing namespace std;\\nint leastInterval(char tasks[], int n, int k) { return 0; }\\nint main() { char t[]={'A','A','A','B','B','B'}; cout<<leastInterval(t,6,2); return 0; }","expectedOutput":"8","solution":"#include <iostream>\\nusing namespace std;\\nint leastInterval(char tasks[], int n, int k) { int cnt[26]={}; for(int i=0;i<n;i++) cnt[tasks[i]-'A']++; int mx=0,mxCnt=0; for(int i=0;i<26;i++) { if(cnt[i]>mx) { mx=cnt[i]; mxCnt=1; } else if(cnt[i]==mx) mxCnt++; } return max(n,(mx-1)*(k+1)+mxCnt); }\\nint main() { char t[]={'A','A','A','B','B','B'}; cout<<leastInterval(t,6,2); return 0; }","explanation":{"approach":"Calculate based on most frequent task.","steps":["Find max frequency","Fill slots or use all tasks"],"complexity":"Time: O(n), Space: O(26)"},"testCases":[{"input":"['A','A','A','B','B','B'], k=2","expectedOutput":"8","explanation":"A_B_A_B_AB"},{"input":"['A','A','A','B','B','B'], k=0","expectedOutput":"6","explanation":"No cooldown"},{"input":"['A','A','A','A','A','A','B','C','D','E','F','G'], k=2","expectedOutput":"16","explanation":"Fill slots"},{"input":"['A'], k=2","expectedOutput":"1","explanation":"Single task"}]},{"id":"ext26","title":"Two Sum with Hashing","description":"Find two numbers that add to target.","difficulty":"EASY","category":"Hashing","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid twoSum(int nums[], int n, int target) {}\\nint main() { int a[]={2,7,11,15}; twoSum(a,4,9); return 0; }","expectedOutput":"0 1","solution":"#include <iostream>\\nusing namespace std;\\nvoid twoSum(int nums[], int n, int target) { for(int i=0;i<n;i++) for(int j=i+1;j<n;j++) if(nums[i]+nums[j]==target) { cout<<i<<\\" \\"<<j; return; } }\\nint main() { int a[]={2,7,11,15}; twoSum(a,4,9); return 0; }","explanation":{"approach":"Check all pairs for target sum.","steps":["For each pair","Check if sum equals target"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"[2,7,11,15], target=9","expectedOutput":"0 1","explanation":"2+7=9"},{"input":"[3,2,4], target=6","expectedOutput":"1 2","explanation":"2+4=6"},{"input":"[3,3], target=6","expectedOutput":"0 1","explanation":"Same values"},{"input":"[1,2,3,4], target=7","expectedOutput":"2 3","explanation":"3+4=7"}]},{"id":"ext27","title":"Group Anagrams","description":"Group strings that are anagrams of each other.","difficulty":"MEDIUM","category":"Hashing","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid groupAnagrams(char* strs[], int n) {}\\nint main() { char* s[]={\\"eat\\",\\"tea\\",\\"tan\\",\\"ate\\",\\"nat\\",\\"bat\\"}; groupAnagrams(s,6); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nvoid groupAnagrams(char* strs[], int n) { int groups=0; bool used[100]={}; for(int i=0;i<n;i++) { if(used[i]) continue; groups++; used[i]=true; int cnt1[26]={}; for(int k=0;strs[i][k];k++) cnt1[strs[i][k]-'a']++; for(int j=i+1;j<n;j++) { if(used[j]) continue; int cnt2[26]={}; for(int k=0;strs[j][k];k++) cnt2[strs[j][k]-'a']++; bool eq=true; for(int k=0;k<26;k++) if(cnt1[k]!=cnt2[k]) { eq=false; break; } if(eq) used[j]=true; } } cout<<groups; }\\nint main() { char* s[]={\\"eat\\",\\"tea\\",\\"tan\\",\\"ate\\",\\"nat\\",\\"bat\\"}; groupAnagrams(s,6); return 0; }","explanation":{"approach":"Compare character counts for anagrams.","steps":["For each string, create frequency signature","Group by matching signatures"],"complexity":"Time: O(n  k), Space: O(n  k)"},"testCases":[{"input":"[eat,tea,tan,ate,nat,bat]","expectedOutput":"3","explanation":"Three groups"},{"input":"[\\"\\"]","expectedOutput":"1","explanation":"Empty string alone"},{"input":"[a]","expectedOutput":"1","explanation":"Single string"},{"input":"[abc,cba,bac,xyz]","expectedOutput":"2","explanation":"Two groups"}]},{"id":"ext28","title":"Valid Anagram","description":"Check if two strings are anagrams.","difficulty":"EASY","category":"Hashing","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isAnagram(char s[], char t[]) { return false; }\\nint main() { cout<<isAnagram(\\"anagram\\",\\"nagaram\\"); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isAnagram(char s[], char t[]) { int cnt[26]={}; int ls=0,lt=0; while(s[ls]) { cnt[s[ls]-'a']++; ls++; } while(t[lt]) { cnt[t[lt]-'a']--; lt++; } if(ls!=lt) return false; for(int i=0;i<26;i++) if(cnt[i]) return false; return true; }\\nint main() { cout<<isAnagram(\\"anagram\\",\\"nagaram\\"); return 0; }","explanation":{"approach":"Count characters and compare.","steps":["Increment count for s","Decrement for t","All counts should be 0"],"complexity":"Time: O(n), Space: O(26)"},"testCases":[{"input":"anagram, nagaram","expectedOutput":"1","explanation":"Valid anagram"},{"input":"rat, car","expectedOutput":"0","explanation":"Not anagram"},{"input":"a, a","expectedOutput":"1","explanation":"Same single char"},{"input":"ab, ba","expectedOutput":"1","explanation":"Swapped letters"}]},{"id":"ext29","title":"Contains Nearby Duplicate","description":"Check if duplicate exists within k distance.","difficulty":"EASY","category":"Hashing","starterCode":"#include <iostream>\\nusing namespace std;\\nbool containsNearbyDuplicate(int nums[], int n, int k) { return false; }\\nint main() { int a[]={1,2,3,1}; cout<<containsNearbyDuplicate(a,4,3); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool containsNearbyDuplicate(int nums[], int n, int k) { for(int i=0;i<n;i++) for(int j=i+1;j<n&&j<=i+k;j++) if(nums[i]==nums[j]) return true; return false; }\\nint main() { int a[]={1,2,3,1}; cout<<containsNearbyDuplicate(a,4,3); return 0; }","explanation":{"approach":"Check pairs within k distance.","steps":["For each i, check i+1 to i+k","Return true if duplicate found"],"complexity":"Time: O(nk), Space: O(1)"},"testCases":[{"input":"[1,2,3,1], k=3","expectedOutput":"1","explanation":"index 0 and 3 within k=3"},{"input":"[1,0,1,1], k=1","expectedOutput":"1","explanation":"index 2 and 3"},{"input":"[1,2,3,1,2,3], k=2","expectedOutput":"0","explanation":"No duplicates within 2"},{"input":"[1,2,1], k=1","expectedOutput":"0","explanation":"Distance is 2, not 1"}]},{"id":"ext30","title":"Longest Consecutive Sequence","description":"Find length of longest consecutive elements sequence.","difficulty":"MEDIUM","category":"Hashing","starterCode":"#include <iostream>\\nusing namespace std;\\nint longestConsecutive(int nums[], int n) { return 0; }\\nint main() { int a[]={100,4,200,1,3,2}; cout<<longestConsecutive(a,6); return 0; }","expectedOutput":"4","solution":"#include <iostream>\\nusing namespace std;\\nint longestConsecutive(int nums[], int n) { if(n==0) return 0; for(int i=0;i<n-1;i++) for(int j=0;j<n-i-1;j++) if(nums[j]>nums[j+1]) swap(nums[j],nums[j+1]); int mx=1,cur=1; for(int i=1;i<n;i++) { if(nums[i]==nums[i-1]) continue; if(nums[i]==nums[i-1]+1) cur++; else cur=1; mx=max(mx,cur); } return mx; }\\nint main() { int a[]={100,4,200,1,3,2}; cout<<longestConsecutive(a,6); return 0; }","explanation":{"approach":"Sort and count consecutive runs.","steps":["Sort array","Count consecutive sequences"],"complexity":"Time: O(n log n), Space: O(1)"},"testCases":[{"input":"[100,4,200,1,3,2]","expectedOutput":"4","explanation":"1,2,3,4 = length 4"},{"input":"[0,3,7,2,5,8,4,6,0,1]","expectedOutput":"9","explanation":"0-8 consecutive"},{"input":"[]","expectedOutput":"0","explanation":"Empty array"},{"input":"[1,2,0,1]","expectedOutput":"3","explanation":"0,1,2 with duplicate 1"}]}]`),YM=JSON.parse('[{"id":"ext31","title":"Kth Largest in Stream","description":"Maintain kth largest element in a stream of numbers.","difficulty":"EASY","category":"Heap","starterCode":"#include <iostream>\\nusing namespace std;\\nclass KthLargest {\\npublic:\\n    KthLargest(int k, int nums[], int n) {}\\n    int add(int val) { return 0; }\\n};\\nint main() { int a[]={4,5,8,2}; KthLargest kl(3,a,4); cout<<kl.add(3); return 0; }","expectedOutput":"4","solution":"#include <iostream>\\nusing namespace std;\\nclass KthLargest { int arr[100],n,k; public: KthLargest(int k, int nums[], int sz):k(k),n(0) { for(int i=0;i<sz;i++) add(nums[i]); } int add(int val) { arr[n++]=val; for(int i=0;i<n-1;i++) for(int j=0;j<n-i-1;j++) if(arr[j]<arr[j+1]) swap(arr[j],arr[j+1]); return arr[k-1]; } };\\nint main() { int a[]={4,5,8,2}; KthLargest kl(3,a,4); cout<<kl.add(3); return 0; }","explanation":{"approach":"Maintain sorted array and return kth element.","steps":["Sort after each add","Return kth largest"],"complexity":"Time: O(n log n), Space: O(n)"},"testCases":[{"input":"add(3) to [4,5,8,2], k=3","expectedOutput":"4","explanation":"Sorted: 8,5,4,3,2 -> 3rd is 4"},{"input":"add(5) to [4,5,8,2,3], k=3","expectedOutput":"5","explanation":"Sorted: 8,5,5,4,3,2 -> 3rd is 5"},{"input":"add(10) to [4,5,8,2,3,5], k=3","expectedOutput":"5","explanation":"10,8,5,... -> 3rd is 5"},{"input":"k=1, add(1) to []","expectedOutput":"1","explanation":"Only element"}]},{"id":"ext32","title":"Top K Frequent Elements","description":"Find k most frequent elements in array.","difficulty":"MEDIUM","category":"Heap","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid topKFrequent(int nums[], int n, int k) {}\\nint main() { int a[]={1,1,1,2,2,3}; topKFrequent(a,6,2); return 0; }","expectedOutput":"1 2","solution":"#include <iostream>\\nusing namespace std;\\nvoid topKFrequent(int nums[], int n, int k) { int vals[100],cnt[100],m=0; for(int i=0;i<n;i++) { int j=0; while(j<m&&vals[j]!=nums[i]) j++; if(j<m) cnt[j]++; else { vals[m]=nums[i]; cnt[m++]=1; } } for(int i=0;i<k;i++) { int mx=0; for(int j=1;j<m;j++) if(cnt[j]>cnt[mx]) mx=j; cout<<vals[mx]<<\\" \\"; cnt[mx]=-1; } }\\nint main() { int a[]={1,1,1,2,2,3}; topKFrequent(a,6,2); return 0; }","explanation":{"approach":"Count frequencies and select top k.","steps":["Count frequency of each element","Select k highest frequency elements"],"complexity":"Time: O(n  k), Space: O(n)"},"testCases":[{"input":"[1,1,1,2,2,3], k=2","expectedOutput":"1 2","explanation":"1 appears 3x, 2 appears 2x"},{"input":"[1], k=1","expectedOutput":"1","explanation":"Single element"},{"input":"[1,2], k=2","expectedOutput":"1 2","explanation":"Both same frequency"},{"input":"[4,4,4,4,5,5,5,6,6,7], k=3","expectedOutput":"4 5 6","explanation":"Top 3 frequent"}]},{"id":"ext33","title":"Kth Smallest in Sorted Matrix","description":"Find kth smallest element in row/col sorted matrix.","difficulty":"MEDIUM","category":"Heap","starterCode":"#include <iostream>\\nusing namespace std;\\nint kthSmallest(int m[][3], int n, int k) { return 0; }\\nint main() { int m[][3]={{1,5,9},{10,11,13},{12,13,15}}; cout<<kthSmallest(m,3,8); return 0; }","expectedOutput":"13","solution":"#include <iostream>\\nusing namespace std;\\nint kthSmallest(int m[][3], int n, int k) { int arr[100],c=0; for(int i=0;i<n;i++) for(int j=0;j<n;j++) arr[c++]=m[i][j]; for(int i=0;i<c-1;i++) for(int j=0;j<c-i-1;j++) if(arr[j]>arr[j+1]) swap(arr[j],arr[j+1]); return arr[k-1]; }\\nint main() { int m[][3]={{1,5,9},{10,11,13},{12,13,15}}; cout<<kthSmallest(m,3,8); return 0; }","explanation":{"approach":"Flatten matrix, sort, and return kth.","steps":["Extract all elements","Sort and return kth"],"complexity":"Time: O(n log n), Space: O(n)"},"testCases":[{"input":"matrix, k=8","expectedOutput":"13","explanation":"8th smallest is 13"},{"input":"matrix, k=1","expectedOutput":"1","explanation":"Smallest is 1"},{"input":"matrix, k=9","expectedOutput":"15","explanation":"Largest is 15"},{"input":"[[1,2],[3,4]], k=2","expectedOutput":"2","explanation":"2nd smallest"}]},{"id":"ext34","title":"Meeting Rooms II","description":"Find minimum meeting rooms required.","difficulty":"MEDIUM","category":"Heap","starterCode":"#include <iostream>\\nusing namespace std;\\nint minMeetingRooms(int start[], int end[], int n) { return 0; }\\nint main() { int s[]={0,5,15}; int e[]={30,10,20}; cout<<minMeetingRooms(s,e,3); return 0; }","expectedOutput":"2","solution":"#include <iostream>\\nusing namespace std;\\nint minMeetingRooms(int start[], int end[], int n) { for(int i=0;i<n-1;i++) for(int j=0;j<n-i-1;j++) if(start[j]>start[j+1]) { swap(start[j],start[j+1]); swap(end[j],end[j+1]); } int rooms[100],m=0; for(int i=0;i<n;i++) { int j=0; while(j<m&&rooms[j]>start[i]) j++; if(j<m) rooms[j]=end[i]; else rooms[m++]=end[i]; } return m; }\\nint main() { int s[]={0,5,15}; int e[]={30,10,20}; cout<<minMeetingRooms(s,e,3); return 0; }","explanation":{"approach":"Sort by start time, assign rooms greedily.","steps":["Sort meetings by start","Reuse room if available, else add new"],"complexity":"Time: O(n log n), Space: O(n)"},"testCases":[{"input":"[[0,30],[5,10],[15,20]]","expectedOutput":"2","explanation":"Two overlapping at max"},{"input":"[[7,10],[2,4]]","expectedOutput":"1","explanation":"No overlap"},{"input":"[[0,5],[5,10],[10,15]]","expectedOutput":"1","explanation":"Sequential, reuse room"},{"input":"[[1,5],[2,6],[3,7]]","expectedOutput":"3","explanation":"All overlap"}]},{"id":"ext35","title":"Sliding Window Maximum","description":"Find maximum in each sliding window of size k.","difficulty":"HARD","category":"Sliding Window","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid maxSlidingWindow(int nums[], int n, int k) {}\\nint main() { int a[]={1,3,-1,-3,5,3,6,7}; maxSlidingWindow(a,8,3); return 0; }","expectedOutput":"3 3 5 5 6 7","solution":"#include <iostream>\\nusing namespace std;\\nvoid maxSlidingWindow(int nums[], int n, int k) { for(int i=0;i<=n-k;i++) { int mx=nums[i]; for(int j=i;j<i+k;j++) mx=max(mx,nums[j]); cout<<mx<<\\" \\"; } }\\nint main() { int a[]={1,3,-1,-3,5,3,6,7}; maxSlidingWindow(a,8,3); return 0; }","explanation":{"approach":"Find max in each window naively.","steps":["For each window position","Find maximum in window"],"complexity":"Time: O(nk), Space: O(1)"},"testCases":[{"input":"[1,3,-1,-3,5,3,6,7], k=3","expectedOutput":"3 3 5 5 6 7","explanation":"Max of each window"},{"input":"[1], k=1","expectedOutput":"1","explanation":"Single element"},{"input":"[9,11], k=2","expectedOutput":"11","explanation":"One window"},{"input":"[1,2,3,4,5], k=2","expectedOutput":"2 3 4 5","explanation":"Sliding through"}]},{"id":"ext36","title":"Implement Trie","description":"Implement prefix tree with insert, search, startsWith.","difficulty":"MEDIUM","category":"Trie","starterCode":"#include <iostream>\\nusing namespace std;\\nclass Trie {\\npublic:\\n    void insert(char word[]) {}\\n    bool search(char word[]) { return false; }\\n    bool startsWith(char prefix[]) { return false; }\\n};\\nint main() { Trie t; t.insert(\\"apple\\"); cout<<t.search(\\"apple\\"); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nclass Trie { char words[100][50]; int n; public: Trie():n(0){} void insert(char word[]) { int i=0; while(word[i]) { words[n][i]=word[i]; i++; } words[n++][i]=0; } bool search(char word[]) { for(int i=0;i<n;i++) { bool eq=true; for(int j=0;word[j]||words[i][j];j++) if(word[j]!=words[i][j]) { eq=false; break; } if(eq) return true; } return false; } bool startsWith(char pre[]) { for(int i=0;i<n;i++) { bool m=true; for(int j=0;pre[j];j++) if(words[i][j]!=pre[j]) { m=false; break; } if(m) return true; } return false; } };\\nint main() { Trie t; t.insert(\\"apple\\"); cout<<t.search(\\"apple\\"); return 0; }","explanation":{"approach":"Store words in array, linear search.","steps":["Insert: add to array","Search: exact match","StartsWith: prefix match"],"complexity":"Time: O(n  L), Space: O(n  L)"},"testCases":[{"input":"insert(apple), search(apple)","expectedOutput":"1","explanation":"Found"},{"input":"insert(apple), search(app)","expectedOutput":"0","explanation":"Prefix only"},{"input":"insert(apple), startsWith(app)","expectedOutput":"1","explanation":"Prefix exists"},{"input":"search(empty)","expectedOutput":"0","explanation":"Not found"}]},{"id":"ext37","title":"Word Break","description":"Check if string can be segmented into dictionary words.","difficulty":"MEDIUM","category":"Trie","starterCode":"#include <iostream>\\nusing namespace std;\\nbool wordBreak(char s[], char* dict[], int n) { return false; }\\nint main() { char* d[]={\\"leet\\",\\"code\\"}; cout<<wordBreak(\\"leetcode\\",d,2); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool wordBreak(char s[], char* dict[], int n) { int len=0; while(s[len]) len++; bool dp[len+1]={}; dp[0]=true; for(int i=1;i<=len;i++) for(int j=0;j<n;j++) { int wl=0; while(dict[j][wl]) wl++; if(i>=wl&&dp[i-wl]) { bool m=true; for(int k=0;k<wl;k++) if(s[i-wl+k]!=dict[j][k]) { m=false; break; } if(m) dp[i]=true; } } return dp[len]; }\\nint main() { char* d[]={\\"leet\\",\\"code\\"}; cout<<wordBreak(\\"leetcode\\",d,2); return 0; }","explanation":{"approach":"Dynamic programming with dictionary matching.","steps":["dp[i] = can form s[0..i-1]","Try each dictionary word"],"complexity":"Time: O(n  m  L), Space: O(n)"},"testCases":[{"input":"leetcode, [leet,code]","expectedOutput":"1","explanation":"leet+code"},{"input":"applepenapple, [apple,pen]","expectedOutput":"1","explanation":"apple+pen+apple"},{"input":"catsandog, [cats,dog,sand,and,cat]","expectedOutput":"0","explanation":"Cannot segment"},{"input":"a, [a]","expectedOutput":"1","explanation":"Single word match"}]},{"id":"ext38","title":"Range Sum Query","description":"Answer range sum queries efficiently.","difficulty":"EASY","category":"Segment Tree","starterCode":"#include <iostream>\\nusing namespace std;\\nclass NumArray {\\n    int a[100],n;\\npublic:\\n    NumArray(int nums[], int sz) { n=sz; for(int i=0;i<n;i++) a[i]=nums[i]; }\\n    int sumRange(int i, int j) { int s=0; for(int k=i;k<=j;k++) s+=a[k]; return s; }\\n};\\nint main() { int a[]={-2,0,3,-5,2,-1}; NumArray na(a,6); cout<<na.sumRange(0,2); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nclass NumArray { int pre[101],n; public: NumArray(int nums[], int sz) { n=sz; pre[0]=0; for(int i=0;i<n;i++) pre[i+1]=pre[i]+nums[i]; } int sumRange(int i, int j) { return pre[j+1]-pre[i]; } };\\nint main() { int a[]={-2,0,3,-5,2,-1}; NumArray na(a,6); cout<<na.sumRange(0,2); return 0; }","explanation":{"approach":"Use prefix sums for O(1) queries.","steps":["Precompute prefix sums","Answer query as pre[j+1] - pre[i]"],"complexity":"Time: O(1) query, Space: O(n)"},"testCases":[{"input":"sumRange(0,2)","expectedOutput":"1","explanation":"-2+0+3=1"},{"input":"sumRange(2,5)","expectedOutput":"-1","explanation":"3+(-5)+2+(-1)=-1"},{"input":"sumRange(0,5)","expectedOutput":"-3","explanation":"Sum of all"},{"input":"sumRange(3,3)","expectedOutput":"-5","explanation":"Single element"}]},{"id":"ext39","title":"Range Sum Query 2D","description":"Answer 2D range sum queries.","difficulty":"MEDIUM","category":"Segment Tree","starterCode":"#include <iostream>\\nusing namespace std;\\nclass NumMatrix {\\n    int m[10][10],r,c;\\npublic:\\n    NumMatrix(int mat[][5], int rows, int cols) { r=rows; c=cols; for(int i=0;i<r;i++) for(int j=0;j<c;j++) m[i][j]=mat[i][j]; }\\n    int sumRegion(int r1, int c1, int r2, int c2) { int s=0; for(int i=r1;i<=r2;i++) for(int j=c1;j<=c2;j++) s+=m[i][j]; return s; }\\n};\\nint main() { int m[][5]={{3,0,1,4,2},{5,6,3,2,1},{1,2,0,1,5},{4,1,0,1,7},{1,0,3,0,5}}; NumMatrix nm(m,5,5); cout<<nm.sumRegion(2,1,4,3); return 0; }","expectedOutput":"8","solution":"#include <iostream>\\nusing namespace std;\\nclass NumMatrix { int pre[11][11],r,c; public: NumMatrix(int mat[][5], int rows, int cols) { r=rows; c=cols; for(int i=0;i<=r;i++) pre[i][0]=0; for(int j=0;j<=c;j++) pre[0][j]=0; for(int i=1;i<=r;i++) for(int j=1;j<=c;j++) pre[i][j]=mat[i-1][j-1]+pre[i-1][j]+pre[i][j-1]-pre[i-1][j-1]; } int sumRegion(int r1, int c1, int r2, int c2) { return pre[r2+1][c2+1]-pre[r1][c2+1]-pre[r2+1][c1]+pre[r1][c1]; } };\\nint main() { int m[][5]={{3,0,1,4,2},{5,6,3,2,1},{1,2,0,1,5},{4,1,0,1,7},{1,0,3,0,5}}; NumMatrix nm(m,5,5); cout<<nm.sumRegion(2,1,4,3); return 0; }","explanation":{"approach":"2D prefix sums with inclusion-exclusion.","steps":["Build 2D prefix sum matrix","Use inclusion-exclusion for rectangle"],"complexity":"Time: O(1) query, Space: O(mn)"},"testCases":[{"input":"sumRegion(2,1,4,3)","expectedOutput":"8","explanation":"Sum of 3x3 rectangle"},{"input":"sumRegion(1,1,2,2)","expectedOutput":"11","explanation":"6+3+2+0=11"},{"input":"sumRegion(0,0,0,0)","expectedOutput":"3","explanation":"Single element"},{"input":"sumRegion(1,2,2,4)","expectedOutput":"12","explanation":"3+2+1+0+1+5=12"}]},{"id":"ext40","title":"Count Smaller Numbers After Self","description":"For each element, count smaller elements to its right.","difficulty":"HARD","category":"Segment Tree","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid countSmaller(int nums[], int n) {}\\nint main() { int a[]={5,2,6,1}; countSmaller(a,4); return 0; }","expectedOutput":"2 1 1 0","solution":"#include <iostream>\\nusing namespace std;\\nvoid countSmaller(int nums[], int n) { for(int i=0;i<n;i++) { int cnt=0; for(int j=i+1;j<n;j++) if(nums[j]<nums[i]) cnt++; cout<<cnt<<\\" \\"; } }\\nint main() { int a[]={5,2,6,1}; countSmaller(a,4); return 0; }","explanation":{"approach":"For each element, count smaller to right.","steps":["For each position","Count elements to right that are smaller"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"[5,2,6,1]","expectedOutput":"2 1 1 0","explanation":"5>2,1; 2>1; 6>1; 1 has none"},{"input":"[1,2,3]","expectedOutput":"0 0 0","explanation":"Ascending, none smaller to right"},{"input":"[3,2,1]","expectedOutput":"2 1 0","explanation":"Descending"},{"input":"[1]","expectedOutput":"0","explanation":"Single element"}]}]'),GM=JSON.parse(`[{"id":"math1","title":"Fibonacci Series","description":"Print first n Fibonacci numbers.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid fibonacci(int n) {}\\nint main() { fibonacci(10); return 0; }","expectedOutput":"0 1 1 2 3 5 8 13 21 34","solution":"#include <iostream>\\nusing namespace std;\\nvoid fibonacci(int n) { int a=0, b=1; for(int i=0;i<n;i++) { cout<<a<<\\" \\"; int c=a+b; a=b; b=c; } }\\nint main() { fibonacci(10); return 0; }","explanation":{"approach":"Each number is sum of previous two.","steps":["Start with 0, 1","Each next = sum of previous two"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"n=10","expectedOutput":"0 1 1 2 3 5 8 13 21 34","explanation":"First 10 Fibonacci"},{"input":"n=1","expectedOutput":"0","explanation":"Just first number"},{"input":"n=5","expectedOutput":"0 1 1 2 3","explanation":"First 5"},{"input":"n=7","expectedOutput":"0 1 1 2 3 5 8","explanation":"First 7"}]},{"id":"math2","title":"Pascal's Triangle Row","description":"Generate nth row of Pascal's triangle.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid pascalRow(int n) {}\\nint main() { pascalRow(5); return 0; }","expectedOutput":"1 4 6 4 1","solution":"#include <iostream>\\nusing namespace std;\\nvoid pascalRow(int n) { int c=1; for(int i=0;i<n;i++) { cout<<c<<\\" \\"; c=c*(n-1-i)/(i+1); } }\\nint main() { pascalRow(5); return 0; }","explanation":{"approach":"Compute binomial coefficients iteratively.","steps":["Start with 1","Multiply by (n-1-i)/(i+1)"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"n=5","expectedOutput":"1 4 6 4 1","explanation":"5th row (1-indexed)"},{"input":"n=1","expectedOutput":"1","explanation":"First row"},{"input":"n=3","expectedOutput":"1 2 1","explanation":"Third row"},{"input":"n=6","expectedOutput":"1 5 10 10 5 1","explanation":"Sixth row"}]},{"id":"math3","title":"Catalan Number","description":"Calculate nth Catalan number.","difficulty":"MEDIUM","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nlong long catalan(int n) { return 0; }\\nint main() { cout<<catalan(5); return 0; }","expectedOutput":"42","solution":"#include <iostream>\\nusing namespace std;\\nlong long catalan(int n) { long long dp[n+1]={}; dp[0]=dp[1]=1; for(int i=2;i<=n;i++) for(int j=0;j<i;j++) dp[i]+=dp[j]*dp[i-1-j]; return dp[n]; }\\nint main() { cout<<catalan(5); return 0; }","explanation":{"approach":"Dynamic programming: C(n) = sum of C(i) * C(n-1-i).","steps":["Base: C(0)=C(1)=1","Sum all splits for larger n"],"complexity":"Time: O(n), Space: O(n)"},"testCases":[{"input":"n=5","expectedOutput":"42","explanation":"5th Catalan number"},{"input":"n=0","expectedOutput":"1","explanation":"C(0)=1"},{"input":"n=3","expectedOutput":"5","explanation":"C(3)=5"},{"input":"n=4","expectedOutput":"14","explanation":"C(4)=14"}]},{"id":"math4","title":"nCr Calculation","description":"Calculate binomial coefficient n choose r.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nlong long nCr(int n, int r) { return 0; }\\nint main() { cout<<nCr(10,3); return 0; }","expectedOutput":"120","solution":"#include <iostream>\\nusing namespace std;\\nlong long nCr(int n, int r) { if(r>n-r) r=n-r; long long res=1; for(int i=0;i<r;i++) { res*=(n-i); res/=(i+1); } return res; }\\nint main() { cout<<nCr(10,3); return 0; }","explanation":{"approach":"Compute nCr = n!/(r!(n-r)!) iteratively.","steps":["Use smaller of r, n-r","Multiply/divide progressively"],"complexity":"Time: O(r), Space: O(1)"},"testCases":[{"input":"n=10, r=3","expectedOutput":"120","explanation":"10!/(3!*7!)=120"},{"input":"n=5, r=2","expectedOutput":"10","explanation":"5!/(2!*3!)=10"},{"input":"n=6, r=0","expectedOutput":"1","explanation":"Choose 0 = 1 way"},{"input":"n=4, r=4","expectedOutput":"1","explanation":"Choose all = 1 way"}]},{"id":"math5","title":"Power Set Size","description":"Calculate number of subsets of n elements.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nint powerSetSize(int n) { return 0; }\\nint main() { cout<<powerSetSize(4); return 0; }","expectedOutput":"16","solution":"#include <iostream>\\nusing namespace std;\\nint powerSetSize(int n) { return 1<<n; }\\nint main() { cout<<powerSetSize(4); return 0; }","explanation":{"approach":"Power set has 2^n subsets.","steps":["Each element: include or exclude","Total = 2^n"],"complexity":"Time: O(1), Space: O(1)"},"testCases":[{"input":"n=4","expectedOutput":"16","explanation":"2^4=16 subsets"},{"input":"n=0","expectedOutput":"1","explanation":"Empty set has 1 subset"},{"input":"n=3","expectedOutput":"8","explanation":"2^3=8"},{"input":"n=10","expectedOutput":"1024","explanation":"2^10=1024"}]},{"id":"math6","title":"Count Set Bits 1 to N","description":"Count total set bits in all numbers from 1 to n.","difficulty":"MEDIUM","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nint countSetBits(int n) { return 0; }\\nint main() { cout<<countSetBits(7); return 0; }","expectedOutput":"12","solution":"#include <iostream>\\nusing namespace std;\\nint countSetBits(int n) { int total=0; for(int i=1;i<=n;i++) { int x=i; while(x) { total+=x&1; x>>=1; } } return total; }\\nint main() { cout<<countSetBits(7); return 0; }","explanation":{"approach":"Count bits in each number and sum.","steps":["For each 1 to n","Count its set bits","Sum all"],"complexity":"Time: O(n log n), Space: O(1)"},"testCases":[{"input":"n=7","expectedOutput":"12","explanation":"1+1+2+1+2+2+3=12"},{"input":"n=4","expectedOutput":"5","explanation":"1+1+2+1=5"},{"input":"n=1","expectedOutput":"1","explanation":"Just 1"},{"input":"n=3","expectedOutput":"4","explanation":"1+1+2=4"}]},{"id":"math7","title":"Sum of Multiples","description":"Sum all multiples of 3 or 5 below n.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nint sumMultiples(int n) { return 0; }\\nint main() { cout<<sumMultiples(10); return 0; }","expectedOutput":"23","solution":"#include <iostream>\\nusing namespace std;\\nint sumMultiples(int n) { int sum=0; for(int i=1;i<n;i++) if(i%3==0||i%5==0) sum+=i; return sum; }\\nint main() { cout<<sumMultiples(10); return 0; }","explanation":{"approach":"Check each number for divisibility by 3 or 5.","steps":["For each i < n","Add if divisible by 3 or 5"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"n=10","expectedOutput":"23","explanation":"3+5+6+9=23"},{"input":"n=20","expectedOutput":"78","explanation":"Sum of 3,5,6,9,10,12,15,18"},{"input":"n=6","expectedOutput":"8","explanation":"3+5=8"},{"input":"n=16","expectedOutput":"60","explanation":"Multiples below 16"}]},{"id":"math8","title":"Digital Root","description":"Find single-digit sum of all digits (repeated).","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nint digitalRoot(int n) { return 0; }\\nint main() { cout<<digitalRoot(12345); return 0; }","expectedOutput":"6","solution":"#include <iostream>\\nusing namespace std;\\nint digitalRoot(int n) { if(n==0) return 0; return 1+(n-1)%9; }\\nint main() { cout<<digitalRoot(12345); return 0; }","explanation":{"approach":"Formula: 1 + (n-1) mod 9.","steps":["Keep summing digits until single digit","Or use mod 9 trick"],"complexity":"Time: O(1), Space: O(1)"},"testCases":[{"input":"n=12345","expectedOutput":"6","explanation":"1+2+3+4+5=15, 1+5=6"},{"input":"n=9","expectedOutput":"9","explanation":"Already single digit"},{"input":"n=99","expectedOutput":"9","explanation":"9+9=18, 1+8=9"},{"input":"n=38","expectedOutput":"2","explanation":"3+8=11, 1+1=2"}]},{"id":"math9","title":"Trailing Zeros in Factorial","description":"Count trailing zeros in n factorial.","difficulty":"EASY","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nint trailingZeros(int n) { return 0; }\\nint main() { cout<<trailingZeros(25); return 0; }","expectedOutput":"6","solution":"#include <iostream>\\nusing namespace std;\\nint trailingZeros(int n) { int c=0; while(n>=5) { n/=5; c+=n; } return c; }\\nint main() { cout<<trailingZeros(25); return 0; }","explanation":{"approach":"Count factors of 5 (plenty of 2s available).","steps":["Count n/5 + n/25 + n/125 + ..."],"complexity":"Time: O(log n), Space: O(1)"},"testCases":[{"input":"n=25","expectedOutput":"6","explanation":"25/5+25/25=5+1=6"},{"input":"n=10","expectedOutput":"2","explanation":"10/5=2"},{"input":"n=100","expectedOutput":"24","explanation":"20+4=24"},{"input":"n=5","expectedOutput":"1","explanation":"5/5=1"}]},{"id":"math10","title":"Smallest Prime Factor","description":"Find smallest prime factor for each number 0 to n.","difficulty":"MEDIUM","category":"Math","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid smallestPrimeFactor(int n) {}\\nint main() { smallestPrimeFactor(10); return 0; }","expectedOutput":"0 1 2 3 2 5 2 7 2 3 2","solution":"#include <iostream>\\nusing namespace std;\\nvoid smallestPrimeFactor(int n) { int spf[n+1]; for(int i=0;i<=n;i++) spf[i]=i; for(int i=2;i*i<=n;i++) if(spf[i]==i) for(int j=i*i;j<=n;j+=i) if(spf[j]==j) spf[j]=i; for(int i=0;i<=n;i++) cout<<spf[i]<<\\" \\"; }\\nint main() { smallestPrimeFactor(10); return 0; }","explanation":{"approach":"Sieve-like approach to find SPF.","steps":["Initialize spf[i] = i","For each prime, mark multiples"],"complexity":"Time: O(n log log n), Space: O(n)"},"testCases":[{"input":"n=10","expectedOutput":"0 1 2 3 2 5 2 7 2 3 2","explanation":"SPF for 0-10"},{"input":"n=5","expectedOutput":"0 1 2 3 2 5","explanation":"SPF for 0-5"},{"input":"n=15","expectedOutput":"0 1 2 3 2 5 2 7 2 3 2 11 2 13 2 3","explanation":"SPF for 0-15"},{"input":"n=1","expectedOutput":"0 1","explanation":"Just 0 and 1"}]}]`),VM=JSON.parse(`[{"id":"ds1","title":"Stack using Array","description":"Implement basic stack operations with array.","difficulty":"EASY","category":"Data Structures","starterCode":"#include <iostream>\\nusing namespace std;\\nclass Stack { int a[100], t; public: Stack():t(-1){} void push(int x){} int pop(){return -1;} int top(){return -1;} bool empty(){return true;} };\\nint main() { Stack s; s.push(1); s.push(2); cout<<s.top()<<\\" \\"; s.pop(); cout<<s.top(); return 0; }","expectedOutput":"2 1","solution":"#include <iostream>\\nusing namespace std;\\nclass Stack { int a[100], t; public: Stack():t(-1){} void push(int x){a[++t]=x;} int pop(){return a[t--];} int top(){return a[t];} bool empty(){return t==-1;} };\\nint main() { Stack s; s.push(1); s.push(2); cout<<s.top()<<\\" \\"; s.pop(); cout<<s.top(); return 0; }","explanation":{"approach":"Array with top pointer, LIFO behavior.","steps":["push: increment top, store","pop: return and decrement top"],"complexity":"Time: O(1) all ops, Space: O(n)"},"testCases":[{"input":"push(1), push(2), top(), pop(), top()","expectedOutput":"2 1","explanation":"LIFO order"},{"input":"push(5), top()","expectedOutput":"5","explanation":"Single element"},{"input":"push(1), push(2), push(3), pop(), pop(), top()","expectedOutput":"1","explanation":"Multiple pops"},{"input":"empty() on new stack","expectedOutput":"true","explanation":"Initial state is empty"}]},{"id":"ds2","title":"Queue using Array","description":"Implement basic queue operations with array.","difficulty":"EASY","category":"Data Structures","starterCode":"#include <iostream>\\nusing namespace std;\\nclass Queue { int a[100], f, r; public: Queue():f(0),r(-1){} void enqueue(int x){} int dequeue(){return -1;} int front(){return -1;} bool empty(){return true;} };\\nint main() { Queue q; q.enqueue(1); q.enqueue(2); cout<<q.front()<<\\" \\"; q.dequeue(); cout<<q.front(); return 0; }","expectedOutput":"1 2","solution":"#include <iostream>\\nusing namespace std;\\nclass Queue { int a[100], f, r; public: Queue():f(0),r(-1){} void enqueue(int x){a[++r]=x;} int dequeue(){return a[f++];} int front(){return a[f];} bool empty(){return f>r;} };\\nint main() { Queue q; q.enqueue(1); q.enqueue(2); cout<<q.front()<<\\" \\"; q.dequeue(); cout<<q.front(); return 0; }","explanation":{"approach":"Array with front and rear pointers, FIFO.","steps":["enqueue: add at rear","dequeue: remove from front"],"complexity":"Time: O(1) all ops, Space: O(n)"},"testCases":[{"input":"enqueue(1), enqueue(2), front(), dequeue(), front()","expectedOutput":"1 2","explanation":"FIFO order"},{"input":"enqueue(5), front()","expectedOutput":"5","explanation":"Single element"},{"input":"enqueue(1), enqueue(2), enqueue(3), dequeue(), front()","expectedOutput":"2","explanation":"After one dequeue"},{"input":"empty() on new queue","expectedOutput":"true","explanation":"Initial state is empty"}]},{"id":"ds3","title":"Linked List Insert","description":"Insert element at end of linked list.","difficulty":"EASY","category":"Data Structures","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int val; Node* next; Node(int x):val(x),next(0){} };\\nNode* insert(Node* head, int x) { return nullptr; }\\nint main() { Node* h=nullptr; h=insert(h,1); h=insert(h,2); h=insert(h,3); Node* t=h; while(t) { cout<<t->val<<\\" \\"; t=t->next; } return 0; }","expectedOutput":"1 2 3","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int val; Node* next; Node(int x):val(x),next(0){} };\\nNode* insert(Node* head, int x) { Node* n=new Node(x); if(!head) return n; Node* t=head; while(t->next) t=t->next; t->next=n; return head; }\\nint main() { Node* h=nullptr; h=insert(h,1); h=insert(h,2); h=insert(h,3); Node* t=h; while(t) { cout<<t->val<<\\" \\"; t=t->next; } return 0; }","explanation":{"approach":"Traverse to end, link new node.","steps":["Create new node","Find last node","Link new node"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"insert 1,2,3","expectedOutput":"1 2 3","explanation":"Insertion order preserved"},{"input":"insert to empty list","expectedOutput":"5","explanation":"First becomes head"},{"input":"insert 10,20","expectedOutput":"10 20","explanation":"Two elements"},{"input":"insert 1,1,1","expectedOutput":"1 1 1","explanation":"Duplicates allowed"}]},{"id":"ds4","title":"Linked List Delete","description":"Delete node with given value from linked list.","difficulty":"EASY","category":"Data Structures","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int val; Node* next; Node(int x):val(x),next(0){} };\\nNode* deleteNode(Node* head, int x) { return nullptr; }\\nint main() { Node* h=new Node(1); h->next=new Node(2); h->next->next=new Node(3); h=deleteNode(h,2); Node* t=h; while(t) { cout<<t->val<<\\" \\"; t=t->next; } return 0; }","expectedOutput":"1 3","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int val; Node* next; Node(int x):val(x),next(0){} };\\nNode* deleteNode(Node* head, int x) { if(!head) return nullptr; if(head->val==x) return head->next; Node* t=head; while(t->next && t->next->val!=x) t=t->next; if(t->next) t->next=t->next->next; return head; }\\nint main() { Node* h=new Node(1); h->next=new Node(2); h->next->next=new Node(3); h=deleteNode(h,2); Node* t=h; while(t) { cout<<t->val<<\\" \\"; t=t->next; } return 0; }","explanation":{"approach":"Find predecessor, skip target node.","steps":["Find node before target","Skip target node"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"1->2->3, delete 2","expectedOutput":"1 3","explanation":"Middle deletion"},{"input":"1->2->3, delete 1","expectedOutput":"2 3","explanation":"Head deletion"},{"input":"1->2->3, delete 3","expectedOutput":"1 2","explanation":"Tail deletion"},{"input":"1->2->3, delete 5","expectedOutput":"1 2 3","explanation":"Not found, no change"}]},{"id":"ds5","title":"Reverse Linked List","description":"Reverse a singly linked list in-place.","difficulty":"EASY","category":"Data Structures","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int val; Node* next; Node(int x):val(x),next(0){} };\\nNode* reverse(Node* head) { return nullptr; }\\nint main() { Node* h=new Node(1); h->next=new Node(2); h->next->next=new Node(3); h=reverse(h); Node* t=h; while(t) { cout<<t->val<<\\" \\"; t=t->next; } return 0; }","expectedOutput":"3 2 1","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int val; Node* next; Node(int x):val(x),next(0){} };\\nNode* reverse(Node* head) { Node* prev=nullptr, *cur=head; while(cur) { Node* next=cur->next; cur->next=prev; prev=cur; cur=next; } return prev; }\\nint main() { Node* h=new Node(1); h->next=new Node(2); h->next->next=new Node(3); h=reverse(h); Node* t=h; while(t) { cout<<t->val<<\\" \\"; t=t->next; } return 0; }","explanation":{"approach":"Iteratively reverse each link.","steps":["Track previous","Reverse current's next","Move forward"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"1->2->3","expectedOutput":"3 2 1","explanation":"Full reversal"},{"input":"1->2","expectedOutput":"2 1","explanation":"Two elements"},{"input":"1","expectedOutput":"1","explanation":"Single element unchanged"},{"input":"null (empty list)","expectedOutput":"null","explanation":"Empty list stays empty"}]},{"id":"ds6","title":"Detect Cycle in List","description":"Check if linked list has a cycle.","difficulty":"MEDIUM","category":"Data Structures","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int val; Node* next; Node(int x):val(x),next(0){} };\\nbool hasCycle(Node* head) { return false; }\\nint main() { Node* h=new Node(1); h->next=new Node(2); h->next->next=new Node(3); h->next->next->next=h->next; cout<<hasCycle(h); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int val; Node* next; Node(int x):val(x),next(0){} };\\nbool hasCycle(Node* head) { Node* s=head, *f=head; while(f && f->next) { s=s->next; f=f->next->next; if(s==f) return true; } return false; }\\nint main() { Node* h=new Node(1); h->next=new Node(2); h->next->next=new Node(3); h->next->next->next=h->next; cout<<hasCycle(h); return 0; }","explanation":{"approach":"Floyd's cycle detection - slow and fast pointers.","steps":["Slow moves 1 step","Fast moves 2 steps","If they meet, cycle exists"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"List with cycle","expectedOutput":"1","explanation":"Cycle detected"},{"input":"1->2->3 (no cycle)","expectedOutput":"0","explanation":"No cycle"},{"input":"Self-loop: 1->1","expectedOutput":"1","explanation":"Single node cycle"},{"input":"Empty list","expectedOutput":"0","explanation":"No cycle in empty"}]},{"id":"ds7","title":"Valid Parentheses","description":"Check if brackets are balanced.","difficulty":"EASY","category":"Data Structures","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isValid(char s[]) { return false; }\\nint main() { cout<<isValid(\\"([{}])\\"); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isValid(char s[]) { char stk[100]; int t=-1; for(int i=0;s[i];i++) { if(s[i]=='('||s[i]=='['||s[i]=='{') stk[++t]=s[i]; else { if(t<0) return false; if(s[i]==')' && stk[t]!='(') return false; if(s[i]==']' && stk[t]!='[') return false; if(s[i]=='}' && stk[t]!='{') return false; t--; } } return t==-1; }\\nint main() { cout<<isValid(\\"([{}])\\"); return 0; }","explanation":{"approach":"Stack to match opening and closing brackets.","steps":["Push opening brackets","Pop and match closing","Stack empty at end = valid"],"complexity":"Time: O(n), Space: O(n)"},"testCases":[{"input":"([{}])","expectedOutput":"1","explanation":"Nested valid"},{"input":"()[]{}","expectedOutput":"1","explanation":"Sequential valid"},{"input":"(]","expectedOutput":"0","explanation":"Mismatched"},{"input":"(()","expectedOutput":"0","explanation":"Unclosed bracket"}]},{"id":"ds8","title":"Min Stack","description":"Stack with O(1) getMin operation.","difficulty":"MEDIUM","category":"Data Structures","starterCode":"#include <iostream>\\nusing namespace std;\\nclass MinStack { public: void push(int x){} void pop(){} int top(){return 0;} int getMin(){return 0;} };\\nint main() { MinStack s; s.push(5); s.push(2); s.push(3); cout<<s.getMin(); return 0; }","expectedOutput":"2","solution":"#include <iostream>\\nusing namespace std;\\nclass MinStack { int a[100], m[100], t; public: MinStack():t(-1){} void push(int x){a[++t]=x; m[t]=t==0?x:min(x,m[t-1]);} void pop(){t--;} int top(){return a[t];} int getMin(){return m[t];} };\\nint main() { MinStack s; s.push(5); s.push(2); s.push(3); cout<<s.getMin(); return 0; }","explanation":{"approach":"Auxiliary stack tracking min at each level.","steps":["Track min at each push","Min updates automatically on pop"],"complexity":"Time: O(1) all ops, Space: O(n)"},"testCases":[{"input":"push(5,2,3), getMin()","expectedOutput":"2","explanation":"Min is 2"},{"input":"push(1,2,3), getMin()","expectedOutput":"1","explanation":"First is min"},{"input":"push(3,2,1), pop(), getMin()","expectedOutput":"2","explanation":"After pop, new min"},{"input":"push(2,2,2), getMin()","expectedOutput":"2","explanation":"All same"}]},{"id":"ds9","title":"Implement Queue using Stacks","description":"Queue implemented with two stacks.","difficulty":"MEDIUM","category":"Data Structures","starterCode":"#include <iostream>\\nusing namespace std;\\nclass MyQueue { int s1[100], s2[100], t1, t2; public: MyQueue():t1(-1),t2(-1){} void push(int x){} int pop(){return 0;} };\\nint main() { MyQueue q; q.push(1); q.push(2); cout<<q.pop()<<\\" \\"<<q.pop(); return 0; }","expectedOutput":"1 2","solution":"#include <iostream>\\nusing namespace std;\\nclass MyQueue { int s1[100], s2[100], t1, t2; public: MyQueue():t1(-1),t2(-1){} void push(int x){s1[++t1]=x;} int pop(){ if(t2<0) while(t1>=0) s2[++t2]=s1[t1--]; return s2[t2--]; } };\\nint main() { MyQueue q; q.push(1); q.push(2); cout<<q.pop()<<\\" \\"<<q.pop(); return 0; }","explanation":{"approach":"Push to s1, pop from s2 (transfer when empty).","steps":["Push always to s1","Pop from s2, refill from s1 if empty"],"complexity":"Time: O(1) amortized, Space: O(n)"},"testCases":[{"input":"push(1,2), pop(), pop()","expectedOutput":"1 2","explanation":"FIFO order"},{"input":"push(1), pop(), push(2), pop()","expectedOutput":"1 2","explanation":"Interleaved ops"},{"input":"push(5), pop()","expectedOutput":"5","explanation":"Single element"},{"input":"push(1,2,3), pop(), pop(), pop()","expectedOutput":"1 2 3","explanation":"Three elements"}]},{"id":"ds10","title":"Implement Stack using Queues","description":"Stack implemented with queues.","difficulty":"MEDIUM","category":"Data Structures","starterCode":"#include <iostream>\\nusing namespace std;\\n#include <queue>\\nclass MyStack { queue<int> q; public: void push(int x){} int pop(){return 0;} };\\nint main() { MyStack s; s.push(1); s.push(2); cout<<s.pop()<<\\" \\"<<s.pop(); return 0; }","expectedOutput":"2 1","solution":"#include <iostream>\\nusing namespace std;\\n#include <queue>\\nclass MyStack { queue<int> q; public: void push(int x){ q.push(x); for(int i=0;i<q.size()-1;i++){q.push(q.front());q.pop();} } int pop(){ int t=q.front(); q.pop(); return t; } };\\nint main() { MyStack s; s.push(1); s.push(2); cout<<s.pop()<<\\" \\"<<s.pop(); return 0; }","explanation":{"approach":"After push, rotate to put new element at front.","steps":["Push to queue","Rotate n-1 elements to back"],"complexity":"Time: O(n) push, O(1) pop, Space: O(n)"},"testCases":[{"input":"push(1,2), pop(), pop()","expectedOutput":"2 1","explanation":"LIFO order"},{"input":"push(5), pop()","expectedOutput":"5","explanation":"Single element"},{"input":"push(1,2,3), pop()","expectedOutput":"3","explanation":"Last pushed = first popped"},{"input":"push(1), push(2), pop(), push(3), pop()","expectedOutput":"2 3","explanation":"Mixed operations"}]}]`),WM=JSON.parse(`[{"id":"final1","title":"Rotate Matrix 90","description":"Rotate matrix clockwise.","difficulty":"MEDIUM","category":"Matrix","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid rotate(int m[][3], int n) {}\\nint main() { int m[3][3]={{1,2,3},{4,5,6},{7,8,9}}; rotate(m,3); for(int i=0;i<3;i++) { for(int j=0;j<3;j++) cout<<m[i][j]<<\\" \\"; } return 0; }","expectedOutput":"7 4 1 8 5 2 9 6 3","solution":"#include <iostream>\\nusing namespace std;\\nvoid rotate(int m[][3], int n) { for(int i=0;i<n;i++) for(int j=i;j<n;j++) swap(m[i][j],m[j][i]); for(int i=0;i<n;i++) for(int j=0;j<n/2;j++) swap(m[i][j],m[i][n-1-j]); }\\nint main() { int m[3][3]={{1,2,3},{4,5,6},{7,8,9}}; rotate(m,3); for(int i=0;i<3;i++) { for(int j=0;j<3;j++) cout<<m[i][j]<<\\" \\"; } return 0; }","explanation":{"approach":"Transpose then reverse each row.","analogy":"Flip diagonally, then mirror horizontally.","steps":["Transpose matrix","Reverse each row"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"{{1,2,3},{4,5,6},{7,8,9}}","expectedOutput":"7 4 1 8 5 2 9 6 3","explanation":"3x3 matrix rotated 90 degrees clockwise"},{"input":"{{1}}","expectedOutput":"1","explanation":"Single element matrix remains unchanged"},{"input":"{{1,2},{3,4}}","expectedOutput":"3 1 4 2","explanation":"2x2 matrix rotation"},{"input":"{{1,2,3,4},{5,6,7,8},{9,10,11,12},{13,14,15,16}}","expectedOutput":"13 9 5 1 14 10 6 2 15 11 7 3 16 12 8 4","explanation":"4x4 matrix rotation"}]},{"id":"final2","title":"Spiral Matrix","description":"Print matrix in spiral.","difficulty":"MEDIUM","category":"Matrix","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid spiral(int m[][4], int r, int c) {}\\nint main() { int m[3][4]={{1,2,3,4},{5,6,7,8},{9,10,11,12}}; spiral(m,3,4); return 0; }","expectedOutput":"1 2 3 4 8 12 11 10 9 5 6 7","solution":"#include <iostream>\\nusing namespace std;\\nvoid spiral(int m[][4], int r, int c) { int t=0,b=r-1,l=0,ri=c-1; while(t<=b && l<=ri) { for(int i=l;i<=ri;i++) cout<<m[t][i]<<\\" \\"; t++; for(int i=t;i<=b;i++) cout<<m[i][ri]<<\\" \\"; ri--; if(t<=b) { for(int i=ri;i>=l;i--) cout<<m[b][i]<<\\" \\"; b--; } if(l<=ri) { for(int i=b;i>=t;i--) cout<<m[i][l]<<\\" \\"; l++; } } }\\nint main() { int m[3][4]={{1,2,3,4},{5,6,7,8},{9,10,11,12}}; spiral(m,3,4); return 0; }","explanation":{"approach":"Track boundaries, shrink after each layer.","analogy":"Peel the onion layer by layer.","steps":["Go right, down, left, up","Shrink boundaries","Repeat"],"complexity":"Time: O(rc), Space: O(1)"},"testCases":[{"input":"{{1,2,3,4},{5,6,7,8},{9,10,11,12}}","expectedOutput":"1 2 3 4 8 12 11 10 9 5 6 7","explanation":"3x4 matrix spiral traversal"},{"input":"{{1,2,3},{4,5,6},{7,8,9}}","expectedOutput":"1 2 3 6 9 8 7 4 5","explanation":"3x3 matrix spiral traversal"},{"input":"{{1}}","expectedOutput":"1","explanation":"Single element matrix"},{"input":"{{1,2,3,4}}","expectedOutput":"1 2 3 4","explanation":"Single row matrix"}]},{"id":"final3","title":"Set Matrix Zeros","description":"Set row and col to 0.","difficulty":"MEDIUM","category":"Matrix","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid setZeroes(int m[][3], int r, int c) {}\\nint main() { int m[3][3]={{1,1,1},{1,0,1},{1,1,1}}; setZeroes(m,3,3); for(int i=0;i<3;i++) for(int j=0;j<3;j++) cout<<m[i][j]<<\\" \\"; return 0; }","expectedOutput":"1 0 1 0 0 0 1 0 1","solution":"#include <iostream>\\nusing namespace std;\\nvoid setZeroes(int m[][3], int r, int c) { bool r0=false, c0=false; for(int i=0;i<r;i++) if(m[i][0]==0) c0=true; for(int j=0;j<c;j++) if(m[0][j]==0) r0=true; for(int i=1;i<r;i++) for(int j=1;j<c;j++) if(m[i][j]==0) { m[i][0]=0; m[0][j]=0; } for(int i=1;i<r;i++) for(int j=1;j<c;j++) if(m[i][0]==0||m[0][j]==0) m[i][j]=0; if(c0) for(int i=0;i<r;i++) m[i][0]=0; if(r0) for(int j=0;j<c;j++) m[0][j]=0; }\\nint main() { int m[3][3]={{1,1,1},{1,0,1},{1,1,1}}; setZeroes(m,3,3); for(int i=0;i<3;i++) for(int j=0;j<3;j++) cout<<m[i][j]<<\\" \\"; return 0; }","explanation":{"approach":"Use first row/col as markers.","analogy":"Mark rows and cols to zero later.","steps":["Mark first row/col","Use them as flags","Set zeros based on flags"],"complexity":"Time: O(rc), Space: O(1)"},"testCases":[{"input":"{{1,1,1},{1,0,1},{1,1,1}}","expectedOutput":"1 0 1 0 0 0 1 0 1","explanation":"Zero at center sets entire row and column to zero"},{"input":"{{0,1,1},{1,1,1},{1,1,1}}","expectedOutput":"0 0 0 0 1 1 0 1 1","explanation":"Zero at corner sets first row and column to zero"},{"input":"{{1,1,1},{1,1,1},{1,1,1}}","expectedOutput":"1 1 1 1 1 1 1 1 1","explanation":"No zeros in matrix - no change"},{"input":"{{0,0,0},{0,0,0},{0,0,0}}","expectedOutput":"0 0 0 0 0 0 0 0 0","explanation":"All zeros remain zeros"}]},{"id":"final4","title":"Sudoku Validator","description":"Check valid sudoku.","difficulty":"MEDIUM","category":"Matrix","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isValidSudoku(int b[][9]) { return false; }\\nint main() { int b[9][9]={{5,3,0,0,7,0,0,0,0},{6,0,0,1,9,5,0,0,0},{0,9,8,0,0,0,0,6,0},{8,0,0,0,6,0,0,0,3},{4,0,0,8,0,3,0,0,1},{7,0,0,0,2,0,0,0,6},{0,6,0,0,0,0,2,8,0},{0,0,0,4,1,9,0,0,5},{0,0,0,0,8,0,0,7,9}}; cout<<isValidSudoku(b); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isValidSudoku(int b[][9]) { for(int i=0;i<9;i++) { int r[10]={}, c[10]={}; for(int j=0;j<9;j++) { if(b[i][j] && r[b[i][j]]++) return false; if(b[j][i] && c[b[j][i]]++) return false; } } for(int bi=0;bi<3;bi++) for(int bj=0;bj<3;bj++) { int s[10]={}; for(int i=0;i<3;i++) for(int j=0;j<3;j++) if(b[bi*3+i][bj*3+j] && s[b[bi*3+i][bj*3+j]]++) return false; } return true; }\\nint main() { int b[9][9]={{5,3,0,0,7,0,0,0,0},{6,0,0,1,9,5,0,0,0},{0,9,8,0,0,0,0,6,0},{8,0,0,0,6,0,0,0,3},{4,0,0,8,0,3,0,0,1},{7,0,0,0,2,0,0,0,6},{0,6,0,0,0,0,2,8,0},{0,0,0,4,1,9,0,0,5},{0,0,0,0,8,0,0,7,9}}; cout<<isValidSudoku(b); return 0; }","explanation":{"approach":"Check rows, cols, and 33 boxes.","analogy":"No repeats in any row, col, or box.","steps":["Check each row","Check each column","Check each 33 box"],"complexity":"Time: O(1), Space: O(1)"},"testCases":[{"input":"Valid partial sudoku","expectedOutput":"1","explanation":"No duplicate digits in any row, column, or 3x3 box"},{"input":"Duplicate in row","expectedOutput":"0","explanation":"Same digit appears twice in one row"},{"input":"Duplicate in 3x3 box","expectedOutput":"0","explanation":"Same digit appears twice in one 3x3 sub-box"},{"input":"Empty sudoku","expectedOutput":"1","explanation":"All zeros is technically valid"}]},{"id":"final5","title":"Word Break","description":"Can string be segmented.","difficulty":"MEDIUM","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nbool wordBreak(char s[], char dict[][10], int n) { return false; }\\nint main() { char dict[][10]={\\"leet\\",\\"code\\"}; cout<<wordBreak(\\"leetcode\\",dict,2); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool wordBreak(char s[], char dict[][10], int n) { int len=0; while(s[len]) len++; bool dp[len+1]={}; dp[0]=true; for(int i=1;i<=len;i++) for(int j=0;j<i;j++) if(dp[j]) { bool match=false; for(int k=0;k<n;k++) { int wl=0; while(dict[k][wl]) wl++; if(wl==i-j) { bool ok=true; for(int m=0;m<wl;m++) if(s[j+m]!=dict[k][m]) ok=false; if(ok) match=true; } } if(match) dp[i]=true; } return dp[len]; }\\nint main() { char dict[][10]={\\"leet\\",\\"code\\"}; cout<<wordBreak(\\"leetcode\\",dict,2); return 0; }","explanation":{"approach":"dp[i] = can we form s[0..i-1] from dictionary.","analogy":"Build string word by word.","steps":["dp[0] = true (empty string)","For each position, check all words"],"complexity":"Time: O(n  m), Space: O(n)"},"testCases":[{"input":"s=\\"leetcode\\", dict=[\\"leet\\",\\"code\\"]","expectedOutput":"1","explanation":"leetcode can be split into leet + code"},{"input":"s=\\"applepenapple\\", dict=[\\"apple\\",\\"pen\\"]","expectedOutput":"1","explanation":"applepenapple = apple + pen + apple"},{"input":"s=\\"catsandog\\", dict=[\\"cats\\",\\"dog\\",\\"sand\\",\\"and\\",\\"cat\\"]","expectedOutput":"0","explanation":"Cannot be segmented into dictionary words"},{"input":"s=\\"a\\", dict=[\\"a\\"]","expectedOutput":"1","explanation":"Single character match"}]},{"id":"final6","title":"House Robber","description":"Max money without adjacent.","difficulty":"MEDIUM","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint rob(int a[], int n) { return 0; }\\nint main() { int a[]={2,7,9,3,1}; cout<<rob(a,5); return 0; }","expectedOutput":"12","solution":"#include <iostream>\\nusing namespace std;\\nint rob(int a[], int n) { if(n==0) return 0; if(n==1) return a[0]; int prev2=a[0], prev1=max(a[0],a[1]); for(int i=2;i<n;i++) { int cur=max(prev1, prev2+a[i]); prev2=prev1; prev1=cur; } return prev1; }\\nint main() { int a[]={2,7,9,3,1}; cout<<rob(a,5); return 0; }","explanation":{"approach":"Rob current + prev2 OR skip current.","analogy":"Can't rob neighbors.","steps":["Either rob house i + profit from i-2","Or skip house i, keep profit from i-1"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"{2,7,9,3,1}","expectedOutput":"12","explanation":"Rob houses 0,2,4 for 2+9+1=12"},{"input":"{1,2,3,1}","expectedOutput":"4","explanation":"Rob houses 0 and 2 for 1+3=4"},{"input":"{2,1,1,2}","expectedOutput":"4","explanation":"Rob houses 0 and 3 for 2+2=4"},{"input":"{100}","expectedOutput":"100","explanation":"Single house - rob it"}]},{"id":"final7","title":"Unique Paths","description":"Paths in grid.","difficulty":"MEDIUM","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint uniquePaths(int m, int n) { return 0; }\\nint main() { cout<<uniquePaths(3,7); return 0; }","expectedOutput":"28","solution":"#include <iostream>\\nusing namespace std;\\nint uniquePaths(int m, int n) { int dp[m][n]; for(int i=0;i<m;i++) for(int j=0;j<n;j++) dp[i][j]=(i==0||j==0)?1:dp[i-1][j]+dp[i][j-1]; return dp[m-1][n-1]; }\\nint main() { cout<<uniquePaths(3,7); return 0; }","explanation":{"approach":"dp[i][j] = paths from top or left.","analogy":"Can only come from above or left.","steps":["First row and col have 1 path each","Others = sum of top + left"],"complexity":"Time: O(mn), Space: O(mn)"},"testCases":[{"input":"m=3, n=7","expectedOutput":"28","explanation":"3x7 grid has 28 unique paths to bottom-right"},{"input":"m=3, n=2","expectedOutput":"3","explanation":"3x2 grid has 3 unique paths"},{"input":"m=1, n=1","expectedOutput":"1","explanation":"1x1 grid has only 1 path (already there)"},{"input":"m=5, n=5","expectedOutput":"70","explanation":"5x5 grid has C(8,4) = 70 paths"}]},{"id":"final8","title":"Decode Ways","description":"Ways to decode number string.","difficulty":"MEDIUM","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint numDecodings(char s[]) { return 0; }\\nint main() { cout<<numDecodings(\\"226\\"); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nint numDecodings(char s[]) { int n=0; while(s[n]) n++; if(n==0||s[0]=='0') return 0; int dp[n+1]={}; dp[0]=1; dp[1]=1; for(int i=2;i<=n;i++) { if(s[i-1]!='0') dp[i]=dp[i-1]; int two=(s[i-2]-'0')*10+(s[i-1]-'0'); if(two>=10&&two<=26) dp[i]+=dp[i-2]; } return dp[n]; }\\nint main() { cout<<numDecodings(\\"226\\"); return 0; }","explanation":{"approach":"1 digit or 2 digit decode.","analogy":"Like Fibonacci with constraints.","steps":["Single digit: 1-9 valid","Two digits: 10-26 valid"],"complexity":"Time: O(n), Space: O(n)"},"testCases":[{"input":"226","expectedOutput":"3","explanation":"Can decode as 2,2,6 or 22,6 or 2,26"},{"input":"12","expectedOutput":"2","explanation":"Can decode as 1,2 or 12"},{"input":"06","expectedOutput":"0","explanation":"Leading zero makes it invalid"},{"input":"11106","expectedOutput":"2","explanation":"1,1,10,6 or 11,10,6"}]},{"id":"final9","title":"Jump Game","description":"Can reach last index.","difficulty":"MEDIUM","category":"Greedy","starterCode":"#include <iostream>\\nusing namespace std;\\nbool canJump(int a[], int n) { return false; }\\nint main() { int a[]={2,3,1,1,4}; cout<<canJump(a,5); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool canJump(int a[], int n) { int reach=0; for(int i=0;i<n;i++) { if(i>reach) return false; reach=max(reach, i+a[i]); } return true; }\\nint main() { int a[]={2,3,1,1,4}; cout<<canJump(a,5); return 0; }","explanation":{"approach":"Track farthest reachable position.","analogy":"Greedy - always update max reach.","steps":["Update max reachable","If current > max reach, impossible"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"{2,3,1,1,4}","expectedOutput":"1","explanation":"Can jump 1->2->last or 1->3->last"},{"input":"{3,2,1,0,4}","expectedOutput":"0","explanation":"Stuck at index 3 with jump length 0"},{"input":"{0}","expectedOutput":"1","explanation":"Already at last index"},{"input":"{1,1,1,1,1}","expectedOutput":"1","explanation":"Can reach end step by step"}]},{"id":"final10","title":"Product Except Self","description":"Product of all except current.","difficulty":"MEDIUM","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid productExceptSelf(int a[], int n) {}\\nint main() { int a[]={1,2,3,4}; productExceptSelf(a,4); return 0; }","expectedOutput":"24 12 8 6","solution":"#include <iostream>\\nusing namespace std;\\nvoid productExceptSelf(int a[], int n) { int res[n]; res[0]=1; for(int i=1;i<n;i++) res[i]=res[i-1]*a[i-1]; int right=1; for(int i=n-1;i>=0;i--) { res[i]*=right; right*=a[i]; } for(int i=0;i<n;i++) cout<<res[i]<<\\" \\"; }\\nint main() { int a[]={1,2,3,4}; productExceptSelf(a,4); return 0; }","explanation":{"approach":"Left products  right products.","analogy":"Prefix and suffix products.","steps":["Calculate prefix products","Multiply by suffix products"],"complexity":"Time: O(n), Space: O(n)"},"testCases":[{"input":"{1,2,3,4}","expectedOutput":"24 12 8 6","explanation":"Each position has product of all other elements"},{"input":"{-1,1,0,-3,3}","expectedOutput":"0 0 9 0 0","explanation":"Zero makes all products 0 except at index 2"},{"input":"{2,3}","expectedOutput":"3 2","explanation":"Simple swap of products"},{"input":"{1,1,1,1}","expectedOutput":"1 1 1 1","explanation":"All ones produce all ones"}]}]`),KM=JSON.parse(`[{"id":"fin11","title":"Longest Common Prefix","description":"Find common prefix.","difficulty":"EASY","category":"Strings","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid longestCommonPrefix(char strs[][20], int n) {}\\nint main() { char strs[][20]={\\"flower\\",\\"flow\\",\\"flight\\"}; longestCommonPrefix(strs,3); return 0; }","expectedOutput":"fl","solution":"#include <iostream>\\nusing namespace std;\\nvoid longestCommonPrefix(char strs[][20], int n) { if(n==0) return; for(int i=0;strs[0][i];i++) { for(int j=1;j<n;j++) if(strs[j][i]!=strs[0][i]) { strs[0][i]=0; cout<<strs[0]; return; } } cout<<strs[0]; }\\nint main() { char strs[][20]={\\"flower\\",\\"flow\\",\\"flight\\"}; longestCommonPrefix(strs,3); return 0; }","explanation":{"approach":"Compare char by char.","analogy":"Stop at first mismatch.","steps":["For each position","Check all strings match"],"complexity":"Time: O(S), Space: O(1)"},"testCases":[{"input":"[\\"flower\\",\\"flow\\",\\"flight\\"]","expectedOutput":"fl","explanation":"Common prefix is 'fl'"},{"input":"[\\"dog\\",\\"racecar\\",\\"car\\"]","expectedOutput":"","explanation":"No common prefix"},{"input":"[\\"interview\\",\\"internet\\",\\"internal\\"]","expectedOutput":"inter","explanation":"Common prefix is 'inter'"},{"input":"[\\"abc\\"]","expectedOutput":"abc","explanation":"Single string is its own prefix"}]},{"id":"fin12","title":"Valid Anagram","description":"Check if anagram.","difficulty":"EASY","category":"Strings","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isAnagram(char s[], char t[]) { return false; }\\nint main() { cout<<isAnagram(\\"anagram\\",\\"nagaram\\"); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isAnagram(char s[], char t[]) { int c[26]={}; for(int i=0;s[i];i++) c[s[i]-'a']++; for(int i=0;t[i];i++) c[t[i]-'a']--; for(int i=0;i<26;i++) if(c[i]!=0) return false; return true; }\\nint main() { cout<<isAnagram(\\"anagram\\",\\"nagaram\\"); return 0; }","explanation":{"approach":"Count characters.","analogy":"Same letters, same counts.","steps":["Count s, subtract t","All counts should be 0"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"s=\\"anagram\\", t=\\"nagaram\\"","expectedOutput":"1","explanation":"Both have same letters"},{"input":"s=\\"rat\\", t=\\"car\\"","expectedOutput":"0","explanation":"Different letters"},{"input":"s=\\"listen\\", t=\\"silent\\"","expectedOutput":"1","explanation":"Classic anagram pair"},{"input":"s=\\"ab\\", t=\\"a\\"","expectedOutput":"0","explanation":"Different lengths"}]},{"id":"fin13","title":"Remove Duplicates II","description":"Allow at most 2 duplicates.","difficulty":"MEDIUM","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nint removeDuplicates(int a[], int n) { return 0; }\\nint main() { int a[]={1,1,1,2,2,3}; int k=removeDuplicates(a,6); for(int i=0;i<k;i++) cout<<a[i]<<\\" \\"; return 0; }","expectedOutput":"1 1 2 2 3","solution":"#include <iostream>\\nusing namespace std;\\nint removeDuplicates(int a[], int n) { if(n<=2) return n; int j=2; for(int i=2;i<n;i++) if(a[i]!=a[j-2]) a[j++]=a[i]; return j; }\\nint main() { int a[]={1,1,1,2,2,3}; int k=removeDuplicates(a,6); for(int i=0;i<k;i++) cout<<a[i]<<\\" \\"; return 0; }","explanation":{"approach":"Two pointers, check 2 back.","analogy":"Allow 2 of same.","steps":["Compare with element 2 positions back","Copy if different"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"{1,1,1,2,2,3}","expectedOutput":"1 1 2 2 3","explanation":"Keep at most 2 of each"},{"input":"{0,0,1,1,1,1,2,3,3}","expectedOutput":"0 0 1 1 2 3 3","explanation":"Multiple duplicates handled"},{"input":"{1,2,3}","expectedOutput":"1 2 3","explanation":"No duplicates to remove"},{"input":"{1,1}","expectedOutput":"1 1","explanation":"Exactly 2 allowed"}]},{"id":"fin14","title":"Search in Rotated","description":"Binary search in rotated array.","difficulty":"MEDIUM","category":"Binary Search","starterCode":"#include <iostream>\\nusing namespace std;\\nint search(int a[], int n, int t) { return -1; }\\nint main() { int a[]={4,5,6,7,0,1,2}; cout<<search(a,7,0); return 0; }","expectedOutput":"4","solution":"#include <iostream>\\nusing namespace std;\\nint search(int a[], int n, int t) { int l=0,r=n-1; while(l<=r) { int m=(l+r)/2; if(a[m]==t) return m; if(a[l]<=a[m]) { if(t>=a[l]&&t<a[m]) r=m-1; else l=m+1; } else { if(t>a[m]&&t<=a[r]) l=m+1; else r=m-1; } } return -1; }\\nint main() { int a[]={4,5,6,7,0,1,2}; cout<<search(a,7,0); return 0; }","explanation":{"approach":"Check which half is sorted.","analogy":"One half is always sorted.","steps":["Find which half is sorted","Check if target is in that half"],"complexity":"Time: O(log n), Space: O(1)"},"testCases":[{"input":"a={4,5,6,7,0,1,2}, t=0","expectedOutput":"4","explanation":"0 is at index 4"},{"input":"a={4,5,6,7,0,1,2}, t=3","expectedOutput":"-1","explanation":"3 not in array"},{"input":"a={1}, t=1","expectedOutput":"0","explanation":"Single element found"},{"input":"a={2,1}, t=1","expectedOutput":"1","explanation":"Two element rotated array"}]},{"id":"fin15","title":"Find Minimum Rotated","description":"Min in rotated sorted array.","difficulty":"MEDIUM","category":"Binary Search","starterCode":"#include <iostream>\\nusing namespace std;\\nint findMin(int a[], int n) { return 0; }\\nint main() { int a[]={3,4,5,1,2}; cout<<findMin(a,5); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nint findMin(int a[], int n) { int l=0,r=n-1; while(l<r) { int m=(l+r)/2; if(a[m]>a[r]) l=m+1; else r=m; } return a[l]; }\\nint main() { int a[]={3,4,5,1,2}; cout<<findMin(a,5); return 0; }","explanation":{"approach":"Binary search for pivot.","analogy":"Min is at rotation point.","steps":["If mid > right, min is in right half","Else min is in left half (including mid)"],"complexity":"Time: O(log n), Space: O(1)"},"testCases":[{"input":"{3,4,5,1,2}","expectedOutput":"1","explanation":"Minimum is 1 after rotation"},{"input":"{4,5,6,7,0,1,2}","expectedOutput":"0","explanation":"Minimum is 0"},{"input":"{1,2,3,4,5}","expectedOutput":"1","explanation":"Not rotated, first element is min"},{"input":"{2,1}","expectedOutput":"1","explanation":"Two element array"}]},{"id":"fin16","title":"Product Except Self","description":"Product of all except self.","difficulty":"MEDIUM","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid productExceptSelf(int a[], int n) {}\\nint main() { int a[]={1,2,3,4}; productExceptSelf(a,4); return 0; }","expectedOutput":"24 12 8 6","solution":"#include <iostream>\\nusing namespace std;\\nvoid productExceptSelf(int a[], int n) { int res[n]; res[0]=1; for(int i=1;i<n;i++) res[i]=res[i-1]*a[i-1]; int right=1; for(int i=n-1;i>=0;i--) { res[i]*=right; right*=a[i]; } for(int i=0;i<n;i++) cout<<res[i]<<\\" \\"; }\\nint main() { int a[]={1,2,3,4}; productExceptSelf(a,4); return 0; }","explanation":{"approach":"Left and right products.","analogy":"Prefix  suffix products.","steps":["Build left products","Multiply by right products"],"complexity":"Time: O(n), Space: O(n)"},"testCases":[{"input":"{1,2,3,4}","expectedOutput":"24 12 8 6","explanation":"Each = product of others"},{"input":"{2,3,4,5}","expectedOutput":"60 40 30 24","explanation":"Example with no 1s"},{"input":"{1,1,1,1}","expectedOutput":"1 1 1 1","explanation":"All ones"},{"input":"{-1,1,-1,1}","expectedOutput":"-1 1 -1 1","explanation":"Mixed signs"}]},{"id":"fin17","title":"Maximum Subarray","description":"Max contiguous sum.","difficulty":"MEDIUM","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint maxSubArray(int a[], int n) { return 0; }\\nint main() { int a[]={-2,1,-3,4,-1,2,1,-5,4}; cout<<maxSubArray(a,9); return 0; }","expectedOutput":"6","solution":"#include <iostream>\\nusing namespace std;\\nint maxSubArray(int a[], int n) { int mx=a[0],cur=a[0]; for(int i=1;i<n;i++) { cur=max(a[i],cur+a[i]); mx=max(mx,cur); } return mx; }\\nint main() { int a[]={-2,1,-3,4,-1,2,1,-5,4}; cout<<maxSubArray(a,9); return 0; }","explanation":{"approach":"Kadane's algorithm.","analogy":"Extend or start fresh.","steps":["cur = max(a[i], cur+a[i])","Track overall max"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"{-2,1,-3,4,-1,2,1,-5,4}","expectedOutput":"6","explanation":"Subarray [4,-1,2,1] = 6"},{"input":"{1}","expectedOutput":"1","explanation":"Single element"},{"input":"{-1,-2,-3}","expectedOutput":"-1","explanation":"All negative, pick least negative"},{"input":"{5,4,-1,7,8}","expectedOutput":"23","explanation":"Entire array is max"}]},{"id":"fin18","title":"Container With Water","description":"Max water between lines.","difficulty":"MEDIUM","category":"Two Pointers","starterCode":"#include <iostream>\\nusing namespace std;\\nint maxArea(int h[], int n) { return 0; }\\nint main() { int h[]={1,8,6,2,5,4,8,3,7}; cout<<maxArea(h,9); return 0; }","expectedOutput":"49","solution":"#include <iostream>\\nusing namespace std;\\nint maxArea(int h[], int n) { int l=0,r=n-1,mx=0; while(l<r) { mx=max(mx,min(h[l],h[r])*(r-l)); if(h[l]<h[r]) l++; else r--; } return mx; }\\nint main() { int h[]={1,8,6,2,5,4,8,3,7}; cout<<maxArea(h,9); return 0; }","explanation":{"approach":"Two pointers, move shorter.","analogy":"Move smaller wall inward.","steps":["Calculate area","Move smaller side"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"{1,8,6,2,5,4,8,3,7}","expectedOutput":"49","explanation":"Between indices 1 and 8"},{"input":"{1,1}","expectedOutput":"1","explanation":"Min container"},{"input":"{4,3,2,1,4}","expectedOutput":"16","explanation":"First and last lines"},{"input":"{1,2,1}","expectedOutput":"2","explanation":"Edges form container"}]},{"id":"fin19","title":"Merge Intervals","description":"Merge overlapping intervals.","difficulty":"MEDIUM","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid mergeIntervals(int a[][2], int n) {}\\nint main() { int a[][2]={{1,3},{2,6},{8,10},{15,18}}; mergeIntervals(a,4); return 0; }","expectedOutput":"1-6 8-10 15-18","solution":"#include <iostream>\\nusing namespace std;\\nvoid mergeIntervals(int a[][2], int n) { for(int i=0;i<n-1;i++) for(int j=0;j<n-i-1;j++) if(a[j][0]>a[j+1][0]) { swap(a[j][0],a[j+1][0]); swap(a[j][1],a[j+1][1]); } int res[n][2], k=0; res[0][0]=a[0][0]; res[0][1]=a[0][1]; for(int i=1;i<n;i++) { if(a[i][0]<=res[k][1]) res[k][1]=max(res[k][1],a[i][1]); else { k++; res[k][0]=a[i][0]; res[k][1]=a[i][1]; } } for(int i=0;i<=k;i++) cout<<res[i][0]<<\\"-\\"<<res[i][1]<<\\" \\"; }\\nint main() { int a[][2]={{1,3},{2,6},{8,10},{15,18}}; mergeIntervals(a,4); return 0; }","explanation":{"approach":"Sort and merge overlapping.","analogy":"Combine overlapping ranges.","steps":["Sort by start","Merge if overlap"],"complexity":"Time: O(n log n), Space: O(n)"},"testCases":[{"input":"{{1,3},{2,6},{8,10},{15,18}}","expectedOutput":"1-6 8-10 15-18","explanation":"[1,3] and [2,6] merge"},{"input":"{{1,4},{4,5}}","expectedOutput":"1-5","explanation":"Adjacent intervals merge"},{"input":"{{1,4},{0,4}}","expectedOutput":"0-4","explanation":"Overlapping from start"},{"input":"{{1,4},{2,3}}","expectedOutput":"1-4","explanation":"One interval inside another"}]},{"id":"fin20","title":"Insert Interval","description":"Insert and merge interval.","difficulty":"MEDIUM","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid insertInterval(int a[][2], int n, int newI[]) {}\\nint main() { int a[][2]={{1,3},{6,9}}; int newI[]={2,5}; insertInterval(a,2,newI); return 0; }","expectedOutput":"1-5 6-9","solution":"#include <iostream>\\nusing namespace std;\\nvoid insertInterval(int a[][2], int n, int newI[]) { int res[n+1][2], k=0, i=0; while(i<n && a[i][1]<newI[0]) { res[k][0]=a[i][0]; res[k++][1]=a[i++][1]; } while(i<n && a[i][0]<=newI[1]) { newI[0]=min(newI[0],a[i][0]); newI[1]=max(newI[1],a[i++][1]); } res[k][0]=newI[0]; res[k++][1]=newI[1]; while(i<n) { res[k][0]=a[i][0]; res[k++][1]=a[i++][1]; } for(int j=0;j<k;j++) cout<<res[j][0]<<\\"-\\"<<res[j][1]<<\\" \\"; }\\nint main() { int a[][2]={{1,3},{6,9}}; int newI[]={2,5}; insertInterval(a,2,newI); return 0; }","explanation":{"approach":"Three phases: before, merge, after.","analogy":"Insert at right spot, merge overlaps.","steps":["Copy non-overlapping before","Merge overlapping","Copy non-overlapping after"],"complexity":"Time: O(n), Space: O(n)"},"testCases":[{"input":"{{1,3},{6,9}}, new={2,5}","expectedOutput":"1-5 6-9","explanation":"New interval merges with first"},{"input":"{{1,2},{3,5},{6,7}}, new={4,8}","expectedOutput":"1-2 3-8","explanation":"Merges multiple intervals"},{"input":"{}, new={5,7}","expectedOutput":"5-7","explanation":"Insert into empty list"},{"input":"{{1,5}}, new={2,3}","expectedOutput":"1-5","explanation":"New interval contained within existing"}]}]`),XM=JSON.parse(`[{"id":"fin21","title":"Climbing Stairs Memoized","description":"Ways to climb n stairs with memo.","difficulty":"EASY","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint climbStairs(int n) { return 0; }\\nint main() { cout<<climbStairs(10); return 0; }","expectedOutput":"89","solution":"#include <iostream>\\nusing namespace std;\\nint dp[100];\\nint solve(int n) { if(n<=1) return 1; if(dp[n]) return dp[n]; return dp[n]=solve(n-1)+solve(n-2); }\\nint climbStairs(int n) { for(int i=0;i<100;i++) dp[i]=0; return solve(n); }\\nint main() { cout<<climbStairs(10); return 0; }","explanation":{"approach":"DP with memoization.","analogy":"Cache computed results.","steps":["If computed, return cached","Else compute and cache"],"complexity":"Time: O(n), Space: O(n)"},"testCases":[{"input":"n=10","expectedOutput":"89","explanation":"Fibonacci pattern: 89 ways to climb 10 stairs"},{"input":"n=2","expectedOutput":"2","explanation":"Either 1+1 or 2 steps"},{"input":"n=5","expectedOutput":"8","explanation":"8 different ways to climb 5 stairs"},{"input":"n=1","expectedOutput":"1","explanation":"Only one way to climb 1 stair"}]},{"id":"fin22","title":"Min Cost Climbing Stairs","description":"Min cost to reach top.","difficulty":"EASY","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint minCostClimbing(int cost[], int n) { return 0; }\\nint main() { int cost[]={10,15,20}; cout<<minCostClimbing(cost,3); return 0; }","expectedOutput":"15","solution":"#include <iostream>\\nusing namespace std;\\nint minCostClimbing(int cost[], int n) { int dp[n+1]={}; for(int i=2;i<=n;i++) dp[i]=min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2]); return dp[n]; }\\nint main() { int cost[]={10,15,20}; cout<<minCostClimbing(cost,3); return 0; }","explanation":{"approach":"DP - min cost at each step.","analogy":"From step i-1 or i-2.","steps":["dp[i] = min cost to reach step i"],"complexity":"Time: O(n), Space: O(n)"},"testCases":[{"input":"{10,15,20}","expectedOutput":"15","explanation":"Pay 15 to step on index 1, then jump to top"},{"input":"{1,100,1,1,1,100,1,1,100,1}","expectedOutput":"6","explanation":"Optimal path avoids 100s"},{"input":"{0,0,0}","expectedOutput":"0","explanation":"All free steps"},{"input":"{10,15}","expectedOutput":"10","explanation":"Start at 0, pay 10, jump to top"}]},{"id":"fin23","title":"Number of 1 Bits","description":"Count set bits.","difficulty":"EASY","category":"Bits","starterCode":"#include <iostream>\\nusing namespace std;\\nint hammingWeight(unsigned int n) { return 0; }\\nint main() { cout<<hammingWeight(11); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nint hammingWeight(unsigned int n) { int c=0; while(n) { c+=n&1; n>>=1; } return c; }\\nint main() { cout<<hammingWeight(11); return 0; }","explanation":{"approach":"Count LSB, shift right.","analogy":"Pop off bits one by one.","steps":["Add n&1 to count","Shift right"],"complexity":"Time: O(log n), Space: O(1)"},"testCases":[{"input":"n=11 (1011 in binary)","expectedOutput":"3","explanation":"Binary 1011 has three 1s"},{"input":"n=128 (10000000)","expectedOutput":"1","explanation":"Power of 2 has one 1"},{"input":"n=255 (11111111)","expectedOutput":"8","explanation":"All 8 bits set"},{"input":"n=0","expectedOutput":"0","explanation":"Zero has no 1 bits"}]},{"id":"fin24","title":"Counting Bits","description":"Count bits for 0 to n.","difficulty":"EASY","category":"Bits","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid countBits(int n) {}\\nint main() { countBits(5); return 0; }","expectedOutput":"0 1 1 2 1 2","solution":"#include <iostream>\\nusing namespace std;\\nvoid countBits(int n) { int dp[n+1]; dp[0]=0; for(int i=1;i<=n;i++) dp[i]=dp[i>>1]+(i&1); for(int i=0;i<=n;i++) cout<<dp[i]<<\\" \\"; }\\nint main() { countBits(5); return 0; }","explanation":{"approach":"DP using i/2.","analogy":"bits(i) = bits(i/2) + last bit.","steps":["dp[i] = dp[i>>1] + (i&1)"],"complexity":"Time: O(n), Space: O(n)"},"testCases":[{"input":"n=5","expectedOutput":"0 1 1 2 1 2","explanation":"0=0,1=1,2=1,3=2,4=1,5=2 ones"},{"input":"n=2","expectedOutput":"0 1 1","explanation":"0,1,2 have 0,1,1 bits"},{"input":"n=0","expectedOutput":"0","explanation":"Only zero"},{"input":"n=8","expectedOutput":"0 1 1 2 1 2 2 3 1","explanation":"Bits for 0-8"}]},{"id":"fin25","title":"Reverse Bits","description":"Reverse 32-bit integer.","difficulty":"EASY","category":"Bits","starterCode":"#include <iostream>\\nusing namespace std;\\nunsigned int reverseBits(unsigned int n) { return 0; }\\nint main() { cout<<reverseBits(43261596); return 0; }","expectedOutput":"964176192","solution":"#include <iostream>\\nusing namespace std;\\nunsigned int reverseBits(unsigned int n) { unsigned int r=0; for(int i=0;i<32;i++) { r=(r<<1)|(n&1); n>>=1; } return r; }\\nint main() { cout<<reverseBits(43261596); return 0; }","explanation":{"approach":"Build reversed bit by bit.","analogy":"Take LSB, put in result MSB position.","steps":["Get LSB of n","Put in result","Shift both"],"complexity":"Time: O(32), Space: O(1)"},"testCases":[{"input":"43261596","expectedOutput":"964176192","explanation":"Binary reversed"},{"input":"1","expectedOutput":"2147483648","explanation":"LSB becomes MSB"},{"input":"0","expectedOutput":"0","explanation":"Zero reversed is zero"},{"input":"4294967295","expectedOutput":"4294967295","explanation":"All 1s reversed is still all 1s"}]},{"id":"fin26","title":"Missing Number","description":"Find missing in 0 to n.","difficulty":"EASY","category":"Bits","starterCode":"#include <iostream>\\nusing namespace std;\\nint missingNumber(int a[], int n) { return 0; }\\nint main() { int a[]={3,0,1}; cout<<missingNumber(a,3); return 0; }","expectedOutput":"2","solution":"#include <iostream>\\nusing namespace std;\\nint missingNumber(int a[], int n) { int x=n; for(int i=0;i<n;i++) x^=i^a[i]; return x; }\\nint main() { int a[]={3,0,1}; cout<<missingNumber(a,3); return 0; }","explanation":{"approach":"XOR all indices and values.","analogy":"Pairs cancel out.","steps":["XOR n and all i and a[i]","Missing number remains"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"{3,0,1}","expectedOutput":"2","explanation":"0,1,3 present, 2 is missing"},{"input":"{0,1}","expectedOutput":"2","explanation":"0,1 present, 2 is missing"},{"input":"{9,6,4,2,3,5,7,0,1}","expectedOutput":"8","explanation":"8 is missing from 0-9"},{"input":"{0}","expectedOutput":"1","explanation":"Only 0 present, 1 is missing"}]},{"id":"fin27","title":"Sum of Two Integers","description":"Add without + or -.","difficulty":"MEDIUM","category":"Bits","starterCode":"#include <iostream>\\nusing namespace std;\\nint getSum(int a, int b) { return 0; }\\nint main() { cout<<getSum(5,3); return 0; }","expectedOutput":"8","solution":"#include <iostream>\\nusing namespace std;\\nint getSum(int a, int b) { while(b) { int c=(unsigned)(a&b)<<1; a=a^b; b=c; } return a; }\\nint main() { cout<<getSum(5,3); return 0; }","explanation":{"approach":"XOR for sum, AND for carry.","analogy":"Binary addition manually.","steps":["XOR = sum without carry","AND<<1 = carry","Repeat until no carry"],"complexity":"Time: O(32), Space: O(1)"},"testCases":[{"input":"a=5, b=3","expectedOutput":"8","explanation":"5+3=8 using bit operations"},{"input":"a=2, b=3","expectedOutput":"5","explanation":"2+3=5"},{"input":"a=-2, b=3","expectedOutput":"1","explanation":"Works with negatives too"},{"input":"a=0, b=0","expectedOutput":"0","explanation":"0+0=0"}]},{"id":"fin28","title":"House Robber II","description":"Circular house robber.","difficulty":"MEDIUM","category":"DP","starterCode":"#include <iostream>\\nusing namespace std;\\nint rob(int a[], int n) { return 0; }\\nint main() { int a[]={2,3,2}; cout<<rob(a,3); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nint robRange(int a[], int l, int r) { int p=0,c=0; for(int i=l;i<=r;i++) { int t=max(c,p+a[i]); p=c; c=t; } return c; }\\nint rob(int a[], int n) { if(n==1) return a[0]; return max(robRange(a,0,n-2),robRange(a,1,n-1)); }\\nint main() { int a[]={2,3,2}; cout<<rob(a,3); return 0; }","explanation":{"approach":"Two cases: skip first or last.","analogy":"Circle means first and last are adjacent.","steps":["Rob houses 0 to n-2","Or rob houses 1 to n-1","Return max"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"{2,3,2}","expectedOutput":"3","explanation":"Rob house 1 only, can't rob adjacent 0 and 2"},{"input":"{1,2,3,1}","expectedOutput":"4","explanation":"Rob houses 0 and 2 for 1+3=4"},{"input":"{1}","expectedOutput":"1","explanation":"Single house, rob it"},{"input":"{1,2}","expectedOutput":"2","explanation":"Rob the larger house"}]},{"id":"fin29","title":"Palindrome Linked List","description":"Check if list is palindrome.","difficulty":"EASY","category":"Linked List","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node* n; Node(int x):v(x),n(0){} };\\nbool isPalindrome(Node* h) { return false; }\\nint main() { Node* h=new Node(1); h->n=new Node(2); h->n->n=new Node(2); h->n->n->n=new Node(1); cout<<isPalindrome(h); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node* n; Node(int x):v(x),n(0){} };\\nNode* rev(Node* h) { Node* p=0; while(h) { Node* t=h->n; h->n=p; p=h; h=t; } return p; }\\nbool isPalindrome(Node* h) { Node* s=h,*f=h; while(f&&f->n) { s=s->n; f=f->n->n; } s=rev(s); while(s) { if(h->v!=s->v) return false; h=h->n; s=s->n; } return true; }\\nint main() { Node* h=new Node(1); h->n=new Node(2); h->n->n=new Node(2); h->n->n->n=new Node(1); cout<<isPalindrome(h); return 0; }","explanation":{"approach":"Reverse second half, compare.","analogy":"Compare first half with reversed second.","steps":["Find middle","Reverse second half","Compare"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"1->2->2->1","expectedOutput":"1","explanation":"Reads same forwards and backwards"},{"input":"1->2","expectedOutput":"0","explanation":"Not a palindrome"},{"input":"1->2->1","expectedOutput":"1","explanation":"Odd length palindrome"},{"input":"1","expectedOutput":"1","explanation":"Single element is palindrome"}]},{"id":"fin30","title":"Linked List Cycle","description":"Detect cycle in list.","difficulty":"EASY","category":"Linked List","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node* n; Node(int x):v(x),n(0){} };\\nbool hasCycle(Node* h) { return false; }\\nint main() { Node* h=new Node(3); h->n=new Node(2); h->n->n=new Node(0); h->n->n->n=new Node(-4); h->n->n->n->n=h->n; cout<<hasCycle(h); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node* n; Node(int x):v(x),n(0){} };\\nbool hasCycle(Node* h) { Node* s=h,*f=h; while(f&&f->n) { s=s->n; f=f->n->n; if(s==f) return true; } return false; }\\nint main() { Node* h=new Node(3); h->n=new Node(2); h->n->n=new Node(0); h->n->n->n=new Node(-4); h->n->n->n->n=h->n; cout<<hasCycle(h); return 0; }","explanation":{"approach":"Floyd's tortoise and hare.","analogy":"Fast catches slow if cycle exists.","steps":["Slow moves 1, fast moves 2","If they meet, cycle exists"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"3->2->0->-4->back to 2","expectedOutput":"1","explanation":"Cycle exists, tail connects to node 2"},{"input":"1->2 (no cycle)","expectedOutput":"0","explanation":"Linear list, no cycle"},{"input":"1->self","expectedOutput":"1","explanation":"Single node pointing to itself"},{"input":"null","expectedOutput":"0","explanation":"Empty list has no cycle"}]}]`),QM=JSON.parse(`[{"id":"fin31","title":"Cycle Start Node","description":"Find where cycle begins.","difficulty":"MEDIUM","category":"Linked List","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node* n; Node(int x):v(x),n(0){} };\\nNode* detectCycle(Node* h) { return nullptr; }\\nint main() { Node* h=new Node(3); h->n=new Node(2); h->n->n=new Node(0); h->n->n->n=new Node(-4); h->n->n->n->n=h->n; Node* r=detectCycle(h); cout<<(r?r->v:-1); return 0; }","expectedOutput":"2","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node* n; Node(int x):v(x),n(0){} };\\nNode* detectCycle(Node* h) { Node* s=h,*f=h; while(f&&f->n) { s=s->n; f=f->n->n; if(s==f) { s=h; while(s!=f) { s=s->n; f=f->n; } return s; } } return 0; }\\nint main() { Node* h=new Node(3); h->n=new Node(2); h->n->n=new Node(0); h->n->n->n=new Node(-4); h->n->n->n->n=h->n; Node* r=detectCycle(h); cout<<(r?r->v:-1); return 0; }","explanation":{"approach":"Floyd's detect, then find start.","analogy":"Reset one pointer to head.","steps":["Detect cycle with fast/slow","Move one to head","Move both by 1, meet at start"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"3->2->0->-4->back to 2","expectedOutput":"2","explanation":"Cycle starts at node with value 2"},{"input":"1->2->back to 1","expectedOutput":"1","explanation":"Cycle starts at head"},{"input":"1 (no cycle)","expectedOutput":"-1","explanation":"No cycle exists"},{"input":"1->2->3->back to 2","expectedOutput":"2","explanation":"Cycle starts at middle node"}]},{"id":"fin32","title":"Reverse Linked List","description":"Reverse entire list.","difficulty":"EASY","category":"Linked List","starterCode":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node* n; Node(int x):v(x),n(0){} };\\nNode* reverseList(Node* h) { return nullptr; }\\nint main() { Node* h=new Node(1); h->n=new Node(2); h->n->n=new Node(3); h->n->n->n=new Node(4); h->n->n->n->n=new Node(5); h=reverseList(h); while(h) { cout<<h->v<<\\" \\"; h=h->n; } return 0; }","expectedOutput":"5 4 3 2 1","solution":"#include <iostream>\\nusing namespace std;\\nstruct Node { int v; Node* n; Node(int x):v(x),n(0){} };\\nNode* reverseList(Node* h) { Node* p=0; while(h) { Node* t=h->n; h->n=p; p=h; h=t; } return p; }\\nint main() { Node* h=new Node(1); h->n=new Node(2); h->n->n=new Node(3); h->n->n->n=new Node(4); h->n->n->n->n=new Node(5); h=reverseList(h); while(h) { cout<<h->v<<\\" \\"; h=h->n; } return 0; }","explanation":{"approach":"Iterative pointer reversal.","analogy":"Flip each arrow.","steps":["Save next","Point current to prev","Move pointers forward"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"1->2->3->4->5","expectedOutput":"5 4 3 2 1","explanation":"Reversed list"},{"input":"1->2","expectedOutput":"2 1","explanation":"Two element list reversed"},{"input":"1","expectedOutput":"1","explanation":"Single element unchanged"},{"input":"null","expectedOutput":"","explanation":"Empty list reversed is empty"}]},{"id":"fin33","title":"Best Time Buy Sell","description":"Max profit one transaction.","difficulty":"EASY","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nint maxProfit(int p[], int n) { return 0; }\\nint main() { int p[]={7,1,5,3,6,4}; cout<<maxProfit(p,6); return 0; }","expectedOutput":"5","solution":"#include <iostream>\\nusing namespace std;\\nint maxProfit(int p[], int n) { int mn=1e9,mx=0; for(int i=0;i<n;i++) { mn=min(mn,p[i]); mx=max(mx,p[i]-mn); } return mx; }\\nint main() { int p[]={7,1,5,3,6,4}; cout<<maxProfit(p,6); return 0; }","explanation":{"approach":"Track min and max profit.","analogy":"Buy low, sell high.","steps":["Track minimum seen","Track max profit so far"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"{7,1,5,3,6,4}","expectedOutput":"5","explanation":"Buy at 1, sell at 6"},{"input":"{7,6,4,3,1}","expectedOutput":"0","explanation":"Prices only decrease, no profit"},{"input":"{1,2,3,4,5}","expectedOutput":"4","explanation":"Buy at 1, sell at 5"},{"input":"{2,4,1}","expectedOutput":"2","explanation":"Buy at 2, sell at 4"}]},{"id":"fin34","title":"Best Time Buy Sell II","description":"Max profit unlimited transactions.","difficulty":"MEDIUM","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nint maxProfit(int p[], int n) { return 0; }\\nint main() { int p[]={7,1,5,3,6,4}; cout<<maxProfit(p,6); return 0; }","expectedOutput":"7","solution":"#include <iostream>\\nusing namespace std;\\nint maxProfit(int p[], int n) { int profit=0; for(int i=1;i<n;i++) if(p[i]>p[i-1]) profit+=p[i]-p[i-1]; return profit; }\\nint main() { int p[]={7,1,5,3,6,4}; cout<<maxProfit(p,6); return 0; }","explanation":{"approach":"Add all positive differences.","analogy":"Capture every upswing.","steps":["If tomorrow higher, buy today sell tomorrow"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"{7,1,5,3,6,4}","expectedOutput":"7","explanation":"(5-1)+(6-3) = 4+3 = 7"},{"input":"{1,2,3,4,5}","expectedOutput":"4","explanation":"Buy at 1, sell at 5 or sum all gains"},{"input":"{7,6,4,3,1}","expectedOutput":"0","explanation":"Always decreasing, no profit"},{"input":"{1,2,3,4,5,1,2,3,4,5}","expectedOutput":"8","explanation":"Two waves of gains"}]},{"id":"fin35","title":"Contains Duplicate","description":"Check if array has duplicates.","difficulty":"EASY","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nbool containsDuplicate(int a[], int n) { return false; }\\nint main() { int a[]={1,2,3,1}; cout<<containsDuplicate(a,4); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool containsDuplicate(int a[], int n) { for(int i=0;i<n;i++) for(int j=i+1;j<n;j++) if(a[i]==a[j]) return true; return false; }\\nint main() { int a[]={1,2,3,1}; cout<<containsDuplicate(a,4); return 0; }","explanation":{"approach":"Check all pairs.","analogy":"Find any match.","steps":["Compare each pair"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"{1,2,3,1}","expectedOutput":"1","explanation":"1 appears twice"},{"input":"{1,2,3,4}","expectedOutput":"0","explanation":"All unique"},{"input":"{1,1,1,3,3,4,3,2,4,2}","expectedOutput":"1","explanation":"Multiple duplicates"},{"input":"{1}","expectedOutput":"0","explanation":"Single element, no duplicate"}]},{"id":"fin36","title":"Single Number","description":"Find element appearing once.","difficulty":"EASY","category":"Bits","starterCode":"#include <iostream>\\nusing namespace std;\\nint singleNumber(int a[], int n) { return 0; }\\nint main() { int a[]={4,1,2,1,2}; cout<<singleNumber(a,5); return 0; }","expectedOutput":"4","solution":"#include <iostream>\\nusing namespace std;\\nint singleNumber(int a[], int n) { int x=0; for(int i=0;i<n;i++) x^=a[i]; return x; }\\nint main() { int a[]={4,1,2,1,2}; cout<<singleNumber(a,5); return 0; }","explanation":{"approach":"XOR all elements.","analogy":"Pairs cancel out.","steps":["XOR cancels duplicates","Single remains"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"{4,1,2,1,2}","expectedOutput":"4","explanation":"4 appears once, others twice"},{"input":"{2,2,1}","expectedOutput":"1","explanation":"1 is the single number"},{"input":"{1}","expectedOutput":"1","explanation":"Only one element"},{"input":"{-1,-1,5}","expectedOutput":"5","explanation":"Works with negative numbers"}]},{"id":"fin37","title":"Majority Element","description":"Element appearing > n/2 times.","difficulty":"EASY","category":"Arrays","starterCode":"#include <iostream>\\nusing namespace std;\\nint majorityElement(int a[], int n) { return 0; }\\nint main() { int a[]={3,2,3}; cout<<majorityElement(a,3); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nint majorityElement(int a[], int n) { int c=0,m=0; for(int i=0;i<n;i++) { if(c==0) m=a[i]; c+=(a[i]==m)?1:-1; } return m; }\\nint main() { int a[]={3,2,3}; cout<<majorityElement(a,3); return 0; }","explanation":{"approach":"Boyer-Moore voting.","analogy":"Cancel different elements.","steps":["If count 0, pick new candidate","Inc if same, dec if different"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"{3,2,3}","expectedOutput":"3","explanation":"3 appears 2 times out of 3"},{"input":"{2,2,1,1,1,2,2}","expectedOutput":"2","explanation":"2 appears 4 times out of 7"},{"input":"{1}","expectedOutput":"1","explanation":"Single element is majority"},{"input":"{6,5,5}","expectedOutput":"5","explanation":"5 appears twice"}]},{"id":"fin38","title":"Valid Parentheses","description":"Check balanced brackets.","difficulty":"EASY","category":"Stack","starterCode":"#include <iostream>\\nusing namespace std;\\nbool isValid(char s[]) { return false; }\\nint main() { cout<<isValid(\\"()[]{}\\"); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool isValid(char s[]) { char stk[100]; int top=-1; for(int i=0;s[i];i++) { if(s[i]=='('||s[i]=='['||s[i]=='{') stk[++top]=s[i]; else { if(top<0) return false; char p=stk[top--]; if((s[i]==')' && p!='(') || (s[i]==']' && p!='[') || (s[i]=='}' && p!='{')) return false; } } return top==-1; }\\nint main() { cout<<isValid(\\"()[]{}\\"); return 0; }","explanation":{"approach":"Stack for matching.","analogy":"Push opens, pop and match closes.","steps":["Push open brackets","Pop and match on close","Stack empty at end"],"complexity":"Time: O(n), Space: O(n)"},"testCases":[{"input":"\\"()[]{}\\"","expectedOutput":"1","explanation":"All brackets properly closed"},{"input":"\\"(]\\"","expectedOutput":"0","explanation":"Mismatched bracket types"},{"input":"\\"([)]\\"","expectedOutput":"0","explanation":"Incorrect nesting order"},{"input":"\\"{[]}\\"","expectedOutput":"1","explanation":"Properly nested"}]},{"id":"fin39","title":"Min Stack","description":"Stack with getMin O(1).","difficulty":"MEDIUM","category":"Stack","starterCode":"#include <iostream>\\nusing namespace std;\\nclass MinStack { public: void push(int x) {} void pop() {} int top() { return 0; } int getMin() { return 0; } };\\nint main() { MinStack s; s.push(-2); s.push(0); s.push(-3); cout<<s.getMin()<<\\" \\"; s.pop(); cout<<s.top()<<\\" \\"<<s.getMin(); return 0; }","expectedOutput":"-3 0 -2","solution":"#include <iostream>\\nusing namespace std;\\nclass MinStack { int stk[100],minStk[100],t,mt; public: MinStack():t(-1),mt(-1){} void push(int x) { stk[++t]=x; if(mt<0||x<=minStk[mt]) minStk[++mt]=x; } void pop() { if(stk[t]==minStk[mt]) mt--; t--; } int top() { return stk[t]; } int getMin() { return minStk[mt]; } };\\nint main() { MinStack s; s.push(-2); s.push(0); s.push(-3); cout<<s.getMin()<<\\" \\"; s.pop(); cout<<s.top()<<\\" \\"<<s.getMin(); return 0; }","explanation":{"approach":"Auxiliary min stack.","analogy":"Track min at each level.","steps":["Push to min stack if <= current min","Pop from min stack if popping min"],"complexity":"Time: O(1), Space: O(n)"},"testCases":[{"input":"push(-2,0,-3), getMin, pop, top, getMin","expectedOutput":"-3 0 -2","explanation":"Min was -3, after pop min is -2"},{"input":"push(1,2,3), getMin","expectedOutput":"1","explanation":"Min is first element"},{"input":"push(3,2,1), pop, getMin","expectedOutput":"2","explanation":"After popping 1, min is 2"},{"input":"push(0,0,0), getMin","expectedOutput":"0","explanation":"All same, min is 0"}]},{"id":"fin40","title":"Evaluate RPN","description":"Evaluate reverse polish notation.","difficulty":"MEDIUM","category":"Stack","starterCode":"#include <iostream>\\nusing namespace std;\\nint evalRPN(char tokens[][10], int n) { return 0; }\\nint main() { char t[][10]={\\"2\\",\\"1\\",\\"+\\",\\"3\\",\\"*\\"}; cout<<evalRPN(t,5); return 0; }","expectedOutput":"9","solution":"#include <iostream>\\nusing namespace std;\\nbool isOp(char c) { return c=='+'||c=='-'||c=='*'||c=='/'; }\\nint evalRPN(char tokens[][10], int n) { int stk[100],top=-1; for(int i=0;i<n;i++) { if(isOp(tokens[i][0]) && !tokens[i][1]) { int b=stk[top--],a=stk[top--]; if(tokens[i][0]=='+') stk[++top]=a+b; else if(tokens[i][0]=='-') stk[++top]=a-b; else if(tokens[i][0]=='*') stk[++top]=a*b; else stk[++top]=a/b; } else { int v=0,neg=0,j=0; if(tokens[i][0]=='-') { neg=1; j=1; } for(;tokens[i][j];j++) v=v*10+(tokens[i][j]-'0'); stk[++top]=neg?-v:v; } } return stk[0]; }\\nint main() { char t[][10]={\\"2\\",\\"1\\",\\"+\\",\\"3\\",\\"*\\"}; cout<<evalRPN(t,5); return 0; }","explanation":{"approach":"Stack for operands.","analogy":"Push numbers, apply operators.","steps":["Push numbers","On operator, pop 2, compute, push result"],"complexity":"Time: O(n), Space: O(n)"},"testCases":[{"input":"[\\"2\\",\\"1\\",\\"+\\",\\"3\\",\\"*\\"]","expectedOutput":"9","explanation":"(2+1)*3 = 9"},{"input":"[\\"4\\",\\"13\\",\\"5\\",\\"/\\",\\"+\\"]","expectedOutput":"6","explanation":"4+(13/5) = 4+2 = 6"},{"input":"[\\"10\\",\\"6\\",\\"9\\",\\"3\\",\\"+\\",\\"-11\\",\\"*\\",\\"/\\",\\"*\\",\\"17\\",\\"+\\",\\"5\\",\\"+\\"]","expectedOutput":"22","explanation":"Complex expression"},{"input":"[\\"3\\",\\"4\\",\\"+\\"]","expectedOutput":"7","explanation":"Simple 3+4=7"}]}]`),JM=JSON.parse(`[{"id":"fin41","title":"Daily Temperatures","description":"Days until warmer temp.","difficulty":"MEDIUM","category":"Stack","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid dailyTemps(int t[], int n) {}\\nint main() { int t[]={73,74,75,71,69,72,76,73}; dailyTemps(t,8); return 0; }","expectedOutput":"1 1 4 2 1 1 0 0","solution":"#include <iostream>\\nusing namespace std;\\nvoid dailyTemps(int t[], int n) { int res[n]={}, stk[n], top=-1; for(int i=n-1;i>=0;i--) { while(top>=0 && t[stk[top]]<=t[i]) top--; res[i]=top<0?0:stk[top]-i; stk[++top]=i; } for(int i=0;i<n;i++) cout<<res[i]<<\\" \\"; }\\nint main() { int t[]={73,74,75,71,69,72,76,73}; dailyTemps(t,8); return 0; }","explanation":{"approach":"Monotonic decreasing stack.","analogy":"Find next greater element.","steps":["Pop while current >= stack top","Difference is days to wait"],"complexity":"Time: O(n), Space: O(n)"},"testCases":[{"input":"{73,74,75,71,69,72,76,73}","expectedOutput":"1 1 4 2 1 1 0 0","explanation":"Days until warmer day for each"},{"input":"{30,40,50,60}","expectedOutput":"1 1 1 0","explanation":"Increasing temps, always 1 day wait except last"},{"input":"{30,60,90}","expectedOutput":"1 1 0","explanation":"Never warmer after 90"},{"input":"{60,50,40,30}","expectedOutput":"0 0 0 0","explanation":"Decreasing temps, never warmer"}]},{"id":"fin42","title":"Next Greater Element","description":"Next larger element.","difficulty":"MEDIUM","category":"Stack","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid nextGreater(int a[], int n) {}\\nint main() { int a[]={4,5,2,25}; nextGreater(a,4); return 0; }","expectedOutput":"5 25 25 -1","solution":"#include <iostream>\\nusing namespace std;\\nvoid nextGreater(int a[], int n) { int res[n], stk[n], top=-1; for(int i=n-1;i>=0;i--) { while(top>=0 && stk[top]<=a[i]) top--; res[i]=top<0?-1:stk[top]; stk[++top]=a[i]; } for(int i=0;i<n;i++) cout<<res[i]<<\\" \\"; }\\nint main() { int a[]={4,5,2,25}; nextGreater(a,4); return 0; }","explanation":{"approach":"Monotonic stack from right.","analogy":"Stack holds candidates.","steps":["Pop while current >= stack top","Top is next greater"],"complexity":"Time: O(n), Space: O(n)"},"testCases":[{"input":"{4,5,2,25}","expectedOutput":"5 25 25 -1","explanation":"Next greater for each element"},{"input":"{13,7,6,12}","expectedOutput":"-1 12 12 -1","explanation":"13 has no greater, 7 and 6 -> 12"},{"input":"{4,3,2,1}","expectedOutput":"-1 -1 -1 -1","explanation":"Decreasing, no next greater exists"},{"input":"{1,2,3,4}","expectedOutput":"2 3 4 -1","explanation":"Each has next as greater"}]},{"id":"fin43","title":"Car Fleet","description":"Count car fleets.","difficulty":"MEDIUM","category":"Stack","starterCode":"#include <iostream>\\nusing namespace std;\\nint carFleet(int target, int pos[], int speed[], int n) { return 0; }\\nint main() { int pos[]={10,8,0,5,3}, speed[]={2,4,1,1,3}; cout<<carFleet(12,pos,speed,5); return 0; }","expectedOutput":"3","solution":"#include <iostream>\\nusing namespace std;\\nint carFleet(int target, int pos[], int speed[], int n) { double time[n]; int idx[n]; for(int i=0;i<n;i++) { idx[i]=i; time[i]=(double)(target-pos[i])/speed[i]; } for(int i=0;i<n-1;i++) for(int j=0;j<n-i-1;j++) if(pos[idx[j]]<pos[idx[j+1]]) { int t=idx[j]; idx[j]=idx[j+1]; idx[j+1]=t; } int fleets=0; double maxTime=-1; for(int i=0;i<n;i++) { if(time[idx[i]]>maxTime) { fleets++; maxTime=time[idx[i]]; } } return fleets; }\\nint main() { int pos[]={10,8,0,5,3}, speed[]={2,4,1,1,3}; cout<<carFleet(12,pos,speed,5); return 0; }","explanation":{"approach":"Sort by position, count fleets.","analogy":"Cars reaching target form fleets.","steps":["Sort by position descending","Count cars with higher arrival time"],"complexity":"Time: O(n log n), Space: O(n)"},"testCases":[{"input":"target=12, pos={10,8,0,5,3}, speed={2,4,1,1,3}","expectedOutput":"3","explanation":"Three car fleets form"},{"input":"target=10, pos={3}, speed={3}","expectedOutput":"1","explanation":"Single car is one fleet"},{"input":"target=100, pos={0,2,4}, speed={4,2,1}","expectedOutput":"1","explanation":"All catch up to form one fleet"},{"input":"target=10, pos={0,4,2}, speed={2,1,3}","expectedOutput":"1","explanation":"All merge into one fleet"}]},{"id":"fin44","title":"Search 2D Matrix II","description":"Search in row/col sorted matrix.","difficulty":"MEDIUM","category":"Matrix","starterCode":"#include <iostream>\\nusing namespace std;\\nbool searchMatrix(int m[][5], int r, int c, int t) { return false; }\\nint main() { int m[][5]={{1,4,7,11,15},{2,5,8,12,19},{3,6,9,16,22},{10,13,14,17,24},{18,21,23,26,30}}; cout<<searchMatrix(m,5,5,5); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nbool searchMatrix(int m[][5], int r, int c, int t) { int i=0,j=c-1; while(i<r && j>=0) { if(m[i][j]==t) return true; if(m[i][j]>t) j--; else i++; } return false; }\\nint main() { int m[][5]={{1,4,7,11,15},{2,5,8,12,19},{3,6,9,16,22},{10,13,14,17,24},{18,21,23,26,30}}; cout<<searchMatrix(m,5,5,5); return 0; }","explanation":{"approach":"Start from top-right corner.","analogy":"Eliminate row or column each step.","steps":["If target < current, go left","If target > current, go down"],"complexity":"Time: O(r+c), Space: O(1)"},"testCases":[{"input":"Matrix 5x5, target=5","expectedOutput":"1","explanation":"5 exists in the matrix"},{"input":"Matrix 5x5, target=20","expectedOutput":"0","explanation":"20 not in matrix"},{"input":"Matrix 5x5, target=1","expectedOutput":"1","explanation":"First element found"},{"input":"Matrix 5x5, target=30","expectedOutput":"1","explanation":"Last element found"}]},{"id":"fin45","title":"Median of Two Sorted","description":"Find median of merged arrays.","difficulty":"HARD","category":"Binary Search","starterCode":"#include <iostream>\\nusing namespace std;\\ndouble findMedian(int a[], int m, int b[], int n) { return 0; }\\nint main() { int a[]={1,3}, b[]={2}; cout<<findMedian(a,2,b,1); return 0; }","expectedOutput":"2","solution":"#include <iostream>\\nusing namespace std;\\ndouble findMedian(int a[], int m, int b[], int n) { if(m>n) return findMedian(b,n,a,m); int lo=0,hi=m,half=(m+n+1)/2; while(lo<=hi) { int i=(lo+hi)/2, j=half-i; int left1=i>0?a[i-1]:-1e9; int right1=i<m?a[i]:1e9; int left2=j>0?b[j-1]:-1e9; int right2=j<n?b[j]:1e9; if(left1<=right2 && left2<=right1) { if((m+n)%2) return max(left1,left2); return (max(left1,left2)+min(right1,right2))/2.0; } if(left1>right2) hi=i-1; else lo=i+1; } return 0; }\\nint main() { int a[]={1,3}, b[]={2}; cout<<findMedian(a,2,b,1); return 0; }","explanation":{"approach":"Binary search on smaller array.","analogy":"Find correct partition.","steps":["Binary search partition in smaller","Derive partition in larger","Check if valid partition"],"complexity":"Time: O(log(min(m,n))), Space: O(1)"},"testCases":[{"input":"a={1,3}, b={2}","expectedOutput":"2","explanation":"Merged: 1,2,3 - median is 2"},{"input":"a={1,2}, b={3,4}","expectedOutput":"2.5","explanation":"Merged: 1,2,3,4 - median is (2+3)/2"},{"input":"a={}, b={1}","expectedOutput":"1","explanation":"Empty first array"},{"input":"a={1,2}, b={1,2}","expectedOutput":"1.5","explanation":"Merged: 1,1,2,2 - median is 1.5"}]},{"id":"fin46","title":"Kth Largest in Stream","description":"Maintain kth largest.","difficulty":"EASY","category":"Heap","starterCode":"#include <iostream>\\nusing namespace std;\\nclass KthLargest { public: KthLargest(int k, int nums[], int n) {} int add(int val) { return 0; } };\\nint main() { int nums[]={4,5,8,2}; KthLargest kl(3,nums,4); cout<<kl.add(3)<<\\" \\"<<kl.add(5); return 0; }","expectedOutput":"4 5","solution":"#include <iostream>\\nusing namespace std;\\nclass KthLargest { int heap[10000],sz,K; void up(int i) { while(i>0 && heap[(i-1)/2]>heap[i]) { swap(heap[(i-1)/2],heap[i]); i=(i-1)/2; } } void down(int i) { while(2*i+1<sz) { int s=2*i+1; if(s+1<sz && heap[s+1]<heap[s]) s++; if(heap[i]<=heap[s]) break; swap(heap[i],heap[s]); i=s; } } public: KthLargest(int k, int nums[], int n) { K=k; sz=0; for(int i=0;i<n;i++) add(nums[i]); } int add(int val) { if(sz<K) { heap[sz++]=val; up(sz-1); } else if(val>heap[0]) { heap[0]=val; down(0); } return heap[0]; } };\\nint main() { int nums[]={4,5,8,2}; KthLargest kl(3,nums,4); cout<<kl.add(3)<<\\" \\"<<kl.add(5); return 0; }","explanation":{"approach":"Min-heap of size k.","analogy":"Keep k largest, return smallest of them.","steps":["Maintain min-heap of k elements","If new > root, replace and heapify"],"complexity":"Time: O(log k), Space: O(k)"},"testCases":[{"input":"k=3, init={4,5,8,2}, add 3, add 5","expectedOutput":"4 5","explanation":"3rd largest after each add"},{"input":"k=1, init={}, add 1","expectedOutput":"1","explanation":"Only element is 1st largest"},{"input":"k=2, init={0}, add 3, add 5","expectedOutput":"0 3","explanation":"Heap grows then updates"},{"input":"k=3, init={1,2,3}, add 4","expectedOutput":"2","explanation":"3rd largest updates"}]},{"id":"fin47","title":"Last Stone Weight","description":"Smash stones until one left.","difficulty":"EASY","category":"Heap","starterCode":"#include <iostream>\\nusing namespace std;\\nint lastStoneWeight(int stones[], int n) { return 0; }\\nint main() { int stones[]={2,7,4,1,8,1}; cout<<lastStoneWeight(stones,6); return 0; }","expectedOutput":"1","solution":"#include <iostream>\\nusing namespace std;\\nint lastStoneWeight(int stones[], int n) { while(n>1) { int m1=0,m2=1; if(stones[m1]<stones[m2]) swap(m1,m2); for(int i=2;i<n;i++) { if(stones[i]>stones[m1]) { m2=m1; m1=i; } else if(stones[i]>stones[m2]) m2=i; } int diff=stones[m1]-stones[m2]; if(m1>m2) { stones[m1]=stones[--n]; stones[m2]=stones[--n]; } else { stones[m2]=stones[--n]; stones[m1]=stones[--n]; } if(diff>0) stones[n++]=diff; } return n?stones[0]:0; }\\nint main() { int stones[]={2,7,4,1,8,1}; cout<<lastStoneWeight(stones,6); return 0; }","explanation":{"approach":"Find two largest, smash.","analogy":"Repeat until one or none left.","steps":["Find two largest","Replace with difference or remove"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"{2,7,4,1,8,1}","expectedOutput":"1","explanation":"After smashing all, 1 remains"},{"input":"{2,2}","expectedOutput":"0","explanation":"Equal stones destroy each other"},{"input":"{1}","expectedOutput":"1","explanation":"Single stone remains"},{"input":"{10,4,2,10}","expectedOutput":"2","explanation":"10-10=0, 4-2=2"}]},{"id":"fin48","title":"K Closest Points","description":"K closest points to origin.","difficulty":"MEDIUM","category":"Heap","starterCode":"#include <iostream>\\nusing namespace std;\\nvoid kClosest(int p[][2], int n, int k) {}\\nint main() { int p[][2]={{1,3},{-2,2},{5,8},{0,1}}; kClosest(p,4,2); return 0; }","expectedOutput":"0,1 -2,2","solution":"#include <iostream>\\nusing namespace std;\\nvoid kClosest(int p[][2], int n, int k) { int dist[n]; for(int i=0;i<n;i++) dist[i]=p[i][0]*p[i][0]+p[i][1]*p[i][1]; for(int i=0;i<k;i++) { int mn=i; for(int j=i+1;j<n;j++) if(dist[j]<dist[mn]) mn=j; swap(dist[i],dist[mn]); swap(p[i][0],p[mn][0]); swap(p[i][1],p[mn][1]); } for(int i=0;i<k;i++) cout<<p[i][0]<<\\",\\"<<p[i][1]<<\\" \\"; }\\nint main() { int p[][2]={{1,3},{-2,2},{5,8},{0,1}}; kClosest(p,4,2); return 0; }","explanation":{"approach":"Partial selection sort.","analogy":"Find k smallest distances.","steps":["Calculate distances","Select k smallest"],"complexity":"Time: O(nk), Space: O(n)"},"testCases":[{"input":"{{1,3},{-2,2},{5,8},{0,1}}, k=2","expectedOutput":"0,1 -2,2","explanation":"Closest 2 points to origin"},{"input":"{{3,3},{5,-1},{-2,4}}, k=2","expectedOutput":"3,3 -2,4","explanation":"Distances: 18, 26, 20"},{"input":"{{1,0}}, k=1","expectedOutput":"1,0","explanation":"Single point"},{"input":"{{0,0},{1,1}}, k=1","expectedOutput":"0,0","explanation":"Origin is closest"}]},{"id":"fin49","title":"Task Scheduler","description":"Min intervals to complete tasks.","difficulty":"MEDIUM","category":"Greedy","starterCode":"#include <iostream>\\nusing namespace std;\\nint leastInterval(char tasks[], int n, int k) { return 0; }\\nint main() { char tasks[]=\\"AAABBB\\"; cout<<leastInterval(tasks,6,2); return 0; }","expectedOutput":"8","solution":"#include <iostream>\\nusing namespace std;\\nint leastInterval(char tasks[], int n, int k) { int freq[26]={}; for(int i=0;i<n;i++) freq[tasks[i]-'A']++; int maxF=0,maxC=0; for(int i=0;i<26;i++) maxF=max(maxF,freq[i]); for(int i=0;i<26;i++) if(freq[i]==maxF) maxC++; int slots=(maxF-1)*(k+1)+maxC; return max(n,slots); }\\nint main() { char tasks[]=\\"AAABBB\\"; cout<<leastInterval(tasks,6,2); return 0; }","explanation":{"approach":"Calculate idle slots needed.","analogy":"Fill gaps between max frequency task.","steps":["Find max frequency","Calculate slots needed","Return max of n and slots"],"complexity":"Time: O(n), Space: O(1)"},"testCases":[{"input":"tasks=AAABBB, k=2","expectedOutput":"8","explanation":"A_B_A_B_AB needs 8 intervals"},{"input":"tasks=AAABBB, k=0","expectedOutput":"6","explanation":"No cooldown, just 6 tasks"},{"input":"tasks=AAAABC, k=2","expectedOutput":"10","explanation":"More idle slots needed"},{"input":"tasks=ABC, k=3","expectedOutput":"3","explanation":"All unique, no wait needed"}]},{"id":"fin50","title":"Design Twitter","description":"Simplified Twitter feed.","difficulty":"MEDIUM","category":"Design","starterCode":"#include <iostream>\\nusing namespace std;\\nclass Twitter { public: void postTweet(int u, int t) {} void getNewsFeed(int u) {} };\\nint main() { Twitter tw; tw.postTweet(1,5); tw.getNewsFeed(1); return 0; }","expectedOutput":"5","solution":"#include <iostream>\\nusing namespace std;\\nclass Twitter { int tweets[100][2], sz; public: Twitter():sz(0){} void postTweet(int u, int t) { tweets[sz][0]=u; tweets[sz++][1]=t; } void getNewsFeed(int u) { int c=0; for(int i=sz-1;i>=0 && c<10;i--) if(tweets[i][0]==u) { cout<<tweets[i][1]<<\\" \\"; c++; } } };\\nint main() { Twitter tw; tw.postTweet(1,5); tw.getNewsFeed(1); return 0; }","explanation":{"approach":"Store tweets with user and timestamp.","analogy":"Simple chronological feed.","steps":["Store (user, tweet) pairs","Return recent 10 from user"],"complexity":"Time: O(n), Space: O(n)"},"testCases":[{"input":"postTweet(1,5), getNewsFeed(1)","expectedOutput":"5","explanation":"User 1's only tweet is 5"},{"input":"postTweet(1,1), postTweet(1,2), getNewsFeed(1)","expectedOutput":"2 1","explanation":"Most recent first"},{"input":"getNewsFeed(1) (no tweets)","expectedOutput":"","explanation":"Empty feed"},{"input":"postTweet(1,10), postTweet(2,20), getNewsFeed(1)","expectedOutput":"10","explanation":"Only user 1's tweets"}]}]`),Oh=[...Fj,...qj,...Hj,...Yj,...Gj,...Vj,...Wj,...Kj,...Xj,...Qj,...Jj,...$j,...Zj],vh=[...eM,...tM,...nM,...iM,...aM,...rM,...sM,...oM,...uM,...lM],bh=[...cM,...pM,...dM,...mM,...fM,...hM,...xM,...gM],Sh=[...yM,...OM,...vM,...bM,...SM,...wM,...CM,..._M,...TM,...NM,...kM,...EM,...IM,...LM,...PM,...BM],wh=[...AM,...jM,...MM,...RM,...DM,...UM,...zM,...FM,...qM,...HM,...YM,...GM,...VM,...WM,...KM,...XM,...QM,...JM],$a=[...Oh,...vh,...bh,...Sh,...wh];console.log(`

              VALKRY Problem Bank - Loaded                

  EASY    : ${String(Oh.length).padStart(4)} questions                           
  MEDIUM  : ${String(vh.length).padStart(4)} questions                           
  HARD    : ${String(bh.length).padStart(4)} questions                           
  CORE    : ${String(Sh.length).padStart(4)} questions (Recursion, Bits, etc)    
  TOPIC   : ${String(wh.length).padStart(4)} questions (Arrays, DP, Graphs, etc) 

  TOTAL   : ${String($a.length).padStart(4)} questions                           

`);function To(){return $a[Math.floor(Math.random()*$a.length)]}function ob(){return[...new Set($a.map(n=>n.category))]}function Hc(){return{EASY:Oh.length,MEDIUM:vh.length,HARD:bh.length,CORE:Sh.length,TOPIC:wh.length,total:$a.length}}const $M=Object.freeze(Object.defineProperty({__proto__:null,getAllCategories:ob,getCountByDifficulty:Hc,getRandomProblem:To,problems:$a},Symbol.toStringTag,{value:"Module"})),t2=()=>{const{user:n}=ga(),[e,i]=S.useState({totalPlayers:0,totalBattles:0}),r=Hc();return S.useEffect(()=>{gh().then(i)},[]),f.jsxs("div",{className:"page",children:[f.jsxs("section",{style:{display:"flex",flexDirection:"column",alignItems:"center",justifyContent:"center",minHeight:"calc(100vh - 52px)",textAlign:"center",padding:"0 22px"},children:[f.jsx("p",{className:"caption",style:{marginBottom:"16px",color:"var(--accent)"},children:"Introducing Valkry"}),f.jsx("h1",{className:"headline-super",style:{maxWidth:"800px",marginBottom:"16px"},children:"Code. Battle. Dominate."}),f.jsx("p",{className:"body-large",style:{maxWidth:"500px",marginBottom:"32px"},children:"Solve. Debug. Compete. Climb the global leaderboard."}),f.jsxs("div",{style:{display:"flex",alignItems:"center",gap:"24px"},children:[f.jsx(ht,{to:n?"/arena":"/signin",children:f.jsx("button",{className:"btn btn-primary",children:n?"Enter Arena":"Get started"})}),f.jsxs(ht,{to:"/leaderboard",className:"btn btn-secondary",children:["View rankings ",f.jsx(gc,{size:14})]})]})]}),f.jsx("section",{style:{padding:"88px 22px",background:"var(--bg-secondary)"},children:f.jsxs("div",{className:"container",children:[f.jsx("h2",{className:"headline",style:{textAlign:"center",marginBottom:"12px"},children:"How it works."}),f.jsx("p",{className:"body-large",style:{textAlign:"center",marginBottom:"56px"},children:"Three steps to start competing."}),f.jsx("div",{className:"grid grid-3",style:{gap:"30px"},children:[{num:"01",title:"Match",desc:"Join the queue and get paired with a similar skill player."},{num:"02",title:"Code",desc:"Solve the problem or fix the bug before your opponent."},{num:"03",title:"Rise",desc:"Win battles to earn points and climb the leaderboard."}].map((o,l)=>f.jsxs("div",{style:{textAlign:"center"},children:[f.jsx("div",{style:{fontSize:"48px",fontWeight:"600",color:"var(--text-tertiary)",marginBottom:"16px"},children:o.num}),f.jsx("h3",{className:"headline-small",style:{marginBottom:"8px"},children:o.title}),f.jsx("p",{style:{color:"var(--text-secondary)",fontSize:"15px",lineHeight:1.5},children:o.desc})]},l))})]})}),f.jsx("section",{style:{padding:"88px 22px"},children:f.jsx("div",{className:"container",children:f.jsxs("div",{className:"grid grid-3",style:{textAlign:"center"},children:[f.jsxs("div",{children:[f.jsx("div",{style:{fontSize:"56px",fontWeight:"600",letterSpacing:"-0.02em"},children:e.totalPlayers||0}),f.jsx("div",{style:{color:"var(--text-secondary)",marginTop:"4px"},children:"Players worldwide"})]}),f.jsxs("div",{children:[f.jsx("div",{style:{fontSize:"56px",fontWeight:"600",letterSpacing:"-0.02em"},children:e.totalBattles||0}),f.jsx("div",{style:{color:"var(--text-secondary)",marginTop:"4px"},children:"Battles completed"})]}),f.jsxs("div",{children:[f.jsxs("div",{style:{fontSize:"56px",fontWeight:"600",letterSpacing:"-0.02em"},children:[r.total,"+"]}),f.jsx("div",{style:{color:"var(--text-secondary)",marginTop:"4px"},children:"Problems available"})]})]})})}),f.jsxs("section",{style:{padding:"88px 22px",background:"var(--bg-secondary)",textAlign:"center"},children:[f.jsx("h2",{className:"headline",style:{marginBottom:"12px"},children:"Ready to compete?"}),f.jsx("p",{className:"body-large",style:{marginBottom:"32px"},children:"Join the arena. It's free."}),f.jsx(ht,{to:n?"/arena":"/signin",children:f.jsxs("button",{className:"btn btn-primary",children:["Start now ",f.jsx(gc,{size:14})]})})]}),f.jsx("footer",{style:{padding:"24px 22px",textAlign:"center",borderTop:"1px solid var(--border)"},children:f.jsx("span",{className:"caption",children:"Valkry  2024"})})]})},ZM=()=>{const[n,e]=S.useState(!1),[i,r]=S.useState(""),[o,l]=S.useState(""),[p,m]=S.useState(""),[h,x]=S.useState(""),[O,y]=S.useState(!1),{loginWithEmail:v,signUpWithEmail:_,loginGoogle:k}=ga(),I=Cc(),D=async z=>{z.preventDefault(),x(""),y(!0);try{n?await _(i,o,p):await v(i,o),I("/dashboard")}catch(H){x(H.message)}finally{y(!1)}},q=async()=>{x(""),y(!0);try{await k(),I("/dashboard")}catch(z){x(z.message)}finally{y(!1)}};return f.jsx("div",{className:"page",style:{display:"flex",alignItems:"center",justifyContent:"center",minHeight:"100vh",background:"var(--bg-secondary)"},children:f.jsxs("div",{style:{width:"100%",maxWidth:"360px",padding:"40px",background:"var(--bg-elevated)",borderRadius:"18px",border:"1px solid var(--border)"},children:[f.jsx("div",{style:{textAlign:"center",marginBottom:"32px"},children:f.jsx(sb,{size:"large"})}),f.jsx("h1",{className:"headline-small",style:{textAlign:"center",marginBottom:"24px"},children:n?"Create your account":"Sign in"}),h&&f.jsx("div",{style:{padding:"12px 16px",background:"rgba(255, 69, 58, 0.1)",borderRadius:"12px",color:"var(--red)",fontSize:"14px",marginBottom:"20px",textAlign:"center"},children:h}),f.jsxs("button",{onClick:q,disabled:O,style:{width:"100%",padding:"12px",background:"white",border:"none",borderRadius:"12px",fontSize:"15px",fontWeight:"500",color:"#1D1D1F",cursor:"pointer",display:"flex",alignItems:"center",justifyContent:"center",gap:"8px",marginBottom:"20px"},children:[f.jsxs("svg",{width:"18",height:"18",viewBox:"0 0 24 24",children:[f.jsx("path",{fill:"#4285F4",d:"M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"}),f.jsx("path",{fill:"#34A853",d:"M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"}),f.jsx("path",{fill:"#FBBC05",d:"M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"}),f.jsx("path",{fill:"#EA4335",d:"M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"})]}),"Continue with Google"]}),f.jsxs("div",{style:{display:"flex",alignItems:"center",gap:"12px",marginBottom:"20px"},children:[f.jsx("div",{style:{flex:1,height:"1px",background:"var(--border)"}}),f.jsx("span",{className:"caption",children:"or"}),f.jsx("div",{style:{flex:1,height:"1px",background:"var(--border)"}})]}),f.jsxs("form",{onSubmit:D,children:[n&&f.jsx("div",{style:{marginBottom:"16px"},children:f.jsxs("div",{style:{position:"relative"},children:[f.jsx(rb,{size:16,style:{position:"absolute",left:"14px",top:"50%",transform:"translateY(-50%)",color:"var(--text-tertiary)"}}),f.jsx("input",{type:"text",className:"input",placeholder:"Name",value:p,onChange:z=>m(z.target.value),style:{paddingLeft:"42px",fontSize:"15px"},required:!0})]})}),f.jsx("div",{style:{marginBottom:"16px"},children:f.jsxs("div",{style:{position:"relative"},children:[f.jsx(tb,{size:16,style:{position:"absolute",left:"14px",top:"50%",transform:"translateY(-50%)",color:"var(--text-tertiary)"}}),f.jsx("input",{type:"email",className:"input",placeholder:"Email",value:i,onChange:z=>r(z.target.value),style:{paddingLeft:"42px",fontSize:"15px"},required:!0})]})}),f.jsx("div",{style:{marginBottom:"24px"},children:f.jsxs("div",{style:{position:"relative"},children:[f.jsx(cj,{size:16,style:{position:"absolute",left:"14px",top:"50%",transform:"translateY(-50%)",color:"var(--text-tertiary)"}}),f.jsx("input",{type:"password",className:"input",placeholder:"Password",value:o,onChange:z=>l(z.target.value),style:{paddingLeft:"42px",fontSize:"15px"},required:!0})]})}),f.jsxs("button",{type:"submit",disabled:O,className:"btn btn-primary",style:{width:"100%",padding:"12px"},children:[O&&f.jsx("div",{className:"spinner"}),n?"Create account":"Sign in"]})]}),f.jsxs("p",{style:{textAlign:"center",marginTop:"24px",fontSize:"14px",color:"var(--text-secondary)"},children:[n?"Already have an account?":"Don't have an account?"," ",f.jsx("button",{onClick:()=>e(!n),style:{background:"none",border:"none",color:"var(--accent)",cursor:"pointer",fontSize:"14px"},children:n?"Sign in":"Sign up"})]})]})})},e6=()=>{const{user:n,loading:e}=ga();if(!e&&!n)return f.jsx(A2,{to:"/signin",replace:!0});const i=n?.name?.split(" ")[0]||"there",[r,o]=S.useState(null),[l,p]=S.useState({}),[m,h]=S.useState([]),[x,O]=S.useState(!0);S.useEffect(()=>{if(!n)return;const v=oA(n.id,_=>{o(_),O(!1)});return mA(n.id).then(p),pA(3).then(h),()=>v()},[n]);const y=Object.keys(l).length;return f.jsx("div",{className:"page",children:f.jsxs("div",{className:"container",style:{paddingTop:"56px",paddingBottom:"56px"},children:[f.jsxs("div",{style:{marginBottom:"48px"},children:[f.jsx("p",{className:"caption",style:{marginBottom:"8px"},children:"Dashboard"}),f.jsxs("h1",{className:"headline",children:["Welcome back, ",i,"."]})]}),f.jsxs("div",{className:"card",style:{padding:"40px",marginBottom:"32px",textAlign:"center",background:"linear-gradient(180deg, var(--bg-elevated) 0%, var(--bg-secondary) 100%)"},children:[f.jsx("h2",{className:"headline-small",style:{marginBottom:"8px"},children:"Ready for a battle?"}),f.jsx("p",{style:{color:"var(--text-secondary)",marginBottom:"24px"},children:"Find an opponent and start competing."}),f.jsx(ht,{to:"/arena",children:f.jsxs("button",{className:"btn btn-primary",style:{padding:"14px 28px"},children:[f.jsx(nb,{size:16}),"Start playing"]})})]}),f.jsx("div",{className:"grid grid-4",style:{marginBottom:"32px"},children:[{label:"Battles",value:r?.battles||0,icon:Oc},{label:"Wins",value:r?.wins||0,icon:of},{label:"Win rate",value:`${r?.winRate||0}%`,icon:ab},{label:"Rating",value:r?.rating||1e3,icon:ib}].map((v,_)=>f.jsxs("div",{className:"card",style:{padding:"20px"},children:[f.jsxs("div",{style:{display:"flex",alignItems:"center",gap:"8px",marginBottom:"12px"},children:[f.jsx(v.icon,{size:16,style:{color:"var(--text-tertiary)"}}),f.jsx("span",{className:"caption",children:v.label})]}),f.jsx("div",{style:{fontSize:"32px",fontWeight:"600",letterSpacing:"-0.02em"},children:x?"":v.value})]},_))}),f.jsxs("div",{className:"grid grid-2",children:[f.jsxs("div",{className:"card",children:[f.jsxs("div",{style:{display:"flex",justifyContent:"space-between",alignItems:"center",marginBottom:"20px"},children:[f.jsx("span",{style:{fontWeight:"600"},children:"Top players"}),f.jsxs(ht,{to:"/leaderboard",className:"btn btn-secondary",style:{padding:0,fontSize:"14px"},children:["See all ",f.jsx(gc,{size:12})]})]}),m.length>0?m.map(v=>f.jsxs("div",{style:{display:"flex",alignItems:"center",gap:"12px",padding:"12px 0",borderTop:"1px solid var(--border)"},children:[f.jsx("span",{style:{width:"24px",fontSize:"14px",color:v.rank===1?"#FFD700":"var(--text-tertiary)"},children:v.rank}),v.avatar?f.jsx("img",{src:v.avatar,alt:v.name,style:{width:"32px",height:"32px",borderRadius:"50%",objectFit:"cover"}}):f.jsx("div",{className:"avatar",style:{width:"32px",height:"32px",fontSize:"13px"},children:v.name?.charAt(0).toUpperCase()||"?"}),f.jsx("span",{style:{flex:1,fontWeight:"500",fontSize:"15px"},children:v.name}),f.jsx("span",{className:"mono",style:{color:"var(--text-secondary)",fontSize:"14px"},children:v.rating?.toLocaleString()})]},v.rank)):f.jsx("div",{style:{padding:"24px 0",textAlign:"center",color:"var(--text-tertiary)"},children:"No players yet"})]}),f.jsxs("div",{className:"card",children:[f.jsx("span",{style:{fontWeight:"600"},children:"Your progress"}),f.jsxs("div",{style:{marginTop:"20px"},children:[f.jsxs("div",{style:{display:"flex",justifyContent:"space-between",alignItems:"center",padding:"12px 0",borderBottom:"1px solid var(--border)"},children:[f.jsx("span",{style:{color:"var(--text-secondary)"},children:"Rank"}),f.jsx("span",{style:{fontWeight:"600",color:"var(--accent)"},children:r?.rank||"Bronze"})]}),f.jsxs("div",{style:{display:"flex",justifyContent:"space-between",alignItems:"center",padding:"12px 0",borderBottom:"1px solid var(--border)"},children:[f.jsx("span",{style:{color:"var(--text-secondary)"},children:"Current streak"}),f.jsxs("span",{style:{fontWeight:"600",display:"flex",alignItems:"center",gap:"4px"},children:[f.jsx(eb,{size:14,style:{color:"var(--orange)"}}),r?.currentStreak||0]})]}),f.jsxs("div",{style:{display:"flex",justifyContent:"space-between",alignItems:"center",padding:"12px 0",borderBottom:"1px solid var(--border)"},children:[f.jsx("span",{style:{color:"var(--text-secondary)"},children:"Best streak"}),f.jsx("span",{style:{fontWeight:"600"},children:r?.bestStreak||0})]}),f.jsxs("div",{style:{display:"flex",justifyContent:"space-between",alignItems:"center",padding:"12px 0"},children:[f.jsx("span",{style:{color:"var(--text-secondary)"},children:"Achievements"}),f.jsxs("span",{style:{fontWeight:"600",display:"flex",alignItems:"center",gap:"4px"},children:[f.jsx(Jv,{size:14,style:{color:"var(--green)"}}),y,"/12"]})]})]})]})]}),y>0&&f.jsxs("div",{className:"card",style:{marginTop:"24px"},children:[f.jsx("span",{style:{fontWeight:"600"},children:"Recent achievements"}),f.jsx("div",{style:{display:"flex",gap:"12px",marginTop:"16px",flexWrap:"wrap"},children:Object.entries(l).slice(0,6).map(([v,_])=>f.jsxs("div",{style:{padding:"12px 16px",background:"var(--bg-secondary)",borderRadius:"12px",display:"flex",alignItems:"center",gap:"8px"},children:[f.jsx(of,{size:16,style:{color:"var(--green)"}}),f.jsx("span",{style:{fontSize:"14px",fontWeight:"500"},children:_.name})]},v))})]})]})})},t6=()=>{const{user:n}=ga(),[e,i]=S.useState(""),[r,o]=S.useState([]),[l,p]=S.useState({totalPlayers:0,battlesToday:0,totalBattles:0}),[m,h]=S.useState(!0);S.useEffect(()=>{const v=dA(_=>{o(_),h(!1)},50);return gh().then(p),()=>v()},[]);const x=r.filter(v=>v.name?.toLowerCase().includes(e.toLowerCase())),O=r.findIndex(v=>v.id===n?.id)+1,y=v=>v===1?"#FFD700":v===2?"#C0C0C0":v===3?"#CD7F32":"var(--text-tertiary)";return f.jsx("div",{className:"page",children:f.jsxs("div",{className:"container",style:{paddingTop:"56px",paddingBottom:"56px"},children:[f.jsxs("div",{style:{marginBottom:"48px"},children:[f.jsx("p",{className:"caption",style:{marginBottom:"8px"},children:"Rankings"}),f.jsx("h1",{className:"headline",children:"Leaderboard"})]}),f.jsxs("div",{className:`grid ${n?"grid-3":"grid-2"}`,style:{marginBottom:"40px"},children:[f.jsxs("div",{className:"card",style:{textAlign:"center",padding:"28px"},children:[f.jsx(Io,{size:20,style:{color:"var(--text-tertiary)",marginBottom:"8px"}}),f.jsx("div",{style:{fontSize:"32px",fontWeight:"600",marginBottom:"4px"},children:r.length||l.totalPlayers||""}),f.jsx("div",{className:"caption",children:"Total players"})]}),f.jsxs("div",{className:"card",style:{textAlign:"center",padding:"28px"},children:[f.jsx(ab,{size:20,style:{color:"var(--text-tertiary)",marginBottom:"8px"}}),f.jsx("div",{style:{fontSize:"32px",fontWeight:"600",marginBottom:"4px"},children:l.battlesToday||0}),f.jsx("div",{className:"caption",children:"Battles today"})]}),n&&f.jsxs("div",{className:"card",style:{textAlign:"center",padding:"28px"},children:[f.jsx(Jv,{size:20,style:{color:"var(--text-tertiary)",marginBottom:"8px"}}),f.jsx("div",{style:{fontSize:"32px",fontWeight:"600",marginBottom:"4px",color:O>0?"var(--accent)":"var(--text)"},children:O>0?`#${O}`:""}),f.jsx("div",{className:"caption",children:"Your rank"})]})]}),f.jsxs("div",{style:{position:"relative",marginBottom:"24px"},children:[f.jsx(yh,{size:16,style:{position:"absolute",left:"16px",top:"50%",transform:"translateY(-50%)",color:"var(--text-tertiary)"}}),f.jsx("input",{type:"text",className:"input",placeholder:"Search players...",value:e,onChange:v=>i(v.target.value),style:{paddingLeft:"44px",fontSize:"15px"}})]}),f.jsx("div",{className:"card",style:{padding:0,overflow:"hidden"},children:m?f.jsxs("div",{style:{padding:"60px",textAlign:"center"},children:[f.jsx("div",{className:"spinner",style:{margin:"0 auto 16px"}}),f.jsx("p",{style:{color:"var(--text-tertiary)"},children:"Loading leaderboard..."})]}):x.length>0?f.jsxs("table",{className:"table",children:[f.jsx("thead",{children:f.jsxs("tr",{children:[f.jsx("th",{style:{width:"60px"},children:"Rank"}),f.jsx("th",{children:"Player"}),f.jsx("th",{style:{textAlign:"right"},children:"Rating"}),f.jsx("th",{style:{textAlign:"right"},children:"Wins"}),f.jsx("th",{style:{textAlign:"right"},children:"Streak"})]})}),f.jsx("tbody",{children:x.map(v=>f.jsxs("tr",{style:{background:v.id===n?.id?"rgba(0, 113, 227, 0.05)":"transparent"},children:[f.jsx("td",{children:v.rank<=3?f.jsx(QA,{size:16,style:{color:y(v.rank)}}):f.jsx("span",{style:{color:"var(--text-tertiary)"},children:v.rank})}),f.jsx("td",{children:f.jsxs("div",{style:{display:"flex",alignItems:"center",gap:"12px"},children:[v.avatar?f.jsx("img",{src:v.avatar,alt:v.name,style:{width:"32px",height:"32px",borderRadius:"50%",objectFit:"cover"}}):f.jsx("div",{className:"avatar",style:{width:"32px",height:"32px",fontSize:"13px"},children:v.name?.charAt(0).toUpperCase()||"?"}),f.jsxs("span",{style:{fontWeight:"500"},children:[v.name,v.id===n?.id&&f.jsx("span",{style:{marginLeft:"8px",fontSize:"12px",color:"var(--accent)"},children:"(you)"})]})]})}),f.jsx("td",{style:{textAlign:"right"},children:f.jsx("span",{className:"mono",children:v.rating?.toLocaleString()})}),f.jsx("td",{style:{textAlign:"right",color:"var(--text-secondary)"},children:v.wins||0}),f.jsx("td",{style:{textAlign:"right"},children:v.streak>0?f.jsxs("span",{style:{display:"inline-flex",alignItems:"center",gap:"4px",color:"var(--orange)"},children:[f.jsx(eb,{size:14}),v.streak]}):f.jsx("span",{style:{color:"var(--text-tertiary)"},children:"0"})})]},v.id))})]}):f.jsx("div",{style:{padding:"60px",textAlign:"center"},children:f.jsx("p",{style:{color:"var(--text-tertiary)"},children:e?"No players found":"No players yet. Be the first!"})})})]})})};function n2(n,e){(e==null||e>n.length)&&(e=n.length);for(var i=0,r=Array(e);i<e;i++)r[i]=n[i];return r}function n6(n){if(Array.isArray(n))return n}function i6(n,e,i){return(e=c6(e))in n?Object.defineProperty(n,e,{value:i,enumerable:!0,configurable:!0,writable:!0}):n[e]=i,n}function a6(n,e){var i=n==null?null:typeof Symbol<"u"&&n[Symbol.iterator]||n["@@iterator"];if(i!=null){var r,o,l,p,m=[],h=!0,x=!1;try{if(l=(i=i.call(n)).next,e!==0)for(;!(h=(r=l.call(i)).done)&&(m.push(r.value),m.length!==e);h=!0);}catch(O){x=!0,o=O}finally{try{if(!h&&i.return!=null&&(p=i.return(),Object(p)!==p))return}finally{if(x)throw o}}return m}}function r6(){throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)}function i2(n,e){var i=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);e&&(r=r.filter(function(o){return Object.getOwnPropertyDescriptor(n,o).enumerable})),i.push.apply(i,r)}return i}function a2(n){for(var e=1;e<arguments.length;e++){var i=arguments[e]!=null?arguments[e]:{};e%2?i2(Object(i),!0).forEach(function(r){i6(n,r,i[r])}):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(i)):i2(Object(i)).forEach(function(r){Object.defineProperty(n,r,Object.getOwnPropertyDescriptor(i,r))})}return n}function s6(n,e){if(n==null)return{};var i,r,o=o6(n,e);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(n);for(r=0;r<l.length;r++)i=l[r],e.indexOf(i)===-1&&{}.propertyIsEnumerable.call(n,i)&&(o[i]=n[i])}return o}function o6(n,e){if(n==null)return{};var i={};for(var r in n)if({}.hasOwnProperty.call(n,r)){if(e.indexOf(r)!==-1)continue;i[r]=n[r]}return i}function u6(n,e){return n6(n)||a6(n,e)||p6(n,e)||r6()}function l6(n,e){if(typeof n!="object"||!n)return n;var i=n[Symbol.toPrimitive];if(i!==void 0){var r=i.call(n,e);if(typeof r!="object")return r;throw new TypeError("@@toPrimitive must return a primitive value.")}return(e==="string"?String:Number)(n)}function c6(n){var e=l6(n,"string");return typeof e=="symbol"?e:e+""}function p6(n,e){if(n){if(typeof n=="string")return n2(n,e);var i={}.toString.call(n).slice(8,-1);return i==="Object"&&n.constructor&&(i=n.constructor.name),i==="Map"||i==="Set"?Array.from(n):i==="Arguments"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i)?n2(n,e):void 0}}function d6(n,e,i){return e in n?Object.defineProperty(n,e,{value:i,enumerable:!0,configurable:!0,writable:!0}):n[e]=i,n}function r2(n,e){var i=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);e&&(r=r.filter(function(o){return Object.getOwnPropertyDescriptor(n,o).enumerable})),i.push.apply(i,r)}return i}function s2(n){for(var e=1;e<arguments.length;e++){var i=arguments[e]!=null?arguments[e]:{};e%2?r2(Object(i),!0).forEach(function(r){d6(n,r,i[r])}):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(i)):r2(Object(i)).forEach(function(r){Object.defineProperty(n,r,Object.getOwnPropertyDescriptor(i,r))})}return n}function m6(){for(var n=arguments.length,e=new Array(n),i=0;i<n;i++)e[i]=arguments[i];return function(r){return e.reduceRight(function(o,l){return l(o)},r)}}function No(n){return function e(){for(var i=this,r=arguments.length,o=new Array(r),l=0;l<r;l++)o[l]=arguments[l];return o.length>=n.length?n.apply(this,o):function(){for(var p=arguments.length,m=new Array(p),h=0;h<p;h++)m[h]=arguments[h];return e.apply(i,[].concat(o,m))}}}function Sc(n){return{}.toString.call(n).includes("Object")}function f6(n){return!Object.keys(n).length}function Jo(n){return typeof n=="function"}function h6(n,e){return Object.prototype.hasOwnProperty.call(n,e)}function x6(n,e){return Sc(e)||ua("changeType"),Object.keys(e).some(function(i){return!h6(n,i)})&&ua("changeField"),e}function g6(n){Jo(n)||ua("selectorType")}function y6(n){Jo(n)||Sc(n)||ua("handlerType"),Sc(n)&&Object.values(n).some(function(e){return!Jo(e)})&&ua("handlersType")}function O6(n){n||ua("initialIsRequired"),Sc(n)||ua("initialType"),f6(n)&&ua("initialContent")}function v6(n,e){throw new Error(n[e]||n.default)}var b6={initialIsRequired:"initial state is required",initialType:"initial state should be an object",initialContent:"initial state shouldn't be an empty object",handlerType:"handler should be an object or a function",handlersType:"all handlers should be a functions",selectorType:"selector should be a function",changeType:"provided value of changes should be an object",changeField:'it seams you want to change a field in the state which is not specified in the "initial" state',default:"an unknown error accured in `state-local` package"},ua=No(v6)(b6),Rl={changes:x6,selector:g6,handler:y6,initial:O6};function S6(n){var e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};Rl.initial(n),Rl.handler(e);var i={current:n},r=No(_6)(i,e),o=No(C6)(i),l=No(Rl.changes)(n),p=No(w6)(i);function m(){var x=arguments.length>0&&arguments[0]!==void 0?arguments[0]:function(O){return O};return Rl.selector(x),x(i.current)}function h(x){m6(r,o,l,p)(x)}return[m,h]}function w6(n,e){return Jo(e)?e(n.current):e}function C6(n,e){return n.current=s2(s2({},n.current),e),e}function _6(n,e,i){return Jo(e)?e(n.current):Object.keys(i).forEach(function(r){var o;return(o=e[r])===null||o===void 0?void 0:o.call(e,n.current[r])}),i}var T6={create:S6},N6={paths:{vs:"https://cdn.jsdelivr.net/npm/monaco-editor@0.55.1/min/vs"}};function k6(n){return function e(){for(var i=this,r=arguments.length,o=new Array(r),l=0;l<r;l++)o[l]=arguments[l];return o.length>=n.length?n.apply(this,o):function(){for(var p=arguments.length,m=new Array(p),h=0;h<p;h++)m[h]=arguments[h];return e.apply(i,[].concat(o,m))}}}function E6(n){return{}.toString.call(n).includes("Object")}function A6(n){return n||o2("configIsRequired"),E6(n)||o2("configType"),n.urls?(j6(),{paths:{vs:n.urls.monacoBase}}):n}function j6(){console.warn(ub.deprecation)}function M6(n,e){throw new Error(n[e]||n.default)}var ub={configIsRequired:"the configuration object is required",configType:"the configuration object should be an object",default:"an unknown error accured in `@monaco-editor/loader` package",deprecation:`Deprecation warning!
    You are using deprecated way of configuration.

    Instead of using
      monaco.config({ urls: { monacoBase: '...' } })
    use
      monaco.config({ paths: { vs: '...' } })

    For more please check the link https://github.com/suren-atoyan/monaco-loader#config
  `},o2=k6(M6)(ub),R6={config:A6},D6=function(){for(var e=arguments.length,i=new Array(e),r=0;r<e;r++)i[r]=arguments[r];return function(o){return i.reduceRight(function(l,p){return p(l)},o)}};function lb(n,e){return Object.keys(e).forEach(function(i){e[i]instanceof Object&&n[i]&&Object.assign(e[i],lb(n[i],e[i]))}),a2(a2({},n),e)}var I6={type:"cancelation",msg:"operation is manually canceled"};function jm(n){var e=!1,i=new Promise(function(r,o){n.then(function(l){return e?o(I6):r(l)}),n.catch(o)});return i.cancel=function(){return e=!0},i}var L6=["monaco"],P6=T6.create({config:N6,isInitialized:!1,resolve:null,reject:null,monaco:null}),cb=u6(P6,2),pu=cb[0],Yc=cb[1];function B6(n){var e=R6.config(n),i=e.monaco,r=s6(e,L6);Yc(function(o){return{config:lb(o.config,r),monaco:i}})}function U6(){var n=pu(function(e){var i=e.monaco,r=e.isInitialized,o=e.resolve;return{monaco:i,isInitialized:r,resolve:o}});if(!n.isInitialized){if(Yc({isInitialized:!0}),n.monaco)return n.resolve(n.monaco),jm(Mm);if(window.monaco&&window.monaco.editor)return pb(window.monaco),n.resolve(window.monaco),jm(Mm);D6(z6,q6)(H6)}return jm(Mm)}function z6(n){return document.body.appendChild(n)}function F6(n){var e=document.createElement("script");return n&&(e.src=n),e}function q6(n){var e=pu(function(r){var o=r.config,l=r.reject;return{config:o,reject:l}}),i=F6("".concat(e.config.paths.vs,"/loader.js"));return i.onload=function(){return n()},i.onerror=e.reject,i}function H6(){var n=pu(function(i){var r=i.config,o=i.resolve,l=i.reject;return{config:r,resolve:o,reject:l}}),e=window.require;e.config(n.config),e(["vs/editor/editor.main"],function(i){var r=i.m||i;pb(r),n.resolve(r)},function(i){n.reject(i)})}function pb(n){pu().monaco||Yc({monaco:n})}function Y6(){return pu(function(n){var e=n.monaco;return e})}var Mm=new Promise(function(n,e){return Yc({resolve:n,reject:e})}),db={config:B6,init:U6,__getMonacoInstance:Y6},G6={wrapper:{display:"flex",position:"relative",textAlign:"initial"},fullWidth:{width:"100%"},hide:{display:"none"}},Rm=G6,V6={container:{display:"flex",height:"100%",width:"100%",justifyContent:"center",alignItems:"center"}},W6=V6;function K6({children:n}){return Ha.createElement("div",{style:W6.container},n)}var X6=K6,Q6=X6;function J6({width:n,height:e,isEditorReady:i,loading:r,_ref:o,className:l,wrapperProps:p}){return Ha.createElement("section",{style:{...Rm.wrapper,width:n,height:e},...p},!i&&Ha.createElement(Q6,null,r),Ha.createElement("div",{ref:o,style:{...Rm.fullWidth,...!i&&Rm.hide},className:l}))}var $6=J6,mb=S.memo($6);function Z6(n){S.useEffect(n,[])}var fb=Z6;function eR(n,e,i=!0){let r=S.useRef(!0);S.useEffect(r.current||!i?()=>{r.current=!1}:n,e)}var an=eR;function Lo(){}function Jr(n,e,i,r){return tR(n,r)||nR(n,e,i,r)}function tR(n,e){return n.editor.getModel(hb(n,e))}function nR(n,e,i,r){return n.editor.createModel(e,i,r?hb(n,r):void 0)}function hb(n,e){return n.Uri.parse(e)}function iR({original:n,modified:e,language:i,originalLanguage:r,modifiedLanguage:o,originalModelPath:l,modifiedModelPath:p,keepCurrentOriginalModel:m=!1,keepCurrentModifiedModel:h=!1,theme:x="light",loading:O="Loading...",options:y={},height:v="100%",width:_="100%",className:k,wrapperProps:I={},beforeMount:D=Lo,onMount:q=Lo}){let[z,H]=S.useState(!1),[J,$]=S.useState(!0),B=S.useRef(null),W=S.useRef(null),ae=S.useRef(null),ce=S.useRef(q),te=S.useRef(D),Ue=S.useRef(!1);fb(()=>{let de=db.init();return de.then(M=>(W.current=M)&&$(!1)).catch(M=>M?.type!=="cancelation"&&console.error("Monaco initialization: error:",M)),()=>B.current?st():de.cancel()}),an(()=>{if(B.current&&W.current){let de=B.current.getOriginalEditor(),M=Jr(W.current,n||"",r||i||"text",l||"");M!==de.getModel()&&de.setModel(M)}},[l],z),an(()=>{if(B.current&&W.current){let de=B.current.getModifiedEditor(),M=Jr(W.current,e||"",o||i||"text",p||"");M!==de.getModel()&&de.setModel(M)}},[p],z),an(()=>{let de=B.current.getModifiedEditor();de.getOption(W.current.editor.EditorOption.readOnly)?de.setValue(e||""):e!==de.getValue()&&(de.executeEdits("",[{range:de.getModel().getFullModelRange(),text:e||"",forceMoveMarkers:!0}]),de.pushUndoStop())},[e],z),an(()=>{B.current?.getModel()?.original.setValue(n||"")},[n],z),an(()=>{let{original:de,modified:M}=B.current.getModel();W.current.editor.setModelLanguage(de,r||i||"text"),W.current.editor.setModelLanguage(M,o||i||"text")},[i,r,o],z),an(()=>{W.current?.editor.setTheme(x)},[x],z),an(()=>{B.current?.updateOptions(y)},[y],z);let Y=S.useCallback(()=>{if(!W.current)return;te.current(W.current);let de=Jr(W.current,n||"",r||i||"text",l||""),M=Jr(W.current,e||"",o||i||"text",p||"");B.current?.setModel({original:de,modified:M})},[i,e,o,n,r,l,p]),ye=S.useCallback(()=>{!Ue.current&&ae.current&&(B.current=W.current.editor.createDiffEditor(ae.current,{automaticLayout:!0,...y}),Y(),W.current?.editor.setTheme(x),H(!0),Ue.current=!0)},[y,x,Y]);S.useEffect(()=>{z&&ce.current(B.current,W.current)},[z]),S.useEffect(()=>{!J&&!z&&ye()},[J,z,ye]);function st(){let de=B.current?.getModel();m||de?.original?.dispose(),h||de?.modified?.dispose(),B.current?.dispose()}return Ha.createElement(mb,{width:_,height:v,isEditorReady:z,loading:O,_ref:ae,className:k,wrapperProps:I})}var aR=iR;S.memo(aR);function rR(n){let e=S.useRef();return S.useEffect(()=>{e.current=n},[n]),e.current}var sR=rR,Dl=new Map;function oR({defaultValue:n,defaultLanguage:e,defaultPath:i,value:r,language:o,path:l,theme:p="light",line:m,loading:h="Loading...",options:x={},overrideServices:O={},saveViewState:y=!0,keepCurrentModel:v=!1,width:_="100%",height:k="100%",className:I,wrapperProps:D={},beforeMount:q=Lo,onMount:z=Lo,onChange:H,onValidate:J=Lo}){let[$,B]=S.useState(!1),[W,ae]=S.useState(!0),ce=S.useRef(null),te=S.useRef(null),Ue=S.useRef(null),Y=S.useRef(z),ye=S.useRef(q),st=S.useRef(),de=S.useRef(r),M=sR(l),V=S.useRef(!1),ne=S.useRef(!1);fb(()=>{let C=db.init();return C.then(P=>(ce.current=P)&&ae(!1)).catch(P=>P?.type!=="cancelation"&&console.error("Monaco initialization: error:",P)),()=>te.current?Re():C.cancel()}),an(()=>{let C=Jr(ce.current,n||r||"",e||o||"",l||i||"");C!==te.current?.getModel()&&(y&&Dl.set(M,te.current?.saveViewState()),te.current?.setModel(C),y&&te.current?.restoreViewState(Dl.get(l)))},[l],$),an(()=>{te.current?.updateOptions(x)},[x],$),an(()=>{!te.current||r===void 0||(te.current.getOption(ce.current.editor.EditorOption.readOnly)?te.current.setValue(r):r!==te.current.getValue()&&(ne.current=!0,te.current.executeEdits("",[{range:te.current.getModel().getFullModelRange(),text:r,forceMoveMarkers:!0}]),te.current.pushUndoStop(),ne.current=!1))},[r],$),an(()=>{let C=te.current?.getModel();C&&o&&ce.current?.editor.setModelLanguage(C,o)},[o],$),an(()=>{m!==void 0&&te.current?.revealLine(m)},[m],$),an(()=>{ce.current?.editor.setTheme(p)},[p],$);let Ce=S.useCallback(()=>{if(!(!Ue.current||!ce.current)&&!V.current){ye.current(ce.current);let C=l||i,P=Jr(ce.current,r||n||"",e||o||"",C||"");te.current=ce.current?.editor.create(Ue.current,{model:P,automaticLayout:!0,...x},O),y&&te.current.restoreViewState(Dl.get(C)),ce.current.editor.setTheme(p),m!==void 0&&te.current.revealLine(m),B(!0),V.current=!0}},[n,e,i,r,o,l,x,O,y,p,m]);S.useEffect(()=>{$&&Y.current(te.current,ce.current)},[$]),S.useEffect(()=>{!W&&!$&&Ce()},[W,$,Ce]),de.current=r,S.useEffect(()=>{$&&H&&(st.current?.dispose(),st.current=te.current?.onDidChangeModelContent(C=>{ne.current||H(te.current.getValue(),C)}))},[$,H]),S.useEffect(()=>{if($){let C=ce.current.editor.onDidChangeMarkers(P=>{let K=te.current.getModel()?.uri;if(K&&P.find(Q=>Q.path===K.path)){let Q=ce.current.editor.getModelMarkers({resource:K});J?.(Q)}});return()=>{C?.dispose()}}return()=>{}},[$,J]);function Re(){st.current?.dispose(),v?y&&Dl.set(l,te.current.saveViewState()):te.current.getModel()?.dispose(),te.current.dispose()}return Ha.createElement(mb,{width:_,height:k,isEditorReady:$,loading:h,_ref:Ue,className:I,wrapperProps:D})}var uR=oR,lR=S.memo(uR),uf=lR;const xb="https://ce.judge0.com",cR=54;async function pR(n,e=""){const i=await fetch(`${xb}/submissions?base64_encoded=false&wait=false`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({source_code:n,language_id:cR,stdin:e})});if(!i.ok){const r=await i.text();throw new Error(`Submission failed: ${i.status} - ${r}`)}return await i.json()}async function dR(n){const e=await fetch(`${xb}/submissions/${n}?base64_encoded=false&fields=stdout,stderr,compile_output,status,time,memory`,{method:"GET",headers:{"Content-Type":"application/json"}});if(!e.ok)throw new Error(`Failed to get result: ${e.statusText}`);return await e.json()}async function mR(n,e=""){const{token:i}=await pR(n,e),r=15,o=2e3;for(let l=0;l<r;l++){await new Promise(m=>setTimeout(m,o));const p=await dR(i);if(p.status&&p.status.id>=3)return{success:p.status.id===3,status:p.status.description,stdout:p.stdout||"",stderr:p.stderr||"",compile_output:p.compile_output||"",time:p.time,memory:p.memory}}throw new Error("Execution timed out")}const fR="modulepreload",hR=function(n){return"/"+n},u2={},gb=function(e,i,r){let o=Promise.resolve();if(i&&i.length>0){let x=function(O){return Promise.all(O.map(y=>Promise.resolve(y).then(v=>({status:"fulfilled",value:v}),v=>({status:"rejected",reason:v}))))};var p=x;document.getElementsByTagName("link");const m=document.querySelector("meta[property=csp-nonce]"),h=m?.nonce||m?.getAttribute("nonce");o=x(i.map(O=>{if(O=hR(O),O in u2)return;u2[O]=!0;const y=O.endsWith(".css"),v=y?'[rel="stylesheet"]':"";if(document.querySelector(`link[href="${O}"]${v}`))return;const _=document.createElement("link");if(_.rel=y?"stylesheet":fR,y||(_.as="script"),_.crossOrigin="",_.href=O,h&&_.setAttribute("nonce",h),document.head.appendChild(_),y)return new Promise((k,I)=>{_.addEventListener("load",k),_.addEventListener("error",()=>I(new Error(`Unable to preload CSS for ${O}`)))})}))}function l(m){const h=new Event("vite:preloadError",{cancelable:!0});if(h.payload=m,window.dispatchEvent(h),!h.defaultPrevented)throw m}return o.then(m=>{for(const h of m||[])h.status==="rejected"&&l(h.reason);return e().catch(l)})};async function yb(n){const e=se(oe,"matchmaking/queue"),i=Gv(e);return await sn(i,{odplayerId:n.id,playerName:n.name,joinedAt:Date.now(),status:"waiting",battleId:null}),console.log("Joined queue with key:",i.key,"player:",n.name),i.key}async function lf(n){if(n)try{const e=se(oe,`matchmaking/queue/${n}`);await Fn(e),console.log("Left queue:",n)}catch(e){console.error("Error leaving queue:",e)}}async function Ob(n,e,i){const r=se(oe,"battles"),o=Gv(r);return await sn(o,{player1:{id:n.id,name:n.name,code:i.starterCode,testsPassed:0,finished:!1},player2:{id:e.id,name:e.name,code:i.starterCode,testsPassed:0,finished:!1},problem:{id:i.id,title:i.title,description:i.description,difficulty:i.difficulty,category:i.category,starterCode:i.starterCode,expectedOutput:i.expectedOutput},status:"active",startedAt:aA(),winner:null}),console.log("Created battle:",o.key),o.key}function vb(n,e){const i=se(oe,`battles/${n}`);return Mn(i,r=>{r.exists()&&e(r.val())}),()=>Gn(i)}async function bb(n,e,i,r){const o=se(oe,`battles/${n}`),l=await Et(o);if(!l.exists())return;const h=l.val().player1.id===e?"player1":"player2",x=se(oe,`battles/${n}/${h}`);await Pt(x,{testsPassed:i,finished:r}),await Pt(o,{status:"finished",winner:h,finishedAt:Date.now()})}async function cf(n,e){const i=se(oe,`battles/${n}`),r=await Et(i);if(!r.exists())return;const l=r.val().player1.id===e,p=l?"player1":"player2",m=l?"player2":"player1";await Pt(se(oe,`battles/${n}/${p}`),{forfeited:!0}),await Pt(i,{status:"finished",winner:m,finishedAt:Date.now(),endReason:"forfeit"})}function Sb(n,e,i,r){const o=se(oe,"matchmaking/queue"),l=se(oe,`matchmaking/queue/${e}`),p=Mn(l,async m=>{if(!m.exists())return;const h=m.val();if(console.log("My entry updated:",h),h.battleId&&h.status==="matched"){console.log("I was matched! Battle:",h.battleId);const x=se(oe,`battles/${h.battleId}`),O=await Et(x);if(O.exists()){const y=O.val(),v=y.player1.id===n,_=v?y.player2:y.player1;i({battleId:h.battleId,problem:y.problem,opponent:_,isPlayer1:v})}await Fn(l)}});return Mn(o,async m=>{if(!m.exists())return;const h=m.val(),O=Object.entries(h).filter(([y,v])=>v.status==="waiting").sort((y,v)=>y[1].joinedAt-v[1].joinedAt);if(console.log("Waiting players:",O.length),O.length>=2){const[y,v]=O[0],[_,k]=O[1];if(y===e){console.log("I am first player, creating battle...");try{const{getRandomProblem:I}=await gb(async()=>{const{getRandomProblem:z}=await Promise.resolve().then(()=>$M);return{getRandomProblem:z}},[]),D=I(),q=await Ob({id:v.odplayerId,name:v.playerName},{id:k.odplayerId,name:k.playerName},D);await Pt(se(oe,`matchmaking/queue/${y}`),{status:"matched",battleId:q}),await Pt(se(oe,`matchmaking/queue/${_}`),{status:"matched",battleId:q}),console.log("Battle created and players matched!")}catch(I){console.error("Error creating battle:",I),r(I)}}else console.log("Waiting for first player to create battle...")}}),()=>{p(),Gn(o)}}const xR=Object.freeze(Object.defineProperty({__proto__:null,createBattle:Ob,forfeitBattle:cf,joinQueue:yb,leaveQueue:lf,subscribeToBattle:vb,subscribeToMatchmaking:Sb,updatePlayerProgress:bb},Symbol.toStringTag,{value:"Module"}));function gR(n){const e=se(oe,`online_players/${n.id}`);return sn(e,{name:n.name,avatar:n.avatar||null,status:"available",onlineSince:Date.now()}),GE(e).remove(),()=>Fn(e)}async function So(n,e){const i=se(oe,`online_players/${n}`);await Pt(i,{status:e})}function yR(n,e){const i=se(oe,"online_players");return Mn(i,r=>{if(!r.exists()){e([]);return}const o=[];r.forEach(l=>{l.key!==n&&o.push({id:l.key,...l.val()})}),e(o)}),()=>Gn(i)}async function l2(n,e,i){const r=se(oe,`challenges/${e}`);return await sn(r,{from:{id:n.id,name:n.name,avatar:n.avatar||null},problem:{id:i.id,title:i.title,description:i.description,difficulty:i.difficulty,category:i.category||"General",starterCode:i.starterCode,expectedOutput:i.expectedOutput,testCases:i.testCases||[]},createdAt:Date.now(),status:"pending",battleId:null}),r}function c2(n,e,i,r){const o=se(oe,`challenges/${n}`);let l=!1;const p=setTimeout(async()=>{if(l)return;const m=await Et(o);m.exists()&&m.val().status==="pending"&&(await Pt(o,{status:"expired"}),setTimeout(()=>Fn(o),1e3))},3e4);return Mn(o,m=>{if(!l)if(m.exists()){const h=m.val();h.status==="accepted"&&h.battleId?(l=!0,clearTimeout(p),e(h)):h.status==="declined"?(l=!0,clearTimeout(p),i()):h.status==="expired"&&(l=!0,clearTimeout(p),r())}else l||(l=!0,clearTimeout(p),r())}),()=>{clearTimeout(p),Gn(o)}}function OR(n,e){const i=se(oe,`challenges/${n}`);return Mn(i,r=>{if(r.exists()){const o=r.val();o.status==="pending"?e(o):e(null)}else e(null)}),()=>Gn(i)}async function vR(n,e,i){const{createBattle:r}=await gb(async()=>{const{createBattle:p}=await Promise.resolve().then(()=>xR);return{createBattle:p}},void 0),o=await r({id:i.from.id,name:i.from.name},{id:n,name:e},i.problem),l=se(oe,`challenges/${n}`);return await Pt(l,{status:"accepted",battleId:o}),setTimeout(()=>Fn(l),5e3),o}async function bR(n){const e=se(oe,`challenges/${n}`);await Pt(e,{status:"declined"}),setTimeout(()=>Fn(e),2e3)}async function SR(n,e){const i=se(oe,`users/${e}/stats`);if(!(await Et(i)).exists())return{success:!1,error:"User not found"};const o=se(oe,`users/${n.id}/friends/${e}`);if((await Et(o)).exists())return{success:!1,error:"Already friends with this user"};const p=se(oe,`users/${e}/friendRequests/${n.id}`);if((await Et(p)).exists())return{success:!1,error:"Friend request already sent"};const h=se(oe,`users/${e}/friendRequests/${n.id}`);return await sn(h,{from:{id:n.id,name:n.name,avatar:n.avatar||null},sentAt:Date.now()}),{success:!0}}async function wR(n,e){const i=se(oe,`users/${n}/friends/${e.id}`),r=se(oe,`users/${e.id}/friends/${n}`),o=se(oe,`users/${n}/stats`),p=(await Et(o)).val();await sn(i,{id:e.id,name:e.name,avatar:e.avatar||null,addedAt:Date.now()}),await sn(r,{id:n,name:p?.name||"Unknown",avatar:p?.avatar||null,addedAt:Date.now()});const m=se(oe,`users/${n}/friendRequests/${e.id}`);return await Fn(m),{success:!0}}async function CR(n,e){const i=se(oe,`users/${n}/friendRequests/${e}`);return await Fn(i),{success:!0}}async function _R(n,e){const i=se(oe,`users/${n}/friends/${e}`),r=se(oe,`users/${e}/friends/${n}`);return await Fn(i),await Fn(r),{success:!0}}function wb(n,e){const i=se(oe,`users/${n}/friends`);return Mn(i,r=>{if(r.exists()){const o=r.val(),l=Object.entries(o).map(([p,m])=>({id:p,...m}));e(l)}else e([])}),()=>Gn(i)}function TR(n,e){const i=se(oe,`users/${n}/friendRequests`);return Mn(i,r=>{if(r.exists()){const o=r.val(),l=Object.entries(o).map(([p,m])=>({id:p,...m}));e(l)}else e([])}),()=>Gn(i)}async function NR(n){const e=se(oe,`users/${n}/stats`),i=await Et(e);if(!i.exists())return null;const r=i.val();return{id:n,name:r.name,avatar:r.avatar,rating:r.rating,rank:r.rank}}function Cb(n,e){const i=[],r={};return n.forEach(o=>{const l=se(oe,`online/${o}`);Mn(l,p=>{r[o]=p.exists()?p.val():null,e({...r})}),i.push(()=>Gn(l))}),()=>i.forEach(o=>o())}const kR=3e4,ER=()=>{const{user:n}=ga(),e=Hn(),[i,r]=S.useState("lobby"),[o,l]=S.useState(!1),[p,m]=S.useState({type:"info",content:'Click "Run" to execute your code'}),[h,x]=S.useState(null),[O,y]=S.useState(null),[v,_]=S.useState(null),[k,I]=S.useState(null),[D,q]=S.useState(To()),[z,H]=S.useState(0),[J,$]=S.useState(0),[B,W]=S.useState(null),[ae,ce]=S.useState([]),[te,Ue]=S.useState(null),[Y,ye]=S.useState(null),[st,de]=S.useState(!1),[M,V]=S.useState(!1),[ne,Ce]=S.useState([]),[Re,C]=S.useState(!1),[P,K]=S.useState(!1),[Q,me]=S.useState([]),[he,Ee]=S.useState({}),ot=S.useRef(null),Ye=S.useRef(null),Vn=S.useRef(null),_i=S.useRef(null),Kt=S.useRef(null),Bt=S.useRef(null),Sn=S.useRef(null),ir=S.useRef(!1),[ar,rr]=S.useState(D.starterCode);S.useEffect(()=>{n&&Wv(n.id,n.name,n.avatar)},[n]),S.useEffect(()=>{if(n&&e.state?.challengeFriend&&!ir.current){const X=e.state.challengeFriend;ir.current=!0,window.history.replaceState({},document.title);const _e=To();l2({id:n.id,name:n.name,avatar:n.avatar},X.id,_e),ye({target:X,problem:_e}),c2(X.id,De=>Ti(De.battleId,X,De.problem),()=>ye(null),()=>ye(null))}},[n,e.state]),S.useEffect(()=>{if(n){const X=gR({id:n.id,name:n.name,avatar:n.avatar});return Vn.current=yR(n.id,_e=>{ce(_e.filter(De=>De.status==="available"))}),_i.current=OR(n.id,Ue),Sn.current=wb(n.id,me),()=>{X(),Vn.current&&Vn.current(),_i.current&&_i.current(),Sn.current&&Sn.current()}}},[n]),S.useEffect(()=>{if(Q.length>0){const X=Q.map(De=>De.id);return Cb(X,Ee)}},[Q]),S.useEffect(()=>{let X;if(i==="playing"){const _e=v||Date.now();X=setInterval(()=>{H(Math.floor((Date.now()-_e)/1e3))},1e3)}return()=>clearInterval(X)},[i,v]);const bs=X=>`${Math.floor(X/60).toString().padStart(2,"0")}:${(X%60).toString().padStart(2,"0")}`,Ti=async(X,_e,De,Xt)=>{Kt.current&&clearTimeout(Kt.current),Bt.current&&clearInterval(Bt.current),y(X),I(_e),q(De),rr(De.starterCode),r("playing"),W(null),_(Date.now()),ye(null),$(0),n&&So(n.id,"in_battle"),Kv("battle");const jt=vb(X,async Ni=>{if(Ni.startedAt&&_(Ni.startedAt),Ni.status==="finished"){const Xc=Ni.player1.id===n.id,hu=Ni.winner===(Xc?"player1":"player2");if(r("finished"),W(hu?"win":"lose"),n&&So(n.id,"available"),Ye.current&&Ye.current(),n){const ur=Math.floor((Date.now()-(Ni.startedAt||Date.now()))/1e3),lr=await lA(n.id,hu,ur),Oa=await fA(n.id,lr);Oa.new.length>0&&Ce(Oa.new)}}});Ye.current=jt},sr=async()=>{if(!n)return;r("searching"),$(0);const X=Date.now();Bt.current=setInterval(()=>{$(Math.floor((Date.now()-X)/1e3))},1e3);try{const _e=await yb({id:n.id,name:n.name});x(_e),Kt.current=setTimeout(async()=>{ot.current&&ot.current(),_e&&await lf(_e),Bt.current&&clearInterval(Bt.current),x(null),r("timeout"),n&&So(n.id,"available")},kR);const De=Sb(n.id,_e,Xt=>{Ti(Xt.battleId,Xt.opponent,Xt.problem,null),De()},()=>{Kt.current&&clearTimeout(Kt.current),Bt.current&&clearInterval(Bt.current),r("lobby")});ot.current=De}catch{Kt.current&&clearTimeout(Kt.current),Bt.current&&clearInterval(Bt.current),r("lobby")}},Ss=async()=>{Kt.current&&clearTimeout(Kt.current),Bt.current&&clearInterval(Bt.current),ot.current&&ot.current(),h&&await lf(h),x(null),r("lobby"),$(0),n&&So(n.id,"available")},Gc=async X=>{const _e=To();await l2({id:n.id,name:n.name,avatar:n.avatar},X.id,_e),ye({target:X,problem:_e}),de(!1),c2(X.id,De=>Ti(De.battleId,X,De.problem),()=>ye(null),()=>ye(null))},Vc=async()=>{const X=await vR(n.id,n.name,te);Ti(X,te.from,te.problem),Ue(null)},At=async()=>{await bR(n.id),Ue(null)},Wc=async()=>{O&&n&&await cf(O,n.id)},du=async()=>{l(!0),m({type:"info",content:"Compiling..."});try{const X=await mR(ar);if(X.compile_output)m({type:"error",content:`Compile Error:
${X.compile_output}`});else if(X.stderr)m({type:"error",content:`Runtime Error:
${X.stderr}`});else{const _e=X.stdout?.trim()===D.expectedOutput?.trim();m({type:_e?"success":"warning",content:_e?`All tests passed!
${X.stdout}`:`Wrong answer
Expected: ${D.expectedOutput}
Got: ${X.stdout}`}),_e&&O&&await bb(O,n.id,1,!0)}}catch(X){m({type:"error",content:X.message})}l(!1)},mu=()=>{const X=To();q(X),rr(X.starterCode),r("playing"),I(null),y(null),_(Date.now()),H(0)},or=()=>{r("lobby"),H(0),W(null),y(null),I(null),Ce([]),K(!1),Ye.current&&Ye.current(),n&&So(n.id,"available")},Kc=async()=>{K(!0),C(!1),O&&n&&await cf(O,n.id)},fu=B==="win"?yc:GA,ya=({children:X,onClose:_e})=>f.jsx("div",{style:{position:"fixed",inset:0,background:"rgba(0,0,0,0.8)",backdropFilter:"blur(8px)",display:"flex",alignItems:"center",justifyContent:"center",zIndex:1e3},onClick:_e,children:f.jsx("div",{style:{background:"var(--bg-elevated)",border:"1px solid var(--border)",borderRadius:"18px",padding:"32px",maxWidth:"400px",width:"90%"},onClick:De=>De.stopPropagation(),children:X})});return f.jsxs("div",{className:"page",style:{display:"flex",flexDirection:"column",height:"100vh",paddingTop:"52px"},children:[M&&f.jsx(ya,{onClose:()=>V(!1),children:f.jsxs("div",{style:{textAlign:"center"},children:[f.jsx(dj,{size:40,style:{color:"var(--accent)",marginBottom:"16px"}}),f.jsx("h2",{className:"headline-small",style:{marginBottom:"8px"},children:"Sign In Required"}),f.jsx("p",{style:{color:"var(--text-secondary)",marginBottom:"28px"},children:"Create an account to compete with other players"}),f.jsxs("div",{style:{display:"flex",flexDirection:"column",gap:"12px"},children:[f.jsx(ht,{to:"/signin",style:{textDecoration:"none"},children:f.jsx("button",{className:"btn btn-primary",style:{width:"100%",padding:"14px"},children:"Sign In / Sign Up"})}),f.jsx("button",{onClick:()=>V(!1),style:{padding:"12px",background:"transparent",border:"none",color:"var(--text-secondary)",cursor:"pointer"},children:"Maybe later"})]})]})}),te&&f.jsx(ya,{children:f.jsxs("div",{style:{textAlign:"center"},children:[f.jsx("div",{style:{width:"80px",height:"80px",margin:"0 auto 20px",borderRadius:"50%",background:"linear-gradient(135deg, rgba(0, 113, 227, 0.2), rgba(48, 209, 88, 0.2))",display:"flex",alignItems:"center",justifyContent:"center",border:"2px solid var(--border)"},children:te.from.avatar?f.jsx("img",{src:te.from.avatar,alt:"",style:{width:"72px",height:"72px",borderRadius:"50%",objectFit:"cover"}}):f.jsx("div",{style:{width:"72px",height:"72px",borderRadius:"50%",background:"var(--bg-elevated)",display:"flex",alignItems:"center",justifyContent:"center",fontSize:"28px",fontWeight:"600",color:"var(--accent)"},children:te.from.name?.charAt(0).toUpperCase()})}),f.jsx("h2",{className:"headline-small",style:{marginBottom:"4px"},children:te.from.name}),f.jsx("p",{style:{color:"var(--text-tertiary)",marginBottom:"28px",fontSize:"15px"},children:"wants to battle you"}),f.jsxs("div",{style:{display:"flex",gap:"12px"},children:[f.jsx("button",{onClick:At,style:{flex:1,padding:"14px",background:"transparent",border:"1px solid var(--border)",borderRadius:"980px",color:"var(--text)",cursor:"pointer",fontSize:"15px",fontWeight:"500",transition:"all 0.2s"},children:"Decline"}),f.jsxs("button",{className:"btn btn-primary",onClick:Vc,style:{flex:1,padding:"14px"},children:[f.jsx(Oc,{size:16})," Accept"]})]})]})}),ne.length>0&&f.jsx(ya,{onClose:()=>Ce([]),children:f.jsxs("div",{style:{textAlign:"center"},children:[f.jsx(of,{size:48,style:{color:"var(--orange)",marginBottom:"16px"}}),f.jsx("h2",{className:"headline-small",style:{marginBottom:"8px"},children:"Achievement Unlocked!"}),ne.map((X,_e)=>f.jsxs("div",{style:{padding:"16px",background:"var(--bg-secondary)",borderRadius:"12px",marginTop:"12px",textAlign:"left"},children:[f.jsx("div",{style:{fontWeight:"600",marginBottom:"4px"},children:X.name}),f.jsx("div",{style:{fontSize:"14px",color:"var(--text-secondary)"},children:X.desc})]},_e)),f.jsx("button",{className:"btn btn-primary",onClick:()=>Ce([]),style:{marginTop:"20px",width:"100%",padding:"12px"},children:"Awesome!"})]})}),st&&f.jsxs(ya,{onClose:()=>de(!1),children:[f.jsxs("div",{style:{display:"flex",justifyContent:"space-between",alignItems:"center",marginBottom:"24px"},children:[f.jsx("h2",{className:"headline-small",style:{margin:0},children:"Challenge Friend"}),f.jsx("button",{onClick:()=>de(!1),className:"btn btn-ghost",style:{padding:"8px"},children:f.jsx(bc,{size:20})})]}),Q.filter(X=>he[X.id]).length>0?f.jsx("div",{style:{display:"flex",flexDirection:"column",gap:"8px"},children:Q.filter(X=>he[X.id]).map(X=>f.jsxs("div",{onClick:()=>Gc(X),style:{display:"flex",alignItems:"center",gap:"12px",padding:"12px 16px",background:"var(--bg-secondary)",borderRadius:"12px",cursor:"pointer",transition:"background 0.15s"},children:[X.avatar?f.jsx("img",{src:X.avatar,alt:X.name,style:{width:"40px",height:"40px",borderRadius:"50%",objectFit:"cover"}}):f.jsx("div",{className:"avatar",style:{width:"40px",height:"40px",fontSize:"15px"},children:X.name?.charAt(0).toUpperCase()}),f.jsxs("div",{style:{flex:1},children:[f.jsx("div",{style:{fontWeight:"500"},children:X.name}),f.jsx("div",{style:{fontSize:"12px",color:"var(--green)"},children:"Online"})]}),f.jsx(Oc,{size:16,style:{color:"var(--accent)"}})]},X.id))}):f.jsxs("div",{style:{textAlign:"center",padding:"40px 0"},children:[f.jsx(Io,{size:32,style:{marginBottom:"12px",opacity:.5,color:"var(--text-tertiary)"}}),f.jsx("p",{style:{color:"var(--text-secondary)",marginBottom:"8px"},children:Q.length===0?"No friends added yet":"No friends online right now"}),f.jsx(ht,{to:"/friends",onClick:()=>de(!1),style:{textDecoration:"none"},children:f.jsxs("button",{className:"btn btn-primary",style:{marginTop:"12px",padding:"10px 20px"},children:[f.jsx(vc,{size:16})," Add Friends"]})})]}),Q.filter(X=>!he[X.id]).length>0&&f.jsxs("div",{style:{marginTop:"20px"},children:[f.jsx("span",{className:"caption",style:{display:"block",marginBottom:"8px"},children:"OFFLINE"}),f.jsx("div",{style:{display:"flex",flexDirection:"column",gap:"6px"},children:Q.filter(X=>!he[X.id]).map(X=>f.jsxs("div",{style:{display:"flex",alignItems:"center",gap:"12px",padding:"10px 14px",background:"var(--bg-secondary)",borderRadius:"10px",opacity:.5},children:[X.avatar?f.jsx("img",{src:X.avatar,alt:X.name,style:{width:"32px",height:"32px",borderRadius:"50%",objectFit:"cover"}}):f.jsx("div",{className:"avatar",style:{width:"32px",height:"32px",fontSize:"12px"},children:X.name?.charAt(0).toUpperCase()}),f.jsx("div",{style:{flex:1,fontSize:"14px"},children:X.name}),f.jsx("span",{style:{fontSize:"11px",color:"var(--text-tertiary)"},children:"Offline"})]},X.id))})]})]}),Re&&f.jsx(ya,{onClose:()=>C(!1),children:f.jsxs("div",{style:{textAlign:"center"},children:[f.jsx(Aj,{size:48,style:{color:"var(--orange)",marginBottom:"16px"}}),f.jsx("h2",{className:"headline-small",style:{marginBottom:"8px"},children:"Reveal Solution?"}),f.jsx("p",{style:{color:"var(--text-secondary)",marginBottom:"8px"},children:"This will show you the complete solution and all test cases."}),k&&f.jsx("div",{style:{background:"rgba(255, 69, 58, 0.12)",border:"1px solid rgba(255, 69, 58, 0.3)",borderRadius:"10px",padding:"12px",marginBottom:"20px"},children:f.jsxs("p",{style:{color:"var(--red)",fontSize:"14px",fontWeight:"500",margin:0},children:[f.jsx(Uj,{size:14,style:{display:"inline",marginRight:"4px"}})," This will forfeit the battle and count as a loss"]})}),!k&&f.jsx("p",{style:{color:"var(--orange)",fontSize:"13px",marginBottom:"20px"},children:"Practice mode - no penalty applied"}),f.jsxs("div",{style:{display:"flex",gap:"12px"},children:[f.jsx("button",{onClick:()=>C(!1),style:{flex:1,padding:"12px",background:"transparent",border:"1px solid var(--border)",borderRadius:"980px",color:"var(--text)",cursor:"pointer"},children:"Cancel"}),f.jsx("button",{onClick:Kc,style:{flex:1,padding:"12px",background:"var(--red)",border:"none",borderRadius:"980px",color:"white",cursor:"pointer",fontWeight:"500"},children:"Reveal Solution"})]})]})}),i==="lobby"&&f.jsx("div",{style:{flex:1,display:"flex",alignItems:"center",justifyContent:"center",padding:"24px"},children:f.jsxs("div",{style:{maxWidth:"380px",width:"100%",textAlign:"center"},children:[f.jsx("h1",{className:"headline",style:{marginBottom:"12px"},children:"Ready to battle?"}),f.jsx("p",{style:{color:"var(--text-secondary)",marginBottom:"40px"},children:"Compete in real-time coding challenges"}),f.jsxs("div",{style:{display:"flex",flexDirection:"column",gap:"12px"},children:[f.jsxs("button",{className:"btn btn-primary",onClick:()=>n?sr():V(!0),style:{width:"100%",padding:"14px"},children:[f.jsx(ib,{size:18})," Find Match"]}),f.jsxs("button",{onClick:()=>n?de(!0):V(!0),style:{width:"100%",padding:"14px",background:"var(--bg-elevated)",border:"1px solid var(--border)",borderRadius:"980px",color:"var(--text)",cursor:"pointer",display:"flex",alignItems:"center",justifyContent:"center",gap:"8px"},children:[f.jsx(vc,{size:18})," Challenge Friend"]}),f.jsxs("button",{onClick:mu,style:{width:"100%",padding:"14px",background:"transparent",border:"none",borderRadius:"980px",color:"var(--text-secondary)",cursor:"pointer",display:"flex",alignItems:"center",justifyContent:"center",gap:"8px"},children:[f.jsx(WA,{size:18})," Solo Practice"]})]})]})}),i==="searching"&&f.jsxs("div",{style:{flex:1,display:"flex",alignItems:"center",justifyContent:"center",flexDirection:"column",gap:"24px"},children:[f.jsx("div",{className:"spinner",style:{width:"40px",height:"40px",borderWidth:"3px"}}),f.jsxs("div",{style:{textAlign:"center"},children:[f.jsx("p",{style:{color:"var(--text-secondary)",marginBottom:"8px"},children:"Finding opponent..."}),f.jsx("p",{className:"mono",style:{fontSize:"24px",fontWeight:"600"},children:bs(J)}),f.jsxs("p",{style:{fontSize:"13px",color:"var(--text-tertiary)",marginTop:"8px"},children:["Timeout in ",Math.max(0,30-J),"s"]})]}),f.jsx("button",{onClick:Ss,style:{padding:"10px 24px",background:"transparent",border:"none",color:"var(--accent)",cursor:"pointer"},children:"Cancel"})]}),i==="timeout"&&f.jsxs("div",{style:{flex:1,display:"flex",alignItems:"center",justifyContent:"center",flexDirection:"column",gap:"24px"},children:[f.jsx(qA,{size:48,style:{color:"var(--orange)"}}),f.jsxs("div",{style:{textAlign:"center"},children:[f.jsx("h2",{className:"headline-small",style:{marginBottom:"8px"},children:"No opponents found"}),f.jsx("p",{style:{color:"var(--text-secondary)"},children:"Try again or practice solo"})]}),f.jsxs("div",{style:{display:"flex",gap:"12px"},children:[f.jsx("button",{onClick:sr,className:"btn btn-primary",style:{padding:"12px 24px"},children:"Try Again"}),f.jsx("button",{onClick:()=>r("lobby"),style:{padding:"12px 24px",background:"var(--bg-elevated)",border:"1px solid var(--border)",borderRadius:"980px",color:"var(--text)",cursor:"pointer"},children:"Back"})]})]}),Y&&i==="lobby"&&f.jsxs("div",{style:{position:"fixed",bottom:"24px",right:"24px",background:"var(--bg-elevated)",border:"1px solid var(--border)",borderRadius:"14px",padding:"16px 20px",display:"flex",alignItems:"center",gap:"12px"},children:[f.jsx("div",{className:"spinner",style:{width:"16px",height:"16px"}}),f.jsxs("span",{style:{fontSize:"15px"},children:["Waiting for ",Y.target.name,"..."]}),f.jsx("button",{onClick:()=>ye(null),style:{background:"none",border:"none",color:"var(--text-tertiary)",cursor:"pointer",padding:"4px"},children:f.jsx(bc,{size:16})})]}),(i==="playing"||i==="finished")&&f.jsxs("div",{style:{flex:1,display:"flex",overflow:"hidden"},children:[f.jsxs("div",{style:{flex:1,display:"flex",flexDirection:"column",borderRight:"1px solid var(--border)"},children:[f.jsx("div",{style:{padding:"12px 20px",borderBottom:"1px solid var(--border)",display:"flex",alignItems:"center"},children:f.jsx("span",{className:"mono",style:{fontSize:"13px",color:"var(--text-tertiary)"},children:"main.cpp"})}),f.jsx("div",{style:{flex:1},children:f.jsx(uf,{height:"100%",defaultLanguage:"cpp",theme:"vs-dark",value:ar,onChange:X=>rr(X||""),options:{fontSize:14,minimap:{enabled:!1},automaticLayout:!0,readOnly:i==="finished",padding:{top:16},fontFamily:"SF Mono, Menlo, Monaco, monospace"}})}),f.jsxs("div",{style:{padding:"16px 20px",borderTop:"1px solid var(--border)",display:"flex",alignItems:"center",gap:"12px"},children:[f.jsx("button",{className:"btn btn-primary",onClick:du,disabled:o||i==="finished",style:{padding:"10px 20px"},children:o?f.jsxs(f.Fragment,{children:[f.jsx("div",{className:"spinner",style:{width:"14px",height:"14px"}})," Running..."]}):f.jsxs(f.Fragment,{children:[f.jsx(nb,{size:16})," Run"]})}),f.jsxs("button",{onClick:()=>rr(D.starterCode),disabled:i==="finished",style:{padding:"10px 16px",background:"transparent",border:"1px solid var(--border)",borderRadius:"980px",color:"var(--text-secondary)",cursor:"pointer",display:"flex",alignItems:"center",gap:"6px"},children:[f.jsx(vj,{size:14})," Reset"]}),k&&i==="playing"&&f.jsxs("button",{onClick:Wc,style:{marginLeft:"auto",padding:"10px 16px",background:"transparent",border:"none",color:"var(--red)",cursor:"pointer",display:"flex",alignItems:"center",gap:"6px"},children:[f.jsx(tj,{size:14})," Forfeit"]})]})]}),f.jsxs("div",{style:{width:"400px",display:"flex",flexDirection:"column",background:"var(--bg-secondary)",overflow:"auto"},children:[f.jsxs("div",{style:{padding:"24px",borderBottom:"1px solid var(--border)"},children:[f.jsx("span",{className:"badge",style:{marginBottom:"12px",background:D.difficulty==="EASY"?"rgba(48, 209, 88, 0.12)":"rgba(255, 159, 10, 0.12)",color:D.difficulty==="EASY"?"var(--green)":"var(--orange)"},children:D.difficulty}),f.jsx("h2",{style:{fontSize:"22px",fontWeight:"600",marginBottom:"12px"},children:D.title}),f.jsx("p",{style:{color:"var(--text-secondary)",fontSize:"15px",lineHeight:1.6},children:D.description}),D.testCases&&D.testCases.length>0&&f.jsxs("div",{style:{marginTop:"16px",paddingTop:"16px",borderTop:"1px solid var(--border)"},children:[f.jsx("span",{className:"caption",style:{display:"block",marginBottom:"10px"},children:"SAMPLE I/O"}),f.jsx("div",{style:{display:"flex",flexDirection:"column",gap:"8px"},children:D.testCases.slice(0,2).map((X,_e)=>f.jsx("div",{style:{background:"var(--bg)",borderRadius:"8px",padding:"10px 12px",border:"1px solid var(--border)",fontSize:"12px"},children:f.jsxs("div",{style:{display:"flex",gap:"12px"},children:[f.jsxs("div",{style:{flex:1},children:[f.jsx("span",{style:{color:"var(--text-tertiary)",fontSize:"10px",fontWeight:"600"},children:"IN"}),f.jsx("code",{className:"mono",style:{display:"block",color:"var(--text)",marginTop:"2px"},children:X.input})]}),f.jsxs("div",{style:{flex:1},children:[f.jsx("span",{style:{color:"var(--text-tertiary)",fontSize:"10px",fontWeight:"600"},children:"OUT"}),f.jsx("code",{className:"mono",style:{display:"block",color:"var(--green)",marginTop:"2px"},children:X.expectedOutput})]})]})},_e))})]})]}),f.jsxs("div",{style:{flex:1,padding:"20px",display:"flex",flexDirection:"column"},children:[f.jsx("span",{className:"caption",style:{marginBottom:"12px"},children:"OUTPUT"}),f.jsx("div",{style:{flex:1,padding:"16px",background:"var(--bg)",borderRadius:"12px",border:"1px solid var(--border)",overflow:"auto"},children:f.jsx("pre",{className:"mono",style:{margin:0,fontSize:"13px",whiteSpace:"pre-wrap",color:p.type==="success"?"var(--green)":p.type==="error"?"var(--red)":"var(--text-secondary)"},children:p.content})})]}),!P&&i==="playing"&&f.jsx("div",{style:{padding:"0 20px 16px"},children:f.jsxs("button",{onClick:()=>C(!0),style:{width:"100%",padding:"10px",background:"transparent",border:"1px dashed var(--border)",borderRadius:"8px",color:"var(--text-tertiary)",cursor:"pointer",fontSize:"13px",display:"flex",alignItems:"center",justifyContent:"center",gap:"6px"},children:[f.jsx(Zv,{size:14}),"View Solution ",k&&"(forfeit)"]})}),P&&f.jsx("div",{style:{padding:"0 20px 20px"},children:f.jsxs("div",{style:{background:"rgba(255, 159, 10, 0.08)",border:"1px solid rgba(255, 159, 10, 0.3)",borderRadius:"12px",padding:"16px"},children:[f.jsx("span",{className:"caption",style:{display:"block",marginBottom:"10px",color:"var(--orange)"},children:"SOLUTION (REVEALED)"}),f.jsx("pre",{className:"mono",style:{margin:0,fontSize:"11px",whiteSpace:"pre-wrap",color:"var(--text)",maxHeight:"150px",overflow:"auto"},children:D.solution}),D.testCases&&f.jsxs("div",{style:{marginTop:"12px",paddingTop:"12px",borderTop:"1px solid var(--border)"},children:[f.jsxs("span",{style:{fontSize:"11px",color:"var(--text-tertiary)",fontWeight:"600"},children:["ALL TEST CASES (",D.testCases.length,")"]}),f.jsx("div",{style:{marginTop:"8px",maxHeight:"120px",overflow:"auto"},children:D.testCases.map((X,_e)=>f.jsxs("div",{style:{fontSize:"11px",padding:"6px 8px",background:"var(--bg)",borderRadius:"6px",marginBottom:"4px"},children:[f.jsxs("span",{className:"mono",style:{color:"var(--text-secondary)"},children:[X.input,"  ",f.jsx("span",{style:{color:"var(--green)"},children:X.expectedOutput})]}),X.explanation&&f.jsxs("span",{style:{color:"var(--text-tertiary)",marginLeft:"8px"},children:["(",X.explanation,")"]})]},_e))})]})]})}),i==="finished"&&f.jsxs("div",{style:{padding:"24px",borderTop:"1px solid var(--border)",textAlign:"center"},children:[f.jsx(fu,{size:48,style:{color:B==="win"?"var(--green)":"var(--red)",marginBottom:"12px"}}),f.jsx("h3",{style:{fontSize:"24px",fontWeight:"600",marginBottom:"4px",color:B==="win"?"var(--green)":"var(--red)"},children:B==="win"?"Victory!":"Defeated"}),f.jsxs("p",{style:{color:"var(--text-tertiary)",marginBottom:"20px"},children:["Time: ",bs(z)]}),f.jsx("button",{className:"btn btn-primary",onClick:or,style:{width:"100%",padding:"14px"},children:"Play Again"})]})]})]})]})},Il=20,AR=()=>{const[n,e]=S.useState("ALL"),[i,r]=S.useState("ALL"),[o,l]=S.useState(""),[p,m]=S.useState(null),[h,x]=S.useState({}),[O,y]=S.useState({}),[v,_]=S.useState(1),k=S.useMemo(()=>["ALL",...ob()],[]);S.useMemo(()=>Hc(),[]);const I=S.useMemo(()=>$a.filter(B=>{const W=n==="ALL"||B.difficulty===n,ae=i==="ALL"||B.category===i,ce=B.title.toLowerCase().includes(o.toLowerCase())||B.description.toLowerCase().includes(o.toLowerCase());return W&&ae&&ce}),[n,i,o]),D=Math.ceil(I.length/Il),q=(v-1)*Il,z=I.slice(q,q+Il);S.useMemo(()=>{_(1)},[n,i,o]);const H=B=>{m(p===B?null:B),p===B&&x({})},J=(B,W)=>{W.stopPropagation(),x(ae=>({...ae,[B]:!ae[B]}))},$=B=>{switch(B){case"EASY":return{background:"rgba(48, 209, 88, 0.12)",color:"var(--green)"};case"MEDIUM":return{background:"rgba(255, 159, 10, 0.12)",color:"var(--orange)"};case"HARD":return{background:"rgba(255, 69, 58, 0.12)",color:"var(--red)"};default:return{background:"rgba(0, 113, 227, 0.12)",color:"var(--accent)"}}};return f.jsx("div",{className:"page",children:f.jsxs("div",{className:"container",style:{paddingTop:"56px",paddingBottom:"56px"},children:[f.jsxs("div",{style:{marginBottom:"48px"},children:[f.jsx("p",{className:"caption",style:{marginBottom:"8px"},children:"Learn"}),f.jsx("h1",{className:"headline",children:"Master C++ Programming."}),f.jsx("p",{className:"body-large",style:{marginTop:"12px"},children:"600+ curated problems with solutions and explanations."})]}),f.jsxs("div",{className:"card",style:{padding:"20px",marginBottom:"24px"},children:[f.jsxs("div",{style:{display:"flex",gap:"12px",flexWrap:"wrap",alignItems:"center"},children:[f.jsxs("div",{style:{flex:1,minWidth:"200px",position:"relative"},children:[f.jsx(yh,{size:16,style:{position:"absolute",left:"14px",top:"50%",transform:"translateY(-50%)",color:"var(--text-tertiary)"}}),f.jsx("input",{type:"text",placeholder:"Search problems...",value:o,onChange:B=>l(B.target.value),className:"input",style:{paddingLeft:"40px"}})]}),f.jsxs("select",{value:n,onChange:B=>e(B.target.value),className:"input",style:{width:"auto",cursor:"pointer",fontFamily:"inherit"},children:[f.jsx("option",{value:"ALL",children:"All Levels"}),f.jsx("option",{value:"EASY",children:"Easy"}),f.jsx("option",{value:"MEDIUM",children:"Medium"}),f.jsx("option",{value:"HARD",children:"Hard"})]}),f.jsx("select",{value:i,onChange:B=>r(B.target.value),className:"input",style:{width:"auto",cursor:"pointer",fontFamily:"inherit"},children:k.map(B=>f.jsx("option",{value:B,children:B==="ALL"?"All Categories":B},B))})]}),f.jsx("div",{style:{display:"flex",justifyContent:"space-between",alignItems:"center",marginTop:"16px"},children:f.jsxs("span",{className:"caption",children:["Showing ",q+1,"-",Math.min(q+Il,I.length)," of ",I.length]})})]}),f.jsx("div",{className:"card",style:{padding:0,overflow:"hidden"},children:f.jsxs("table",{className:"table",children:[f.jsx("thead",{children:f.jsxs("tr",{children:[f.jsx("th",{style:{width:"50px"},children:"#"}),f.jsx("th",{children:"Problem"}),f.jsx("th",{style:{width:"100px"},children:"Level"}),f.jsx("th",{style:{width:"140px"},children:"Category"})]})}),f.jsx("tbody",{children:z.map((B,W)=>f.jsxs(Ha.Fragment,{children:[f.jsxs("tr",{onClick:()=>H(B.id),style:{cursor:"pointer"},children:[f.jsx("td",{className:"mono",style:{color:"var(--text-tertiary)"},children:q+W+1}),f.jsx("td",{children:f.jsxs("div",{style:{display:"flex",alignItems:"center",gap:"8px"},children:[p===B.id?f.jsx(RA,{size:16,style:{color:"var(--accent)",flexShrink:0}}):f.jsx(e2,{size:16,style:{color:"var(--text-tertiary)",flexShrink:0}}),f.jsxs("div",{children:[f.jsx("div",{style:{fontWeight:"500"},children:B.title}),f.jsx("div",{style:{fontSize:"13px",color:"var(--text-tertiary)",marginTop:"2px"},children:B.description})]})]})}),f.jsx("td",{children:f.jsx("span",{className:"badge",style:$(B.difficulty),children:B.difficulty})}),f.jsx("td",{style:{color:"var(--text-secondary)"},children:B.category})]}),p===B.id&&f.jsx("tr",{children:f.jsx("td",{colSpan:4,style:{padding:0,background:"var(--bg-secondary)"},children:f.jsxs("div",{style:{padding:"24px"},children:[f.jsxs("div",{className:"grid grid-2",style:{marginBottom:"24px"},children:[f.jsxs("div",{children:[f.jsx("span",{className:"caption",style:{display:"block",marginBottom:"8px"},children:"DESCRIPTION"}),f.jsx("p",{style:{color:"var(--text)",lineHeight:"1.5"},children:B.description})]}),f.jsxs("div",{children:[f.jsx("span",{className:"caption",style:{display:"block",marginBottom:"8px"},children:"EXPECTED OUTPUT"}),f.jsx("code",{className:"mono",style:{background:"var(--bg-elevated)",padding:"10px 14px",borderRadius:"8px",display:"block",color:"var(--green)"},children:B.expectedOutput})]})]}),B.testCases&&B.testCases.length>0&&f.jsxs("div",{style:{marginBottom:"24px"},children:[f.jsxs("div",{style:{display:"flex",justifyContent:"space-between",alignItems:"center",marginBottom:"12px"},children:[f.jsxs("span",{className:"caption",children:["TEST CASES (",B.testCases.length,")"]}),B.testCases.length>3&&f.jsx("button",{onClick:ae=>{ae.stopPropagation(),y(ce=>({...ce,[B.id]:!ce[B.id]}))},style:{background:"transparent",border:"none",color:"var(--accent)",cursor:"pointer",fontSize:"13px",fontWeight:"500"},children:O[B.id]?"Show Less":`Show All ${B.testCases.length}`})]}),f.jsx("div",{style:{display:"flex",flexDirection:"column",gap:"8px"},children:(O[B.id]?B.testCases:B.testCases.slice(0,3)).map((ae,ce)=>f.jsxs("div",{style:{background:"var(--bg-elevated)",borderRadius:"10px",padding:"12px 14px",border:"1px solid var(--border)"},children:[f.jsxs("div",{style:{display:"flex",justifyContent:"space-between",alignItems:"flex-start",gap:"16px"},children:[f.jsxs("div",{style:{flex:1},children:[f.jsx("span",{style:{fontSize:"11px",color:"var(--text-tertiary)",fontWeight:"600",letterSpacing:"0.5px"},children:"INPUT"}),f.jsx("code",{className:"mono",style:{display:"block",fontSize:"13px",color:"var(--text)",marginTop:"4px"},children:ae.input})]}),f.jsxs("div",{style:{flex:1},children:[f.jsx("span",{style:{fontSize:"11px",color:"var(--text-tertiary)",fontWeight:"600",letterSpacing:"0.5px"},children:"OUTPUT"}),f.jsx("code",{className:"mono",style:{display:"block",fontSize:"13px",color:"var(--green)",marginTop:"4px"},children:ae.expectedOutput})]})]}),ae.explanation&&f.jsxs("div",{style:{marginTop:"8px",paddingTop:"8px",borderTop:"1px solid var(--border)",display:"flex",alignItems:"flex-start",gap:"6px"},children:[f.jsx(sj,{size:12,style:{color:"var(--text-tertiary)",marginTop:"2px",flexShrink:0}}),f.jsx("span",{style:{fontSize:"12px",color:"var(--text-secondary)"},children:ae.explanation})]})]},ce))})]}),f.jsxs("div",{style:{marginBottom:"24px"},children:[f.jsx("span",{className:"caption",style:{display:"block",marginBottom:"12px"},children:"STARTER CODE"}),f.jsx("div",{style:{borderRadius:"12px",overflow:"hidden",border:"1px solid var(--border)"},children:f.jsx(uf,{height:"160px",defaultLanguage:"cpp",value:B.starterCode,theme:"vs-dark",options:{readOnly:!0,minimap:{enabled:!1},fontSize:13,scrollBeyondLastLine:!1,lineNumbers:"on",padding:{top:12}}})})]}),f.jsxs("button",{onClick:ae=>J(B.id,ae),className:"btn btn-primary",style:{marginBottom:h[B.id]?"24px":0},children:[h[B.id]?f.jsx($A,{size:16}):f.jsx(Zv,{size:16}),h[B.id]?"Hide Solution":"Show Solution"]}),h[B.id]&&f.jsxs(f.Fragment,{children:[f.jsxs("div",{style:{marginBottom:"24px"},children:[f.jsx("span",{className:"caption",style:{display:"block",marginBottom:"12px"},children:"SOLUTION"}),f.jsx("div",{style:{borderRadius:"12px",overflow:"hidden",border:"1px solid rgba(255, 159, 10, 0.3)"},children:f.jsx(uf,{height:"200px",defaultLanguage:"cpp",value:B.solution,theme:"vs-dark",options:{readOnly:!0,minimap:{enabled:!1},fontSize:13,scrollBeyondLastLine:!1,lineNumbers:"on",padding:{top:12}}})})]}),B.explanation&&f.jsxs("div",{className:"card",style:{background:"var(--bg-elevated)"},children:[f.jsx("span",{className:"caption",style:{display:"block",marginBottom:"16px"},children:"EXPLANATION"}),B.explanation.approach&&f.jsxs("div",{style:{marginBottom:"16px"},children:[f.jsx("span",{style:{fontWeight:"500",color:"var(--accent)"},children:"Approach: "}),f.jsx("span",{style:{color:"var(--text-secondary)"},children:B.explanation.approach})]}),B.explanation.analogy&&f.jsxs("div",{style:{marginBottom:"16px",padding:"14px 16px",background:"rgba(0, 113, 227, 0.08)",borderRadius:"10px",borderLeft:"3px solid var(--accent)"},children:[f.jsx("span",{style:{fontWeight:"500",color:"var(--accent)"},children:"Analogy: "}),f.jsx("span",{style:{color:"var(--text)"},children:B.explanation.analogy})]}),B.explanation.steps&&f.jsxs("div",{style:{marginBottom:"16px"},children:[f.jsx("span",{style:{fontWeight:"500",color:"var(--green)",display:"block",marginBottom:"8px"},children:"Steps:"}),f.jsx("ol",{style:{paddingLeft:"20px",color:"var(--text-secondary)",margin:0},children:B.explanation.steps.map((ae,ce)=>f.jsx("li",{style:{marginBottom:"4px",lineHeight:"1.5"},children:ae},ce))})]}),B.explanation.complexity&&f.jsx("div",{style:{display:"inline-block",padding:"8px 14px",background:"var(--bg-secondary)",borderRadius:"8px"},children:f.jsx("span",{className:"mono",style:{color:"var(--text-secondary)",fontSize:"13px"},children:B.explanation.complexity})})]})]})]})})})]},B.id))})]})}),D>1&&f.jsxs("div",{style:{display:"flex",justifyContent:"center",alignItems:"center",gap:"8px",marginTop:"24px"},children:[f.jsx("button",{onClick:()=>_(1),disabled:v===1,className:"btn btn-ghost",style:{padding:"8px"},children:f.jsx(BA,{size:18})}),f.jsx("button",{onClick:()=>_(B=>Math.max(1,B-1)),disabled:v===1,className:"btn btn-ghost",style:{padding:"8px"},children:f.jsx(IA,{size:18})}),f.jsxs("span",{style:{padding:"0 16px",color:"var(--text-secondary)"},children:["Page ",v," of ",D]}),f.jsx("button",{onClick:()=>_(B=>Math.min(D,B+1)),disabled:v===D,className:"btn btn-ghost",style:{padding:"8px"},children:f.jsx(e2,{size:18})}),f.jsx("button",{onClick:()=>_(D),disabled:v===D,className:"btn btn-ghost",style:{padding:"8px"},children:f.jsx(zA,{size:18})})]}),I.length===0&&f.jsxs("div",{className:"empty",children:[f.jsx("p",{style:{fontSize:"17px",marginBottom:"8px"},children:"No problems found"}),f.jsx("p",{style:{fontSize:"14px"},children:"Try adjusting your filters"})]})]})})};const _b="firebasestorage.googleapis.com",Tb="storageBucket",jR=120*1e3,MR=600*1e3;class rt extends Si{constructor(e,i,r=0){super(Dm(e),`Firebase Storage: ${i} (${Dm(e)})`),this.status_=r,this.customData={serverResponse:null},this._baseMessage=this.message,Object.setPrototypeOf(this,rt.prototype)}get status(){return this.status_}set status(e){this.status_=e}_codeEquals(e){return Dm(e)===this.code}get serverResponse(){return this.customData.serverResponse}set serverResponse(e){this.customData.serverResponse=e,this.customData.serverResponse?this.message=`${this._baseMessage}
${this.customData.serverResponse}`:this.message=this._baseMessage}}var it;(function(n){n.UNKNOWN="unknown",n.OBJECT_NOT_FOUND="object-not-found",n.BUCKET_NOT_FOUND="bucket-not-found",n.PROJECT_NOT_FOUND="project-not-found",n.QUOTA_EXCEEDED="quota-exceeded",n.UNAUTHENTICATED="unauthenticated",n.UNAUTHORIZED="unauthorized",n.UNAUTHORIZED_APP="unauthorized-app",n.RETRY_LIMIT_EXCEEDED="retry-limit-exceeded",n.INVALID_CHECKSUM="invalid-checksum",n.CANCELED="canceled",n.INVALID_EVENT_NAME="invalid-event-name",n.INVALID_URL="invalid-url",n.INVALID_DEFAULT_BUCKET="invalid-default-bucket",n.NO_DEFAULT_BUCKET="no-default-bucket",n.CANNOT_SLICE_BLOB="cannot-slice-blob",n.SERVER_FILE_WRONG_SIZE="server-file-wrong-size",n.NO_DOWNLOAD_URL="no-download-url",n.INVALID_ARGUMENT="invalid-argument",n.INVALID_ARGUMENT_COUNT="invalid-argument-count",n.APP_DELETED="app-deleted",n.INVALID_ROOT_OPERATION="invalid-root-operation",n.INVALID_FORMAT="invalid-format",n.INTERNAL_ERROR="internal-error",n.UNSUPPORTED_ENVIRONMENT="unsupported-environment"})(it||(it={}));function Dm(n){return"storage/"+n}function Ch(){const n="An unknown error occurred, please check the error payload for server response.";return new rt(it.UNKNOWN,n)}function RR(n){return new rt(it.OBJECT_NOT_FOUND,"Object '"+n+"' does not exist.")}function DR(n){return new rt(it.QUOTA_EXCEEDED,"Quota for bucket '"+n+"' exceeded, please view quota on https://firebase.google.com/pricing/.")}function IR(){const n="User is not authenticated, please authenticate using Firebase Authentication and try again.";return new rt(it.UNAUTHENTICATED,n)}function LR(){return new rt(it.UNAUTHORIZED_APP,"This app does not have permission to access Firebase Storage on this project.")}function PR(n){return new rt(it.UNAUTHORIZED,"User does not have permission to access '"+n+"'.")}function BR(){return new rt(it.RETRY_LIMIT_EXCEEDED,"Max retry time for operation exceeded, please try again.")}function UR(){return new rt(it.CANCELED,"User canceled the upload/download.")}function zR(n){return new rt(it.INVALID_URL,"Invalid URL '"+n+"'.")}function FR(n){return new rt(it.INVALID_DEFAULT_BUCKET,"Invalid default bucket '"+n+"'.")}function qR(){return new rt(it.NO_DEFAULT_BUCKET,"No default bucket found. Did you set the '"+Tb+"' property when initializing the app?")}function HR(){return new rt(it.CANNOT_SLICE_BLOB,"Cannot slice blob for upload. Please retry the upload.")}function YR(){return new rt(it.NO_DOWNLOAD_URL,"The given file does not have any download URLs.")}function GR(n){return new rt(it.UNSUPPORTED_ENVIRONMENT,`${n} is missing. Make sure to install the required polyfills. See https://firebase.google.com/docs/web/environments-js-sdk#polyfills for more information.`)}function pf(n){return new rt(it.INVALID_ARGUMENT,n)}function Nb(){return new rt(it.APP_DELETED,"The Firebase app was deleted.")}function VR(n){return new rt(it.INVALID_ROOT_OPERATION,"The operation '"+n+"' cannot be performed on a root reference, create a non-root reference using child, such as .child('file.png').")}function Po(n,e){return new rt(it.INVALID_FORMAT,"String does not match format '"+n+"': "+e)}function wo(n){throw new rt(it.INTERNAL_ERROR,"Internal error: "+n)}class rn{constructor(e,i){this.bucket=e,this.path_=i}get path(){return this.path_}get isRoot(){return this.path.length===0}fullServerUrl(){const e=encodeURIComponent;return"/b/"+e(this.bucket)+"/o/"+e(this.path)}bucketOnlyServerUrl(){return"/b/"+encodeURIComponent(this.bucket)+"/o"}static makeFromBucketSpec(e,i){let r;try{r=rn.makeFromUrl(e,i)}catch{return new rn(e,"")}if(r.path==="")return r;throw FR(e)}static makeFromUrl(e,i){let r=null;const o="([A-Za-z0-9.\\-_]+)";function l(J){J.path.charAt(J.path.length-1)==="/"&&(J.path_=J.path_.slice(0,-1))}const p="(/(.*))?$",m=new RegExp("^gs://"+o+p,"i"),h={bucket:1,path:3};function x(J){J.path_=decodeURIComponent(J.path)}const O="v[A-Za-z0-9_]+",y=i.replace(/[.]/g,"\\."),v="(/([^?#]*).*)?$",_=new RegExp(`^https?://${y}/${O}/b/${o}/o${v}`,"i"),k={bucket:1,path:3},I=i===_b?"(?:storage.googleapis.com|storage.cloud.google.com)":i,D="([^?#]*)",q=new RegExp(`^https?://${I}/${o}/${D}`,"i"),H=[{regex:m,indices:h,postModify:l},{regex:_,indices:k,postModify:x},{regex:q,indices:{bucket:1,path:2},postModify:x}];for(let J=0;J<H.length;J++){const $=H[J],B=$.regex.exec(e);if(B){const W=B[$.indices.bucket];let ae=B[$.indices.path];ae||(ae=""),r=new rn(W,ae),$.postModify(r);break}}if(r==null)throw zR(e);return r}}class WR{constructor(e){this.promise_=Promise.reject(e)}getPromise(){return this.promise_}cancel(e=!1){}}function KR(n,e,i){let r=1,o=null,l=null,p=!1,m=0;function h(){return m===2}let x=!1;function O(...D){x||(x=!0,e.apply(null,D))}function y(D){o=setTimeout(()=>{o=null,n(_,h())},D)}function v(){l&&clearTimeout(l)}function _(D,...q){if(x){v();return}if(D){v(),O.call(null,D,...q);return}if(h()||p){v(),O.call(null,D,...q);return}r<64&&(r*=2);let H;m===1?(m=2,H=0):H=(r+Math.random())*1e3,y(H)}let k=!1;function I(D){k||(k=!0,v(),!x&&(o!==null?(D||(m=2),clearTimeout(o),y(0)):D||(m=1)))}return y(0),l=setTimeout(()=>{p=!0,I(!0)},i),I}function XR(n){n(!1)}function QR(n){return n!==void 0}function JR(n){return typeof n=="object"&&!Array.isArray(n)}function _h(n){return typeof n=="string"||n instanceof String}function p2(n){return Th()&&n instanceof Blob}function Th(){return typeof Blob<"u"}function d2(n,e,i,r){if(r<e)throw pf(`Invalid value for '${n}'. Expected ${e} or greater.`);if(r>i)throw pf(`Invalid value for '${n}'. Expected ${i} or less.`)}function Nh(n,e,i){let r=e;return i==null&&(r=`https://${e}`),`${i}://${r}/v0${n}`}function kb(n){const e=encodeURIComponent;let i="?";for(const r in n)if(n.hasOwnProperty(r)){const o=e(r)+"="+e(n[r]);i=i+o+"&"}return i=i.slice(0,-1),i}var Ya;(function(n){n[n.NO_ERROR=0]="NO_ERROR",n[n.NETWORK_ERROR=1]="NETWORK_ERROR",n[n.ABORT=2]="ABORT"})(Ya||(Ya={}));function $R(n,e){const i=n>=500&&n<600,o=[408,429].indexOf(n)!==-1,l=e.indexOf(n)!==-1;return i||o||l}class ZR{constructor(e,i,r,o,l,p,m,h,x,O,y,v=!0,_=!1){this.url_=e,this.method_=i,this.headers_=r,this.body_=o,this.successCodes_=l,this.additionalRetryCodes_=p,this.callback_=m,this.errorCallback_=h,this.timeout_=x,this.progressCallback_=O,this.connectionFactory_=y,this.retry=v,this.isUsingEmulator=_,this.pendingConnection_=null,this.backoffId_=null,this.canceled_=!1,this.appDelete_=!1,this.promise_=new Promise((k,I)=>{this.resolve_=k,this.reject_=I,this.start_()})}start_(){const e=(r,o)=>{if(o){r(!1,new Ll(!1,null,!0));return}const l=this.connectionFactory_();this.pendingConnection_=l;const p=m=>{const h=m.loaded,x=m.lengthComputable?m.total:-1;this.progressCallback_!==null&&this.progressCallback_(h,x)};this.progressCallback_!==null&&l.addUploadProgressListener(p),l.send(this.url_,this.method_,this.isUsingEmulator,this.body_,this.headers_).then(()=>{this.progressCallback_!==null&&l.removeUploadProgressListener(p),this.pendingConnection_=null;const m=l.getErrorCode()===Ya.NO_ERROR,h=l.getStatus();if(!m||$R(h,this.additionalRetryCodes_)&&this.retry){const O=l.getErrorCode()===Ya.ABORT;r(!1,new Ll(!1,null,O));return}const x=this.successCodes_.indexOf(h)!==-1;r(!0,new Ll(x,l))})},i=(r,o)=>{const l=this.resolve_,p=this.reject_,m=o.connection;if(o.wasSuccessCode)try{const h=this.callback_(m,m.getResponse());QR(h)?l(h):l()}catch(h){p(h)}else if(m!==null){const h=Ch();h.serverResponse=m.getErrorText(),this.errorCallback_?p(this.errorCallback_(m,h)):p(h)}else if(o.canceled){const h=this.appDelete_?Nb():UR();p(h)}else{const h=BR();p(h)}};this.canceled_?i(!1,new Ll(!1,null,!0)):this.backoffId_=KR(e,i,this.timeout_)}getPromise(){return this.promise_}cancel(e){this.canceled_=!0,this.appDelete_=e||!1,this.backoffId_!==null&&XR(this.backoffId_),this.pendingConnection_!==null&&this.pendingConnection_.abort()}}class Ll{constructor(e,i,r){this.wasSuccessCode=e,this.connection=i,this.canceled=!!r}}function eD(n,e){e!==null&&e.length>0&&(n.Authorization="Firebase "+e)}function tD(n,e){n["X-Firebase-Storage-Version"]="webjs/"+(e??"AppManager")}function nD(n,e){e&&(n["X-Firebase-GMPID"]=e)}function iD(n,e){e!==null&&(n["X-Firebase-AppCheck"]=e)}function aD(n,e,i,r,o,l,p=!0,m=!1){const h=kb(n.urlParams),x=n.url+h,O=Object.assign({},n.headers);return nD(O,e),eD(O,i),tD(O,l),iD(O,r),new ZR(x,n.method,O,n.body,n.successCodes,n.additionalRetryCodes,n.handler,n.errorHandler,n.timeout,n.progressCallback,o,p,m)}function rD(){return typeof BlobBuilder<"u"?BlobBuilder:typeof WebKitBlobBuilder<"u"?WebKitBlobBuilder:void 0}function sD(...n){const e=rD();if(e!==void 0){const i=new e;for(let r=0;r<n.length;r++)i.append(n[r]);return i.getBlob()}else{if(Th())return new Blob(n);throw new rt(it.UNSUPPORTED_ENVIRONMENT,"This browser doesn't seem to support creating Blobs")}}function oD(n,e,i){return n.webkitSlice?n.webkitSlice(e,i):n.mozSlice?n.mozSlice(e,i):n.slice?n.slice(e,i):null}function uD(n){if(typeof atob>"u")throw GR("base-64");return atob(n)}const Bn={RAW:"raw",BASE64:"base64",BASE64URL:"base64url",DATA_URL:"data_url"};class Im{constructor(e,i){this.data=e,this.contentType=i||null}}function lD(n,e){switch(n){case Bn.RAW:return new Im(Eb(e));case Bn.BASE64:case Bn.BASE64URL:return new Im(Ab(n,e));case Bn.DATA_URL:return new Im(pD(e),dD(e))}throw Ch()}function Eb(n){const e=[];for(let i=0;i<n.length;i++){let r=n.charCodeAt(i);if(r<=127)e.push(r);else if(r<=2047)e.push(192|r>>6,128|r&63);else if((r&64512)===55296)if(!(i<n.length-1&&(n.charCodeAt(i+1)&64512)===56320))e.push(239,191,189);else{const l=r,p=n.charCodeAt(++i);r=65536|(l&1023)<<10|p&1023,e.push(240|r>>18,128|r>>12&63,128|r>>6&63,128|r&63)}else(r&64512)===56320?e.push(239,191,189):e.push(224|r>>12,128|r>>6&63,128|r&63)}return new Uint8Array(e)}function cD(n){let e;try{e=decodeURIComponent(n)}catch{throw Po(Bn.DATA_URL,"Malformed data URL.")}return Eb(e)}function Ab(n,e){switch(n){case Bn.BASE64:{const o=e.indexOf("-")!==-1,l=e.indexOf("_")!==-1;if(o||l)throw Po(n,"Invalid character '"+(o?"-":"_")+"' found: is it base64url encoded?");break}case Bn.BASE64URL:{const o=e.indexOf("+")!==-1,l=e.indexOf("/")!==-1;if(o||l)throw Po(n,"Invalid character '"+(o?"+":"/")+"' found: is it base64 encoded?");e=e.replace(/-/g,"+").replace(/_/g,"/");break}}let i;try{i=uD(e)}catch(o){throw o.message.includes("polyfill")?o:Po(n,"Invalid character found")}const r=new Uint8Array(i.length);for(let o=0;o<i.length;o++)r[o]=i.charCodeAt(o);return r}class jb{constructor(e){this.base64=!1,this.contentType=null;const i=e.match(/^data:([^,]+)?,/);if(i===null)throw Po(Bn.DATA_URL,"Must be formatted 'data:[<mediatype>][;base64],<data>");const r=i[1]||null;r!=null&&(this.base64=mD(r,";base64"),this.contentType=this.base64?r.substring(0,r.length-7):r),this.rest=e.substring(e.indexOf(",")+1)}}function pD(n){const e=new jb(n);return e.base64?Ab(Bn.BASE64,e.rest):cD(e.rest)}function dD(n){return new jb(n).contentType}function mD(n,e){return n.length>=e.length?n.substring(n.length-e.length)===e:!1}class na{constructor(e,i){let r=0,o="";p2(e)?(this.data_=e,r=e.size,o=e.type):e instanceof ArrayBuffer?(i?this.data_=new Uint8Array(e):(this.data_=new Uint8Array(e.byteLength),this.data_.set(new Uint8Array(e))),r=this.data_.length):e instanceof Uint8Array&&(i?this.data_=e:(this.data_=new Uint8Array(e.length),this.data_.set(e)),r=e.length),this.size_=r,this.type_=o}size(){return this.size_}type(){return this.type_}slice(e,i){if(p2(this.data_)){const r=this.data_,o=oD(r,e,i);return o===null?null:new na(o)}else{const r=new Uint8Array(this.data_.buffer,e,i-e);return new na(r,!0)}}static getBlob(...e){if(Th()){const i=e.map(r=>r instanceof na?r.data_:r);return new na(sD.apply(null,i))}else{const i=e.map(p=>_h(p)?lD(Bn.RAW,p).data:p.data_);let r=0;i.forEach(p=>{r+=p.byteLength});const o=new Uint8Array(r);let l=0;return i.forEach(p=>{for(let m=0;m<p.length;m++)o[l++]=p[m]}),new na(o,!0)}}uploadData(){return this.data_}}function Mb(n){let e;try{e=JSON.parse(n)}catch{return null}return JR(e)?e:null}function fD(n){if(n.length===0)return null;const e=n.lastIndexOf("/");return e===-1?"":n.slice(0,e)}function hD(n,e){const i=e.split("/").filter(r=>r.length>0).join("/");return n.length===0?i:n+"/"+i}function Rb(n){const e=n.lastIndexOf("/",n.length-2);return e===-1?n:n.slice(e+1)}function xD(n,e){return e}class Rt{constructor(e,i,r,o){this.server=e,this.local=i||e,this.writable=!!r,this.xform=o||xD}}let Pl=null;function gD(n){return!_h(n)||n.length<2?n:Rb(n)}function Db(){if(Pl)return Pl;const n=[];n.push(new Rt("bucket")),n.push(new Rt("generation")),n.push(new Rt("metageneration")),n.push(new Rt("name","fullPath",!0));function e(l,p){return gD(p)}const i=new Rt("name");i.xform=e,n.push(i);function r(l,p){return p!==void 0?Number(p):p}const o=new Rt("size");return o.xform=r,n.push(o),n.push(new Rt("timeCreated")),n.push(new Rt("updated")),n.push(new Rt("md5Hash",null,!0)),n.push(new Rt("cacheControl",null,!0)),n.push(new Rt("contentDisposition",null,!0)),n.push(new Rt("contentEncoding",null,!0)),n.push(new Rt("contentLanguage",null,!0)),n.push(new Rt("contentType",null,!0)),n.push(new Rt("metadata","customMetadata",!0)),Pl=n,Pl}function yD(n,e){function i(){const r=n.bucket,o=n.fullPath,l=new rn(r,o);return e._makeStorageReference(l)}Object.defineProperty(n,"ref",{get:i})}function OD(n,e,i){const r={};r.type="file";const o=i.length;for(let l=0;l<o;l++){const p=i[l];r[p.local]=p.xform(r,e[p.server])}return yD(r,n),r}function Ib(n,e,i){const r=Mb(e);return r===null?null:OD(n,r,i)}function vD(n,e,i,r){const o=Mb(e);if(o===null||!_h(o.downloadTokens))return null;const l=o.downloadTokens;if(l.length===0)return null;const p=encodeURIComponent;return l.split(",").map(x=>{const O=n.bucket,y=n.fullPath,v="/b/"+p(O)+"/o/"+p(y),_=Nh(v,i,r),k=kb({alt:"media",token:x});return _+k})[0]}function bD(n,e){const i={},r=e.length;for(let o=0;o<r;o++){const l=e[o];l.writable&&(i[l.server]=n[l.local])}return JSON.stringify(i)}class Lb{constructor(e,i,r,o){this.url=e,this.method=i,this.handler=r,this.timeout=o,this.urlParams={},this.headers={},this.body=null,this.errorHandler=null,this.progressCallback=null,this.successCodes=[200],this.additionalRetryCodes=[]}}function Pb(n){if(!n)throw Ch()}function SD(n,e){function i(r,o){const l=Ib(n,o,e);return Pb(l!==null),l}return i}function wD(n,e){function i(r,o){const l=Ib(n,o,e);return Pb(l!==null),vD(l,o,n.host,n._protocol)}return i}function Bb(n){function e(i,r){let o;return i.getStatus()===401?i.getErrorText().includes("Firebase App Check token is invalid")?o=LR():o=IR():i.getStatus()===402?o=DR(n.bucket):i.getStatus()===403?o=PR(n.path):o=r,o.status=i.getStatus(),o.serverResponse=r.serverResponse,o}return e}function CD(n){const e=Bb(n);function i(r,o){let l=e(r,o);return r.getStatus()===404&&(l=RR(n.path)),l.serverResponse=o.serverResponse,l}return i}function _D(n,e,i){const r=e.fullServerUrl(),o=Nh(r,n.host,n._protocol),l="GET",p=n.maxOperationRetryTime,m=new Lb(o,l,wD(n,i),p);return m.errorHandler=CD(e),m}function TD(n,e){return n&&n.contentType||e&&e.type()||"application/octet-stream"}function ND(n,e,i){const r=Object.assign({},i);return r.fullPath=n.path,r.size=e.size(),r.contentType||(r.contentType=TD(null,e)),r}function kD(n,e,i,r,o){const l=e.bucketOnlyServerUrl(),p={"X-Goog-Upload-Protocol":"multipart"};function m(){let H="";for(let J=0;J<2;J++)H=H+Math.random().toString().slice(2);return H}const h=m();p["Content-Type"]="multipart/related; boundary="+h;const x=ND(e,r,o),O=bD(x,i),y="--"+h+`\r
Content-Type: application/json; charset=utf-8\r
\r
`+O+`\r
--`+h+`\r
Content-Type: `+x.contentType+`\r
\r
`,v=`\r
--`+h+"--",_=na.getBlob(y,r,v);if(_===null)throw HR();const k={name:x.fullPath},I=Nh(l,n.host,n._protocol),D="POST",q=n.maxUploadRetryTime,z=new Lb(I,D,SD(n,i),q);return z.urlParams=k,z.headers=p,z.body=_.uploadData(),z.errorHandler=Bb(e),z}class ED{constructor(){this.sent_=!1,this.xhr_=new XMLHttpRequest,this.initXhr(),this.errorCode_=Ya.NO_ERROR,this.sendPromise_=new Promise(e=>{this.xhr_.addEventListener("abort",()=>{this.errorCode_=Ya.ABORT,e()}),this.xhr_.addEventListener("error",()=>{this.errorCode_=Ya.NETWORK_ERROR,e()}),this.xhr_.addEventListener("load",()=>{e()})})}send(e,i,r,o,l){if(this.sent_)throw wo("cannot .send() more than once");if(fa(e)&&r&&(this.xhr_.withCredentials=!0),this.sent_=!0,this.xhr_.open(i,e,!0),l!==void 0)for(const p in l)l.hasOwnProperty(p)&&this.xhr_.setRequestHeader(p,l[p].toString());return o!==void 0?this.xhr_.send(o):this.xhr_.send(),this.sendPromise_}getErrorCode(){if(!this.sent_)throw wo("cannot .getErrorCode() before sending");return this.errorCode_}getStatus(){if(!this.sent_)throw wo("cannot .getStatus() before sending");try{return this.xhr_.status}catch{return-1}}getResponse(){if(!this.sent_)throw wo("cannot .getResponse() before sending");return this.xhr_.response}getErrorText(){if(!this.sent_)throw wo("cannot .getErrorText() before sending");return this.xhr_.statusText}abort(){this.xhr_.abort()}getResponseHeader(e){return this.xhr_.getResponseHeader(e)}addUploadProgressListener(e){this.xhr_.upload!=null&&this.xhr_.upload.addEventListener("progress",e)}removeUploadProgressListener(e){this.xhr_.upload!=null&&this.xhr_.upload.removeEventListener("progress",e)}}class AD extends ED{initXhr(){this.xhr_.responseType="text"}}function Ub(){return new AD}class Za{constructor(e,i){this._service=e,i instanceof rn?this._location=i:this._location=rn.makeFromUrl(i,e.host)}toString(){return"gs://"+this._location.bucket+"/"+this._location.path}_newRef(e,i){return new Za(e,i)}get root(){const e=new rn(this._location.bucket,"");return this._newRef(this._service,e)}get bucket(){return this._location.bucket}get fullPath(){return this._location.path}get name(){return Rb(this._location.path)}get storage(){return this._service}get parent(){const e=fD(this._location.path);if(e===null)return null;const i=new rn(this._location.bucket,e);return new Za(this._service,i)}_throwIfRoot(e){if(this._location.path==="")throw VR(e)}}function jD(n,e,i){n._throwIfRoot("uploadBytes");const r=kD(n.storage,n._location,Db(),new na(e,!0),i);return n.storage.makeRequestWithTokens(r,Ub).then(o=>({metadata:o,ref:n}))}function MD(n){n._throwIfRoot("getDownloadURL");const e=_D(n.storage,n._location,Db());return n.storage.makeRequestWithTokens(e,Ub).then(i=>{if(i===null)throw YR();return i})}function RD(n,e){const i=hD(n._location.path,e),r=new rn(n._location.bucket,i);return new Za(n.storage,r)}function DD(n){return/^[A-Za-z]+:\/\//.test(n)}function ID(n,e){return new Za(n,e)}function zb(n,e){if(n instanceof kh){const i=n;if(i._bucket==null)throw qR();const r=new Za(i,i._bucket);return e!=null?zb(r,e):r}else return e!==void 0?RD(n,e):n}function LD(n,e){if(e&&DD(e)){if(n instanceof kh)return ID(n,e);throw pf("To use ref(service, url), the first argument must be a Storage instance.")}else return zb(n,e)}function m2(n,e){const i=e?.[Tb];return i==null?null:rn.makeFromBucketSpec(i,n)}function PD(n,e,i,r={}){n.host=`${e}:${i}`;const o=fa(e);o&&(Sf(`https://${n.host}/b`),wf("Storage",!0)),n._isUsingEmulator=!0,n._protocol=o?"https":"http";const{mockUserToken:l}=r;l&&(n._overrideAuthToken=typeof l=="string"?l:H2(l,n.app.options.projectId))}class kh{constructor(e,i,r,o,l,p=!1){this.app=e,this._authProvider=i,this._appCheckProvider=r,this._url=o,this._firebaseVersion=l,this._isUsingEmulator=p,this._bucket=null,this._host=_b,this._protocol="https",this._appId=null,this._deleted=!1,this._maxOperationRetryTime=jR,this._maxUploadRetryTime=MR,this._requests=new Set,o!=null?this._bucket=rn.makeFromBucketSpec(o,this._host):this._bucket=m2(this._host,this.app.options)}get host(){return this._host}set host(e){this._host=e,this._url!=null?this._bucket=rn.makeFromBucketSpec(this._url,e):this._bucket=m2(e,this.app.options)}get maxUploadRetryTime(){return this._maxUploadRetryTime}set maxUploadRetryTime(e){d2("time",0,Number.POSITIVE_INFINITY,e),this._maxUploadRetryTime=e}get maxOperationRetryTime(){return this._maxOperationRetryTime}set maxOperationRetryTime(e){d2("time",0,Number.POSITIVE_INFINITY,e),this._maxOperationRetryTime=e}async _getAuthToken(){if(this._overrideAuthToken)return this._overrideAuthToken;const e=this._authProvider.getImmediate({optional:!0});if(e){const i=await e.getToken();if(i!==null)return i.accessToken}return null}async _getAppCheckToken(){if(Vt(this.app)&&this.app.settings.appCheckToken)return this.app.settings.appCheckToken;const e=this._appCheckProvider.getImmediate({optional:!0});return e?(await e.getToken()).token:null}_delete(){return this._deleted||(this._deleted=!0,this._requests.forEach(e=>e.cancel()),this._requests.clear()),Promise.resolve()}_makeStorageReference(e){return new Za(this,e)}_makeRequest(e,i,r,o,l=!0){if(this._deleted)return new WR(Nb());{const p=aD(e,this._appId,r,o,i,this._firebaseVersion,l,this._isUsingEmulator);return this._requests.add(p),p.getPromise().then(()=>this._requests.delete(p),()=>this._requests.delete(p)),p}}async makeRequestWithTokens(e,i){const[r,o]=await Promise.all([this._getAuthToken(),this._getAppCheckToken()]);return this._makeRequest(e,i,r,o).getPromise()}}const f2="@firebase/storage",h2="0.14.0";const Fb="storage";function BD(n,e,i){return n=at(n),jD(n,e,i)}function UD(n){return n=at(n),MD(n)}function zD(n,e){return n=at(n),LD(n,e)}function FD(n=Nf(),e){n=at(n);const r=Nc(n,Fb).getImmediate({identifier:e}),o=z2("storage");return o&&qD(r,...o),r}function qD(n,e,i,r={}){PD(n,e,i,r)}function HD(n,{instanceIdentifier:e}){const i=n.getProvider("app").getImmediate(),r=n.getProvider("auth-internal"),o=n.getProvider("app-check-internal");return new kh(i,r,o,e,er)}function YD(){Va(new la(Fb,HD,"PUBLIC").setMultipleInstances(!0)),Un(f2,h2,""),Un(f2,h2,"esm2020")}YD();const GD=()=>{const{user:n,loading:e}=ga(),i=Cc(),r=S.useRef(null),[o,l]=S.useState(""),[p,m]=S.useState(null),[h,x]=S.useState(null),[O,y]=S.useState(!1),[v,_]=S.useState({type:"",text:""}),[k,I]=S.useState(!1);if(S.useEffect(()=>{n&&(l(n.name||""),m(n.avatar||null))},[n]),!e&&!n)return f.jsx(A2,{to:"/signin",replace:!0});const D=(H,J=400,$=400,B=.8)=>new Promise(W=>{const ae=new FileReader;ae.onload=ce=>{const te=new Image;te.onload=()=>{const Ue=document.createElement("canvas");let{width:Y,height:ye}=te;Y>ye?Y>J&&(ye=ye*J/Y,Y=J):ye>$&&(Y=Y*$/ye,ye=$),Ue.width=Y,Ue.height=ye,Ue.getContext("2d").drawImage(te,0,0,Y,ye),Ue.toBlob(W,"image/jpeg",B)},te.src=ce.target.result},ae.readAsDataURL(H)}),q=async H=>{const J=H.target.files[0];if(J){if(J.size>10*1024*1024){_({type:"error",text:"Image must be smaller than 10MB"});return}const $=new FileReader;$.onloadend=()=>{m($.result)},$.readAsDataURL(J),_({type:"info",text:"Optimizing image..."});const B=await D(J),W=new File([B],J.name,{type:"image/jpeg"});x(W),_({type:"",text:""})}},z=async()=>{y(!0),_({type:"",text:""});try{let H=n?.avatar;if(h){const J=FD(),$=zD(J,`avatars/${n.id}/${Date.now()}`);await BD($,h),H=await UD($)}await OO(Xr.currentUser,{displayName:o,photoURL:H}),H&&await sA(n.id,H),_({type:"success",text:"Profile updated successfully!"}),setTimeout(()=>{window.location.reload()},1e3)}catch(H){console.error("Error updating profile:",H),_({type:"error",text:"Failed to update profile. Please try again."})}y(!1)};return f.jsx("div",{className:"page",children:f.jsxs("div",{className:"container",style:{paddingTop:"56px",paddingBottom:"56px",maxWidth:"500px"},children:[f.jsxs("button",{onClick:()=>i(-1),className:"btn btn-ghost",style:{marginBottom:"24px",padding:"8px 0"},children:[f.jsx(SA,{size:18}),"Back"]}),f.jsxs("div",{style:{marginBottom:"40px"},children:[f.jsx("p",{className:"caption",style:{marginBottom:"8px"},children:"Settings"}),f.jsx("h1",{className:"headline",children:"Your Profile"})]}),f.jsxs("div",{style:{textAlign:"center",marginBottom:"40px"},children:[f.jsxs("div",{onClick:()=>r.current?.click(),style:{width:"120px",height:"120px",borderRadius:"50%",margin:"0 auto 16px",background:p?`url(${p}) center/cover`:"var(--bg-elevated)",border:"2px solid var(--border)",display:"flex",alignItems:"center",justifyContent:"center",cursor:"pointer",transition:"border-color 0.2s",position:"relative"},onMouseEnter:H=>H.currentTarget.style.borderColor="var(--accent)",onMouseLeave:H=>H.currentTarget.style.borderColor="var(--border)",children:[!p&&f.jsx("span",{style:{fontSize:"40px",color:"var(--text-tertiary)"},children:n?.name?.charAt(0).toUpperCase()||"U"}),f.jsx("div",{style:{position:"absolute",bottom:"4px",right:"4px",width:"32px",height:"32px",borderRadius:"50%",background:"var(--accent)",display:"flex",alignItems:"center",justifyContent:"center"},children:f.jsx(EA,{size:16,color:"white"})})]}),f.jsx("input",{ref:r,type:"file",accept:"image/*",onChange:q,style:{display:"none"}}),f.jsx("p",{className:"caption",children:"Click to upload a photo"})]}),f.jsxs("div",{className:"card",style:{background:"var(--bg-elevated)"},children:[f.jsxs("div",{style:{marginBottom:"20px"},children:[f.jsx("label",{className:"caption",style:{display:"block",marginBottom:"8px"},children:"Display Name"}),f.jsxs("div",{style:{position:"relative"},children:[f.jsx(rb,{size:16,style:{position:"absolute",left:"14px",top:"50%",transform:"translateY(-50%)",color:"var(--text-tertiary)"}}),f.jsx("input",{type:"text",value:o,onChange:H=>l(H.target.value),className:"input",style:{paddingLeft:"40px"},placeholder:"Your name"})]})]}),f.jsxs("div",{style:{marginBottom:"20px"},children:[f.jsx("label",{className:"caption",style:{display:"block",marginBottom:"8px"},children:"Email"}),f.jsxs("div",{style:{position:"relative"},children:[f.jsx(tb,{size:16,style:{position:"absolute",left:"14px",top:"50%",transform:"translateY(-50%)",color:"var(--text-tertiary)"}}),f.jsx("input",{type:"email",value:n?.email||"",className:"input",style:{paddingLeft:"40px",opacity:.6},disabled:!0})]}),f.jsx("p",{style:{fontSize:"12px",color:"var(--text-tertiary)",marginTop:"6px"},children:"Email cannot be changed"})]}),f.jsxs("div",{style:{marginBottom:"20px"},children:[f.jsx("label",{className:"caption",style:{display:"block",marginBottom:"8px"},children:"Your User ID"}),f.jsxs("div",{style:{display:"flex",alignItems:"center",gap:"8px",padding:"12px 14px",background:"var(--bg-secondary)",borderRadius:"10px",border:"1px solid var(--border)"},children:[f.jsx("code",{className:"mono",style:{flex:1,fontSize:"12px",color:"var(--text)",wordBreak:"break-all"},children:n?.id}),f.jsxs("button",{onClick:()=>{navigator.clipboard.writeText(n?.id),I(!0),setTimeout(()=>I(!1),2e3)},style:{padding:"6px 12px",background:k?"var(--green)":"var(--accent)",border:"none",borderRadius:"6px",color:"white",cursor:"pointer",fontSize:"12px",fontWeight:"500",display:"flex",alignItems:"center",gap:"4px"},children:[k?f.jsx(yc,{size:12}):f.jsx($v,{size:12}),k?"Copied!":"Copy"]})]}),f.jsx("p",{style:{fontSize:"12px",color:"var(--text-tertiary)",marginTop:"6px"},children:"Share this ID with friends so they can add you"})]}),f.jsxs("div",{style:{marginBottom:"24px"},children:[f.jsx("label",{className:"caption",style:{display:"block",marginBottom:"8px"},children:"Username"}),f.jsxs("div",{style:{position:"relative"},children:[f.jsx(_A,{size:16,style:{position:"absolute",left:"14px",top:"50%",transform:"translateY(-50%)",color:"var(--text-tertiary)"}}),f.jsx("input",{type:"text",value:n?.handle||"",className:"input",style:{paddingLeft:"40px",opacity:.6},disabled:!0})]})]}),v.text&&f.jsx("div",{style:{padding:"12px 16px",borderRadius:"10px",marginBottom:"20px",background:v.type==="success"?"rgba(48, 209, 88, 0.1)":v.type==="info"?"rgba(0, 113, 227, 0.1)":"rgba(255, 69, 58, 0.1)",color:v.type==="success"?"var(--green)":v.type==="info"?"var(--accent)":"var(--red)",fontSize:"14px"},children:v.text}),f.jsxs("button",{onClick:z,disabled:O||!o.trim(),className:"btn btn-primary",style:{width:"100%",padding:"14px",opacity:O?.7:1},children:[f.jsx(Sj,{size:16}),O?"Saving...":"Save Changes"]})]})]})})},VD=()=>{const[n,e]=S.useState({totalPlayers:0,totalBattles:0}),i=Hc();return S.useEffect(()=>{gh().then(e)},[]),f.jsxs("div",{className:"page",children:[f.jsxs("section",{style:{minHeight:"calc(100vh - 52px)",display:"flex",flexDirection:"column",alignItems:"center",justifyContent:"center",textAlign:"center",padding:"0 22px"},children:[f.jsx("p",{className:"caption",style:{marginBottom:"12px",color:"var(--accent)"},children:"About"}),f.jsx("h1",{className:"headline-super",style:{marginBottom:"16px"},children:"Valkry"}),f.jsxs("p",{className:"body-large",style:{maxWidth:"500px",marginBottom:"0"},children:["Real-time competitive programming battles.",f.jsx("br",{}),"Solve. Debug. Climb."]})]}),f.jsx("section",{style:{padding:"88px 22px",background:"var(--bg-secondary)"},children:f.jsx("div",{className:"container",children:f.jsxs("div",{className:"grid grid-3",style:{textAlign:"center"},children:[f.jsxs("div",{children:[f.jsx("div",{style:{fontSize:"48px",fontWeight:"600",letterSpacing:"-0.02em"},children:n.totalPlayers||0}),f.jsx("div",{className:"caption",children:"Players"})]}),f.jsxs("div",{children:[f.jsx("div",{style:{fontSize:"48px",fontWeight:"600",letterSpacing:"-0.02em"},children:n.totalBattles||0}),f.jsx("div",{className:"caption",children:"Battles"})]}),f.jsxs("div",{children:[f.jsxs("div",{style:{fontSize:"48px",fontWeight:"600",letterSpacing:"-0.02em"},children:[i.total,"+"]}),f.jsx("div",{className:"caption",children:"Problems"})]})]})})}),f.jsx("section",{style:{padding:"120px 22px"},children:f.jsxs("div",{className:"container",style:{maxWidth:"600px",textAlign:"center"},children:[f.jsx("img",{src:"/creator.jpg",alt:"Muhammad Dyen Asif",style:{width:"140px",height:"140px",borderRadius:"50%",objectFit:"cover",marginBottom:"32px"}}),f.jsx("h2",{className:"headline",style:{marginBottom:"8px"},children:"Muhammad Dyen Asif"}),f.jsx("p",{className:"caption",style:{marginBottom:"24px"},children:"FAST NUCES"}),f.jsx("p",{style:{fontSize:"17px",color:"var(--text-secondary)",lineHeight:1.7,marginBottom:"40px"},children:"Built Valkry to explore real-time systems, competitive programming, and modern web development. A passion project combining coding challenges with hands-on Firebase and React experience."}),f.jsxs("div",{style:{display:"flex",justifyContent:"center",gap:"20px"},children:[f.jsx("a",{href:"https://github.com/DyneStein",target:"_blank",rel:"noopener noreferrer",style:{width:"48px",height:"48px",borderRadius:"50%",background:"var(--bg-elevated)",border:"1px solid var(--border)",display:"flex",alignItems:"center",justifyContent:"center",color:"var(--text)",transition:"all 0.2s"},onMouseOver:r=>{r.currentTarget.style.background="var(--text)",r.currentTarget.style.color="var(--bg)"},onMouseOut:r=>{r.currentTarget.style.background="var(--bg-elevated)",r.currentTarget.style.color="var(--text)"},children:f.jsx(aj,{size:20})}),f.jsx("a",{href:"https://www.linkedin.com/in/dynestein/",target:"_blank",rel:"noopener noreferrer",style:{width:"48px",height:"48px",borderRadius:"50%",background:"var(--bg-elevated)",border:"1px solid var(--border)",display:"flex",alignItems:"center",justifyContent:"center",color:"var(--text)",transition:"all 0.2s"},onMouseOver:r=>{r.currentTarget.style.background="#0077b5",r.currentTarget.style.color="#fff",r.currentTarget.style.borderColor="#0077b5"},onMouseOut:r=>{r.currentTarget.style.background="var(--bg-elevated)",r.currentTarget.style.color="var(--text)",r.currentTarget.style.borderColor="var(--border)"},children:f.jsx(uj,{size:20})}),f.jsx("a",{href:"https://www.youtube.com/@dyenasif6247",target:"_blank",rel:"noopener noreferrer",style:{width:"48px",height:"48px",borderRadius:"50%",background:"var(--bg-elevated)",border:"1px solid var(--border)",display:"flex",alignItems:"center",justifyContent:"center",color:"var(--text)",transition:"all 0.2s"},onMouseOver:r=>{r.currentTarget.style.background="#ff0000",r.currentTarget.style.color="#fff",r.currentTarget.style.borderColor="#ff0000"},onMouseOut:r=>{r.currentTarget.style.background="var(--bg-elevated)",r.currentTarget.style.color="var(--text)",r.currentTarget.style.borderColor="var(--border)"},children:f.jsx(Pj,{size:20})})]})]})}),f.jsxs("section",{style:{padding:"88px 22px",background:"var(--bg-secondary)",textAlign:"center"},children:[f.jsx("h2",{className:"headline",style:{marginBottom:"12px"},children:"Ready to compete?"}),f.jsx("p",{className:"body-large",style:{marginBottom:"32px"},children:"Join the arena."}),f.jsx(ht,{to:"/arena",children:f.jsxs("button",{className:"btn btn-primary",children:["Enter Arena ",f.jsx(gc,{size:14})]})})]}),f.jsx("footer",{style:{padding:"24px 22px",textAlign:"center",borderTop:"1px solid var(--border)"},children:f.jsx("span",{className:"caption",children:"Valkry  2024  Built with React & Firebase"})})]})},WD=()=>{const{user:n}=ga(),[e,i]=S.useState("friends"),[r,o]=S.useState([]),[l,p]=S.useState([]),[m,h]=S.useState({}),[x,O]=S.useState(""),[y,v]=S.useState(null),[_,k]=S.useState(""),[I,D]=S.useState(!1),[q,z]=S.useState(!1),[H,J]=S.useState("");S.useEffect(()=>{if(!n)return;const Y=wb(n.id,o),ye=TR(n.id,p);return()=>{Y(),ye()}},[n]),S.useEffect(()=>{if(r.length>0){const Y=r.map(st=>st.id);return Cb(Y,h)}},[r]);const $=()=>{navigator.clipboard.writeText(n.id),z(!0),setTimeout(()=>z(!1),2e3)},B=async()=>{if(x.trim()){if(D(!0),v(null),k(""),x.trim()===n.id){k("You can't add yourself as a friend"),D(!1);return}try{const Y=new Promise((st,de)=>setTimeout(()=>de(new Error("Search timed out")),15e3)),ye=await Promise.race([NR(x.trim()),Y]);ye?v(ye):k("User not found. Make sure the ID is correct.")}catch(Y){console.error("Search error:",Y),Y.message==="Search timed out"?k("Search timed out. Please check your connection and try again."):Y.code==="PERMISSION_DENIED"||Y.message?.includes("permission")?k("Permission denied. Please sign out and sign in again."):Y.message?.includes("network")||Y.message?.includes("offline")?k("Network error. Please check your internet connection."):k(`Search failed: ${Y.message||"Unknown error"}. Please try again.`)}D(!1)}},W=async()=>{if(!y)return;const Y=await SR({id:n.id,name:n.name,avatar:n.avatar},y.id);Y.success?(J("Friend request sent!"),v(null),O("")):k(Y.error),setTimeout(()=>J(""),3e3)},ae=async Y=>{await wR(n.id,Y.from),J(`${Y.from.name} is now your friend!`),setTimeout(()=>J(""),3e3)},ce=async Y=>{await CR(n.id,Y.id)},te=async Y=>{window.confirm(`Remove ${Y.name} from friends?`)&&(await _R(n.id,Y.id),J(`Removed ${Y.name} from friends`),setTimeout(()=>J(""),3e3))};if(!n)return f.jsx("div",{className:"page",children:f.jsxs("div",{className:"container",style:{paddingTop:"100px",textAlign:"center"},children:[f.jsx(Io,{size:48,style:{color:"var(--text-tertiary)",marginBottom:"16px"}}),f.jsx("h2",{className:"headline-small",style:{marginBottom:"12px"},children:"Sign in Required"}),f.jsx("p",{style:{color:"var(--text-secondary)",marginBottom:"24px"},children:"Sign in to add friends and challenge them"}),f.jsx(ht,{to:"/signin",children:f.jsx("button",{className:"btn btn-primary",children:"Sign In"})})]})});const Ue=[{id:"friends",label:"Friends",icon:Io,count:r.length},{id:"requests",label:"Requests",icon:Zy,count:l.length},{id:"add",label:"Add Friend",icon:vc}];return f.jsx("div",{className:"page",children:f.jsxs("div",{className:"container",style:{paddingTop:"56px",paddingBottom:"56px",maxWidth:"600px"},children:[f.jsxs("div",{style:{marginBottom:"32px"},children:[f.jsx("p",{className:"caption",style:{marginBottom:"8px"},children:"Social"}),f.jsx("h1",{className:"headline",children:"Friends"})]}),f.jsxs("div",{className:"card",style:{padding:"16px",marginBottom:"24px",background:"var(--bg-elevated)"},children:[f.jsxs("div",{style:{display:"flex",justifyContent:"space-between",alignItems:"center"},children:[f.jsxs("div",{children:[f.jsx("span",{style:{fontSize:"12px",color:"var(--text-tertiary)",fontWeight:"600"},children:"YOUR ID"}),f.jsx("div",{className:"mono",style:{fontSize:"13px",color:"var(--text)",marginTop:"4px"},children:n.id})]}),f.jsxs("button",{onClick:$,style:{padding:"8px 14px",background:q?"var(--green)":"var(--bg-secondary)",border:"none",borderRadius:"8px",color:q?"white":"var(--text)",cursor:"pointer",display:"flex",alignItems:"center",gap:"6px",fontSize:"13px"},children:[q?f.jsx(yc,{size:14}):f.jsx($v,{size:14}),q?"Copied!":"Copy"]})]}),f.jsx("p",{style:{fontSize:"12px",color:"var(--text-tertiary)",marginTop:"8px"},children:"Share this ID with friends so they can add you"})]}),f.jsx("div",{style:{display:"flex",gap:"8px",marginBottom:"24px"},children:Ue.map(Y=>f.jsxs("button",{onClick:()=>i(Y.id),style:{flex:1,padding:"12px 16px",background:e===Y.id?"var(--accent)":"var(--bg-elevated)",border:e===Y.id?"none":"1px solid var(--border)",borderRadius:"10px",color:e===Y.id?"white":"var(--text)",cursor:"pointer",display:"flex",alignItems:"center",justifyContent:"center",gap:"8px",fontSize:"14px",fontWeight:"500",position:"relative"},children:[f.jsx(Y.icon,{size:16}),Y.label,Y.count>0&&f.jsx("span",{style:{background:e===Y.id?"rgba(255,255,255,0.3)":"var(--accent)",color:"white",padding:"2px 6px",borderRadius:"10px",fontSize:"11px",fontWeight:"600"},children:Y.count})]},Y.id))}),H&&f.jsxs("div",{style:{padding:"12px 16px",background:"rgba(48, 209, 88, 0.12)",border:"1px solid rgba(48, 209, 88, 0.3)",borderRadius:"10px",marginBottom:"16px",color:"var(--green)",fontSize:"14px"},children:[f.jsx(yc,{size:14,style:{display:"inline",marginRight:"4px"}}),H]}),e==="friends"&&f.jsx("div",{className:"card",style:{padding:0,overflow:"hidden"},children:r.length>0?r.map((Y,ye)=>f.jsxs("div",{style:{display:"flex",alignItems:"center",gap:"12px",padding:"16px",borderBottom:ye<r.length-1?"1px solid var(--border)":"none"},children:[Y.avatar?f.jsx("img",{src:Y.avatar,alt:Y.name,style:{width:"44px",height:"44px",borderRadius:"50%",objectFit:"cover"}}):f.jsx("div",{className:"avatar",style:{width:"44px",height:"44px",fontSize:"16px"},children:Y.name?.charAt(0).toUpperCase()}),f.jsxs("div",{style:{flex:1},children:[f.jsx("div",{style:{fontWeight:"500"},children:Y.name}),f.jsx("div",{style:{fontSize:"12px",color:m[Y.id]?"var(--green)":"var(--text-tertiary)"},children:m[Y.id]?" Online":" Offline"})]}),f.jsx(ht,{to:"/arena",state:{challengeFriend:Y},style:{textDecoration:"none"},children:f.jsxs("button",{className:"btn btn-primary",style:{padding:"8px 14px",fontSize:"13px"},disabled:!m[Y.id],children:[f.jsx(Oc,{size:14})," Challenge"]})}),f.jsx("button",{onClick:()=>te(Y),style:{padding:"8px",background:"transparent",border:"none",color:"var(--text-tertiary)",cursor:"pointer"},children:f.jsx(Nj,{size:16})})]},Y.id)):f.jsxs("div",{style:{padding:"48px 24px",textAlign:"center"},children:[f.jsx(Io,{size:40,style:{color:"var(--text-tertiary)",marginBottom:"12px",opacity:.5}}),f.jsx("p",{style:{color:"var(--text-secondary)",marginBottom:"8px"},children:"No friends yet"}),f.jsx("p",{style:{color:"var(--text-tertiary)",fontSize:"13px"},children:"Add friends to challenge them in battles"})]})}),e==="requests"&&f.jsx("div",{className:"card",style:{padding:0,overflow:"hidden"},children:l.length>0?l.map((Y,ye)=>f.jsxs("div",{style:{display:"flex",alignItems:"center",gap:"12px",padding:"16px",borderBottom:ye<l.length-1?"1px solid var(--border)":"none"},children:[Y.from.avatar?f.jsx("img",{src:Y.from.avatar,alt:Y.from.name,style:{width:"44px",height:"44px",borderRadius:"50%",objectFit:"cover"}}):f.jsx("div",{className:"avatar",style:{width:"44px",height:"44px",fontSize:"16px"},children:Y.from.name?.charAt(0).toUpperCase()}),f.jsxs("div",{style:{flex:1},children:[f.jsx("div",{style:{fontWeight:"500"},children:Y.from.name}),f.jsx("div",{style:{fontSize:"12px",color:"var(--text-tertiary)"},children:"Wants to be friends"})]}),f.jsxs("button",{onClick:()=>ae(Y),style:{padding:"8px 14px",background:"var(--green)",border:"none",borderRadius:"8px",color:"white",cursor:"pointer",display:"flex",alignItems:"center",gap:"4px",fontSize:"13px"},children:[f.jsx(jA,{size:14})," Accept"]}),f.jsx("button",{onClick:()=>ce(Y),style:{padding:"8px",background:"transparent",border:"1px solid var(--border)",borderRadius:"8px",color:"var(--text-tertiary)",cursor:"pointer"},children:f.jsx(bc,{size:16})})]},Y.id)):f.jsxs("div",{style:{padding:"48px 24px",textAlign:"center"},children:[f.jsx(Zy,{size:40,style:{color:"var(--text-tertiary)",marginBottom:"12px",opacity:.5}}),f.jsx("p",{style:{color:"var(--text-secondary)"},children:"No pending requests"})]})}),e==="add"&&f.jsxs("div",{className:"card",style:{padding:"24px"},children:[f.jsx("h3",{style:{marginBottom:"16px",fontSize:"17px",fontWeight:"600"},children:"Add by User ID"}),f.jsx("p",{style:{color:"var(--text-secondary)",marginBottom:"16px",fontSize:"14px"},children:"Enter your friend's User ID to send them a friend request"}),f.jsxs("div",{style:{display:"flex",gap:"8px",marginBottom:"16px"},children:[f.jsx("input",{type:"text",placeholder:"Paste User ID here...",value:x,onChange:Y=>{O(Y.target.value),k(""),v(null)},className:"input",style:{flex:1}}),f.jsx("button",{onClick:B,className:"btn btn-primary",disabled:!x.trim()||I,style:{padding:"12px 20px"},children:I?"Searching...":f.jsxs(f.Fragment,{children:[f.jsx(yh,{size:16})," Search"]})})]}),_&&f.jsx("div",{style:{padding:"12px",background:"rgba(255, 69, 58, 0.12)",border:"1px solid rgba(255, 69, 58, 0.3)",borderRadius:"8px",color:"var(--red)",fontSize:"14px"},children:_}),y&&f.jsxs("div",{style:{padding:"16px",background:"var(--bg-secondary)",borderRadius:"12px",display:"flex",alignItems:"center",gap:"12px"},children:[y.avatar?f.jsx("img",{src:y.avatar,alt:y.name,style:{width:"48px",height:"48px",borderRadius:"50%",objectFit:"cover"}}):f.jsx("div",{className:"avatar",style:{width:"48px",height:"48px",fontSize:"18px"},children:y.name?.charAt(0).toUpperCase()}),f.jsxs("div",{style:{flex:1},children:[f.jsx("div",{style:{fontWeight:"500",marginBottom:"2px"},children:y.name}),f.jsxs("div",{style:{fontSize:"12px",color:"var(--text-tertiary)"},children:[y.rank,"  ",y.rating," rating"]})]}),f.jsxs("button",{onClick:W,className:"btn btn-primary",style:{padding:"10px 16px"},children:[f.jsx(vc,{size:16})," Add Friend"]})]})]})]})})};function KD(){return f.jsx(hA,{children:f.jsx(MC,{children:f.jsxs("div",{children:[f.jsx(zj,{}),f.jsxs(uC,{children:[f.jsx(Tn,{path:"/",element:f.jsx(t2,{})}),f.jsx(Tn,{path:"/signin",element:f.jsx(ZM,{})}),f.jsx(Tn,{path:"/dashboard",element:f.jsx(e6,{})}),f.jsx(Tn,{path:"/leaderboard",element:f.jsx(t6,{})}),f.jsx(Tn,{path:"/arena",element:f.jsx(ER,{})}),f.jsx(Tn,{path:"/learn",element:f.jsx(AR,{})}),f.jsx(Tn,{path:"/profile",element:f.jsx(GD,{})}),f.jsx(Tn,{path:"/about",element:f.jsx(VD,{})}),f.jsx(Tn,{path:"/friends",element:f.jsx(WD,{})}),f.jsx(Tn,{path:"/features",element:f.jsx(t2,{})})]})]})})})}pw.createRoot(document.getElementById("root")).render(f.jsx(S.StrictMode,{children:f.jsx(KD,{})}));
